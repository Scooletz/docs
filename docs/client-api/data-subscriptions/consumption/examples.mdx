---
title: "Subscription Consumption Examples"
sidebar_label: Examples
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/language-switcher";
import LanguageContent from "@site/src/components/language-content";

export const supportedLanguages = ["csharp", "java", "python", "nodejs"];


# Subscription Consumption Examples
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* In this page:  
  * [Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples#client-with-full-exception-handling-and-processing-retries)
  * [Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples#worker-with-a-specified-batch-size)
  * [Worker that operates with a session](../../../client-api/data-subscriptions/consumption/examples#worker-that-operates-with-a-session)
  * [Worker that processes dynamic objects](../../../client-api/data-subscriptions/consumption/examples#worker-that-processes-dynamic-objects)
  * [Worker that processes a blittable object](../../../client-api/data-subscriptions/consumption/examples#worker-that-processes-a-blittable-object)
  * [Subscription that ends when no documents are left](../../../client-api/data-subscriptions/consumption/examples#subscription-that-ends-when-no-documents-are-left)
  * [Subscription that uses included documents](../../../client-api/data-subscriptions/consumption/examples#subscription-that-uses-included-documents)
  * [Subscription workers with failover on other nodes](../../../client-api/data-subscriptions/consumption/examples#subscription-workers-with-failover-on-other-nodes)
  * [Primary and secondary workers](../../../client-api/data-subscriptions/consumption/examples#primary-and-secondary-workers)

</Admonition>
## Client with full exception handling and processing retries

Here we implement a client that handles exceptions thrown by the worker.  
If the exception is recoverable, the client retries creating the worker.

<TabItem value="something" label="reconnecting_client">
<CodeBlock language="csharp">
{`while (true)
\{
    // Create the worker:
    // ==================
    var options = new SubscriptionWorkerOptions(subscriptionName);

    // Configure the worker:
    // Allow a downtime of up to 2 hours,
    // and wait 2 minutes before reconnecting
    options.MaxErroneousPeriod = TimeSpan.FromHours(2);
    options.TimeToWaitBeforeConnectionRetry = TimeSpan.FromMinutes(2);

    subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(options);

    try
    \{
        // Subscribe to connection retry events
        // and log any exceptions that occur during processing
        subscriptionWorker.OnSubscriptionConnectionRetry += exception =>
        \{
            Logger.Error("Error during subscription processing: " + subscriptionName,
                exception);
        \};

        // Run the worker:
        // ===============
        await subscriptionWorker.Run(batch =>
        \{
            foreach (var item in batch.Items)
            \{
                // Forcefully stop subscription processing if the ID is "companies/2-A"
                // and throw an exception to let external logic handle the specific case
                if (item.Result.Company == "companies/2-A")
                \{
                    // The custom exception thrown from here
                    // will be wrapped by \`SubscriberErrorException\`
                    throw new UnsupportedCompanyException(
                        "Company ID can't be 'companies/2-A', pleases fix");
                \}

                // Process the order document - provide your own logic
                ProcessOrder(item.Result);
            \}
        \}, cancellationToken);

        // The Run method will stop if the subscription worker is disposed,
        // exiting the while loop
        return;
    \}
    catch (Exception e)
    \{
        Logger.Error("Failure in subscription: " + subscriptionName, e);

        // The following exceptions are Not recoverable
        if (e is DatabaseDoesNotExistException ||
            e is SubscriptionDoesNotExistException ||
            e is SubscriptionInvalidStateException ||
            e is AuthorizationException)
            throw;


        if (e is SubscriptionClosedException)
            // Subscription probably closed explicitly by admin
            return;

        if (e is SubscriberErrorException se)
        \{
            // For UnsupportedCompanyException we want to throw an exception,
            // otherwise, continue processing
            if (se.InnerException != null && se.InnerException is UnsupportedCompanyException)
            \{
                throw;
            \}

            // Call continue to skip the current while(true) iteration and try reconnecting
            // in the next one, allowing the worker to process future batches.
            continue;
        \}

        // Handle this depending on the subscription opening strategy
        if (e is SubscriptionInUseException)
            continue;

        // Call return to exit the while(true) loop,
        // dispose the worker (via finally), and stop the subscription.
        return;
    \}
    finally
    \{
        subscriptionWorker.Dispose();
    \}
\}
`}
</CodeBlock>
</TabItem>



## Worker with a specified batch size

Here we create a worker and specify the maximum number of documents the server will send to the worker in each batch.

<TabItem value="something" label="subscription_worker_with_batch_size">
<CodeBlock language="csharp">
{`var workerWBatch = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
    \{
        MaxDocsPerBatch = 20
    \});

_ = workerWBatch.Run(x =>
\{
    // your custom logic 
\});
`}
</CodeBlock>
</TabItem>



## Worker that operates with a session

Here we create a subscription that sends _Order_ documents that do not have a shipping date.  
The worker receiving these documents will update the `ShippedAt` field value and save the document back to the server via the session.

<Admonition type="info" title="Info">
Note:  
The session is opened with `batch.OpenSession` instead of with `Store.OpenSession`.
</Admonition>

<TabItem value="something" label="subscription_with_open_session_usage">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions()
\{
    Query = @"from Orders as o where o.ShippedAt = null"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    // Open a session with 'batch.OpenSession'
    using (var session = batch.OpenSession())
    \{
        foreach (var order in batch.Items.Select(x => x.Result))
        \{
            TransferOrderToShipmentCompany(order); // call your custom method 
            order.ShippedAt = DateTime.UtcNow;     // update the document field
        \}

        // Save the updated Order documents
        session.SaveChanges();
    \}
\});
`}
</CodeBlock>
</TabItem>



## Worker that processes dynamic objects

Here we define a subscription that projects the _Order_ documents into a dynamic format.  
The worker processes the dynamic objects it receives.

<TabItem value="something" label="dynamic_worker">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = "My dynamic subscription";
store.Subscriptions.Create(new SubscriptionCreationOptions<Order>()
\{
    Name = subscriptionName,
    Projection = order => 
        new \{ DynanamicField_1 = "Company: " + order.Company + " Employee: " + order.Employee \}
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    foreach (var item in batch.Items)
    \{
        // Access the dynamic field in the document
        dynamic field = item.Result.DynanamicField_1;
        
        // Call your custom method
        ProcessItem(field); 
    \}
\});
`}
</CodeBlock>
</TabItem>



## Worker that processes a blittable object

Create a worker that processes documents as low level blittable objects.  
This can be useful in extreme high-performance scenarios, but may be dangerous due to the direct usage of unmanaged memory.

<TabItem value="something" label="blittable_worker">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions<Order>
\{
    Projection = x => new
    \{
        x.Employee
    \}
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = 
    // Specify \`BlittableJsonReaderObject\` as the generic type parameter
    store.Subscriptions.GetSubscriptionWorker<BlittableJsonReaderObject>(subscriptionName);

_ = subscriptionWorker.Run(batch =>
\{
    foreach (var item in batch.Items)
    \{
        // Access the Employee field within the blittable object
        var employeeField = item.Result["Employee"].ToString();
        
        ProcessItem(employeeField); // call your custom method 
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents are left

Here we create a subscription client that runs until there are no more new documents to process.  
This is useful for ad-hoc, single-use processing where the user needs to ensure that all documents are fully processed.

<TabItem value="something" label="single_run">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================
var subscriptionName = store.Subscriptions.Create<Order>(
    new SubscriptionCreationOptions<Order>
    \{
        Filter = order => order.Lines.Sum(line => line.PricePerUnit * line.Quantity) > 10000,
        Projection = order => new OrderAndCompany
        \{
            OrderId = order.Id,
            Company = RavenQuery.Load<Company>(order.Company)
        \}
    \});

// Create the subscription worker that will consume the documents:
// ===============================================================
var highValueOrdersWorker = store.Subscriptions.GetSubscriptionWorker<OrderAndCompany>(
    new SubscriptionWorkerOptions(subscriptionName)
    \{
        // Here we set the worker to stop when there are no more documents left to send 
        // Will throw SubscriptionClosedException when it finishes it's job
        CloseWhenNoDocsLeft = true
    \});

try
\{
    await highValueOrdersWorker.Run(batch =>
    \{
        foreach (var item in batch.Items)
        \{
            SendThankYouNoteToEmployee(item.Result); // call your custom method 
        \}
    \});
\}
catch (SubscriptionClosedException)
\{
    // That's expected, no more documents to process
\}
`}
</CodeBlock>
</TabItem>



## Subscription that uses included documents

Here we create a subscription that, in addition to sending all the _Order_ documents to the worker,  
will include all the referenced _Product_ documents in the batch sent to the worker.

When the worker accesses these _Product_ documents, no additional requests will be made to the server.

<TabItem value="something" label="subscription_with_includes_path_usage">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions()
\{
    // Include the referenced Product documents for each Order document
    Query = @"from Orders include Lines[].Product"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    // Open a session via 'batch.OpenSession'
    // in order to access the Product documents
    using (var session = batch.OpenSession())
    \{
        foreach (var order in batch.Items.Select(x => x.Result))
        \{
            foreach (var orderLine in order.Lines)
            \{
                // Calling Load will Not generate a request to the server,
                // because orderLine.Product was included in the batch
                var product = session.Load<Product>(orderLine.Product);
                
                ProcessOrderAndProduct(order, product); // call your custom method
            \}
        \}
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription workers with failover on other nodes

In this configuration, any available node will create a worker.  
If the worker fails, another available node will take over.

<TabItem value="something" label="waitforfree">
<CodeBlock language="csharp">
{`var worker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.WaitForFree
\});
`}
</CodeBlock>
</TabItem>



## Primary and secondary workers

Here we create two workers:  

* The primary worker, with a `TakeOver` strategy, will take over the other worker and establish the connection.
* The secondary worker, with a `WaitForFree` strategy, will wait for the first worker to fail (due to machine failure, etc.).

The primary worker:  
<TabItem value="something" label="waiting_subscription_1">
<CodeBlock language="csharp">
{`var primaryWorker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.TakeOver
\});

while (true)
\{
    try
    \{
        await primaryWorker.Run(x =>
        \{
            // your logic
        \});
    \}
    catch (Exception)
    \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>

The secondary worker:  
<TabItem value="something" label="waiting_subscription_2">
<CodeBlock language="csharp">
{`var secondaryWorker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.WaitForFree
\});

while (true)
\{
    try
    \{
        await secondaryWorker.Run(x =>
        \{
            // your logic
        \});
    \}
    catch (Exception)
    \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="Note">

*  this page:  
   * [Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples#worker-with-a-specified-batch-size)  
   * [Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples#client-with-full-exception-handling-and-processing-retries)  
   * [Subscription that ends when no documents left](../../../client-api/data-subscriptions/consumption/examples#subscription-that-ends-when-no-documents-left)  
   * [Worker that processes raw objects](../../../client-api/data-subscriptions/consumption/examples#sworker-that-processes-raw-objects)  
   * [Worker that operates with a session](../../../client-api/data-subscriptions/consumption/examples#worker-that-operates-with-a-session)
   * [Subscription that uses included documents](../../../client-api/data-subscriptions/consumption/examples#subscription-that-uses-included-documents)  
   * [Primary and secondary workers](../../../client-api/data-subscriptions/consumption/examples#primary-and-secondary-workers)  

</Admonition>
## Worker with a specified batch size

Here we create a worker and specify the maximum number of documents the server will send to the worker in each batch.

<TabItem value="something-something" label="subscription_worker_with_batch_size">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subscriptionName);
options.setMaxDocsPerBatch(20);
SubscriptionWorker<Order> workerWBatch = store.subscriptions().getSubscriptionWorker(Order.class, options);
workerWBatch.run(x -> \{ /* custom logic */\});
`}
</CodeBlock>
</TabItem>



## Client with full exception handling and processing retries

Here we implement a client that handles exceptions thrown by a worker.  
If the exception is recoverable, the client retries creating the worker.

<TabItem value="something-something" label="reconnecting_client">
<CodeBlock language="java">
{`while (true) \{
    SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subscriptionName);
    // here we configure that we allow a down time of up to 2 hours,
    // and will wait for 2 minutes for reconnecting

    options.setMaxErroneousPeriod(Duration.ofHours(2));
    options.setTimeToWaitBeforeConnectionRetry(Duration.ofMinutes(2));

    subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, options);

    try \{
        // here we are able to be informed of any exception that happens during processing
        subscriptionWorker.addOnSubscriptionConnectionRetry(exception -> \{
            logger.error("Error during subscription processing: " + subscriptionName, exception);
        \});

        subscriptionWorker.run(batch -> \{
            for (SubscriptionBatch.Item<Order> item : batch.getItems()) \{
                // we want to force close the subscription processing in that case
                // and let the external code decide what to do with that
                if ("Europe".equalsIgnoreCase(item.getResult().getShipVia())) \{
                    throw new IllegalStateException("We cannot ship via Europe");
                \}
                processOrder(item.getResult());
            \}
        \}).get();


        // Run will complete normally if you have disposed the subscription
        return;
    \} catch (Exception e) \{
        logger.error("Failure in subscription: " + subscriptionName, e);

        e = ExceptionsUtils.unwrapException(e);
        if (e instanceof DatabaseDoesNotExistException ||
            e instanceof SubscriptionDoesNotExistException ||
            e instanceof SubscriptionInvalidStateException ||
            e instanceof AuthorizationException) \{
            throw e; // not recoverable
        \}

        if (e instanceof SubscriptionClosedException) \{
            // closed explicitly by admin, probably
            return;
        \}

        if (e instanceof SubscriberErrorException) \{
            SubscriberErrorException se = (SubscriberErrorException) e;
            // for IllegalStateException type, we want to throw an exception, otherwise
            // we continue processing
            if (se.getCause() != null && se.getCause() instanceof IllegalStateException) \{
                throw e;
            \}

            continue;
        \}

        // handle this depending on subscription
        // open strategy (discussed later)
        if (e instanceof SubscriptionInUseException) \{
            continue;
        \}

        return;
    \} finally \{
        subscriptionWorker.close();
    \}
\}
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents left

Here we create a subscription client that runs only up to the point there are no more new documents left to process.  

This is useful for ad-hoc, single-use processing where the user needs to ensure that all documents are fully processed.

<TabItem value="something-something" label="single_run">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subsId);

// Here we ask the worker to stop when there are no documents left to send.
// Will throw SubscriptionClosedException when it finishes it's job
options.setCloseWhenNoDocsLeft(true);
SubscriptionWorker<OrderAndCompany> highValueOrdersWorker = store
    .subscriptions().getSubscriptionWorker(OrderAndCompany.class, options);

try \{
    highValueOrdersWorker.run(batch -> \{
        for (SubscriptionBatch.Item<OrderAndCompany> item : batch.getItems()) \{
            sendThankYouNoteToEmployee(item.getResult());
        \}
    \});
\} catch (SubscriptionClosedException e) \{
    //that's expected
\}
`}
</CodeBlock>
</TabItem>



## Worker that processes raw objects

Here we create a worker that processes received data as ObjectNode objects.

<TabItem value="something-something" label="dynamic_worker">
<CodeBlock language="java">
{`String subscriptionName = "My dynamic subscription";

SubscriptionCreationOptions subscriptionCreationOptions = new SubscriptionCreationOptions();
subscriptionCreationOptions.setName("My dynamic subscription");
subscriptionCreationOptions.setQuery("from Orders as o \\n" +
    "select \{ \\n" +
    "   DynamicField_1: 'Company:' + o.Company + ' Employee: ' + o.Employee \\n" +
    "\}");

SubscriptionWorker<ObjectNode> worker = store.subscriptions().getSubscriptionWorker(subscriptionName);
worker.run(x -> \{
    for (SubscriptionBatch.Item<ObjectNode> item : x.getItems()) \{
        ObjectNode result = item.getResult();
        raiseNotification(result.get("DynamicField_1"));
    \}
\});
`}
</CodeBlock>
</TabItem>



## Worker that operates with a session

Here we create a subscription that sends Order documents that do not have a shipping date.  
The worker receiving these documents will update the `ShippedAt` field value and save the document back to the server via the session.

<TabItem value="something-something" label="subscription_with_open_session_usage">
<CodeBlock language="java">
{`SubscriptionCreationOptions subscriptionCreationOptions = new SubscriptionCreationOptions();
subscriptionCreationOptions.setQuery("from Orders as o where o.ShippedAt = null");
String subscriptionName = store.subscriptions().create(subscriptionCreationOptions);

SubscriptionWorker<Order> subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, subscriptionName);

subscriptionWorker.run(batch -> \{
    try (IDocumentSession session = batch.openSession()) \{
        for (SubscriptionBatch.Item<Order> orderItem : batch.getItems()) \{
            transferOrderToShipmentCompany(orderItem.getResult());
            orderItem.getResult().setShippedAt(new Date());
        \}

        // we know that we have at least one order to ship,
        // because the subscription query above has that in it's WHERE clause
        session.saveChanges();
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that uses included documents

Here we create a subscription that, in addition to sending all the _Order_ documents to the worker,  
will include all the referenced _Product_ documents in the batch sent to the worker.

When the worker accesses these _Product_ documents, no additional requests will be made to the server.

<TabItem value="something-something" label="subscription_with_includes_path_usage">
<CodeBlock language="java">
{`SubscriptionCreationOptions subscriptionCreationOptions = new SubscriptionCreationOptions();
subscriptionCreationOptions.setQuery("from Orders include Lines[].Product");


String subscriptionName = store.subscriptions().create(subscriptionCreationOptions);

SubscriptionWorker<Order> subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, subscriptionName);

subscriptionWorker.run(batch -> \{
    try (IDocumentSession session = batch.openSession()) \{
        for (SubscriptionBatch.Item<Order> orderItem : batch.getItems()) \{
            Order order = orderItem.getResult();
            for (OrderLine orderLine : order.getLines()) \{
                // this line won't generate a request, because orderLine.Product was included
                Product product = session.load(Product.class, orderLine.getProduct());
                raiseProductNotification(order, product);
            \}
        \}
    \}
\});
`}
</CodeBlock>
</TabItem>



## Primary and secondary workers

Here we create two workers:  

* The primary worker, with a `TAKE_OVER` strategy, will take over the other worker and establish the connection.
* The secondary worker, with a `WAIT_FOR_FREE` strategy, will wait for the first worker to fail (due to machine failure, etc.).

The primary worker:

<TabItem value="something-something" label="waiting_subscription_1">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options1 = new SubscriptionWorkerOptions(subscriptionName);
options1.setStrategy(SubscriptionOpeningStrategy.TAKE_OVER);
SubscriptionWorker<Order> worker1 = store.subscriptions().getSubscriptionWorker(Order.class, options1);


while (true) \{
    try \{
        worker1
            .run(x -> \{
                // your logic
            \});
    \} catch (Exception e) \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>

The secondary worker:

<TabItem value="something-something" label="waiting_subscription_2">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options2 = new SubscriptionWorkerOptions(subscriptionName);
options2.setStrategy(SubscriptionOpeningStrategy.WAIT_FOR_FREE);
SubscriptionWorker<Order> worker2 = store.subscriptions().getSubscriptionWorker(Order.class, options2);

while (true) \{
    try \{
        worker2
            .run(x -> \{
                // your logic
            \});
    \} catch (Exception e) \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* In this page:  
  * [Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples#client-with-full-exception-handling-and-processing-retries)
  * [Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples#worker-with-a-specified-batch-size)
  * [Worker that operates with a session](../../../client-api/data-subscriptions/consumption/examples#worker-that-operates-with-a-session)
  * [Worker that processes dynamic objects](../../../client-api/data-subscriptions/consumption/examples#worker-that-processes-dynamic-objects)
  * [Subscription that ends when no documents are left](../../../client-api/data-subscriptions/consumption/examples#subscription-that-ends-when-no-documents-are-left)
  * [Subscription that uses included documents](../../../client-api/data-subscriptions/consumption/examples#subscription-that-uses-included-documents)
  * [Subscription workers with failover on other nodes](../../../client-api/data-subscriptions/consumption/examples#subscription-workers-with-failover-on-other-nodes)
  * [Primary and secondary workers](../../../client-api/data-subscriptions/consumption/examples#primary-and-secondary-workers)

</Admonition>
## Client with full exception handling and processing retries

Here we implement a client that handles exceptions thrown by a worker.  
If the exception is recoverable, the client retries creating the worker.

<TabItem value="something-something" label="reconnecting_client">
<CodeBlock language="python">
{`while True:
    options = SubscriptionWorkerOptions(subscription_name)

    # here we configure that we allow a down time of up to 2 hours, and will wait for 2 minutes for reconnecting
    options.max_erroneous_period = timedelta(hours=2)
    options.time_to_wait_before_connection_retry = timedelta(minutes=2)

    subscription_worker = store.subscriptions.get_subscription_worker(options, Order)

    try:
        # here we are able to be informed of any exceptions that happens during processing
        subscription_worker.add_on_subscription_connection_retry(
            lambda exception: logger.error(
                f"Error during subscription processing: \{subscription_name\}", exc_info=exception
            )
        )

        def _process_documents_callback(batch: SubscriptionBatch[Order]):
            for item in batch.items:
                # we want to force close the subscription processing in that case
                # and let the external code decide what to do with that
                if item.result.company == "companies/2-A":
                    raise UnsupportedCompanyException(
                        "Company Id can't be 'companies/2-A', you must fix this"
                    )
                process_order(item.result)

            # Run will complete normally if you have disposed the subscription
            return

        # Pass the callback to worker.run()
        subscription_worker.run(_process_documents_callback)

    except Exception as e:
        logger.error(f"Failure in subscription: \{subscription_name\}", exc_info=e)
        exception_type = type(e)
        if (
            exception_type is DatabaseDoesNotExistException
            or exception_type is SubscriptionDoesNotExistException
            or exception_type is SubscriptionInvalidStateException
            or exception_type is AuthorizationException
        ):
            raise  # not recoverable

        if exception_type is SubscriptionClosedException:
            # closed explicitely by admin, probably
            return

        if exception_type is SubscriberErrorException:
            # for UnsupportedCompanyException type, we want to throw an exception, otherwise
            # we continue processing
            if e.args[1] is not None and type(e.args[1]) is UnsupportedCompanyException:
                raise

            continue

        # handle this depending on subscription
        # open strategy (discussed later)
        if e is SubscriptionInUseException:
            continue

        return
    finally:
        subscription_worker.close(False)
`}
</CodeBlock>
</TabItem>



## Worker with a specified batch size

Here we create a worker and specify the maximum number of documents the server will send to the worker in each batch.

<TabItem value="something-something" label="subscription_worker_with_batch_size">
<CodeBlock language="python">
{`worker_w_batch = store.subscriptions.get_subscription_worker(
    SubscriptionWorkerOptions(subscription_name, max_docs_per_batch=20), Order
)

_ = worker_w_batch.run(
    process_documents=lambda batch: ...
)  # Pass your method that takes SubscriptionBatch[_T] as an argument, with your logic in it
`}
</CodeBlock>
</TabItem>



## Worker that operates with a session

Here we create a subscription that sends _Order_ documents that do not have a shipping date.  
The worker receiving these documents will update the `ShippedAt` field value and save the document back to the server via the session.

<TabItem value="something-something" label="subscription_with_open_session_usage">
<CodeBlock language="python">
{`subscription_name = store.subscriptions.create_for_options(
    SubscriptionCreationOptions(query="from Orders as o where o.ShippedAt = null")
)

subscription_worker = store.subscriptions.get_subscription_worker_by_name(subscription_name, Order)

def _transfer_order_callback(batch: SubscriptionBatch[Order]):
    with batch.open_session() as session:
        for order in (item.result for item in batch.items):
            transfer_order_to_shipment_company(order)
            order.shipped_at = datetime.utcnow()

        # we know that we have at least one order to ship,
        # because the subscription query above has that in it's WHERE clause
        session.save_changes()

_ = subscription_worker.run(_transfer_order_callback)
`}
</CodeBlock>
</TabItem>



## Worker that processes dynamic objects

Here we define a subscription that projects the _Order_ documents into a dynamic format.  
The worker processes the dynamic objects it receives.

<TabItem value="something-something" label="dynamic_worker">
<CodeBlock language="python">
{`subscription_name = "My dynamic subscription"
store.subscriptions.create_for_class(
    Order,
    SubscriptionCreationOptions(
        subscription_name,
        query="""
        From Orders as o
        Select 
        \{
            dynamic_field_1: "Company: " + o.Company + " Employee: " + o.Employee,
        \}
        """,
    ),
)

subscription_worker = store.subscriptions.get_subscription_worker_by_name(subscription_name)

def _raise_notification_callback(batch: SubscriptionBatch[Order]):
    for item in batch.items:
        raise_notification(item.result.dynamic_field_1)

_ = subscription_worker.run(_raise_notification_callback)
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents are left

Here we create a subscription client that runs only up to the point there are no more new documents left to process.  

This is useful for ad-hoc, single-use processing where the user needs to ensure that all documents are fully processed.

<TabItem value="something-something" label="single_run">
<CodeBlock language="python">
{`high_value_orders_worker = store.subscriptions.get_subscription_worker(
    SubscriptionWorkerOptions(
        subs_id,
        # Here we ask the worker to stop when there are no documents left to send.
        # Will throw SubscriptionClosedException when it finishes its job
        close_when_no_docs_left=True,
    ),
    OrderAndCompany,
)

try:

    def _subscription_batch_callback(batch: SubscriptionBatch[OrderAndCompany]):
        for item in batch.items:
            send_thank_you_note_to_employee(item.result)

    high_value_orders_worker.run(_subscription_batch_callback)
except SubscriptionClosedException:
    # that's expected
    ...
`}
</CodeBlock>
</TabItem>



## Subscription that uses included documents

Here we create a subscription that, in addition to sending all the _Order_ documents to the worker,  
will include all the referenced _Product_ documents in the batch sent to the worker.

When the worker accesses these _Product_ documents, no additional requests will be made to the server.

<TabItem value="something" label="subscription_with_includes_path_usage">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions()
\{
    // Include the referenced Product documents for each Order document
    Query = @"from Orders include Lines[].Product"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    // Open a session via 'batch.OpenSession'
    // in order to access the Product documents
    using (var session = batch.OpenSession())
    \{
        foreach (var order in batch.Items.Select(x => x.Result))
        \{
            foreach (var orderLine in order.Lines)
            \{
                // Calling Load will Not generate a request to the server,
                // because orderLine.Product was included in the batch
                var product = session.Load<Product>(orderLine.Product);
                
                ProcessOrderAndProduct(order, product); // call your custom method
            \}
        \}
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription workers with failover on other nodes

In this configuration, any available node will create a worker.  
If the worker fails, another available node will take over.

<TabItem value="something-something" label="waitforfree">
<CodeBlock language="python">
{`worker = store.subscriptions.get_subscription_worker(
    SubscriptionWorkerOptions(subscription_name, strategy=SubscriptionOpeningStrategy.WAIT_FOR_FREE), Order
)
`}
</CodeBlock>
</TabItem>



## Primary and secondary workers

Here we create two workers:  

* The primary worker, with a `TAKE_OVER` strategy, will take over the other worker and establish the connection.
* The secondary worker, with a `WAIT_FOR_FREE` strategy, will wait for the first worker to fail (due to machine failure, etc.).

The primary worker:  
<TabItem value="something-something" label="waiting_subscription_1">
<CodeBlock language="python">
{`primary_worker = store.subscriptions.get_subscription_worker(SubscriptionWorkerOptions(subscription_name, strategy=SubscriptionOpeningStrategy.TAKE_OVER), Order)

while True:
    try:
        run_future = primary_worker.run(lambda batch: ...) # your logic
    except Exception:
        ... # retry
`}
</CodeBlock>
</TabItem>

The secondary worker:  
<TabItem value="something-something" label="waiting_subscription_2">
<CodeBlock language="python">
{`secondary_worker = store.subscriptions.get_subscription_worker(SubscriptionWorkerOptions(subscription_name), strategy=SubscriptionOpeningStrategy.WAIT_FOR_FREE)

while True:
    try:
        run_future = secondary_worker.run(lambda batch: ...) # your logic
    except Exception:
        ... # retry
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* In this page:
  * [Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples#client-with-full-exception-handling-and-processing-retries)
  * [Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples#worker-with-a-specified-batch-size)
  * [Worker that operates with a session](../../../client-api/data-subscriptions/consumption/examples#worker-that-operates-with-a-session)
  * [Worker that processes dynamic objects](../../../client-api/data-subscriptions/consumption/examples#worker-that-processes-dynamic-objects)
  * [Subscription that ends when no documents are left](../../../client-api/data-subscriptions/consumption/examples#subscription-that-ends-when-no-documents-are-left)
  * [Subscription that uses included documents](../../../client-api/data-subscriptions/consumption/examples#subscription-that-uses-included-documents)
  * [Primary and secondary workers](../../../client-api/data-subscriptions/consumption/examples#primary-and-secondary-workers)

</Admonition>
## Client with full exception handling and processing retries

Here we implement a client that handles exceptions thrown by the worker.  
If the exception is recoverable, the client retries creating the worker.

<TabItem value="something-something" label="consume_1">
<CodeBlock language="nodejs">
{`// Create the subscription task on the server:
// ===========================================

const subscriptionName = await documentStore.subscriptions.create(\{
    name: "ProcessOrdersWithLowFreight",
    query: "from Orders where Freight < 0.5"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

await setupReconnectingWorker(subscriptionName);

async function setupReconnectingWorker(subscriptionName) \{
    let subscriptionWorker;

    await reconnect();

    function closeWorker(worker) \{
        worker.dispose();
    \}

    async function reconnect() \{
        if (subscriptionWorker) \{
            closeWorker(subscriptionWorker);
        \}

        // Configure the worker:
        const subscriptionWorkerOptions = \{
            subscriptionName: subscriptionName,
            // Allow a downtime of up to 2 hours
            maxErroneousPeriod: 2 * 3600 * 1000,
            // Wait 2 minutes before reconnecting
            timeToWaitBeforeConnectionRetry: 2 * 60 * 1000
        \};

        subscriptionWorker = 
            store.subscriptions.getSubscriptionWorker(subscriptionWorkerOptions);

        // Subscribe to connection retry events,
        // and log any exceptions that occur during processing
        subscriptionWorker.on("connectionRetry", error => \{
            console.error(
                "Error during subscription processing: " + subscriptionName, error);
        \});

        // Run the worker:
        // =============== 
        subscriptionWorker.on("batch", (batch, callback) => \{
            try \{
                for (const item of batch.items) \{
                    const orderDocument = item.result;
                    
                    // Forcefully stop subscription processing if the ID is "companies/46-A"
                    // and throw an exception to let external logic handle the specific case
                    if (orderDocument.Company && orderDocument.Company === "companies/46-A") \{
                        // 'The InvalidOperationException' thrown from here
                        // will be wrapped by \`SubscriberErrorException\`
                        callback(new InvalidOperationException(
                            "Company ID can't be 'companies/46-A', pleases fix"));
                        return;
                    \}

                    // Process the order document - provide your own logic
                    processOrder(orderDocument);
                \}
                // Call 'callback' once you're done
                // The worker will send an acknowledgement to the server,
                // so that server can send next batch
                callback();
            \} 
            catch(err) \{
                callback(err);
            \}
        \});

        // Handle errors:
        // ============== 
        subscriptionWorker.on("error", error => \{
            console.error("Failure in subscription: " + subscriptionName, error);

            // The following exceptions are Not recoverable
            if (error.name === "DatabaseDoesNotExistException" ||
                error.name === "SubscriptionDoesNotExistException" ||
                error.name === "SubscriptionInvalidStateException" ||
                error.name === "AuthorizationException") \{
                throw error;
            \}

            if (error.name === "SubscriptionClosedException") \{
                // Subscription probably closed explicitly by admin
                return closeWorker(subscriptionWorker);
            \}

            if (error.name === "SubscriberErrorException") \{
                // For the InvalidOperationException we want to throw an exception,
                // otherwise, continue processing
                if (error.cause && error.cause.name === "InvalidOperationException") \{
                    throw error;
                \}

                setTimeout(reconnect, 1000);
                return;
            \}

            // Handle this depending on the subscription opening strategy
            if (error.name === "SubscriptionInUseException") \{
                setTimeout(reconnect, 1000);
                return;
            \}

            setTimeout(reconnect, 1000);
            return;
        \});

        // Handle worker end event:
        // ========================
        subscriptionWorker.on("end", () => \{
            closeWorker(subscriptionWorker);
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>



## Worker with a specified batch size

Here we create a worker and specify the maximum number of documents the server will send to the worker in each batch.

<TabItem value="something-something" label="consume_2">
<CodeBlock language="nodejs">
{`// Create the subscription task on the server:
// ===========================================

const subscriptionName = await documentStore.subscriptions.create(\{
    name: "ProcessOrders",
    query: "from Orders"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

const workerOptions = \{
    subscriptionName: subscriptionName,
    maxDocsPerBatch: 20 // Set the maximum number of documents per batch
\};

const worker = documentStore.subscriptions.getSubscriptionWorker(workerOptions);

worker.on("batch", (batch, callback) => \{
    try \{
        // Add your logic for processing the incoming batch items here...   

        // Call 'callback' once you're done
        // The worker will send an acknowledgement to the server,
        // so that server can send next batch
        callback();

    \} catch(err) \{
        callback(err);
    \}
\});
`}
</CodeBlock>
</TabItem>



## Worker that operates with a session

Here we create a subscription that sends _Order_ documents that do not have a shipping date.  
The worker receiving these documents will update the `ShippedAt` field value and save the document back to the server via the session.

<Admonition type="info" title="Info">
Note:  
The session is opened with `batch.openSession` instead of with `documentStore.openSession`.
</Admonition>

<TabItem value="something-something" label="consume_3">
<CodeBlock language="nodejs">
{`// Create the subscription task on the server:
// ===========================================

const subscriptionName = await documentStore.subscriptions.create(\{
    name: "ProcessOrdersThatWereNotShipped",
    query: "from Orders as o where o.ShippedAt = null"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

const workerOptions = \{ subscriptionName \};
const worker = documentStore.subscriptions.getSubscriptionWorker(workerOptions);

worker.on("batch", async (batch, callback)
    try \{
        // Open a session with 'batch.openSession'
        const session = batch.openSession();
        
        for (const item of batch.items) \{
            orderDocument = item.result;

            transferOrderToShipmentCompany(orderDocument); // call your custom method 
            orderDocument.ShippedAt = new Date();  // update the document field
        \}

        // Save the updated Order documents
        await session.saveChanges();
        callback();
        
    \} catch(err) \{
        callback(err);
    \}
\});
`}
</CodeBlock>
</TabItem>



## Worker that processes dynamic objects

Here we define a subscription that projects the _Order_ documents into a dynamic format.  
The worker processes the dynamic objects it receives.

<TabItem value="something-something" label="consume_4">
<CodeBlock language="nodejs">
{`// Create the subscription task on the server:
// ===========================================

const subscriptionName = await documentStore.subscriptions.create(\{
    name: "ProcessDynamicFields",
    query: \`From Orders as o
            Select \{
                dynamicField: "Company: " + o.Company + " Employee: " + o.Employee,
            \}\`
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

const workerOptions = \{ subscriptionName \};
const worker =  documentStore.subscriptions.getSubscriptionWorker(workerOptions);

worker.on("batch", (batch, callback) => \{
    for (const item of batch.items) \{
        
        // Access the dynamic field in the document
        const field = item.result.dynamicField;

        // Call your custom method
        processItem(field);
    \}

    callback();
\});
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents are left

Here we create a subscription client that runs until there are no more new documents to process.  
This is useful for ad-hoc, single-use processing where the user needs to ensure that all documents are fully processed.

<TabItem value="something-something" label="consume_5">
<CodeBlock language="nodejs">
{`// Create the subscription task on the server:
// ===========================================

// Define the filtering criteria
const query = \`
                declare function getOrderLinesSum(doc) \{
                    var sum = 0;
                    for (var i in doc.Lines) \{
                        sum += doc.Lines[i].PricePerUnit * doc.Lines[i].Quantity;
                    \}
                    return sum;
                \}
                
                from Orders as o 
                where getOrderLinesSum(o) > 10_000\`;

// Create the subscription with the defined query
const subscriptionName = await documentStore.subscriptions.create(\{ query \});

// Create the subscription worker that will consume the documents:
// ===============================================================

const workerOptions = \{
    subscriptionName: subscriptionName,
    // Here we set the worker to stop when there are no more documents left to send 
    // Will throw SubscriptionClosedException when it finishes it's job
    closeWhenNoDocsLeft: true
\};

const highValueOrdersWorker = 
    documentStore.subscriptions.getSubscriptionWorker(workerOptions);

highValueOrdersWorker.on("batch", (batch, callback) => \{
    for (const item of batch.items) \{
        sendThankYouNoteToEmployee(item.result); // call your custom method 
    \}

    callback();
\});

highValueOrdersWorker.on("error", err => \{
    if (err.name === "SubscriptionClosedException") \{
        // That's expected, no more documents to process
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that uses included documents

Here we create a subscription that, in addition to sending all the _Order_ documents to the worker,  
will include all the referenced _Product_ documents in the batch sent to the worker.

When the worker accesses these _Product_ documents, no additional requests will be made to the server.

<TabItem value="something-something" label="consume_6">
<CodeBlock language="nodejs">
{`// Create the subscription task on the server:
// ===========================================

const subscriptionName = await documentStore.subscriptions.create(\{
    name: "ProcessIncludedDocuments",
    query: \`from Orders include Lines[].Product\`
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

const workerOptions = \{ subscriptionName \};
const worker = documentStore.subscriptions.getSubscriptionWorker(workerOptions);

worker.on("batch", async (batch, callback) => \{
    // Open a session via 'batch.openSession'
    // in order to access the Product documents
    const session = batch.openSession();
    
    for (const item of batch.items) \{
        const orderDocument = item.result;
        
        for (const orderLine of orderDocument.Lines)
        \{
            // Calling 'load' will Not generate a request to the server,
            // because orderLine.Product was included in the batch
            const product = await session.load(orderLine.Product);
            const productName = product.Name;

            // Call your custom method
            processOrderAndProduct(order, product);
        \}
    \}
    
    callback();
\});
`}
</CodeBlock>
</TabItem>



## Primary and secondary workers

Here we create two workers:

* The primary worker, with a `TakeOver` strategy, will take over the other worker and establish the connection.  
* The secondary worker, with a `WaitForFree` strategy, will wait for the first worker to fail (due to machine failure, etc.).

The primary worker:

<TabItem value="something-something" label="consume_7">
<CodeBlock language="nodejs">
{`const workerOptions1 = \{
    subscriptionName,
    strategy: "TakeOver",
    documentType: Order
\};

const worker1 = documentStore.subscriptions.getSubscriptionWorker(workerOptions1);

worker1.on("batch", (batch, callback) => \{
    // your logic
    callback();
\});

worker1.on("error", err => \{
    // retry
\});
`}
</CodeBlock>
</TabItem>

The secondary worker:

<TabItem value="something-something" label="consume_8">
<CodeBlock language="nodejs">
{`const workerOptions2 = \{
    subscriptionName,
    strategy: "WaitForFree",
    documentType: Order
\};

const worker2 = documentStore.subscriptions.getSubscriptionWorker(workerOptions2);

worker2.on("batch", (batch, callback) => \{
    // your logic
    callback();
\});

worker2.on("error", err => \{
    // retry
\});
`}
</CodeBlock>
</TabItem>




</LanguageContent>