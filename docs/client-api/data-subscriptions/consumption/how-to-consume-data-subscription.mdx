---
title: "How to Consume a Data Subscription"
sidebar_label: How to Consume a Data Subscription
sidebar_position: 0
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "nodejs"];


# How to Consume a Data Subscription
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Batches of documents sent from a Subscription Task defined on the server are consumed and processed by a subscription worker client.

* The `SubscriptionWorker` object, defined on the client, manages the communication between the server and the client and processes the document batches sent from the server.  

* There are several ways to create and configure the SubscriptionWorker - see [SubscriptionWorkerOptions](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions).  

* In this page:
  * [SubscriptionWorker lifecycle](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#subscriptionworker-lifecycle)  
  * [Error handling](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#error-handling)  
  * [Worker strategies](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#worker-strategies)   
  * [Determining which workers a subscription will serve](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#determining-which-workers-a-subscription-will-serve)  

</Admonition>
## SubscriptionWorker lifecycle

A `SubscriptionWorker` object starts its life from being generated by the `DocumentsStore.Subscriptions`:
<TabItem value="something" label="subscription_open_simple">
<CodeBlock language="csharp">
{`subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
`}
</CodeBlock>
</TabItem>

At this point, the worker has only got its configuration. No connection or processing happens at this moment.  
To start processing, the `Run` method should be called. The Run method receives the batch processing logic that should be performed:
<TabItem value="something" label="subscription_run_simple">
<CodeBlock language="csharp">
{`subscriptionRuntimeTask = subscriptionWorker.Run(batch =>
\{
    // your logic here
\});
`}
</CodeBlock>
</TabItem>

From this point on, the subscription worker will start processing batches.  
If processing is aborted for any reason, the returned task (`subscriptionRuntimeTask`) will complete with an exception.  



## Error handling

<Admonition type="info" title="Subscription worker connection failures" id="subscription-worker-connection-failures" href="#subscription-worker-connection-failures">

Subscription worker connection failures may occur during the routine communication between the worker and the server.
When an unexpected error arises, the worker will attempt to **reconnect to the server**.

However, there are several conditions under which the worker will stop its operation but will Not attempt to reconnect:

* The subscription no longer exists or has been deleted.
* Another worker has taken control of the subscription (see [connection strategy](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#available-worker-strategies)).
* The worker is unable to connect to any of the servers.
* The worker could not receive the node responsible for the task  
  (this can happen when there is no leader in the cluster).
* An authorization exception occurred.
* An exception occurred during the connection establishment phase.
* The database doesn't exist.

</Admonition>

<Admonition type="info" title="Batch processing execution failures" id="batch-processing-execution-failures" href="#batch-processing-execution-failures">

An exception may occur while processing a batch of documents in the worker.
For example:

<TabItem value="something" label="throw_during_user_logic">
<CodeBlock language="csharp">
{`_ = workerWBatch.Run(x => throw new Exception());
`}
</CodeBlock>
</TabItem>

When creating a worker, the worker can be configured to handle these exceptions in either of the following ways,
depending on the `IgnoreSubscriberErrors` property in [SubscriptionWorkerOptions](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions):

* **Abort processing completely**  
  When `IgnoreSubscriberErrors = false` (default):  
  The current batch processing will be aborted, and in this case, the worker will wrap the thrown exception in a `SubscriberErrorException` and will rethrow it.
  Processing of the subscription will be terminated without acknowledging progress to the server or retrying to connect.  
  As a result, the task returned by the `Run` function will complete in an erroneous state, throwing a _SubscriberErrorException_.

* **Continue processing subsequent batches**  
  When `IgnoreSubscriberErrors = true`:    
  The current batch processing will be aborted; however, the erroneous batch will be acknowledged without retrying,
  and processing will continue with the next batches.

</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">

Two properties in the [SubscriptionWorkerOptions](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions) 
object control the behavior of a worker attempting to reconnect with the server:

* `TimeToWaitBeforeConnectionRetry`  
  The time the worker will wait before attempting to reconnect.  
  Default: 5 seconds.  
* `MaxErroneousPeriod`  
  The maximum amount of time the subscription connection can remain in an erroneous state.   
  Once this period is exceeded, the worker will stop trying to reconnect.  
  Default: 5 minutes.  

</Admonition>

<Admonition type="info" title="Timing out" id="timing-out" href="#timing-out">

A worker will time out after losing its connectivity with the server for a given time period.  

* The timeout period can be set using the `ConnectionStreamTimeout` option. E.g.:  
<TabItem value="something" label="worker_timeout_minimal_sample">
<CodeBlock language="csharp">
{`var options = new SubscriptionWorkerOptions(subscriptionName);

// Set the worker's timeout period
options.ConnectionStreamTimeout = TimeSpan.FromSeconds(45);
`}
</CodeBlock>
</TabItem>
* Default timeout period: 30 second  

</Admonition>

<Admonition type="info" title="OnUnexpectedSubscriptionError" id="onunexpectedsubscriptionerror" href="#onunexpectedsubscriptionerror">

`OnUnexpectedSubscriptionError` is the event that is triggered when a connection failure occurs between the subscription worker and the server,
resulting in an unexpected exception.  
When this happens, the worker will automatically attempt to reconnect.  
This event is useful for logging these unexpected exceptions.

</Admonition>



## Worker strategies
 
Subscription workers are configured with a **strategy** that determines whether multiple workers 
can connect to the subscription concurrently or if only one worker can connect at a time.

The _one-worker-at-a-time_ strategy also determines how the workers interact with each other 
to resolve which will establish the subscription connection.
### One worker per subscription strategies

The following three strategies allow only a **single worker to connect to the subscription at any given time**,  
and determine what happens when one worker is connected and another tries to connect.  

* `SubscriptionOpeningStrategy.OpenIfFree`  
  The server will allow a worker to connect only if no other worker is currently connected.  
  If there is an existing connection, the incoming worker will throw a `SubscriptionInUseException`.  
* `SubscriptionOpeningStrategy.WaitForFree`  
  If the worker cannot open the subscription because it is in use by another worker, it will wait for the currently connected worker to disconnect before establishing the connection.
  This is useful in worker failover scenarios, where one worker is connected while another is awaiting its turn to take its place.
* `SubscriptionOpeningStrategy.TakeOver`  
  The server will allow an incoming connection to take over an existing one,  
  based on the connection strategy in use by the currently connected worker:
  * If the existing connection **does not** have a `TakeOver` strategy:  
    The incoming connection will take over, causing the existing connection to throw a `SubscriptionInUseException`.  
  * If the existing connection **has** a `TakeOver` strategy:  
    The incoming connection will throw a `SubscriptionInUseException` exception.  
### Multiple workers per subscription strategy

* `SubscriptionOpeningStrategy.Concurrent`  
  The server allows multiple workers to connect to the same subscription **concurrently**.  
  Read more about concurrent subscriptions [here](../../../client-api/data-subscriptions/concurrent-subscriptions).  



## Determining which workers a subscription will serve

<Admonition type="note" title="Note">

The **strategy used by the first worker connecting to a subscription** determines 
which additional workers the subscription can serve until all worker connections are dropped.

</Admonition>

* A subscription that serves one or more [concurrent](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#multiple-workers-per-subscription-strategy) workers, 
  **can only serve other concurrent workers** until all connections are dropped. 
  If a worker with a [one worker per subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#one-worker-per-subscription-strategies) 
  strategy attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  

* A subscription that serves a worker with a [one worker per subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#one-worker-per-subscription-strategies) strategy, 
  **cannot** serve [concurrent](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#multiple-workers-per-subscription-strategy) 
  workers until that worker's connection is dropped. 
  If a concurrent worker attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  




</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="Note">

Subscriptions are consumed by processing batches of documents received from the server. 
A `SubscriptionWorker` object manages the documents processing and the communication between the client and the server according to a set of configurations received upon it's creation. 
We've introduced several ways to create and configure a SubscriptionWorker, starting from just giving a subscription name, and ending with a detailed configuration object - `SubscriptionWorkerOptions`.

* In this page:
   * [SubscriptionWorker lifecycle](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#subscriptionworker-lifecycle)  
   * [Error handling](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#error-handling)  
   * [Worker strategies](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#worker-strategies)

</Admonition>
## SubscriptionWorker lifecycle

A `SubscriptionWorker` object starts its life from being generated by the `DocumentsStore.subscriptions`:

<TabItem value="something-something" label="subscription_open_simple">
<CodeBlock language="java">
{`subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, subscriptionName);
`}
</CodeBlock>
</TabItem>

At this point, the worker has only got its configuration. No connection or processing happens at this moment.  
In order to start processing, the `run` method should be called. The `run` method receives the batch processing logic that should be performed:

<TabItem value="something-something" label="subscription_run_simple">
<CodeBlock language="java">
{`subscriptionRuntimeTask = subscriptionWorker.run(batch -> \{
    // your logic here
\});
`}
</CodeBlock>
</TabItem>

From this point on, the subscription worker will start processing batches. If for any reason, the processing is aborted, the returned task (`subscriptionRuntimeTask`) will complete with an exception.



## Error handling

<Admonition type="info" title="Subscription worker connection failures" id="subscription-worker-connection-failures" href="#subscription-worker-connection-failures">

Subscription worker connection failures may occur during the routine communication between the worker and the server.
When an unexpected error arises, the worker will attempt to **reconnect to the server**.

However, there are several conditions under which the worker will stop its operation but will Not attempt to reconnect:

* The subscription no longer exists or has been deleted.
* Another worker has taken control of the subscription (see [connection strategy](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#available-worker-strategies)).
* The worker is unable to connect to any of the servers.
* The worker could not receive the node responsible for the task  
  (this can happen when there is no leader in the cluster).
* An authorization exception occurred.
* An exception occurred during the connection establishment phase.
* The database doesn't exist.

</Admonition>

<Admonition type="info" title="Batch processing execution failures" id="batch-processing-execution-failures" href="#batch-processing-execution-failures">

An exception may occur while processing a batch of documents in the worker.
For example:

<TabItem value="something-something" label="throw_during_user_logic">
<CodeBlock language="java">
{`workerWBatch.run(x -> \{
    throw new RuntimeException();
\});
`}
</CodeBlock>
</TabItem>

When creating a worker, the worker can be configured to handle these exceptions in either of the following ways,
depending on the `IgnoreSubscriberErrors` property in [SubscriptionWorkerOptions](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions):

* **Abort processing completely**  
  When `IgnoreSubscriberErrors` is set to _false_ (default):  
  The current batch processing will be aborted, and in this case, the worker will wrap the thrown exception in a `SubscriberErrorException` and will rethrow it.
  Processing of the subscription will be terminated without acknowledging progress to the server or retrying to connect.  
  As a result, the task returned by the `Run` function will complete in an erroneous state, throwing a _SubscriberErrorException_.

* **Continue processing subsequent batches**  
  When `IgnoreSubscriberErrors` is set to _true_:   
  The current batch processing will be aborted; however, the erroneous batch will be acknowledged without retrying,
  and processing will continue with the next batches.

</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">

Two properties in the [SubscriptionWorkerOptions](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions)
object control the behavior of a worker attempting to reconnect with the server:

* `timeToWaitBeforeConnectionRetry`  
  The time the worker will wait before attempting to reconnect.  
  Default: 5 seconds.
* `maxErroneousPeriod`  
  The maximum amount of time the subscription connection can remain in an erroneous state.   
  Once this period is exceeded, the worker will stop trying to reconnect.  
  Default: 5 minutes.

</Admonition>



## Worker strategies

There can only be one active subscription worker working on a subscription. 
Nevertheless, there are scenarios where it is required to interact between an existing subscription worker and one that tries to connect. 
This relationship and interoperation is configured by the `SubscriptionConnectionOptions` `Strategy` field.  
The strategy field is an enum, having the following values:  

* `OPEN_IF_FREE` - the server will allow the worker to connect only if there isn't any other currently connected workers.  
  If there is a existing connection, the incoming worker will throw a SubscriptionInUseException.  
* `WAIT_FOR_FREE` - If the client currently cannot open the subscription because it is used by another client, it will wait for the previous client to disconnect and only then will connect.  
  This is useful in client failover scenarios where there is one active client and another one already waiting to take its place.  
* `TAKE_OVER` - the server will allow an incoming connection to overthrow an existing one. It will behave according to the existing connection strategy:
  * The existing connection has a strategy that is not `TAKE_OVER`. In this case, the incoming connection will take over it causing the existing connection to throw a SubscriptionInUseException exception.  
  * The existing connection has a strategy that is `TAKE_OVER`. In this case, the incoming connection will throw a SubscriptionInUseException exception.  




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* Batches of documents sent from a Subscription Task defined on the server are consumed and processed by a subscription worker client.  
 
* The `subscription_worker` object, defined on the client, manages the communication between the server and the client and processes the document batches sent from the server.  
 
* There are several ways to create and configure the SubscriptionWorker - see `SubscriptionWorkerOptions`.  

* In this page:
  * [`subscription_worker` lifecycle](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#subscription_worker-lifecycle)  
  * [Error handling](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#error-handling)  
  * [Worker strategies](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#worker-strategies)
  * [Determining which workers a subscription will serve](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#determining-which-workers-a-subscription-will-serve)  

</Admonition>
## `subscription_worker` lifecycle

A `subscription_worker` object starts its life from being generated by the `store.subscriptions`:
<TabItem value="something-something" label="subscription_open_simple">
<CodeBlock language="python">
{`subscription_worker = store.subscriptions.get_subscription_worker_by_name(subscription_name, Order)
`}
</CodeBlock>
</TabItem>

At this point, the worker has only got its configuration. No connection or processing happens at this moment.  
To start processing, the `run` method should be called. The Run method receives the batch processing logic that should be performed:
<TabItem value="something-something" label="subscription_run_simple">
<CodeBlock language="python">
{`subscription_runtime_task = subscription_worker.run(
    process_documents=lambda batch: ...
)  # Pass your method that takes SubscriptionBatch[_T] as an argument, with your logic in it
`}
</CodeBlock>
</TabItem>

From this point on, the subscription worker will start processing batches.  
If processing is aborted for any reason, the returned task (`subscription_runtime_task`) will complete with an exception.  



## Error handling

<Admonition type="info" title="Subscription worker connection failures" id="subscription-worker-connection-failures" href="#subscription-worker-connection-failures">

Subscription worker connection failures may occur during the routine communication between the worker and the server.
When an unexpected error arises, the worker will attempt to **reconnect to the server**.

However, there are several conditions under which the worker will stop its operation but will Not attempt to reconnect:

* The subscription no longer exists or has been deleted.
* Another worker has taken control of the subscription (see [connection strategy](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#available-worker-strategies)).
* The worker is unable to connect to any of the servers.
* The worker could not receive the node responsible for the task  
  (this can happen when there is no leader in the cluster).
* An authorization exception occurred.
* An exception occurred during the connection establishment phase.
* The database doesn't exist.

</Admonition>

<Admonition type="info" title="Batch processing execution failures" id="batch-processing-execution-failures" href="#batch-processing-execution-failures">

An exception may occur while processing a batch of documents in the worker.
For example:

<TabItem value="something-something" label="throw_during_user_logic">
<CodeBlock language="python">
{`def _throw_exception(batch: SubscriptionBatch):
    raise Exception()

_ = worker_w_batch.run(_throw_exception)
`}
</CodeBlock>
</TabItem>

When creating a worker, the worker can be configured to handle these exceptions in either of the following ways,
depending on the `ignore_subscriber_errors` property in [SubscriptionWorkerOptions](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions):

* **Abort processing completely**  
  When `ignore_subscriber_errors` is set to _false_ (default):  
  The current batch processing will be aborted, and in this case, the worker will wrap the thrown exception in a `SubscriberErrorException` and will rethrow it.
  Processing of the subscription will be terminated without acknowledging progress to the server or retrying to connect.  
  As a result, the task returned by the `Run` function will complete in an erroneous state, throwing a _SubscriberErrorException_.

* **Continue processing subsequent batches**  
  When `ignore_subscriber_errors` is set to _true_:    
  The current batch processing will be aborted; however, the erroneous batch will be acknowledged without retrying,
  and processing will continue with the next batches.

</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">

Two properties in the [SubscriptionWorkerOptions](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions)
object control the behavior of a worker attempting to reconnect with the server:

* `time_to_wait_before_connection_retry`  
  The time the worker will wait before attempting to reconnect.  
  Default: 5 seconds.
* `max_erroneous_period`  
  The maximum amount of time the subscription connection can remain in an erroneous state.   
  Once this period is exceeded, the worker will stop trying to reconnect.  
  Default: 5 minutes.  

</Admonition>

<Admonition type="info" title="`on_unexpected_subscription_error`" id="on_unexpected_subscription_error" href="#on_unexpected_subscription_error">

`on_unexpected_subscription_error` is the event that is triggered when a connection failure occurs between the subscription worker and the server,
resulting in an unexpected exception.  
When this happens, the worker will automatically attempt to reconnect.  
This event is useful for logging these unexpected exceptions.

</Admonition>



## Worker strategies

Subscription workers are configured with a **strategy** that determines whether multiple workers
can connect to the subscription concurrently or if only one worker can connect at a time.

The _one-worker-at-a-time_ strategy also determines how the workers interact with each other
to resolve which will establish the subscription connection.
### One worker per subscription strategies

The following three strategies allow only a **single worker to connect to the subscription at any given time**,  
and determine what happens when one worker is connected and another tries to connect.

* `SubscriptionOpeningStrategy.OPEN_IF_FREE`  
  The server will allow a worker to connect only if no other worker is currently connected.  
  If there is an existing connection, the incoming worker will throw a `SubscriptionInUseException`.
* `SubscriptionOpeningStrategy.WAIT_FOR_FREE`  
  If the worker cannot open the subscription because it is in use by another worker, it will wait for the currently connected worker to disconnect before establishing the connection.
  This is useful in worker failover scenarios, where one worker is connected while another is awaiting its turn to take its place.
* `SubscriptionOpeningStrategy.TAKE_OVER`  
  The server will allow an incoming connection to take over an existing one,  
  based on the connection strategy in use by the currently connected worker:
    * If the existing connection **does not** have a `TAKE_OVER` strategy:  
      The incoming connection will take over, causing the existing connection to throw a `SubscriptionInUseException`.
    * If the existing connection **has** a `TAKE_OVER` strategy:  
      The incoming connection will throw a `SubscriptionInUseException` exception.
### Multiple workers per subscription strategy

* `SubscriptionOpeningStrategy.CONCURRENT`  
  The server allows multiple workers to connect to the same subscription **concurrently**.  
  Read more about concurrent subscriptions [here](../../../client-api/data-subscriptions/concurrent-subscriptions).



## Determining which workers a subscription will serve

<Admonition type="note" title="Note">

The **strategy used by the first worker connecting to a subscription** determines
which additional workers the subscription can serve until all worker connections are dropped.

</Admonition>

* A subscription that serves one or more [CONCURRENT](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#multiple-workers-per-subscription-strategy) workers, 
  **can only serve other concurrent workers** until all connections are dropped. 
  If a worker with a [one worker per subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#one-worker-per-subscription-strategies) 
  strategy attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  

* A subscription that serves a worker with a [one worker per subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#one-worker-per-subscription-strategies) strategy, 
  **cannot** serve [CONCURRENT](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#multiple-workers-per-subscription-strategy) 
  workers until that worker's connection is dropped. 
  If a concurrent worker attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Batches of documents sent from a Subscription Task defined on the server are consumed and processed by a subscription worker client.

* The `SubscriptionWorker` object, defined on the client, manages the communication between the server and the client and processes the document batches sent from the server.  

* There are several ways to create and configure the SubscriptionWorker - see [subscription worker options](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions).  

* In this page:
  * [SubscriptionWorker lifecycle](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#subscriptionworker-lifecycle)  
  * [Error handling](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#error-handling)  
  * [Worker strategies](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#worker-strategies)   
  * [Determining which workers a subscription will serve](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#determining-which-workers-a-subscription-will-serve)  

</Admonition>
## SubscriptionWorker lifecycle

Create a `SubscriptionWorker` object by calling `getSubscriptionWorker`:

<TabItem value="something-something" label="consume_1">
<CodeBlock language="nodejs">
{`const worker = documentStore.subscriptions.getSubscriptionWorker(\{
    subscriptionName: "your subscription name"
\});
`}
</CodeBlock>
</TabItem>

At this stage, the worker is initialized, no connection to the server or document processing occurs yet.

To start handling documents from the subscription, you need to define a listener for the `batch` event.  
This event is triggered whenever a new batch of documents is received.

Add an event handler using `on` method of the worker object to process incoming batches:

<TabItem value="something-something" label="consume_2">
<CodeBlock language="nodejs">
{`worker.on("batch", (batch, callback) => \{
    try \{
        // Add your logic for processing the incoming batch items here...               

        // Call 'callback' once you're done
        // The worker will send an acknowledgement to the server,
        // allowing the server to send the next batch
        callback();

    \} catch(err) \{
        // If processing fails for a particular batch then pass the error to the callback
        callback(err);
    \}
\});
`}
</CodeBlock>
</TabItem>

Once the event handler is defined, the worker will begin processing batches of documents sent by the server.
Each batch must be acknowledged by calling `callback()` once processing is complete. 



## Error handling

<Admonition type="info" title="Subscription worker connection failures" id="subscription-worker-connection-failures" href="#subscription-worker-connection-failures">

Subscription worker connection failures may occur during the routine communication between the worker and the server.
When an unexpected error arises, the worker will attempt to **reconnect to the server**.

However, there are several conditions under which the worker will stop its operation but will Not attempt to reconnect:

* The subscription no longer exists or has been deleted.
* Another worker has taken control of the subscription (see [connection strategy](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#available-worker-strategies)).
* The worker is unable to connect to any of the servers.
* The worker could not receive the node responsible for the task  
  (this can happen when there is no leader in the cluster).
* An authorization exception occurred.
* An exception occurred during the connection establishment phase.
* The database doesn't exist.

</Admonition>

<Admonition type="info" title="Batch processing execution failures" id="batch-processing-execution-failures" href="#batch-processing-execution-failures">

An exception may occur while processing a batch of documents in the worker.
For example:

<TabItem value="something-something" label="consume_3">
<CodeBlock language="nodejs">
{`worker.on("batch", (batch, callback) => \{
    try \{
        throw new Error("Exception occurred");
    \} catch (err) \{
        callback(err); // Pass the error to the callback to signal failure
    \}
\});
`}
</CodeBlock>
</TabItem>

When creating a worker, the worker can be configured to handle these exceptions in either of the following ways,
depending on the `ignoreSubscriberErrors` property in the [subscription worker options](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions):

* **Abort processing completely**  
  When `ignoreSubscriberErrors` is `false` (default):  
  The current batch processing will be aborted, and in this case, the worker will wrap the thrown exception in a `SubscriberErrorException` and will rethrow it.
  Processing of the subscription will be terminated without acknowledging progress to the server or retrying to connect.  
  As a result, the worker task will complete in an erroneous state, throwing a _SubscriberErrorException_.

* **Continue processing subsequent batches**  
  When `ignoreSubscriberErrors` is  `true`:    
  The current batch processing will be aborted; however, the erroneous batch will be acknowledged without retrying,
  and processing will continue with the next batches.

</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">

Two properties in the [subscription worker options](../../../client-api/data-subscriptions/consumption/api-overview#subscriptionworkeroptions) 
object control the behavior of a worker attempting to reconnect with the server:

* `timeToWaitBeforeConnectionRetry`  
  The time the worker will wait before attempting to reconnect.  
  Default: 5 seconds.  
* `maxErroneousPeriod`  
  The maximum amount of time the subscription connection can remain in an erroneous state.   
  Once this period is exceeded, the worker will stop trying to reconnect.  
  Default: 5 minutes.  

</Admonition>

<Admonition type="info" title="unexpectedSubscriptionError" id="unexpectedsubscriptionerror" href="#unexpectedsubscriptionerror">

`unexpectedSubscriptionError` is the event that is triggered when a connection failure occurs between the subscription worker and the server,
resulting in an unexpected exception.  
When this happens, the worker will automatically attempt to reconnect.  
This event is useful for logging these unexpected exceptions.

</Admonition>



## Worker strategies
 
Subscription workers are configured with a **strategy** that determines whether multiple workers 
can connect to the subscription concurrently or if only one worker can connect at a time.

The _one-worker-at-a-time_ strategy also determines how the workers interact with each other 
to resolve which will establish the subscription connection.
### One worker per subscription strategies

The following three strategies allow only a **single worker to connect to the subscription at any given time**,  
and determine what happens when one worker is connected and another tries to connect.  

* `OpenIfFree`  
  The server will allow a worker to connect only if no other worker is currently connected.  
  If there is an existing connection, the incoming worker will throw a `SubscriptionInUseException`.  
* `WaitForFree`  
  If the worker cannot open the subscription because it is in use by another worker, it will wait for the currently connected worker to disconnect before establishing the connection.
  This is useful in worker failover scenarios, where one worker is connected while another is awaiting its turn to take its place.
* `TakeOver`  
  The server will allow an incoming connection to take over an existing one,  
  based on the connection strategy in use by the currently connected worker:
  * If the existing connection **does not** have a `TakeOver` strategy:  
    The incoming connection will take over, causing the existing connection to throw a `SubscriptionInUseException`.  
  * If the existing connection **has** a `TakeOver` strategy:  
    The incoming connection will throw a `SubscriptionInUseException` exception.  
### Multiple workers per subscription strategy

* `Concurrent`  
  The server allows multiple workers to connect to the same subscription **concurrently**.  
  Read more about concurrent subscriptions [here](../../../client-api/data-subscriptions/concurrent-subscriptions).  



## Determining which workers a subscription will serve

<Admonition type="note" title="Note">

The **strategy used by the first worker connecting to a subscription** determines 
which additional workers the subscription can serve until all worker connections are dropped.

</Admonition>

* A subscription that serves one or more [concurrent](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#multiple-workers-per-subscription-strategy) workers, 
  **can only serve other concurrent workers** until all connections are dropped. 
  If a worker with a [one worker per subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#one-worker-per-subscription-strategies) 
  strategy attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  

* A subscription that serves a worker with a [one worker per subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#one-worker-per-subscription-strategies) strategy, 
  **cannot** serve [concurrent](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription#multiple-workers-per-subscription-strategy) 
  workers until that worker's connection is dropped. 
  If a concurrent worker attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  




</LanguageContent>