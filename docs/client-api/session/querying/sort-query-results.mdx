---
title: "Sort Query Results"
sidebar_label: Sort Query Results
sidebar_position: 5
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/language-switcher";
import LanguageContent from "@site/src/components/language-content";

export const supportedLanguages = ["csharp", "python", "php", "nodejs"];


# Sort Query Results
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* When making a query, the server will return the results __sorted__ only if explicitly requested by the query.  
  If no sorting method is specified when issuing the query then results will not be sorted.

    * Note: An exception to the above rule is when [Boosting](../../../indexes/boosting) is involved in the query.  
      Learn more in [Automatic score-based ordering](../../../indexes/boosting#automatic-score-based-ordering).

* Sorting is applied by the server after the query filtering stage.  
  Applying filtering is recommended as it reduces the number of results RavenDB needs to sort  
  when querying a large dataset.

* Multiple sorting actions can be chained.

* This article provides examples of sorting query results when making a __dynamic-query__.  
  For sorting results when querying a __static-index__ see [sort index query results](../../../indexes/querying/sorting).

* In this page:
    * [Order by field value](../../../client-api/session/querying/sort-query-results#order-by-field-value)
 
    * [Order by score](../../../client-api/session/querying/sort-query-results#order-by-score)
        * [Get resulting score](../../../client-api/session/querying/sort-query-results#get-resulting-score)
  
    * [Order by random](../../../client-api/session/querying/sort-query-results#order-by-random)
   
    * [Order by spatial](../../../client-api/session/querying/sort-query-results#order-by-spatial)
     
    * [Order by count (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-count-(aggregation-query))
  
    * [Order by sum (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-sum-(aggregation-query))

    * [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type)

    * [Chain ordering](../../../client-api/session/querying/sort-query-results#chain-ordering)

    * [Custom sorters](../../../client-api/session/querying/sort-query-results#custom-sorters) 

    * [Syntax](../../../client-api/session/querying/sort-query-results#syntax)

</Admonition>
## Order by field value

* Use `OrderBy` or `OrderByDescending` to order the results by the specified document-field.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
     // Make a dynamic query on the Products collection    
    .Query<Product>()
     // Apply filtering (optional)
    .Where(x => x.UnitsInStock > 10)
     // Call 'OrderBy', pass the document-field by which to order the results
    .OrderBy(x => x.UnitsInStock)
    .ToList();

// Results will be sorted by the 'UnitsInStock' value in ascending order,
// with smaller values listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
     // Make a dynamic query on the Products collection    
    .Query<Product>()
     // Apply filtering (optional)
    .Where(x => x.UnitsInStock > 10)
     // Call 'OrderBy', pass the document-field by which to order the results
    .OrderBy(x => x.UnitsInStock)
    .ToListAsync();

// Results will be sorted by the 'UnitsInStock' value in ascending order,
// with smaller values listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced
     // Make a DocumentQuery on the Products collection    
    .DocumentQuery<Product>()
     // Apply filtering (optional)
    .WhereGreaterThan(x => x.UnitsInStock, 10)
     // Call 'OrderBy', pass the document-field by which to order the results
    .OrderBy(x => x.UnitsInStock)
    .ToList();

// Results will be sorted by the 'UnitsInStock' value in ascending order,
// with smaller values listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

__Ordering Type__:

* By default, the `OrderBy` methods will determine the `OrderingType` from the property path expression  
  and specify that ordering type in the generated RQL that is sent to the server.  

* E.g. in the above example, ordering by `x => x.UnitsInStock` will result in `OrderingType.Long`  
  because that property data type is an integer.

* Different ordering can be forced - see [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type) below.

</Admonition>



## Order by score

* When querying with some filtering conditions, a basic score is calculated for each item in the results  
  by the underlying indexing engine.

* The higher the score value the better the match.  

* Use `OrderByScore` or `OrderByScoreDescending` to order by this score.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
    .Query<Product>()
     // Apply filtering
    .Where(x => x.UnitsInStock < 5 || x.Discontinued)
     // Call 'OrderByScore'
    .OrderByScore()
    .ToList();

// Results will be sorted by the score value
// with best matching documents (higher score values) listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
    .Query<Product>()
     // Apply filtering
    .Where(x => x.UnitsInStock < 5 || x.Discontinued)
     // Call 'OrderByScore'
    .OrderByScore()
    .ToListAsync();

// Results will be sorted by the score value
// with best matching documents (higher score values) listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced
    .DocumentQuery<Product>()
     // Apply filtering
    .WhereLessThan(x => x.UnitsInStock, 5)
    .OrElse()
    .WhereEquals(x => x.Discontinued, true)
     // Call 'OrderByScore'
    .OrderByScore()
    .ToList();

// Results will be sorted by the score value
// with best matching documents (higher score values) listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock < 5 or Discontinued == true
order by score()
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

#### Get resulting score:
The score details can be retrieved by either:

* __Request to include explanations__:  
  You can get the score details and see how it was calculated by requesting to include explanations in the query.
  Currently, this is only available when using Lucene as the underlying indexing engine.  
  Learn more in [Include query explanations](../../../client-api/session/querying/debugging/include-explanations).

* __Get score from metadata__:    

    * The score is available in the `@index-score` metadata property within each result.  
      Note the following difference between the underlying indexing engines:

      * When using __Lucene__:  
          This metadata property is always available in the results.  
          Read more about Lucene scoring [here](https://lucene.apache.org/core/3_3_0/scoring.html).

      * When using __Corax__:  
          In order to enhance performance, this metadata property is Not included in the results by default.  
          To get this metadata property you must set the [Indexing.Corax.IncludeDocumentScore](../../../server/configuration/indexing-configuration#indexing.corax.includedocumentscore) configuration value to _true_.  
          Learn about the available methods for setting an indexing configuration key in this [indexing-configuration](../../../server/configuration/indexing-configuration) article.

    * The following example shows how to get the score from the metadata of the resulting entities that were loaded to the session:  

<TabItem value="something-something" label="get_score_from_metadata">
<CodeBlock language="csharp">
{`// Make a query:
// =============

List<Employee> employees = session
    .Query<Employee>()
    .Search(x => x.Notes, "English")
    .Search(x => x.Notes, "Italian", boost: 10)
    .ToList();

// Get the score:
// ==============

// Call 'GetMetadataFor', pass an entity from the resulting employees list
var metadata = session.Advanced.GetMetadataFor(employees[0]);

// Score is available in the '@index-score' metadata property
var score = metadata[Constants.Documents.Metadata.IndexScore];
`}
</CodeBlock>
</TabItem>
 
</Admonition>



## Order by random

* Use `RandomOrdering` to randomize the order of the query results.

* An optional seed parameter can be passed.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
    .Query<Product>()
    .Where(x => x.UnitsInStock > 10)
     // Call 'Customize' with 'RandomOrdering'
    .Customize(x => x.RandomOrdering())
     // An optional seed can be passed, e.g.:
     // .Customize(x => x.RandomOrdering('someSeed'))
    .ToList();

// Results will be randomly ordered.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
    .Query<Product>()
    .Where(x => x.UnitsInStock > 10)
     // Call 'Customize' with 'RandomOrdering'
    .Customize(x => x.RandomOrdering())
     // An optional seed can be passed, e.g.:
     // .Customize(x => x.RandomOrdering('someSeed'))
    .ToListAsync();

// Results will be randomly ordered.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced  
    .DocumentQuery<Product>()
    .WhereGreaterThan(x => x.UnitsInStock, 10)
     // Call 'RandomOrdering'
    .RandomOrdering()
     // An optional seed can be passed, e.g.:
     // .RandomOrdering('someSeed')
    .ToList();

// Results will be randomly ordered.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by random()
// order by random(someSeed)
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by spatial

* If your data contains geographical locations,  
  spatial query results can be sorted based on their distance from a specific point.

* See detailed explanation in [Spatial Sorting](../../../client-api/session/querying/how-to-make-a-spatial-query#spatial-sorting).



## Order by count (aggregation query)

* The results of a [group-by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `Count` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var numberOfProductsPerCategory = session
    .Query<Product>()
     // Make an aggregation query
    .GroupBy(x => x.Category)
    .Select(x => new
    {
        // Group by Category
        Category = x.Key,
        // Count the number of product documents per category
        Count = x.Count()
    })
     // Order by the Count value
    .OrderBy(x => x.Count)
    .ToList();

// Results will contain the number of Product documents per category
// ordered by that count in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var numberOfProductsPerCategory = await asyncSession
    .Query<Product>()
     // Make an aggregation query
    .GroupBy(x => x.Category)
    .Select(x => new
    {
        // Group by Category
        Category = x.Key,
        // Count the number of product documents per category
        Count = x.Count()
    })
     // Order by the Count value
    .OrderBy(x => x.Count)
    .ToListAsync();

// Results will contain the number of Product documents per category
// ordered by that count in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var numberOfProductsPerCategory = session.Advanced
    .DocumentQuery<Product>()
     // Group by Category
    .GroupBy("Category")
    .SelectKey("Category")
     // Count the number of product documents per category
    .SelectCount()
     // Order by the Count value
     // Here you need to specify the ordering type explicitly 
    .OrderBy("Count", OrderingType.Long)
    .ToList();

// Results will contain the number of Product documents per category
// ordered by that count in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by count() as long
select key() as "Category", count()
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by sum (aggregation query)

* The results of a [group-by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `Sum` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var numberOfUnitsInStockPerCategory = session
    .Query<Product>()
     // Make an aggregation query
    .GroupBy(x => x.Category)
    .Select(x => new
    {
        // Group by Category
        Category = x.Key,
        // Sum the number of units in stock per category
        Sum = x.Sum(x => x.UnitsInStock)
    })
     // Order by the Sum value
    .OrderBy(x => x.Sum)
    .ToList();

// Results will contain the total number of units in stock per category
// ordered by that number in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var numberOfUnitsInStockPerCategory = await asyncSession
    .Query<Product>()
     // Make an aggregation query
    .GroupBy(x => x.Category)
    .Select(x => new
    {
        // Group by Category
        Category = x.Key,
        // Sum the number of units in stock per category
        Sum = x.Sum(x => x.UnitsInStock)
    })
     // Order by the Sum value
    .OrderBy(x => x.Sum)
    .ToListAsync();

// Results will contain the total number of units in stock per category
// ordered by that number in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var numberOfUnitsInStockPerCategory = session.Advanced
    .DocumentQuery<Product>()
     // Group by Category
    .GroupBy("Category")
    .SelectKey("Category")
     // Sum the number of units in stock per category
    .SelectSum(new GroupByField
    {
        FieldName = "UnitsInStock",
        ProjectedName = "Sum"
    })
     // Order by the Sum value
     // Here you need to specify the ordering type explicitly 
    .OrderBy("Sum", OrderingType.Long)
    .ToList();

// Results will contain the total number of units in stock per category
// ordered by that number in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by Sum as long
select key() as 'Category', sum(UnitsInStock) as Sum
`}
</CodeBlock>
</TabItem>
</Tabs>



## Force ordering type

* By default, the `OrderBy` methods will determine the `OrderingType` from the property path expression  
  and specify that ordering type in the generated RQL that is sent to the server.

* A different ordering can be forced by passing the ordering type explicitly to `OrderBy` or `OrderByDescending`.

* The following ordering types are available:

    * `OrderingType.Long`
    * `OrderingType.Double`
    * `OrderingType.AlphaNumeric`
    * `OrderingType.String` (lexicographic ordering)

* When using RQL directly, if no ordering type is specified, then the server defaults to lexicographic ordering.

<Admonition type="note" title="Note">

__Using alphanumeric ordering example__:

* When ordering mixed-character strings by the default lexicographical ordering  
  then comparison is done character by character based on the Unicode values.  
  For example, "Abc9" will come after "Abc10" since 9 is greater than 1.

* If you want the digit characters to be ordered as numbers then use alphanumeric ordering  
  where "Abc10" will result after "Abc9".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
    .Query<Product>()
     // Call 'OrderBy', order by field 'QuantityPerUnit'
     // Pass a second param, requesting to order the text alphanumerically
    .OrderBy(x => x.QuantityPerUnit, OrderingType.AlphaNumeric)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
    .Query<Product>()
     // Call 'OrderBy', order by field 'QuantityPerUnit'
     // Pass a second param, requesting to order the text alphanumerically
    .OrderBy(x => x.QuantityPerUnit, OrderingType.AlphaNumeric)
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced
    .DocumentQuery<Product>()
     // Call 'OrderBy', order by field 'QuantityPerUnit'
     // Pass a second param, requesting to order the text alphanumerically
    .OrderBy(x => x.QuantityPerUnit, OrderingType.AlphaNumeric)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
order by QuantityPerUnit as alphanumeric
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="something" label="sort_16_results">
<CodeBlock language="csharp">
{`// Running the above query on the NorthWind sample data,
// would produce the following order for the QuantityPerUnit field:
// ================================================================

// "1 kg pkg."
// "1k pkg."
// "2 kg box."
// "4 - 450 g glasses"
// "5 kg pkg."
// ...

// While running with the default Lexicographical ordering would have produced:
// ============================================================================

// "1 kg pkg."
// "10 - 200 g glasses"
// "10 - 4 oz boxes"
// "10 - 500 g pkgs."
// "10 - 500 g pkgs."
// ...
`}
</CodeBlock>
</TabItem>

</Admonition>



## Chain ordering

* It is possible to chain multiple orderings in the query.  
  Any combination of secondary sorting is possible as the fields are indexed independently of one another.

* There is no limit on the number of sorting actions that can be chained.
  
* This is achieved by using the `ThenBy` (`ThenByDescending`) and `ThenByScore` (`ThenByScoreDescending`) methods.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
    .Query<Product>()
    .Where(x => x.UnitsInStock > 10)
     // Apply the primary sort by 'UnitsInStock'
    .OrderByDescending(x => x.UnitsInStock)
     // Apply a secondary sort by the score (for products with the same # of units in stock)
    .ThenByScore()
     // Apply another sort by 'Name' (for products with same # of units in stock and same score)
    .ThenBy(x => x.Name)
    .ToList();

// Results will be sorted by the 'UnitsInStock' value (descending),
// then by score,
// and then by 'Name' (ascending).
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
    .Query<Product>()
    .Where(x => x.UnitsInStock > 10)
     // Apply the primary sort by 'UnitsInStock'
    .OrderByDescending(x => x.UnitsInStock)
     // Apply a secondary sort by the score (for products with the same # of units in stock)
    .ThenByScore()
     // Apply another sort by 'Name' (for products with same # of units in stock and same score)
    .ThenBy(x => x.Name)
    .ToListAsync();

// Results will be sorted by the 'UnitsInStock' value (descending),
// then by score,
// and then by 'Name' (ascending).
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced
    .DocumentQuery<Product>()
    .WhereGreaterThan(x => x.UnitsInStock, 10)
     // Apply the primary sort by 'UnitsInStock'
    .OrderByDescending(x => x.UnitsInStock)
     // Apply a secondary sort by the score
    .OrderByScore()
     // Apply another sort by 'Name'
    .OrderBy(x => x.Name)
    .ToList();

// Results will be sorted by the 'UnitsInStock' value (descending),
// then by score,
// and then by 'Name' (ascending).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long desc, score(), Name
`}
</CodeBlock>
</TabItem>
</Tabs>



## Custom sorters 

* The Lucene indexing engine allows you to create your own custom sorters.  
  Custom sorters are not supported by [Corax](../../../indexes/search-engine/corax).  
 
* Custom sorters can be deployed to the server by either:  

     * Sending the [Put Sorters Operation](../../../client-api/operations/maintenance/sorters/put-sorter) from your code.
  
     * Uploading a custom sorter from Studio, see [Custom Sorters View](../../../studio/database/settings/custom-sorters).

* Once the custom sorter is deployed, you can sort the query results with it.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
    .Query<Product>()
    .Where(x => x.UnitsInStock > 10)
     // Order by field 'UnitsInStock', pass the name of your custom sorter class
    .OrderBy(x => x.UnitsInStock, "MySorter")
    .ToList();

// Results will be sorted by the 'UnitsInStock' value
// according to the logic from 'MySorter' class
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
    .Query<Product>()
    .Where(x => x.UnitsInStock > 10)
     // Order by field 'UnitsInStock', pass the name of your custom sorter class
    .OrderBy(x => x.UnitsInStock, "MySorter")
    .ToListAsync();

// Results will be sorted by the 'UnitsInStock' value
// according to the logic from 'MySorter' class
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced
    .DocumentQuery<Product>()
    .WhereGreaterThan(x => x.UnitsInStock, 10)
     // Order by field 'UnitsInStock', pass the name of your custom sorter class
    .OrderBy(x => x.UnitsInStock, "MySorter")
    .ToList();

// Results will be sorted by the 'UnitsInStock' value
// according to the logic from 'MySorter' class
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by custom(UnitsInStock, "MySorter")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax

<TabItem value="something" label="syntax">
<CodeBlock language="csharp">
{`// OrderBy overloads:
IOrderedQueryable<T> OrderBy<T>(string path, OrderingType ordering);
IOrderedQueryable<T> OrderBy<T>(Expression<Func<T, object>> path, OrderingType ordering);
IOrderedQueryable<T> OrderBy<T>(string path, string sorterName);
IOrderedQueryable<T> OrderBy<T>(Expression<Func<T, object>> path, string sorterName);

// OrderByDescending overloads:
IOrderedQueryable<T> OrderByDescending<T>(string path, OrderingType ordering);
IOrderedQueryable<T> OrderByDescending<T>(Expression<Func<T, object>> path, OrderingType ordering);
IOrderedQueryable<T> OrderByDescending<T>(string path, string sorterName);
IOrderedQueryable<T> OrderByDescending<T>(Expression<Func<T, object>> path, string sorterName);
`}
</CodeBlock>
</TabItem>

| Parameter      | Type                          | Description                                                                                                                                                                |
|----------------|-------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| __path__       | `string`                      | The name of the field to sort by                                                                                                                                           |
| __path__       | `Expression<Func<T, object>>` | A lambda expression to the field by which to sort                                                                                                                          |
| __ordering__   | `QueryStatistics`             | The ordering type that will be used to sort the results:<br/>`OrderingType.Long`<br/>`OrderingType.Double`<br/>`OrderingType.AlphaNumeric`<br/>`OrderingType.String` (default) |
| __sorterName__ | `string`                      | The name of your custom sorter class                                                                                                                                       |




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* When making a query, the server will return the results **sorted** only if explicitly requested by the query.  
  If no sorting method is specified when issuing the query then results will not be sorted.

    * Note: An exception to the above rule is when [Boosting](../../../indexes/boosting) is involved in the query.  
      Learn more in [Automatic score-based ordering](../../../indexes/boosting#automatic-score-based-ordering).

* Sorting is applied by the server after the query filtering stage.  
  Applying filtering is recommended as it reduces the number of results RavenDB needs to sort  
  when querying a large dataset.

* Multiple sorting actions can be chained.

* This article provides examples of sorting query results when making a **dynamic-query**.  
  For sorting results when querying a **static-index** see [sort index query results](../../../indexes/querying/sorting).

* In this page:
    * [Order by field value](../../../client-api/session/querying/sort-query-results#order-by-field-value)
 
    * [Order by score](../../../client-api/session/querying/sort-query-results#order-by-score)
        * [Get resulting score](../../../client-api/session/querying/sort-query-results#get-resulting-score)
  
    * [Order by random](../../../client-api/session/querying/sort-query-results#order-by-random)
   
    * [Order by spatial](../../../client-api/session/querying/sort-query-results#order-by-spatial)
     
    * [Order by count (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-count-(aggregation-query))
  
    * [Order by sum (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-sum-(aggregation-query))

    * [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type)

    * [Chain ordering](../../../client-api/session/querying/sort-query-results#chain-ordering)

    * [Custom sorters](../../../client-api/session/querying/sort-query-results#custom-sorters) 

    * [Syntax](../../../client-api/session/querying/sort-query-results#syntax)

</Admonition>
## Order by field value

* Use `OrderBy` or `OrderByDescending` to order the results by the specified document-field.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session
    # Make a dynamic query on the 'Products' collection
    .query_collection("Products")
    # Apply filtering (optional)
    .where_greater_than("units_in_stock", 10)
    # Call 'order_by'
    # Pass the document-field by which to order the results and the ordering type
    .order_by("units_in_stock", OrderingType.LONG)
)

# Results will be sorted by the 'units_in_stock' value in ascending order,
# with smaller values listed first
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

**Ordering Type**:

* By default, the `order_by` methods will determine the `OrderingType` from the property path expression  
  and specify that ordering type in the generated RQL that is sent to the server.  

* E.g. in the above example, ordering by `x => x.units_in_stock` will result in `OrderingType.LONG`  
  because that property data type is an integer.

* Different ordering can be forced - see [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type) below.

</Admonition>



## Order by score

* When querying with some filtering conditions, a basic score is calculated for each item in the results  
  by the underlying indexing engine.

* The higher the score value the better the match.  

* Use `order_by_score` or `order_by_score_descending` to order the query results by this score.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session.query_collection("Products")
    # Apply filtering
    .where_less_than("units_in_stock", 5)
    .or_else()
    .where_equals("discontinued", True)
    # Call 'order_by_score'
    .order_by_score()
)

# Results will be sorted by the score value
# with best matching documents (higher score values) listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock < 5 or Discontinued == true
order by score()
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

#### Get resulting score:
The score details can be retrieved by either:

* **Request to include explanations**:  
  You can get the score details and see how it was calculated by requesting to include explanations in the query.
  Currently, this is only available when using Lucene as the underlying indexing engine.  
  Learn more in [Include query explanations](../../../client-api/session/querying/debugging/include-explanations).

* **Get score from metadata**:    

    * The score is available in the `@index-score` metadata property within each result.  
      Note the following difference between the underlying indexing engines:

      * When using **Lucene**:  
          This metadata property is always available in the results.  
          Read more about Lucene scoring [here](https://lucene.apache.org/core/3_3_0/scoring.html).

      * When using **Corax**:  
          In order to enhance performance, this metadata property is Not included in the results by default.  
          To get this metadata property you must set the [Indexing.Corax.IncludeDocumentScore](../../../server/configuration/indexing-configuration#indexing.corax.includedocumentscore) configuration value to `True`  
          Learn about the available methods for setting an indexing configuration key in this [indexing-configuration](../../../server/configuration/indexing-configuration) article.

</Admonition>



## Order by random

* Use `RandomOrdering` to randomize the order of the query results.

* An optional seed parameter can be passed.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session.query_collection("Products").where_greater_than("units_in_stock", 10)
    # Call 'random_ordering'
    .random_ordering()
    # An optional seed can be passed, e.g.:
    # .random_ordering("someSeed")
)

# Results will be randomly ordered
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by random()
// order by random(someSeed)
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by spatial

* If your data contains geographical locations,  
  spatial query results can be sorted based on their distance from a specific point.

* See detailed explanation in [Spatial Sorting](../../../client-api/session/querying/how-to-make-a-spatial-query#spatial-sorting).



## Order by count (aggregation query)

* The results of a [group_by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `count` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`number_of_products_per_category = list(
    session.query_collection("Products", Product)
    # Group by category
    .group_by("category").select_key("category")
    # Count the number of product documents per category
    .select_count()
    # Order by the count value
    .order_by("count", OrderingType.LONG)
)

# Results will contain the number of Product documents per category
# ordered by that count in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by count() as long
select key() as "Category", count()
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by sum (aggregation query)

* The results of a [group_by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `sum` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`number_of_units_in_stock_per_category = list(
    session.query_collection("Products", Product)
    # Group by category
    .group_by("category").select_key("category")
    # Sum the number of units in stock per category
    .select_sum(GroupByField("units_in_stock", "sum"))
    # Order by the sum value
    .order_by("sum", OrderingType.LONG)
)

# Results will contain the total number of units in stock per category
# ordered by that number in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by Sum as long
select key() as 'Category', sum(UnitsInStock) as Sum
`}
</CodeBlock>
</TabItem>
</Tabs>



## Force ordering type

* By default, the `order_by` methods will determine the `OrderingType` from the property path expression  
  and specify that ordering type in the generated RQL that is sent to the server.

* A different ordering can be forced by passing the ordering type explicitly to `order_by` or `order_by_descending`.

* The following ordering types are available:

    * `OrderingType.LONG`
    * `OrderingType.DOUBLE`
    * `OrderingType.ALPHA_NUMERIC`
    * `OrderingType.STRING` (lexicographic ordering)

* When using RQL directly, if no ordering type is specified, then the server defaults to lexicographic ordering.

<Admonition type="note" title="Note">

**Using alphanumeric ordering example**:

* When ordering mixed-character strings by the default lexicographical ordering  
  then comparison is done character by character based on the Unicode values.  
  For example, "Abc9" will come after "Abc10" since 9 is greater than 1.

* If you want the digit characters to be ordered as numbers then use alphanumeric ordering  
  where "Abc10" will result after "Abc9".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session.query_collection("products")
    # Call 'order_by', order by field 'quantity_per_unit'
    # Pass a second param, requesting to order the text alphanumerically
    .order_by("quantity_per_unit", OrderingType.ALPHA_NUMERIC)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
order by QuantityPerUnit as alphanumeric
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



## Chain ordering

* It is possible to chain multiple orderings in the query.  
  Any combination of secondary sorting is possible as the fields are indexed independently of one another.

* There is no limit on the number of sorting actions that can be chained.
  
* This is achieved by using the `then_by` (`then_by_descending`) and `then_by_score` (`then_by_score_descending`) methods.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session.query_collection("Products").where_greater_than("units_in_stock", 10)
    # Apply the primary sort by 'units_in_stock'
    .order_by_descending("units_in_stock", OrderingType.LONG)
    # Apply a secondary sort by the score
    .order_by_score()
    # Apply another sort by 'Name'
    .order_by("name")
)

#  Results will be sorted by the 'units_in_stock' value (descending),
#  then by score,
#  and then by 'name' (ascending).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long desc, score(), Name
`}
</CodeBlock>
</TabItem>
</Tabs>



## Custom sorters 

* The Lucene indexing engine allows you to create your own custom sorters.  
  Custom sorters are not supported by [Corax](../../../indexes/search-engine/corax).  
 
* Custom sorters can be deployed to the server by either:  

     * Sending the [Put Sorters Operation](../../../client-api/operations/maintenance/sorters/put-sorter) from your code.
  
     * Uploading a custom sorter from Studio, see [Custom Sorters View](../../../studio/database/settings/custom-sorters).

* Once the custom sorter is deployed, you can sort the query results with it.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session.query(object_type=Product).where_greater_than("units_in_stock", 10)
    # Order by field 'units_in_stock', pass the name of your custom sorter class
    .order_by("units_in_stock", "MySorter")
)

# Results will be sorted by the 'units_in_stock' value
# according to the logic from 'MySorter' class
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by custom(UnitsInStock, "MySorter")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax

<TabItem value="something-something" label="syntax">
<CodeBlock language="python">
{`# order_by:
def order_by(
    self, field: str, sorter_name_or_ordering_type: Union[str, OrderingType] = OrderingType.STRING
) -> DocumentQuery[_T]: ...

# order_by_descending:
def order_by_descending(
    self, field: str, sorter_name_or_ordering_type: Union[str, OrderingType] = OrderingType.STRING
) -> DocumentQuery[_T]: ...
`}
</CodeBlock>
</TabItem>

| Parameter      | Type                          | Description                                                                                                                                                                |
|----------------|-------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **field**       | `str`                      | The name of the field to sort by                                                                                                                                           |
| **sorter_name_or_ordering_type**       | `Union[str, OrderingType]` | The custom sorter class name<br/>**-or-**<br/>The results sorting ordering type<br/>Can be:<br/>`OrderingType.LONG`<br/>`OrderingType.DOUBLE`<br/>`OrderingType.ALPHA_NUMERIC`<br/>`OrderingType.STRING` (default) |




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* When making a query, the server will return the results **sorted** only if explicitly requested by the query.  
  If no sorting method is specified when issuing the query then results will not be sorted.
  
    * Note: An exception to the above rule is when [Boosting](../../../indexes/boosting) is involved in the query.  
      Learn more in [Automatic score-based ordering](../../../indexes/boosting#automatic-score-based-ordering).  

* Sorting is applied by the server after the query filtering stage.  
  Applying filtering is recommended as it reduces the number of results RavenDB needs to sort  
  when querying a large dataset.

* Multiple sorting actions can be chained.

* This article provides examples of sorting query results when making a **dynamic-query**.  
  For sorting results when querying a **static-index** see [sort index query results](../../../indexes/querying/sorting).

* In this page:
    * [Order by field value](../../../client-api/session/querying/sort-query-results#order-by-field-value) 
  
    * [Order by score](../../../client-api/session/querying/sort-query-results#order-by-score)  
        * [Get resulting score](../../../client-api/session/querying/sort-query-results#get-resulting-score)
     
    * [Order by random](../../../client-api/session/querying/sort-query-results#order-by-random)   
     
    * [Order by spatial](../../../client-api/session/querying/sort-query-results#order-by-spatial)
     
    * [Order by count (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-count-(aggregation-query))
     
    * [Order by sum (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-sum-(aggregation-query))
     
    * [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type)
     
    * [Chain ordering](../../../client-api/session/querying/sort-query-results#chain-ordering)
     
    * [Custom sorters](../../../client-api/session/querying/sort-query-results#custom-sorters)
     
    * [Syntax](../../../client-api/session/querying/sort-query-results#syntax)

</Admonition>
## Order by field value

* Use `orderBy` or `orderByDescending` (see below) to order the results by the specified document field.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session
    // Make a dynamic query on the Products collection
    ->query(Product::class)
    // Apply filtering (optional)
    ->whereGreaterThan("UnitsInStock", 10)
    // Call 'OrderBy', pass the document-field by which to order the results
    ->orderBy("UnitsInStock")
    ->toList();

// Results will be sorted by the 'UnitsInStock' value in ascending order,
// with smaller values listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session->advanced()
    // Make a DocumentQuery on the Products collection
    ->documentQuery(Product::class)
    // Apply filtering (optional)
    ->whereGreaterThan("UnitsInStock", 10)
    // Call 'OrderBy', pass the document-field by which to order the results
    ->orderBy("UnitsInStock")
    ->toList();

// Results will be sorted by the 'UnitsInStock' value in ascending order,
// with smaller values listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

**Ordering Type**:

* By default, the `orderBy` methods will determine the `OrderingType` from the property path expression  
  and specify that ordering type in the generated RQL that is sent to the server.  

* E.g. in the above example, ordering by `UnitsInStock` will result in `OrderingType::long`  
  because this property's data type is integer.

* Different ordering can be forced - see [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type) below.

</Admonition>



## Order by score

* When querying with some filtering conditions, a basic score is calculated for each item in the results  
  by the underlying indexing engine. (Read more about Lucene scoring [here](https://lucene.apache.org/core/3_3_0/scoring.html)).

* The higher the score value the better the match.  

* Use `orderByScore` to order the query results by this score.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session
    ->query(Product::class)
    // Apply filtering
    ->whereLessThan("UnitsInStock", 5)
    ->orElse()
    ->whereEquals("Discontinued", true)
    // Call 'orderByScore'
    ->orderByScore()
    ->toList();

// Results will be sorted by the score value
// with best matching documents (higher score values) listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session->advanced()
    ->documentQuery(Product::class)
    // Apply filtering
    ->whereLessThan("UnitsInStock", 5)
    ->orElse()
    ->whereEquals("Discontinued", true)
    // Call 'orderByScore'
    ->orderByScore()
    ->toList();

// Results will be sorted by the score value
// with best matching documents (higher score values) listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock < 5 or Discontinued == true
order by score()
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

#### Get resulting score:
The score details can be retrieved by either:  
 
  * **Request to include explanations**:  
    You can get the score details and see how it was calculated by requesting to include explanations in the query. 
    Currently, this is only available when using Lucene as the underlying indexing engine.  
    Learn more in [Include query explanations](../../../client-api/session/querying/debugging/include-explanations).
   
  * **Get score from metadata**:  
    The score is available in the `INDEX_SCORE` metadata property within each result.  
    The following example shows how to get the score from the metadata of the resulting entities that were loaded to the session:

<TabItem value="something-something" label="get_score_from_metadata">
<CodeBlock language="php">
{`// Make a query:
// =============

$employees = $session
    ->query(Employee::class)
    ->search("Notes", "English")
    ->search("Notes", "Italian")
    ->boost(10)
    ->toList();

// Get the score:
// ==============

// Call 'GetMetadataFor', pass an entity from the resulting employees list
$metadata = $session->advanced()->getMetadataFor($employees[0]);

// Score is available in the 'INDEX_SCORE' metadata property
$score = $metadata[DocumentsMetadata::INDEX_SCORE];
`}
</CodeBlock>
</TabItem>

</Admonition>



## Order by random

* Use `randomOrdering` to randomize the order of the query results.

* An optional seed parameter can be passed.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session->query(Product::class)
    ->whereGreaterThan("UnitsInStock", 10)
    // Call 'randomOrdering'
    ->randomOrdering()
    // An optional seed can be passed, e.g.:
    // ->randomOrdering('someSeed')
    ->toList();

// Results will be randomly ordered.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session->advanced()
    ->documentQuery(Product::class)
    ->whereGreaterThan("UnitsInStock", 10)
    // Call 'randomOrdering'
    ->randomOrdering()
    // An optional seed can be passed, e.g.:
    // ->randomOrdering('someSeed')
    ->toList();

// Results will be randomly ordered.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by random()
// order by random(someSeed)
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by spatial

* If your data contains geographical locations,  
  spatial query results can be sorted based on their distance from a specific point.

* See detailed explanation in [Spatial Sorting](../../../client-api/session/querying/how-to-make-a-spatial-query#spatial-sorting).



## Order by count (aggregation query)

* The results of a [group-by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `Count` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$numberOfProductsPerCategory = $session
    ->query(Product::class)
    // Make an aggregation query
    ->groupBy("Category")
    ->selectKey("Category")
    // Count the number of product documents per category
    ->selectCount()
    // Order by the Count value
    // Here you need to specify the ordering type explicitly
    ->orderBy("Count", OrderingType::long())
    ->toList();

// Results will contain the number of Product documents per category
// ordered by that count in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`$numberOfProductsPerCategory = $session->advanced()
    ->documentQuery(Product::class)
    // Group by Category
    ->groupBy("Category")
    ->selectKey("Category")
    // Count the number of product documents per category
    ->selectCount()
    // Order by the Count value
    // Here you need to specify the ordering type explicitly
    ->orderBy("Count", OrderingType::long())
    ->toList();

// Results will contain the number of Product documents per category
// ordered by that count in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by count() as long
select key() as "Category", count()
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by sum (aggregation query)

* The results of a [group-by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `Sum` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$numberOfUnitsInStockPerCategory = $session
    ->query(Product::class)
    // Make an aggregation query
    // Group by Category
    ->groupBy("Category")
    // Order by the Sum value
    ->selectKey("Category")
    ->selectSum(new GroupByField("UnitsInStock", "Sum"))
    ->orderBy("Sum")
    ->toList();

// Results will contain the total number of units in stock per category
// ordered by that number in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`$numberOfUnitsInStockPerCategory = $session->advanced()
    ->documentQuery(Product::class)
    // Group by Category
    ->groupBy("Category")
    ->selectKey("Category")
    // Sum the number of units in stock per category
    ->selectSum(new GroupByField("UnitsInStock", "Sum"))
    // Order by the Sum value
    // Here you need to specify the ordering type explicitly
    ->orderBy("Sum", OrderingType::long())
    ->toList();

// Results will contain the total number of units in stock per category
// ordered by that number in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by Sum as long
select key() as 'Category', sum(UnitsInStock) as Sum
`}
</CodeBlock>
</TabItem>
</Tabs>



## Force ordering type

* By default, the `orderBy` methods will determine the `OrderingType` from the property path expression  
  and specify that ordering type in the generated RQL that is sent to the server.

* A different ordering can be forced by passing the ordering type explicitly to `orderBy` or `orderByDescending`.

* The following ordering types are available:

    * `OrderingType::long`
    * `OrderingType::double`
    * `OrderingType::alphaNumeric`
    * `OrderingType::string` (lexicographic ordering)

* When using RQL directly, if no ordering type is specified, then the server defaults to lexicographic ordering.

<Admonition type="note" title="Note">

**Using alphanumeric ordering example**:

* When ordering mixed-character strings by the default lexicographical ordering  
  then comparison is done character by character based on the Unicode values.  
  For example, "Abc9" will come after "Abc10" since 9 is greater than 1.

* If you want the digit characters to be ordered as numbers then use alphanumeric ordering  
  where "Abc10" will result after "Abc9".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session
    ->query(Product::class)
    // Call 'OrderBy', order by field 'QuantityPerUnit'
    // Pass a second param, requesting to order the text alphanumerically
    ->orderBy("QuantityPerUnit", OrderingType::alphaNumeric())
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session->advanced()
    ->documentQuery(Product::class)
    // Call 'OrderBy', order by field 'QuantityPerUnit'
    // Pass a second param, requesting to order the text alphanumerically
    ->orderBy("QuantityPerUnit", OrderingType::alphaNumeric())
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
order by QuantityPerUnit as alphanumeric
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



## Chain ordering

* It is possible to chain multiple orderings in the query.  
  Any combination of secondary sorting is possible as the fields are indexed independently of one another.

* There is no limit on the number of sorting actions that can be chained.
  
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session
    ->query(Product::class)
    ->whereGreaterThan("UnitsInStock", 10)
    // Apply the primary sort by 'UnitsInStock'
    ->orderByDescending("UnitsInStock")
    // Apply a secondary sort by the score (for products with the same # of units in stock)
    ->orderByScore()
    // Apply another sort by 'Name' (for products with same # of units in stock and same score)
    ->orderBy("Name")
    ->toList();

// Results will be sorted by the 'UnitsInStock' value (descending),
// then by score,
// and then by 'Name' (ascending).
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session->advanced()
    ->documentQuery(Product::class)
    ->whereGreaterThan("UnitsInStock", 10)
    // Apply the primary sort by 'UnitsInStock'
    ->orderByDescending("UnitsInStock")
    // Apply a secondary sort by the score
    ->orderByScore()
    // Apply another sort by 'Name'
    ->orderBy("Name")
    ->toList();

// Results will be sorted by the 'UnitsInStock' value (descending),
// then by score,
// and then by 'Name' (ascending).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long desc, score(), Name
`}
</CodeBlock>
</TabItem>
</Tabs>



## Custom sorters 

* The Lucene indexing engine allows you to create your own custom sorters.  
  Custom sorters can be deployed to the server by either:  

     * Sending the [Put Sorters Operation](../../../client-api/operations/maintenance/sorters/put-sorter) from your code.
  
     * Uploading a custom sorter from Studio, see [Custom Sorters View](../../../studio/database/settings/custom-sorters).

* Once the custom sorter is deployed, you can sort the query results with it.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session
    ->query(Product::class)
    ->whereGreaterThan("UnitsInStock", 10)
    // Order by field 'UnitsInStock', pass the name of your custom sorter class
    ->orderBy("UnitsInStock", "MySorter")
    ->toList();

// Results will be sorted by the 'UnitsInStock' value
// according to the logic from 'MySorter' class
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="php">
{`/** @var array<Product> $products */
$products = $session->advanced()
    ->documentQuery(Product::class)
    ->whereGreaterThan("UnitsInStock", 10)
    // Order by field 'UnitsInStock', pass the name of your custom sorter class
    ->orderBy("UnitsInStock", "MySorter")
    ->toList();

// Results will be sorted by the 'UnitsInStock' value
// according to the logic from 'MySorter' class
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by custom(UnitsInStock, "MySorter")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax

<TabItem value="something-something" label="syntax">
<CodeBlock language="php">
{`/**
 * Usage:
 *   - orderBy("lastName"); // same as call: orderBy("lastName", OrderingType::string())
 *   - orderBy("lastName", OrderingType::string());
 *
 *   - orderBy("units_in_stock", "MySorter");
 *     // Results will be sorted by the 'units_in_stock' value according to the logic from 'MySorter' class
 */
function orderBy(string $field, $sorterNameOrOrdering = null): DocumentQueryInterface;

/**
 * Usage:
 *   - orderByDescending("lastName"); // same as call: orderBy("lastName", OrderingType::string())
 *   - orderByDescending("lastName", OrderingType::string());
 *
 *   - orderByDescending("units_in_stock", "MySorter");
 *     // Results will be sorted by the 'units_in_stock' value according to the logic from 'MySorter' class
 */
function orderByDescending(string $field, $sorterNameOrOrdering = null): DocumentQueryInterface;
`}
</CodeBlock>
</TabItem>

| Parameter  | Type     | Description          |
|------------|----------|----------------------|
| **$field** | `string` | The field to sort by |
| **$sorterNameOrOrdering** | `string` | The ordering type to sort the results by:<br/>`OrderingType::long`<br/>`OrderingType::double`<br/>`OrderingType::alphaNumeric`<br/>`OrderingType::string` (default) |




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* When making a query, the server will return the results __sorted__ only if explicitly requested by the query.  
  If no sorting method is specified when issuing the query then results will not be sorted.

    * Note: An exception to the above rule is when [Boosting](../../../indexes/boosting) is involved in the query.  
      Learn more in [Automatic score-based ordering](../../../indexes/boosting#automatic-score-based-ordering).

* Sorting is applied by the server after the query filtering stage.  
  Applying filtering is recommended as it reduces the number of results RavenDB needs to sort  
  when querying a large dataset.

* Multiple sorting actions can be chained.

* This article provides examples of sorting query results when making a __dynamic-query__.  
  For sorting results when querying a __static-index__ see [sort index query results](../../../indexes/querying/sorting).

* In this page:
    * [Order by field value](../../../client-api/session/querying/sort-query-results#order-by-field-value)
 
    * [Order by score](../../../client-api/session/querying/sort-query-results#order-by-score)
        * [Get resulting score](../../../client-api/session/querying/sort-query-results#get-resulting-score)
  
    * [Order by random](../../../client-api/session/querying/sort-query-results#order-by-random)
   
    * [Order by spatial](../../../client-api/session/querying/sort-query-results#order-by-spatial)
     
    * [Order by count (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-count-(aggregation-query))
  
    * [Order by sum (aggregation query)](../../../client-api/session/querying/sort-query-results#order-by-sum-(aggregation-query))

    * [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type)

    * [Chain ordering](../../../client-api/session/querying/sort-query-results#chain-ordering)

    * [Custom sorters](../../../client-api/session/querying/sort-query-results#custom-sorters) 

    * [Syntax](../../../client-api/session/querying/sort-query-results#syntax)

</Admonition>
## Order by field value

* Use `orderBy` or `orderByDescending` to order the results by the specified document-field.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const products = await session
     // Make a dynamic query on the 'products' collection    
    .query({ collection: "products" })
     // Apply filtering (optional)
    .whereGreaterThan("UnitsInStock", 10)
     // Call 'orderBy'
     // Pass the document-field by which to order the results and the ordering type
    .orderBy("UnitsInStock", "Long")
    .all(); 

// Results will be sorted by the 'UnitsInStock' value in ascending order,
// with smaller values listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

__Ordering Type__:

* If no ordering type is specified in the query then the server will apply the default lexicographical ordering.

* In the above example, the ordering type was set to `Long`.

* Different ordering can be forced - see [Force ordering type](../../../client-api/session/querying/sort-query-results#force-ordering-type) below.

</Admonition>



## Order by score

* When querying with some filtering conditions, a basic score is calculated for each item in the results  
  by the underlying indexing engine.

* The higher the score value the better the match.  

* Use `orderByScore` or `orderByScoreDescending` to order by this score.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const products = await session
    .query({ collection: "products" })
     // Apply filtering
    .whereLessThan("UnitsInStock", 5)
    .orElse()
    .whereEquals("Discontinued", true)
     // Call 'orderByScore'
    .orderByScore()
    .all();

// Results will be sorted by the score value
// with best matching documents (higher score values) listed first.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock < 5 or Discontinued == true
order by score()
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">

#### Get resulting score:
The score details can be retrieved by either:

* __Request to include explanations__:  
  You can get the score details and see how it was calculated by requesting to include explanations in the query.
  Currently, this is only available when using Lucene as the underlying indexing engine.  
  Learn more in [Include query explanations](../../../client-api/session/querying/debugging/include-explanations).

* __Get score from metadata__:

    * The score is available in the `@index-score` metadata property within each result.  
      Note the following difference between the underlying indexing engines:

        * When using __Lucene__:  
          This metadata property is always available in the results.  
          Read more about Lucene scoring [here](https://lucene.apache.org/core/3_3_0/scoring.html).

        * When using __Corax__:  
          In order to enhance performance, this metadata property is Not included in the results by default.  
          To get this metadata property you must set the [Indexing.Corax.IncludeDocumentScore](../../../server/configuration/indexing-configuration#indexing.corax.includedocumentscore) configuration value to _true_.  
          Learn about the available methods for setting an indexing configuration key in this [indexing-configuration](../../../server/configuration/indexing-configuration) article.

    * The following example shows how to get the score from the metadata of the resulting entities that were loaded to the session:

<TabItem value="something-something" label="get_score_from_metadata">
<CodeBlock language="nodejs">
{`// Make a query:
// =============

const employees = await session
    .query(\{ collection: "Employees"\})
    .search('Notes', 'English')
    .search('Notes', 'Italian')
    .boost(10)
    .all();

// Get the score:
// ==============

// Call 'getMetadataFor', pass an entity from the resulting employees list
const metadata = session.advanced.getMetadataFor(employees[0]);

// Score is available in the '@index-score' metadata property
const score = metadata[CONSTANTS.Documents.Metadata.INDEX_SCORE];
`}
</CodeBlock>
</TabItem>

</Admonition>



## Order by random

* Use `randomOrdering` to randomize the order of the query results.

* An optional seed parameter can be passed.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const products = await session
    .query({ collection: "products" })
    .whereGreaterThan("UnitsInStock", 10)
     // Call 'randomOrdering'
    .randomOrdering()
     // An optional seed can be passed, e.g.:
     // .randomOrdering("someSeed")
    .all();

// Results will be randomly ordered.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by random()
// order by random(someSeed)
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by spatial

* If your data contains geographical locations,  
  spatial query results can be sorted based on their distance from a specific point.

* See detailed explanation in [Spatial Sorting](../../../client-api/session/querying/how-to-make-a-spatial-query#spatial-sorting).



## Order by count (aggregation query)

* The results of a [group-by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `count` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const numberOfProductsPerCategory = await session
    .query({ collection: "products" })
     // Group by category
    .groupBy("Category")
    .selectKey("Category")
     // Count the number of product documents per category
    .selectCount()
     // Order by the count value
    .orderBy("count", "Long")
    .all();

// Results will contain the number of Product documents per category
// ordered by that count in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by count() as long
select key() as "Category", count()
`}
</CodeBlock>
</TabItem>
</Tabs>



## Order by sum (aggregation query)

* The results of a [group-by query](../../../client-api/session/querying/how-to-perform-group-by-query) can be sorted by the `sum` aggregation operation used in the query.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const numberOfUnitsInStockPerCategory = await session
    .query({ collection: "products" })
     // Group by category
    .groupBy("Category")
    .selectKey("Category")
     // Sum the number of units in stock per category
    .selectSum(new GroupByField("UnitsInStock", "sum"))
     // Order by the sum value
    .orderBy("sum", "Long")
    .all();

// Results will contain the total number of units in stock per category
// ordered by that number in ascending order.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
group by Category
order by sum as long
select key() as 'Category', sum(UnitsInStock) as sum
`}
</CodeBlock>
</TabItem>
</Tabs>



## Force ordering type

* If no ordering type is specified in the query then the server will apply the default lexicographical ordering.

* A different ordering can be forced by passing the ordering type explicitly to `orderBy` or `orderByDescending`.

* The following ordering types are available:

    * `Long`
    * `Double`
    * `AlphaNumeric`
    * `String` (lexicographic ordering)

<Admonition type="note" title="Note">

__Using alphanumeric ordering example__:

* When ordering mixed-character strings by the default lexicographical ordering  
  then comparison is done character by character based on the Unicode values.  
  For example, "Abc9" will come after "Abc10" since 9 is greater than 1.

* If you want the digit characters to be ordered as numbers then use alphanumeric ordering  
  where "Abc10" will result after "Abc9".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const products = await session
    .query({ collection: "products" })
     // Call 'OrderBy', order by field 'QuantityPerUnit'
     // Pass a second param, requesting to order the text alphanumerically
    .orderBy("QuantityPerUnit", "AlphaNumeric")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
order by QuantityPerUnit as alphanumeric
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="something-something" label="sort_6_results">
<CodeBlock language="nodejs">
{`// Running the above query on the NorthWind sample data,
// would produce the following order for the QuantityPerUnit field:
// ================================================================

// "1 kg pkg."
// "1k pkg."
// "2 kg box."
// "4 - 450 g glasses"
// "5 kg pkg."
// ...

// While running with the default Lexicographical ordering would have produced:
// ============================================================================

// "1 kg pkg."
// "10 - 200 g glasses"
// "10 - 4 oz boxes"
// "10 - 500 g pkgs."
// "10 - 500 g pkgs."
// ...
`}
</CodeBlock>
</TabItem>

</Admonition>



## Chain ordering

* It is possible to chain multiple orderings in the query.  
  Any combination of secondary sorting is possible as the fields are indexed independently of one another.

* There is no limit on the number of sorting actions that can be chained.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const products = await session
    .query({ collection: "products" })
    .whereGreaterThan("UnitsInStock", 10)
     // Apply the primary sort by 'UnitsInStock'
    .orderByDescending("UnitsInStock", "Long")
     // Apply a secondary sort by the score
    .orderByScore()
     // Apply another sort by 'Name'
    .orderBy("Name")
    .all();

// Results will be sorted by the 'UnitsInStock' value (descending),
// then by score,
// and then by 'Name' (ascending).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by UnitsInStock as long desc, score(), Name
`}
</CodeBlock>
</TabItem>
</Tabs>



## Custom sorters 

* The Lucene indexing engine allows you to create your own custom sorters.  
  Custom sorters are not supported by [Corax](../../../indexes/search-engine/corax).  

* Custom sorters can be deployed to the server by either:  

     * Sending the [Put Sorters Operation](../../../client-api/operations/maintenance/sorters/put-sorter) from your code.
  
     * Uploading a custom sorter from Studio, see [Custom Sorters View](../../../studio/database/settings/custom-sorters).

* Once the custom sorter is deployed, you can sort the query results with it.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const products = await session
    .query({ collection: "products" })
    .whereGreaterThan("UnitsInStock", 10)
     // Order by field 'UnitsInStock', pass the name of your custom sorter class
    .orderBy("UnitsInStock", { sorterName: "MySorter" })
    .all();

// Results will be sorted by the 'UnitsInStock' value
// according to the logic from 'MySorter' class
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
where UnitsInStock > 10
order by custom(UnitsInStock, "MySorter")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax

<TabItem value="something-something" label="syntax">
<CodeBlock language="nodejs">
{`// orderBy overloads:
orderBy(field);
orderBy(field, ordering);
orderBy(field, options);

// orderByDescending overloads:
orderByDescending(field);
orderByDescending(field, ordering);
orderByDescending(field, options);
`}
</CodeBlock>
</TabItem>

| Parameter    | Type     | Description                                                                                                            |
|--------------|----------|------------------------------------------------------------------------------------------------------------------------|
| __field__    | `string` | The name of the field to sort by                                                                                       |
| __ordering__ | `string` | The ordering type that will be used to sort the results:<br/>`Long`<br/>`Double`<br/>`AlphaNumeric`<br/>`String` (default) |
| __options__  | `object` | An object that specifies the custom `sorterName`                                                                       |




</LanguageContent>