---
title: "Project Query Results"
sidebar_label: Project Query Results
sidebar_position: 6
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Project Query Results
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Applying a projection in a query allows you to shape the query results to meet specific requirements,  
  delivering just the data needed instead of the original full document content. 

* This article provides examples of projecting query results when making a **dynamic-query**.  
  For projecting results when querying a **static-index** see [project index query results](../../../indexes/querying/projections).

* In this article:
  * [Projections overview](../../../client-api/session/querying/how-to-project-query-results#projections-overview)
  * [Projection Methods](../../../client-api/session/querying/how-to-project-query-results#projection-methods)  
      * [Select](../../../client-api/session/querying/how-to-project-query-results#select)  
      * [ProjectInto](../../../client-api/session/querying/how-to-project-query-results#projectinto)  
      * [SelectFields](../../../client-api/session/querying/how-to-project-query-results#selectfields)
  * [Single projection per query](../../../client-api/session/querying/how-to-project-query-results#single-projection-per-query)

</Admonition>
## Projections overview
**What are projections**:

* A projection refers to the **transformation of query results** into a customized structure,  
  modifying the shape of the data returned by the server.

* Instead of retrieving the full document from the server and then picking relevant data from it on the client,  
  you can request a subset of the data, specifying the document fields you want to get from the server.

* The query can load [related documents](../../../indexes/indexing-related-documents#what-are-related-documents) and have their data merged into the projection results.

* Objects and arrays, including content from nested structures, can be projected.  
  An alias name can be given to the projected fields, and any calculations can be applied within the projection.
**When to use projections**:

* Projections allow you to tailor the query results specifically to your needs.  
  Getting specific details to display can be useful when presenting data to users or populating user interfaces.  
  Projection queries are also useful with [subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions) 
  since all transformation work is done on the server side without having to send a lot of data over the wire.

* Returning partial document data from the server reduces network traffic,  
  as clients receive only relevant data required for a particular task, enhancing overall performance.  

* Savings can be significant if you need to show just a bit of information from a large document. For example:  
  the size of the result when querying for all "Orders" documents where "Company" is "companies/65-A" is 19KB.  
  Performing the same query and projecting only the "Employee" and "OrderedAt" fields results in only 5KB.

* However, when you need to actively work with the complete set of data on the client side,  
  then do use a query without a projection to retrieve the full document from the server.
**Projections are not tracked by the session**:

* On the client side, the resulting projected entities returned by the query are Not tracked by the Session.

* Any modification made to a projection entity will not modify the corresponding document on the server when _SaveChanges_ is called.
**Projections are the final stage in the query pipeline**:

* Projections are applied as the last stage in the query pipeline,  
  after the query has been processed, filtered, sorted, and paged.

* This means that the projection does Not apply to all the documents in the collection,  
  but only to the documents matching the query predicate.

* Within the projection you can only filter what data will be returned from the matching documents,  
  but you cannot filter which documents will be returned. That has already been determined earlier in the query pipeline.

* Only a single projection request can be made per Query (and DocumentQuery).  
  Learn more in [single projection per query](../../../client-api/session/querying/how-to-project-query-results#single-projection-per-query).
**The cost of projections**:

* Queries in RavenDB do not allow any computation to occur during the query phase.  
  However, you can perform any [calculations](../../../client-api/session/querying/how-to-project-query-results#example---projection-with-calculations)
  inside the projection.

* But while calculations within a projection are allowed, having a very complex logic can impact query performance.  
  So RavenDB limits the total time it will spend processing a query and its projections.  
  Exceeding this time limit will fail the query. This is configurable, see the following configuration keys:  
      * [Databases.QueryTimeoutInSec](../../../server/configuration/database-configuration#databases.querytimeoutinsec)
      * [Databases.QueryOperationTimeoutInSec](../../../server/configuration/database-configuration#databases.queryoperationtimeoutinsec)



## Projection Methods

## Select

* The most common way to perform a query with a projection is to use the `Select` method.  

* You can specify what fields from the document you want to retrieve and even provide a complex expression.

<Admonition type="note" title="Note">

##### Example I - Projecting individual fields of the document:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session
     // Make a dynamic query on the Companies collection
    .Query<Company>()
     // Call Select to define the new structure that will be returned per Company document
    .Select(x => new
    {
        Name = x.Name,
        City = x.Address.City,
        Country = x.Address.Country
    })
    .ToList();

// Each resulting object in the list is Not a 'Company' entity,
// it is a new object containing ONLY the fields specified in the Select.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession
    // Make a dynamic query on the Companies collection
    .Query<Company>()
    // Call Select to define the new structure that will be returned per Company document
    .Select(x => new {Name = x.Name, City = x.Address.City, Country = x.Address.Country})
    .ToListAsync();

// Each resulting object in the list is Not a 'Company' entity,
// it is a new object containing ONLY the fields specified in the Select.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select Name, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example II - Projecting arrays and objects:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session
    .Query<Order>()
    .Select(x => new
    {
        ShipTo = x.ShipTo,
        // Retrieve all product names from the Lines array in an Order document
        ProductNames = x.Lines.Select(y => y.ProductName)
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession
    .Query<Order>()
    .Select(x => new
    {
        ShipTo = x.ShipTo,
        // Retrieve all product names from the Lines array in an Order document
        ProductNames = x.Lines.Select(y => y.ProductName)
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Using simple expression:
from "Orders"
select ShipTo, Lines[].ProductName as ProductNames

// Using JavaScript object literal syntax:
from "Orders" as x
select {
    ShipTo: x.ShipTo, 
    ProductNames: x.Lines.map(y => y.ProductName)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example III - Projection with expression:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session
    .Query<Employee>()
    .Select(x => new
    {
        // Any expression can be provided for the projected content
        FullName = x.FirstName + " " + x.LastName
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession
    .Query<Employee>()
    .Select(x => new
    {
        // Any expression can be provided for the projected content
        FullName = x.FirstName + " " + x.LastName
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e
select {
    FullName: e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example IV - Projection with calculations:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session
    .Query<Order>()
    .Select(x => new
    {
        // Any calculations can be done within a projection
        TotalProducts = x.Lines.Count,
        TotalDiscountedProducts = x.Lines.Count(x => x.Discount > 0),
        TotalPrice = x.Lines.Sum(l => l.PricePerUnit * l.Quantity)
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession
    .Query<Order>()
    .Select(x => new
    {
        // Any calculations can be done within a projection
        TotalProducts = x.Lines.Count,
        TotalDiscountedProducts = x.Lines.Count(x => x.Discount > 0),
        TotalPrice = x.Lines.Sum(l => l.PricePerUnit * l.Quantity)
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" as x
select {
    TotalProducts: x.Lines.length,
    TotalDiscountedProducts: x.Lines.filter(x => x.Discount > 0).length,
    TotalPrice: x.Lines
                  .map(l => l.PricePerUnit * l.Quantity)
                  .reduce((a, b) => a + b, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example V - Projecting using functions:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Use LINQ query syntax notation
var projectedResults = (from e in session.Query<Employee>()
    // Define a function
    let format = (Func<Employee, string>)(p => p.FirstName + " " + p.LastName)
    select new
    {
        // Call the function from the projection
        FullName = format(e)
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Use LINQ query syntax notation
var projectedResults = await (from e in asyncSession.Query<Employee>()
    // Define a function
    let format = (Func<Employee, string>)(p => p.FirstName + " " + p.LastName)
    select new
    {
        // Call the function from the projection
        FullName = format(e)
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`declare function output(e) {
    var format = p => p.FirstName + " " + p.LastName;
    return { FullName: format(e) };
}
from "Employees" as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example VI - Projecting using a loaded document:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Use LINQ query syntax notation
var projectedResults = (from o in session.Query<Order>()
    // Use RavenQuery.Load to load the related Company document
    let c = RavenQuery.Load<Company>(o.Company)
    select new
    {
        CompanyName = c.Name, // info from the related Company document
        ShippedAt = o.ShippedAt // info from the Order document
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Use LINQ query syntax notation
var projectedResults = (from o in asyncSession.Query<Order>()
    // Use RavenQuery.Load to load the related Company document
    let c = RavenQuery.Load<Company>(o.Company)
    select new
    {
        CompanyName = c.Name, // info from the related Company document
        ShippedAt = o.ShippedAt // info from the Order document
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example VII - Projection with dates:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session
    .Query<Employee>()
    .Select(e => new
    {
        DayOfBirth = e.Birthday.Day,
        MonthOfBirth = e.Birthday.Month,
        Age = DateTime.Today.Year - e.Birthday.Year
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession
    .Query<Employee>()
    .Select(e => new
    {
        DayOfBirth = e.Birthday.Day,
        MonthOfBirth = e.Birthday.Month,
        Age = DateTime.Today.Year - e.Birthday.Year
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select { 
    DayOfBirth: new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth: new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age: new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example VIII - Projection with raw JavaScript code:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session.Query<Employee>()
    .Select(e => new
    {
        // Provide a JavaScript expression to the RavenQuery.Raw method
        Date = RavenQuery.Raw<DateTime>("new Date(Date.parse(e.Birthday))"),
        Name = RavenQuery.Raw(e.FirstName, "substr(0, 3)")
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession.Query<Employee>()
    .Select(e => new
    {
        // Provide a JavaScript expression to the RavenQuery.Raw method
        Date = RavenQuery.Raw<DateTime>("new Date(Date.parse(e.Birthday))"),
        Name = RavenQuery.Raw(e.FirstName, "substr(0, 3)")
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select {
    Date: new Date(Date.parse(e.Birthday)), 
    Name: e.FirstName.substr(0, 3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example IX - Projection with metadata:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session.Query<Employee>()
    .Select(e => new
    {
        Name = e.FirstName, Metadata = RavenQuery.Metadata(e) // Get the metadata
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession.Query<Employee>()
    .Select(e => new
    {
        Name = e.FirstName, Metadata = RavenQuery.Metadata(e) // Get the metadata
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select {
     Name: e.FirstName, 
     Metadata: getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example X - Projection with include:

When using `Include` in a projection query,  
RavenDB includes the related document only if the included path is one of the fields in the projection.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session
    .Query<Product>()
     // NOTE:
     // While the following 'Include' line compiles,
     // the related Supplier document will NOT BE INCLUDED in the query results,
     // because 'Supplier' is not one of the projected fields in the 'Select' clause.
    .Include(x => x.Supplier)
    .Select(x => new
    {
        Name = x.Name,
        ProductCategory = x.Category
    })
     // The related Category document WILL BE INCLUDED in the query results,
     // since 'ProductCategory' is one of the projected fields.
    .Include(x => x.ProductCategory)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession
    .Query<Product>()
     // NOTE:
     // While the following 'Include' line compiles,
     // the related Supplier document will NOT BE INCLUDED in the query results,
     // because 'Supplier' is not one of the projected fields in the 'Select' clause.
    .Include(x => x.Supplier)
    .Select(x => new
    {
        Name = x.Name,
        ProductCategory = x.Category
    })
     // The related Category document WILL BE INCLUDED in the query results,
     // since 'ProductCategory' is one of the projected fields.
    .Include(x =>x.ProductCategory)
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products"
select Name, Category as ProductCategory
include Supplier, ProductCategory

// NOTE:
// Only the related Category document WILL BE INCLUDED in the query results.

// The related Supplier document will NOT BE INCLUDED in the query results,
// because 'Supplier' is Not one of the projected fields in the 'select' clause.
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## ProjectInto

* Instead of `Select`, you can use `ProjectInto` to project all public fields from a generic type.
 
* The results will be projected into objects of the specified projection class.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var projectedResults = session
    .Query<Company>()
    // Call 'ProjectInto' instead of using 'Select'
    // Pass the projection class
    .ProjectInto<ContactDetails>()
    .ToList();

// Each resulting object in the list is Not a 'Company' entity,
// it is an object of type 'ContactDetails'.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var projectedResults = await asyncSession
    .Query<Company>()
    // Call 'ProjectInto' instead of using 'Select'
    // Pass the projection class
    .ProjectInto<ContactDetails>()
    .ToListAsync();

// Each resulting object in the list is Not a 'Company' entity,
// it is an object of type 'ContactDetails'.
`}
</CodeBlock>
</TabItem>
<TabItem value="Projection_class" label="Projection_class">
<CodeBlock language="csharp">
{`public class ContactDetails
{
    // The projection class contains field names from the 'Company' document
    public string Name { get; set; }
    public string Phone { get; set; }
    public string Fax { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select Name, Phone, Fax
`}
</CodeBlock>
</TabItem>
</Tabs>



## SelectFields

The `SelectFields` method can only be used by a [Document Query](../../../client-api/session/querying/document-query/what-is-document-query).  
It has two overloads:

<TabItem value="something" label="csharp">
<CodeBlock language="csharp">
{`// 1) Select fields to project by the projection class type
IDocumentQuery<TProjection> SelectFields<TProjection>();

// 2) Select specific fields to project
IDocumentQuery<TProjection> SelectFields<TProjection>(params string[] fields);
`}
</CodeBlock>
</TabItem>
<Admonition type="note" title="Note">

##### Using projection class type

The projection class fields are the fields that you want to project from the document class.

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Make a dynamic DocumentQuery
var projectedResults = session.Advanced
    .DocumentQuery<Company>()
    // Call 'SelectFields'
    // Pass the projection class type
    .SelectFields<ContactDetails>()
    .ToList();

// Each resulting object in the list is Not a 'Company' entity,
// it is an object of type 'ContactDetails'.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`// Make a dynamic DocumentQuery
var projectedResults = await asyncSession.Advanced
    .AsyncDocumentQuery<Company>()
    // Call 'SelectFields'
    // Pass the projection class type
    .SelectFields<ContactDetails>()
    .ToListAsync();

// Each resulting object in the list is Not a 'Company' entity,
// it is an object of type 'ContactDetails'.
`}
</CodeBlock>
</TabItem>
<TabItem value="Projection_class" label="Projection_class">
<CodeBlock language="csharp">
{`public class ContactDetails
{
    // The projection class contains field names from the 'Company' document
    public string Name { get; set; }
    public string Phone { get; set; }
    public string Fax { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select Name, Phone, Fax
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Using specific fields

The fields specified are the fields that you want to project from the projection class.

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Define an array with the field names that will be projected
var projectionFields = new string[]
{
    // Fields from 'ContactDetails' class:
    "Name", "Phone"
};

// Make a dynamic DocumentQuery
var projectedResults = session.Advanced
    .DocumentQuery<Company>()
    // Call 'SelectFields'
    // Pass the projection class type & the fields to be projected from it
    .SelectFields<ContactDetails>(projectionFields)
    .ToList();

// Each resulting object in the list is Not a 'Company' entity,
// it is an object of type 'ContactDetails' containing data ONLY for the specified fields.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`// Define an array with the field names that will be projected
var projectionFields = new string[]
{
    // Fields from 'ContactDetails' class:
    "Name", "Phone"
};

// Make a dynamic DocumentQuery
var projectedResults = await asyncSession.Advanced
    .AsyncDocumentQuery<Company>()
    // Call 'SelectFields'
    // Pass the projection class type & the fields to be projected from it
    .SelectFields<ContactDetails>(projectionFields)
    .ToListAsync();

// Each resulting object in the list is Not a 'Company' entity,
// it is an object of type 'ContactDetails' containing data ONLY for the specified fields.
`}
</CodeBlock>
</TabItem>
<TabItem value="Projection_class" label="Projection_class">
<CodeBlock language="csharp">
{`public class ContactDetails
{
    // The projection class contains field names from the 'Company' document
    public string Name { get; set; }
    public string Phone { get; set; }
    public string Fax { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## Single projection per query

* As of RavenDB v6.0, only a single projection request can be made per Query (and DocumentQuery).

* Attempting multiple projection executions in the same query will result in an exception.

    * Query:  
      Multiple `Select` calls or a combination of `ProjectInto` with a `Select` call will result in an exception.
   
    * DocumentQuery:  
      Multiple `SelectFields` calls will result in an exception.

<TabItem value="something" label="projections_13">
<CodeBlock language="csharp">
{`// For example:
try
\{
    var projectedResults = session
        .Query<Company>()
        // Make first projection
        .ProjectInto<ContactDetails>()
        // A second projection is not supported and will throw
        .Select(x => new \{Name = x.Name\})
        .ToList();
\}
catch (Exception e)
\{
    // The following exception will be thrown:
    // "Projection is already done. You should not project your result twice."
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="java">


Instead of pulling full documents in query results you can just grab some pieces of data from documents. You can also transform the projected
results. The projections are defined with the usage of:

- [SelectFields](../../../client-api/session/querying/how-to-project-query-results#selectfields)
- [OfType](../../../client-api/session/querying/how-to-project-query-results#oftype---simple-projection)

## SelectFields

The most common way to perform a query with projection is to use the `selectFields` method. You can specify what fields from a document you want to retrieve.

### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`// request name, city and country for all entities from 'Companies' collection
QueryData queryData = new QueryData(
    new String[] { "Name", "Address.city", "Address.country"},
    new String[] { "Name", "City", "Country"});
List<NameCityAndCountry> results = session
    .query(Company.class)
    .selectFields(NameCityAndCountry.class, queryData)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Companies
select Name, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`QueryData queryData = new QueryData(new String[]{ "ShipTo", "Lines[].ProductName" },
    new String[]{"ShipTo", "Products"});

List<ShipToAndProducts> results = session.query(Order.class)
    .selectFields(ShipToAndProducts.class, queryData)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders
select ShipTo, Lines[].ProductName as Products
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<FullName> results = session.advanced().rawQuery(FullName.class, "from Employees as e " +
    "select {" +
    "    FullName : e.FirstName + \\" \\" + e.LastName " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Employees as e
select {
    FullName : e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IV - Projection with `declared function`

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Employee> results = session.advanced().rawQuery(Employee.class, "declare function output(e) { " +
    "    var format = function(p){ return p.FirstName + \\" \\" + p.LastName; }; " +
    "    return { FullName : format(e) }; " +
    "} " +
    "from Employees as e select output(e)").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from Employees as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example V - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Total> results = session.advanced().rawQuery(Total.class, "from Orders as o " +
    "select { " +
    "    Total : o.Lines.reduce( " +
    "        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0) " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VI - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<OrderProjection> results = session.advanced().rawQuery(OrderProjection.class, "from Orders as o " +
    "load o.Company as c " +
    "select { " +
    "    CompanyName: c.Name," +
    "    ShippedAt: o.ShippedAt" +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VII - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<EmployeeProjection> results = session.advanced().rawQuery(EmployeeProjection.class, "from Employees as e " +
    "select { " +
    "    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), " +
    "    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1, " +
    "    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Employees as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VIII - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<EmployeeProjection> results = session.advanced().rawQuery(EmployeeProjection.class, "from Employees as e " +
    "select { " +
    "    Date : new Date(Date.parse(e.Birthday)), " +
    "    Name : e.FirstName.substr(0,3) " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Employees as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IX - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Employee> results = session.advanced().rawQuery(Employee.class, "from Employees as e " +
    "select {" +
    "     Name : e.FirstName, " +
    "     Metadata : getMetadata(e)" +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Employees as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

This method overload retrieves all public fields of the class given in generic and uses them to perform projection to the requested type.
You can use this method instead of using `selectFields` together with all fields of the projection class.

### Example X

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<ContactDetails> results = session.query(Company.class, Companies_ByContact.class)
    .selectFields(ContactDetails.class)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="java">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`private class Companies_ByContact extends AbstractIndexCreationTask {
    public Companies_ByContact() {

        map = "from c in docs.Companies select new  { Name = c.Contact.Name, Phone = c.Phone } ";

        storeAllFields(FieldStorage.YES); // name and phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>

</Tabs>



## OfType - simple projection

`ofType` is a client-side projection. The easiest explanation of how it works is to take the results that the server returns and map them to given type. This may become useful when querying an index that contains fields that are not available in mapped type.

### Example

<TabItem value="something-something" label="projections_10">
<CodeBlock language="java">
{`// query index 'Products_BySupplierName'
// return documents from collection 'Products' that have a supplier 'Norske Meierier'
// project them to 'Products'
List<Product> results = session.query(Products_BySupplierName.Result.class, Products_BySupplierName.class)
    .whereEquals("Name", "Norske Meierier")
    .ofType(Product.class)
    .toList();
`}
</CodeBlock>
</TabItem>



<Admonition type="note" title="Note">
Projected entities (even named types) are not tracked by the session.
</Admonition>

<Admonition type="note" title="Note">
If the projected fields are stored inside the index itself (`FieldStorage.YES` in the index definition), then the query results will be created directly from there instead of retrieving documents in order to project.
</Admonition>


</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* Applying a projection in a query allows you to shape the query results to meet specific requirements,  
  delivering just the data needed instead of the original full document content. 

* This article provides examples of projecting query results when making a **dynamic-query**.  
  For projecting results when querying a **static-index** see [project index query results](../../../indexes/querying/projections).

* In this page:

  * [Projections overview](../../../client-api/session/querying/how-to-project-query-results#projections-overview)

  * [Projection Methods](../../../client-api/session/querying/how-to-project-query-results#projection-methods)  
      * [select_fields_query_data](../../../client-api/session/querying/how-to-project-query-results#select_fields_query_data)  
      * [raw_query with `select`](../../../client-api/session/querying/how-to-project-query-results#raw_query-with-select)  
      * [select_fields](../../../client-api/session/querying/how-to-project-query-results#select_fields)  

  * [Single projection per query](../../../client-api/session/querying/how-to-project-query-results#single-projection-per-query)

</Admonition>
## Projections overview

### What are projections:

* A projection refers to the **transformation of query results** into a customized structure,  
  modifying the shape of the data returned by the server.

* Instead of retrieving the full document from the server and then picking relevant data from it on the client,  
  you can request a subset of the data, specifying the document fields you want to get from the server.

* The query can load [related documents](../../../indexes/indexing-related-documents#what-are-related-documents) and have their data merged into the projection results.

* Objects and arrays can be projected, fields can be renamed, and any calculations can be made within the projection.

* Content from inner objects and arrays can be projected.  
  An alias name can be given to the projected fields, and any calculations can be made within the projection.

### When to use projections:

* Projections allow you to tailor the query results specifically to your needs.  
  Getting specific details to display can be useful when presenting data to users or populating user interfaces.  
  Projection queries are also useful with [subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions) 
  since all transformation work is done on the server side without having to send a lot of data over the wire.

* Returning partial document data from the server reduces network traffic,  
  as clients receive only relevant data required for a particular task, enhancing overall performance.  

* Savings can be significant if you need to show just a bit of information from a large document. For example:  
  the size of the result when querying for all "Orders" documents where "Company" is "companies/65-A" is 19KB.  
  Performing the same query and projecting only the "Employee" and "OrderedAt" fields results in only 5KB.

* However, when you need to actively work with the complete set of data on the client side,  
  then do use a query without a projection to retrieve the full document from the server.

### Projections are not tracked by the session:

* On the client side, the resulting projected entities returned by the query are Not tracked by the Session.

* Any modification made to a projection entity will not modify the corresponding document on the server when `save_changes` is called.

### Projections are the final stage in the query pipeline:

* Projections are applied as the last stage in the query pipeline,  
  after the query has been processed, filtered, sorted, and paged.

* This means that the projection does Not apply to all the documents in the collection,  
  but only to the documents matching the query predicate.

* Within the projection you can only filter what data will be returned from the matching documents,  
  but you cannot filter which documents will be returned. That has already been determined earlier in the query pipeline.

* Only a single projection request can be made per query.  
  Learn more in [single projection per query](../../../client-api/session/querying/how-to-project-query-results#single-projection-per-query).

### The cost of projections:

* Queries in RavenDB do not allow any computation to occur during the query phase.  
  However, you can perform any [calculations](../../../client-api/session/querying/how-to-project-query-results#example---projection-with-calculations) 
* inside the projection.

* But while calculations within a projection are allowed, having a very complex logic can impact query performance.  
  So RavenDB limits the total time it will spend processing a query and its projections.  
  Exceeding this time limit will fail the query. This is configurable, see the following configuration keys:  
      * [Databases.QueryTimeoutInSec](../../../server/configuration/database-configuration#databases.querytimeoutinsec)
      * [Databases.QueryOperationTimeoutInSec](../../../server/configuration/database-configuration#databases.queryoperationtimeoutinsec)




## Projection Methods

## select_fields_query_data

* The most common way to perform a query with a projection is to use the `select_fields` or `select_fields_query_data` method.  

* You can specify what fields from the document you want to retrieve and even provide a complex expression.

### Example - Projecting individual fields of the document:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`class CompanyNameCityAndCountry:
    def __init__(self, name: str = None, city: str = None, country: str = None):
        self.name = name
        self.city = city
        self.country = country

query_data = QueryData(["name", "address.city", "address.country"], ["name", "city", "country"])
results = list(
    session.query(object_type=Company).select_fields_query_data(CompanyNameCityAndCountry, query_data)
)

# Each resulting object in the list is not a 'Company' entity, it is a new object containing ONLY the
# fields specified in the query_data
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select Name, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projecting arrays and objects:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`class OrderShippingAddressAndProductNames:
    def __init__(self, ship_to: str = None, product_names: List[str] = None):
        self.ship_to = ship_to
        self.product_names = product_names

# Retrieve all product names from the Lines array in an Order document
query_data = QueryData(["ship_to", "lines[].product_name"], ["ship_to", "product_names"])

projected_results = list(
    session.query(object_type=Order).select_fields_query_data(
        OrderShippingAddressAndProductNames, query_data
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Using simple expression:
from "Orders"
select ShipTo, Lines[].ProductName as ProductNames

// Using JavaScript object literal syntax:
from "Orders" as x
select {
    ShipTo: x.ShipTo, 
    ProductNames: x.Lines.map(y => y.ProductName)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with expression:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`class EmployeeFullName:
    def __init__(self, full_name: str):
        self.full_name = full_name

# Use custom function in query data or raw query
query_data = QueryData.custom_function("o", "{ full_name: o.first_name + ' ' + o.last_name }")
projected_results = list(
    session.query(object_type=Employee).select_fields_query_data(EmployeeFullName, query_data)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e
select {
    FullName: e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with calculations:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`class ProductsRaport:
    def __init__(
        self, total_products: int = None, total_discounted_products: int = None, total_price: int = None
    ):
        self.total_products = total_products
        self.total_discounted_products = total_discounted_products
        self.total_price = total_price

# Use custom function in query data or raw query
query_data = QueryData.custom_function(
    "o",
    "{"
    "total_products: o.lines.length,"
    " total_discounted_products: o.lines.filter((line) => line.discount > 0).length,"
    " total_price: o.lines.reduce("
    "(accumulator, line) => accumulator + line.price_per_unit * line.quantity, 0) "
    "}",
)
projected_results = list(
    session.query(object_type=Order).select_fields_query_data(ProductsRaport, query_data)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" as x
select {
    TotalProducts: x.Lines.length,
    TotalDiscountedProducts: x.Lines.filter(x => x.Discount > 0).length,
    TotalPrice: x.Lines
                  .map(l => l.PricePerUnit * l.Quantity)
                  .reduce((a, b) => a + b, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## raw_query with `select`

Data can be projected by sending the server raw RQL with the `select` keyword using the `raw_query` method.  

### Example - Projection with dates:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`class EmployeeAgeDetails:
    def __init__(self, day_of_birth: str = None, month_of_birth: str = None, age: str = None):
        self.day_of_birth = day_of_birth
        self.month_of_birth = month_of_birth
        self.age = age

# Use custom function in query data or raw query
results = session.advanced.raw_query(
    "from Employees as e select {"
    ' "day_of_birth : new Date(Date.parse(e.birthday)).getDate(),'
    " month_of_birth : new Date(Date.parse(e.birthday)).getMonth() + 1,"
    " age : new Date().getFullYear() - new Date(Date.parse(e.birthday)).getFullYear()"
    "}",
    EmployeeAgeDetails,
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select { 
    DayOfBirth: new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth: new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age: new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with raw JavaScript code:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`class EmployeeBirthdayAndName:
    def __init__(self, date: str = None, name: str = None):
        self.date = date
        self.name = name

# Use custom function in query data or raw query
results = list(
    session.advanced.raw_query(
        "from Employees as e select {"
        "date: new Date(Date.parse(e.birthday)),"
        "name: e.first_name.substr(0,3)"
        "}",
        EmployeeBirthdayAndName,
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select {
    Date: new Date(Date.parse(e.Birthday)), 
    Name: e.FirstName.substr(0, 3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with metadata:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`projected_results = list(
    session.advanced.raw_query(
        "from Employees as e "
        + "select {"
        + "     name : e.first_name, "
        + "     metadata : getMetadata(e)"
        + "}",
        EmployeeNameAndMetadata,
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select {
     Name: e.FirstName, 
     Metadata: getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## select_fields

The projected fields can also be specified using the `select_fields` method.  

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="python">
{`# Lets define an array with the field names that will be projected
# (its optional, you can pass field names as args loosely)
projection_fields = ["name", "phone"]
# Make a query
projected_results = list(
    session.advanced.document_query(object_type=Company)
    # Call 'select_fields'
    # Pass the projection class type & the fields to be projected from it
    .select_fields(ContactDetails, *projection_fields)
)

# Each resulting object in the list is not a 'Company' entity
# it is an object of type 'ContactDetails' containing data ONLY for the specified fields
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>



## Single projection per query

* As of RavenDB v6.0, only a single projection request can be made per query.

* Attempting multiple projection executions in the same query, e.g. by calling 
  `select_fields_query_data` multiple times or by calling `select_fields_query_data` 
  and then `select_fields`, will result in an exception.  

<TabItem value="something-something" label="projections_13">
<CodeBlock language="python">
{`# For example:
query_data = QueryData(["name"], ["funny_name"])
try:
    projected_results = list(
        session.query(object_type=Company)
        # Make a first projection
        .select_fields(ContactDetails)
        # A second projection is not supported and will raise an error
        .select_fields_query_data(CompanyNameCityAndCountry, query_data)
    )
except Exception as e:
    pass
    # The following exception will be raised:
    # "Projection is already done. You should not project your result twice."
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* Applying a projection in a query allows you to shape the query results to meet specific requirements,  
  delivering just the data needed instead of the original full document content. 

* This article provides examples of projecting query results when making a **dynamic-query**.  
  For projecting results when querying a **static-index** see [project index query results](../../../indexes/querying/projections).

* In this page:

  * [Projections overview](../../../client-api/session/querying/how-to-project-query-results#projections-overview)

  * [Projection Methods](../../../client-api/session/querying/how-to-project-query-results#projection-methods)  
      * [`select`, `selectFields`](../../../client-api/session/querying/how-to-project-query-results#select,-selectfields)  
      * [`ofType`](../../../client-api/session/querying/how-to-project-query-results#oftype)  

  * [Single projection per query](../../../client-api/session/querying/how-to-project-query-results#single-projection-per-query)

</Admonition>
## Projections overview

### What are projections:

* A projection refers to the **transformation of query results** into a customized structure,  
  modifying the shape of the data returned by the server.

* Instead of retrieving the full document from the server and then picking relevant data from it on the client,  
  you can request a subset of the data, specifying the document fields you want to get from the server.

* The query can load [related documents](../../../indexes/indexing-related-documents#what-are-related-documents) and have their data merged into the projection results.

* Objects and arrays can be projected, fields can be renamed, and any calculations can be made within the projection.

* Content from inner objects and arrays can be projected.  
  An alias name can be given to the projected fields, and any calculations can be made within the projection.

### When to use projections:

* Projections allow you to tailor the query results specifically to your needs.  
  Getting specific details to display can be useful when presenting data to users or populating user interfaces.  
  Projection queries are also useful with [subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions) 
  since all transformation work is done on the server side without having to send a lot of data over the wire.

* Returning partial document data from the server reduces network traffic,  
  as clients receive only relevant data required for a particular task, enhancing overall performance.  

* Savings can be significant if you need to show just a bit of information from a large document. For example:  
  the size of the result when querying for all "Orders" documents where "Company" is "companies/65-A" is 19KB.  
  Performing the same query and projecting only the "Employee" and "OrderedAt" fields results in only 5KB.

* However, when you need to actively work with the complete set of data on the client side,  
  then do use a query without a projection to retrieve the full document from the server.

### Projections are not tracked by the session:

* On the client side, the resulting projected entities returned by the query are Not tracked by the Session.

* Any modification made to a projection entity will not modify the corresponding document on the server when _SaveChanges_ is called.

### Projections are the final stage in the query pipeline:

* Projections are applied as the last stage in the query pipeline,  
  after the query has been processed, filtered, sorted, and paged.

* This means that the projection does Not apply to all the documents in the collection,  
  but only to the documents matching the query predicate.

* Within the projection you can only filter what data will be returned from the matching documents,  
  but you cannot filter which documents will be returned. That has already been determined earlier in the query pipeline.

* Only a [single projection request](../../../client-api/session/querying/how-to-project-query-results#single-projection-per-query) can be made per query.  

### The cost of projections:

* Queries in RavenDB do not allow any computation to occur during the query phase.  
  However, you can perform any [calculations](../../../client-api/session/querying/how-to-project-query-results#example---projection-with-calculations) 
  inside the projection.

* But while calculations within a projection are allowed, having a very complex logic can impact query performance.  
  So RavenDB limits the total time it will spend processing a query and its projections.  
  Exceeding this time limit will fail the query. This is configurable, see the following configuration keys:  
      * [Databases.QueryTimeoutInSec](../../../server/configuration/database-configuration#databases.querytimeoutinsec)
      * [Databases.QueryOperationTimeoutInSec](../../../server/configuration/database-configuration#databases.queryoperationtimeoutinsec)



## Projection Methods

## `select`, `selectFields`

Projections are commonly performed in PHP using the `select` and `selectFields` methods.  
You can specify what fields from a document you want to retrieve and even provide complex expression.

### Example - Projecting Individual Fields of the Document:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_1@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`// request name, city and country for all entities from 'Companies' collection
$queryData = new QueryData(
    [ "Name", "Address.city", "Address.country"],
    [ "Name", "City", "Country"]
);

/** @var array<NameCityAndCountry> $results */
$results = $session
    ->query(Company::class)
    ->selectFields(NameCityAndCountry::class, $queryData)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Companies
select Name, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projecting Arrays and Objects:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_2@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`$queryData = new QueryData(
    [ "ShipTo", "Lines[].ProductName" ],
    [ "ShipTo", "Products" ]
);

/** @var array<ShipToAndProducts> $results */
$results = $session->query(Order::class)
    ->selectFields(ShipToAndProducts::class, $queryData)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders
select ShipTo, Lines[].ProductName as Products
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with expression:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_3@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`/** @var array<FullName> $results */
$results = $session->advanced()->rawQuery(FullName::class, "from Employees as e " .
    "select {" .
    "    FullName : e.FirstName + \\" \\" + e.LastName " .
    "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e
select {
    FullName: e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with Calculation:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_4@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`/** @var array<Total> $results */
$results = $session->advanced()->rawQuery(Total::class, "from Orders as o " .
    "select { " .
    "    Total : o.Lines.reduce( " .
    "        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0) " .
    "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection Using a Loaded Document:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_5@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`/** @var array<OrderProjection> $results */
$results = $session->advanced()->rawQuery(OrderProjection::class, "from Orders as o " .
    "load o.Company as c " .
    "select { " .
    "    CompanyName: c.Name," .
    "    ShippedAt: o.ShippedAt" .
    "}")
->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with Dates:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_6@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`/** @var array<EmployeeProjection> $results */
$results = $session->advanced()->rawQuery(EmployeeProjection::class, "from Employees as e " .
    "select { " .
    "    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), " .
    "    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1, " .
    "    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() " .
    "}")
->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with Raw JavaScript Code:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_7@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`/** @var array<EmployeeProjection> $results */
$results = $session->advanced()->rawQuery(EmployeeProjection::class, "from Employees as e " .
    "select { " .
    "    Date : new Date(Date.parse(e.Birthday)), " .
    "    Name : e.FirstName.substr(0,3) " .
    "}")
->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example - Projection with Metadata:

<Tabs groupId='languageSyntax'>
<TabItem value="Php" label="Php">
<CodeBlock language="php projections_13@clientapi\session\querying\howtoprojectqueryresults.php /}">
{`/** @var array<Employee> $results */
$results = $session->advanced()->rawQuery(Employee::class, "from Employees as e " .
    "select {" .
    "     Name : e.FirstName, " .
    "     Metadata : getMetadata(e)" .
    "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Employees" as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## `ofType`

`ofType` is a client-side projection that maps results that the server returns into a given type.  
This may become useful when querying an index that contains fields that are not available in the mapped type.  

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="php">
{`// query index 'Products_BySupplierName'
// return documents from collection 'Products' that have a supplier 'Norske Meierier'
// project them to 'Products'
/** @var array<Product> $results */
$results = $session->query(Products_BySupplierName_Result::class, Products_BySupplierName::class)
    ->whereEquals("Name", "Norske Meierier")
    ->ofType(Product::class)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Products_BySupplierName extends AbstractIndexCreationTask
{
}

class Products_BySupplierName_Result
{
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Single projection per query

As of RavenDB v6.0, only a single projection request can be made per query.
Attempting multiple projection executions in the same query will result in an exception.




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Applying a projection in a query allows you to shape the query results to meet specific requirements,  
  delivering just the data needed instead of the original full document content.

* This article provides examples of projecting query results when making a **dynamic-query**.  
  For projecting results when querying a **static-index** see [project index query results](../../../indexes/querying/projections).

* In this article:
    * [Projections overview](../../../client-api/session/querying/how-to-project-query-results#projections-overview)
    * [SelectFields](../../../client-api/session/querying/how-to-project-query-results#selectfields)  
    * [Projecting nested object types](../../../client-api/session/querying/how-to-project-query-results#projecting-nested-object-types)  
    * [Syntax](../../../client-api/session/querying/how-to-project-query-results#syntax)

</Admonition>
## Projections overview
**What are projections**:

* A projection refers to the **transformation of query results** into a customized structure,  
  modifying the shape of the data returned by the server.

* Instead of retrieving the full document from the server and then picking relevant data from it on the client,  
  you can request a subset of the data, specifying the document fields you want to get from the server.

* The query can load [related documents](../../../indexes/indexing-related-documents#what-are-related-documents) and have their data merged into the projection results.

* Content from inner objects and arrays can be projected in addition to [projecting the nested object types](../../../client-api/session/querying/how-to-project-query-results#projecting-nested-object-types).

* An alias name can be given to the projected fields, and any calculations can be applied within the projection.
**When to use projections**:

* Projections allow you to tailor the query results specifically to your needs.  
  Getting specific details to display can be useful when presenting data to users or populating user interfaces.  
  Projection queries are also useful with [subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions)
  since all transformation work is done on the server side without having to send a lot of data over the wire.

* Returning partial document data from the server reduces network traffic,  
  as clients receive only relevant data required for a particular task, enhancing overall performance.

* Savings can be significant if you need to show just a bit of information from a large document. For example:  
  the size of the result when querying for all "Orders" documents where "Company" is "companies/65-A" is 19KB.  
  Performing the same query and projecting only the "Employee" and "OrderedAt" fields results in only 5KB.

* However, when you need to actively work with the complete set of data on the client side,  
  then do use a query without a projection to retrieve the full document from the server.
**Projections are not tracked by the session**:

* On the client side, the resulting projected entities returned by the query are Not tracked by the Session.

* Any modification made to a projection entity will not modify the corresponding document on the server when _SaveChanges_ is called.
**Projections are the final stage in the query pipeline**:

* Projections are applied as the last stage in the query pipeline,  
  after the query has been processed, filtered, sorted, and paged.

* This means that the projection does Not apply to all the documents in the collection,  
  but only to the documents matching the query predicate.

* Within the projection you can only filter what data will be returned from the matching documents,  
  but you cannot filter which documents will be returned. That has already been determined earlier in the query pipeline.
**The cost of projections**:

* Queries in RavenDB do not allow any computation to occur during the query phase.  
  However, you can perform any [calculations](../../../client-api/session/querying/how-to-project-query-results#example-v---projection-with-calculations)
  inside the projection.

* But while calculations within a projection are allowed, having a very complex logic can impact query performance.  
  So RavenDB limits the total time it will spend processing a query and its projections.  
  Exceeding this time limit will fail the query. This is configurable, see the following configuration keys:  
  * [Databases.QueryTimeoutInSec](../../../server/configuration/database-configuration#databases.querytimeoutinsec)
  * [Databases.QueryOperationTimeoutInSec](../../../server/configuration/database-configuration#databases.queryoperationtimeoutinsec)



## SelectFields

* Use `selectFields` to specify which fields should be returned per document that is matching the query criteria.

* Complex projection expressions can be provided directly with RQL via the `rawQuery` syntax,  
  see examples below.

<Admonition type="note" title="Note">

##### Example I - Projecting individual fields of the document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`// Make a dynamic query on the Companies collection
const projectedResults = await session.query({ collection: "companies" })
     // Call 'selectFields'
     // Pass a list of fields that will be returned per Company document
    .selectFields([ "Name", "Address.City", "Address.Country"])
    .all();

// Each resulting object in the list is Not a 'Company' entity,
// it is a new object containing ONLY the fields specified in the selectFields method.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "companies"
select Name, Address.City, Address.Country
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example II - Projecting individual fields with alias

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`// Define a QueryData object that will be used in the selectFields method
const queryData = new QueryData(
    // Specify the document-fields you want to project from the document
    [ "Name", "Address.City", "Address.Country"],
    // Provide an ALIAS name for each document-field
    [ "CompanyName", "City", "Country"]);

const projectedResults = await session.query({ collection: "companies" })
    // Call 'selectFields', pass the queryData object
    .selectFields(queryData)
    .all();

// Each resulting object in the list is Not a 'Company' entity,
// it is a new object containing ONLY the fields specified in the selectFields method
// using their corresponding alias names.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "companies"
select Name as CompanyName, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example III - Projecting arrays and objects

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`// Define the projection with QueryData if you wish to use alias names
const queryData = new QueryData(
    // Project the 'ShipTo' object and all product names from the Lines array in the document
    [ "ShipTo", "Lines[].ProductName" ],
    // Assign alias names
    [ "ShipTo", "ProductNames" ]);

const projectedResults = await session.query({ collection: "orders" })
    .selectFields(queryData)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Using simple expression:
from "orders"
select ShipTo, Lines[].ProductName as ProductNames

// Using JavaScript object literal syntax:
from "Orders" as x
select {
    ShipTo: x.ShipTo,
    ProductNames: x.Lines.map(y => y.ProductName)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example IV - Projection with expression

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`// Define the projected data expression within a custom function.
// Any expression can be provided for the projected content.
const queryData = QueryData.customFunction("e", \`{
    FullName: e.FirstName + " " + e.LastName 
}\`);

const projectedResults = await session.query({ collection: "employees" })
    .selectFields(queryData)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "employees" as e
select {
    FullName: e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example V - Projection with calculations

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const projectedResults = await session.advanced
     // Can provide an RQL query via the 'rawQuery' method
    .rawQuery(\`from "Orders" as x
               // Using JavaScript object literal syntax:
               select {
                   // Any calculations can be done within the projection
                   TotalProducts: x.Lines.length,
                   TotalDiscountedProducts: x.Lines.filter(x => x.Discount > 0).length,
                   TotalPrice: x.Lines
                                .map(l => l.PricePerUnit * l.Quantity)
                                .reduce((a, b) => a + b, 0) }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "orders" as x
select {
    TotalProducts: x.Lines.length,
    TotalDiscountedProducts: x.Lines.filter(x => x.Discount > 0).length,
    TotalPrice: x.Lines
                 .map(l => l.PricePerUnit * l.Quantity)
                 .reduce((a, b) => a + b, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example VI - Projecting using functions

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const projectedResults = await session.advanced
    .rawQuery(\`// Declare a function
               declare function output(e) {
                   var format = p => p.FirstName + " " + p.LastName;
                   return { 
                       FullName: format(e)
                   };
               }
               // Call the function from the projection
               from "employees" as e select output(e)\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`declare function output(e) {
    var format = p => p.FirstName + " " + p.LastName;
    return { FullName: format(e) };
}
from "employees" as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example VII - Projecting using a loaded document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const projectedResults = await session.advanced
    .rawQuery(\`from "Orders" as o
               load o.Company as c         // load the related Company document
               select {
                   CompanyName: c.Name,    // info from the related Company document
                   ShippedAt: o.ShippedAt  // info from the Order document
               }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "orders" as o
load o.Company as c
select {
    CompanyName: c.Name,
    ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example VIII - Projection with dates

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const projectedResults = await session.advanced
    .rawQuery(\`from "employees" as e
               select {
                   DayOfBirth: new Date(Date.parse(e.Birthday)).getDate(),
                   MonthOfBirth: new Date(Date.parse(e.Birthday)).getMonth() + 1,
                   Age: new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear()
               }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "employees" as e
select {
    DayOfBirth: new Date(Date.parse(e.Birthday)).getDate(),
    MonthOfBirth: new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age: new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear()
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example IX - Projection with metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const projectedResults = await session.advanced
    .rawQuery(\`from "employees" as e
               select {
                   Name: e.FirstName,
                   Metadata: getMetadata(e) // Get the metadata
               }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "employees" as e
select {
    Name: e.FirstName,
    Metadata: getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Example X - Projection with include:

When using `include` in a projection query,  
RavenDB includes the related document only if the included path is one of the fields in the projection.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const projectedResults = await session.query({ collection: "products" })
     // NOTE:
     // While the following 'include' line compiles,
     // the related Supplier document will NOT BE INCLUDED in the query results,
     // because 'Supplier' is not one of the projected fields in the 'selectFields' clause.
    .include("Supplier")
    .selectFields([ "Name", "Category"])
     // The related Category document WILL BE INCLUDED in the query results,
     // since 'Category' is one of the projected fields.
    .include("Category")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "products"
select Name, Category
include Supplier, Category

// NOTE:
// Only the related Category document WILL BE INCLUDED in the query results.

// The related Supplier document will NOT BE INCLUDED in the query results,
// because 'Supplier' is Not one of the projected fields in the 'select' clause.
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## Projecting nested object types

In the Node.js client, when projecting query results using the `selectFields` method (not via the `rawQuery` syntax),  
the metadata field `@nested-object-types` from the document will be automatically added to the list of fields to project in the generated RQL that is sent to the server.

<TabItem value="something-something" label="projections_10">
<CodeBlock language="nodejs">
{`// For example - Create a document with nested objects: 
// ====================================================

class User \{
    constructor(firstName, lastName, jobDetails, lastLogin) \{
        this.firstName = firstName;
        this.lastName = lastName;
        this.jobDetails = jobDetails
        this.lastLogin = lastLogin;
    \}
\}

class Job \{
    constructor(company, title) \{
        this.company = company;
        this.title = title;
    \}
\}

const job = new Job("RavenDB", "CEO");
const user = new User("Ayende", "Rahien", job, new Date(2023, 11, 12));

await session.store(user, "users/1");
await session.saveChanges();

// Query the users collecions:
// ===========================

class Projection \{
    constructor(jobDetails, lastLogin) \{
        this.jobDetails = jobDetails;
        this.lastLogin = lastLogin;
    \}
\}

const projectedResults = await session.query(\{ collection: "users" \})
     // Project selected fields:
    .selectFields(["jobDetails", "lastLogin"], Projection)
    .all();
`}
</CodeBlock>
</TabItem>

<TabItem value="something" label="sql">
<CodeBlock language="sql">
{`// The following RQL is generated by the Node.js client:
// =====================================================

from "users"
select name, @metadata.@nested-object-types as **PROJECTED_NESTED_OBJECT_TYPES**
`}
</CodeBlock>
</TabItem>

<TabItem value="something-something" label="projections_10_results">
<CodeBlock language="nodejs">
{`// Query results will include the following projected fields:
// ==========================================================

// \{
//     jobDetails = \{ "company": "RavenDB", "title": "CEO" \}
//     lastLogin = "2023-12-11T22:00:00.000Z"
//     __PROJECTED_NESTED_OBJECT_TYPES__ = \{ "jobDetails": "Job", lastLogin": "date" \} // Nested field types 
// \}
`}
</CodeBlock>
</TabItem>



## Syntax

<TabItem value="something-something" label="syntax">
<CodeBlock language="nodejs">
{`selectFields(property);
selectFields(properties);

selectFields(property, projectionClass);
selectFields(properties, projectionClass);
selectFields(properties, projectionClass, projectionBehavior);

selectFields(queryData, projectionClass);
selectFields(queryData, projectionClass, projectionBehavior);
`}
</CodeBlock>
</TabItem>

| Parameter              | Type        | Description                                                                                                                                             |
|------------------------|-------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|
| **property**           | `string`    | Field name to project                                                                                                                                   |
| **properties**         | `string[]`  | List of field names to project                                                                                                                          |
| **queryData**          | `QueryData` | Object with projection query definitions                                                                                                                |
| **projectionClass**    | `object`    | The class type of the projected fields                                                                                                                  |
| **projectionBehavior** | `string`    | Projection behavior is useful when querying a static-index.<br/>Learn more in [projection behavior with indexes](../../../indexes/querying/projections). |




</LanguageContent>

<!---
### Session
- [Query Overview](../../../client-api/session/querying/how-to-query)
- [How to Stream Query Results](../../../client-api/session/querying/how-to-stream-query-results)

### Indexes
- [Querying an index](../../../indexes/querying/query-index)
- [Project index query results](../../../indexes/querying/projections)

### Server
- [JavaScript Engine](../../../server/kb/javascript-engine)

### Querying
- [Basics](../../../indexes/querying/query-index)
- [Projections](../../../indexes/querying/projections)


-->