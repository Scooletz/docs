---
title: "Session: Saving changes"
sidebar_label: Saving changes
sidebar_position: 6
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Session: Saving changes
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Pending session operations like `Store`, `Delete`, and many others. will not be sent to the server until `SaveChanges` is called.

<Admonition type="info" title="Info">

Whenever you execute `SaveChanges()` to send a batch of operations like put, update, or delete in a request,  
the server will wrap these operations in a [transaction](../../client-api/faq/transaction-support.mdx) upon execution in the database.  

Either all operations will be saved as a single, atomic transaction or none of them will be.  
Once `SaveChanges()` returns successfully, it is guaranteed that all changes are persisted in the database.  

</Admonition>

## Syntax

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`void SaveChanges();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Task SaveChangesAsync();
`}
</CodeBlock>
</TabItem>
</Tabs> 

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// storing new entity
session.Store(new Employee
{
    FirstName = "John",
    LastName = "Doe"
});

session.SaveChanges();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// storing new entity
await asyncSession.StoreAsync(new Employee
{
    FirstName = "John",
    LastName = "Doe"
});

await asyncSession.SaveChangesAsync();
`}
</CodeBlock>
</TabItem>
</Tabs> 


## Waiting for Indexes

You can ask the server to wait until the indexes are caught up with changes made within the current session before the `SaveChanges` returns.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout (default: `false`).
* You can specify indexes that you want to wait for. If you don't specify anything here, RavenDB will automatically select just the indexes that are impacted 
by this write.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`session.Advanced.WaitForIndexesAfterSaveChanges(
    timeout: TimeSpan.FromSeconds(30),
    throwOnTimeout: true,
    indexes: new[] { "index/1", "index/2" });

session.Store(new Employee
{
    FirstName = "John",
    LastName = "Doe"
});

session.SaveChanges();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`asyncSession.Advanced.WaitForIndexesAfterSaveChanges(
    timeout: TimeSpan.FromSeconds(30),
    throwOnTimeout: true,
    indexes: new[] { "index/1", "index/2" });

await asyncSession.StoreAsync(new Employee
{
    FirstName = "John",
    LastName = "Doe"
});

await asyncSession.SaveChangesAsync();
`}
</CodeBlock>
</TabItem>
</Tabs> 



## Waiting for Replication - Write Assurance

Sometimes you might need to ensure that changes made in the session will be replicated to more than one node of the cluster before the `SaveChanges` returns.
It can be useful if you have some writes that are really important so you want to be sure the stored values will reside on multiple machines. Also it might be necessary to use
when you customize [the read balance behavior](../../client-api/configuration/load-balance/read-balance-behavior.mdx) and need to ensure the next request from the user 
will be able to read what he or she just wrote (the next open session might access a different node).

You can ask the server to wait until the replication is caught up with those particular changes.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout, which may happen in case of network issues (default: `true`).
* You can specify to how many replicas (nodes) the currently saved write must be replicated, before the `SaveChanges` returns (default: 1).
* You can specify whether the `SaveChanges` will return only when the current write was replicated to majority of the nodes (default: `false`).

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`session.Advanced.WaitForReplicationAfterSaveChanges(
    timeout: TimeSpan.FromSeconds(30),
    throwOnTimeout: false, //default true
    replicas: 2, //minimum replicas to replicate
    majority: false);

session.Store(new Employee
{
    FirstName = "John",
    LastName = "Doe"
});

session.SaveChanges();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`asyncSession.Advanced.WaitForReplicationAfterSaveChanges(
    timeout: TimeSpan.FromSeconds(30),
    throwOnTimeout: false, //default true
    replicas: 2, //minimum replicas to replicate
    majority: false);

await asyncSession.StoreAsync(new Employee
{
    FirstName = "John",
    LastName = "Doe"
});

await asyncSession.SaveChangesAsync();
`}
</CodeBlock>
</TabItem>
</Tabs> 

<Admonition type="warning" title="Important" id="important" href="#important">
The `WaitForReplicationAfterSaveChanges` method waits only for replicas which are part of the cluster. It means that external replication destinations are not counted towards the number specified in `replicas` parameter, since they are not part of the cluster.
</Admonition>

<Admonition type="warning" title="Important" id="important" href="#important">

Even if RavenDB was not able to write your changes to the number of replicas you specified, the data has been already written to some nodes. You will get an error but data is already there.

This is a powerful feature, but you need to be aware of the possible pitfalls of using it.

</Admonition>



## Transaction Mode - Cluster Wide

Setting `TransactionMode` to `TransactionMode.ClusterWide` will enable the [Cluster Transactions](../../server/clustering/cluster-transactions.mdx) feature.

With this feature enabled the [Session](../../client-api/session/what-is-a-session-and-how-does-it-work.mdx) will support the following _write_ commands:

- `Store`/`StoreAsync`
- `Delete`
- `CreateCompareExchangeValue`
- `UpdateCompareExchangeValue`
- `DeleteCompareExchangeValue`


Here is an example of creating a unique user with cluster wide.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`using (var store = new DocumentStore())
{
    using (var session = store.OpenSession(new SessionOptions
    {
        //default is:     TransactionMode.SingleNode
        TransactionMode = TransactionMode.ClusterWide
    }))
    {
        var user = new Employee
        {
            FirstName = "John",
            LastName = "Doe"
        };
        session.Store(user);

        // this transaction is now conditional on this being 
        // successfully created (so, no other users with this name)
        // it also creates an association to the new user's id
        session.Advanced.ClusterTransaction
            .CreateCompareExchangeValue("usernames/John", user.Id);

        session.SaveChanges();
    }
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`using (var session = store.OpenAsyncSession(new SessionOptions
{
    //default is:     TransactionMode.SingleNode
    TransactionMode = TransactionMode.ClusterWide
}))
{
    var user = new Employee
    {
        FirstName = "John",
        LastName = "Doe"
    };
    await session.StoreAsync(user);

    // this transaction is now conditional on this being 
    // successfully created (so, no other users with this name)
    // it also creates an association to the new user's id
    session.Advanced.ClusterTransaction
        .CreateCompareExchangeValue("usernames/John", user.Id);

    await session.SaveChangesAsync();
}
`}
</CodeBlock>
</TabItem>
</Tabs> 




</LanguageContent>
<LanguageContent language="java">


Pending session operations like `store`, `delete`, and many others, will not be sent to the server until `saveChanges` is called.

<Admonition type="info" title="Info">

Whenever you execute `saveChanges()` to send a batch of operations like put, update, or delete in a request,  
the server will wrap these operations in a [transaction](../../client-api/faq/transaction-support.mdx) upon execution in the database.

Either all operations will be saved as a single, atomic transaction or none of them will be.  
Once `saveChanges()` returns successfully, it is guaranteed that all changes are persisted in the database.

</Admonition>

## Syntax

<TabItem value="saving_changes_1" label="saving_changes_1">
<CodeBlock language="java">
{`void saveChanges();
`}
</CodeBlock>
</TabItem>

### Example

<TabItem value="saving_changes_2" label="saving_changes_2">
<CodeBlock language="java">
{`Employee employee = new Employee();
employee.setFirstName("John");
employee.setLastName("Doe");

session.store(employee);
session.saveChanges();;
`}
</CodeBlock>
</TabItem>

## Waiting for Indexes

You can ask the server to wait until the indexes are caught up with changes made within the current session before the `saveChanges` returns.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout (default: `false`).
* You can specify indexes that you want to wait for. If you don't specify anything here, RavenDB will automatically select just the indexes that are impacted 
by this write.

<TabItem value="saving_changes_3" label="saving_changes_3">
<CodeBlock language="java">
{`session.advanced().waitForIndexesAfterSaveChanges(builder -> \{
    builder.withTimeout(Duration.ofSeconds(30))
        .throwOnTimeout(true)
        .waitForIndexes("index/1", "index/2");

    Employee employee = new Employee();
    employee.setFirstName("John");
    employee.setLastName("Doe");
    session.store(employee);

    session.saveChanges();
\});
`}
</CodeBlock>
</TabItem>



## Waiting for Replication - Write Assurance

Sometimes you might need to ensure that changes made in the session will be replicated to more than one node of the cluster before the `saveChanges` returns.
It can be useful if you have some writes that are really important so you want to be sure the stored values will reside on multiple machines. Also it might be necessary to use
when you customize [the read balance behavior](../../client-api/configuration/load-balance/overview.mdx) and need to ensure the next request from the user 
will be able to read what he or she just wrote (the next open session might access a different node).

You can ask the server to wait until the replication is caught up with those particular changes.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout, which may happen in case of network issues (default: `true`).
* You can specify to how many replicas (nodes) the currently saved write must be replicated, before the `saveChanges` returns (default: 1).
* You can specify whether the `saveChanges` will return only when the current write was replicated to majority of the nodes (default: `false`).

<TabItem value="saving_changes_4" label="saving_changes_4">
<CodeBlock language="java">
{`session
    .advanced()
    .waitForReplicationAfterSaveChanges(builder -> \{
        builder.withTimeout(Duration.ofSeconds(30))
            .throwOnTimeout(false) //default true
            .numberOfReplicas(2)//minimum replicas to replicate
            .majority(false);
    \});

Employee employee = new Employee();
employee.setFirstName("John");
employee.setLastName("Doe");

session.store(employee);
session.saveChanges();
`}
</CodeBlock>
</TabItem>

<Admonition type="warning" title="Important" id="important" href="#important">
The `waitForReplicationAfterSaveChanges` method waits only for replicas which are part of the cluster. It means that external replication destinations are not counted towards the number specified in `replicas` parameter, since they are not part of the cluster.
</Admonition>

<Admonition type="warning" title="Important" id="important" href="#important">

The usage of `waitForReplicationAfterSaveChanges` doesn't involve a distributed transaction (those are not supported since RavenDB 4.0). Even if RavenDB was not able
to write your changes to the number of replicas you specified, the data has been already written to some nodes. You will get an error but data is already there.

This is a powerful feature, but you need to be aware of the possible pitfalls of using it.

</Admonition>

 

## Transaction Mode - Cluster Wide

Setting `transactionMode` to `TransactionMode.CLUSTER_WIDE` will enable the [Cluster Transactions](../../server/clustering/cluster-transactions.mdx) feature.

With this feature enabled the [Session](../../client-api/session/what-is-a-session-and-how-does-it-work.mdx) will support the following _write_ commands:

- `store`
- `delete`
- `createCompareExchangeValue`
- `updateCompareExchangeValue`
- `deleteCompareExchangeValue`


Here is an example of creating a unique user with cluster wide.

<TabItem value="cluster_store_with_compare_exchange" label="cluster_store_with_compare_exchange">
<CodeBlock language="java">
{`try (IDocumentStore store = new DocumentStore()) \{
    SessionOptions sessionOptions = new SessionOptions();
    // default is: TransactionMode.SINGLE_NODE
    sessionOptions.setTransactionMode(TransactionMode.CLUSTER_WIDE);
    try (IDocumentSession session = store.openSession(sessionOptions)) \{
        Employee user = new Employee();
        user.setFirstName("John");
        user.setLastName("Doe");

        session.store(user);

        // this transaction is now conditional on this being
        // successfully created (so, no other users with this name)
        // it also creates an association to the new user's id
        session.advanced().clusterTransaction()
            .createCompareExchangeValue("usernames/John", user.getId());

        session.saveChanges();
    \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="python">


Pending session operations e.g. `store`, `delete` and many others will not be send to the server until `save_changes` is called.

<Admonition type="info" title="Info">

Whenever you execute `save_changes()` to send a batch of operations like put, update, or delete in a request,  
the server will wrap these operations in a [transaction](../../client-api/faq/transaction-support.mdx) upon execution in the database.  

Either all operations will be saved as a single, atomic transaction or none of them will be.  
Once `save_changes()` returns successfully, it is guaranteed that all changes are persisted in the database.  

</Admonition>

## Syntax

<TabItem value="saving_changes_1" label="saving_changes_1">
<CodeBlock language="python">
{`def save_changes(self) -> None:
    ...
`}
</CodeBlock>
</TabItem>

### Example

<TabItem value="saving_changes_2" label="saving_changes_2">
<CodeBlock language="python">
{`session.store(Employee(first_name="John", last_name="Doe"))

session.save_changes()
`}
</CodeBlock>
</TabItem>


## Waiting for Indexes

You can ask the server to wait until the indexes are caught up with changes made within the current session before the `save_changes` returns.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout (default: `False`).
* You can specify indexes that you want to wait for. If you don't specify anything here, RavenDB will automatically select just the indexes that are impacted 
by this write.

<TabItem value="saving_changes_3" label="saving_changes_3">
<CodeBlock language="python">
{`def _build_wait(idx_wait_opt_builder: InMemoryDocumentSessionOperations.IndexesWaitOptsBuilder) -> None:
    idx_wait_opt_builder.with_timeout(timedelta(seconds=30))
    idx_wait_opt_builder.throw_on_timeout(True)
    idx_wait_opt_builder.wait_for_indexes("index/1", "index/2")

# this function can be also passed as a lambda
session.advanced.wait_for_indexes_after_save_changes(_build_wait)

session.store(Employee(first_name="John", last_name="Doe"))

session.save_changes()
`}
</CodeBlock>
</TabItem>



## Waiting for Replication - Write Assurance

Sometimes you might need to ensure that changes made in the session will be replicated to more than one node of the cluster before the `save_changes` returns.
It can be useful if you have some writes that are really important so you want to be sure the stored values will reside on multiple machines. Also it might be necessary to use
when you customize [the read balance behavior](../../client-api/configuration/load-balance/read-balance-behavior.mdx) and need to ensure the next request from the user 
will be able to read what he or she just wrote (the next open session might access a different node).

You can ask the server to wait until the replication is caught up with those particular changes.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout, which may happen in case of network issues (default: `True`).
* You can specify to how many replicas (nodes) the currently saved write must be replicated, before the `save_changes` returns (default: 1).
* You can specify whether the `save_changes` will return only when the current write was replicated to majority of the nodes (default: `False`).

<TabItem value="saving_changes_4" label="saving_changes_4">
<CodeBlock language="python">
{`def _build_wait(
    repl_wait_builder: InMemoryDocumentSessionOperations.ReplicationWaitOptsBuilder,
) -> None:
    repl_wait_builder.with_timeout(timedelta(seconds=30))
    repl_wait_builder.throw_on_timeout(False)  # default True
    repl_wait_builder.number_of_replicas(2)  # minimum replicas to replicate
    repl_wait_builder.majority(False)

# this function can be also passed as a lambda
session.advanced.wait_for_replication_after_save_changes(_build_wait)

session.store(Employee(first_name="John", last_name="Doe"))
session.save_changes()
`}
</CodeBlock>
</TabItem>

<Admonition type="warning" title="Important" id="important" href="#important">
The `wait_for_replication_after_save_changes` method waits only for replicas which are part of the cluster. It means that external replication destinations are not counted towards the number specified in `replicas` parameter, since they are not part of the cluster.
</Admonition>

<Admonition type="warning" title="Important" id="important" href="#important">

Even if RavenDB was not able to write your changes to the number of replicas you specified, the data has been already written to some nodes. You will get an error but data is already there.

This is a powerful feature, but you need to be aware of the possible pitfalls of using it.

</Admonition>



## Transaction Mode - Cluster Wide

Setting `TransactionMode` to `TransactionMode.CLUSTER_WIDE` will enable the [Cluster Transactions](../../server/clustering/cluster-transactions.mdx) feature.

With this feature enabled the [session](../../client-api/session/what-is-a-session-and-how-does-it-work.mdx) will support the following _write_ commands:

- `store`
- `delete`
- `create_compare_exchange_value`
- `update_compare_exchange_value`
- `delete_compare_exchange_value`


Here is an example of creating a unique user with cluster wide.

<TabItem value="cluster_store_with_compare_exchange" label="cluster_store_with_compare_exchange">
<CodeBlock language="python">
{`DocumentStore = DocumentStoreFake
with DocumentStore() as store:
    with store.open_session(
        session_options=SessionOptions(
            # default is:    TransactionMode.SINGLE_NODE
            transaction_mode=TransactionMode.CLUSTER_WIDE
        )
    ) as session:
        user = Employee(first_name="John", last_name="Doe")
        session.store(user)

        # this transaction is now conditional on this being
        # successfully created (so, no other users with this name)
        # it also creates an association to the new user's id
        session.advanced.cluster_transaction.create_compare_exchange_value("usernames/John", user.Id)

        session.save_changes()
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="php">


Pending session operations like `store`, `delete`, and many others, will not be sent to the server until `saveChanges` is called.

<Admonition type="info" title="Info">

When `saveChanges()` is applied to send a batch of operations (e.g. `put`, `update`, and `delete`) 
in a request, the server will wrap these operations in a [transaction](../../client-api/faq/transaction-support.mdx) 
upon execution in the database.  

Either all operations are performed as a single, atomic transaction, or none of them are.  
Once `saveChanges()` returns successfully, it is guaranteed that all changes are persisted in the database.  

</Admonition>

## Syntax

<TabItem value="saving_changes_1" label="saving_changes_1">
<CodeBlock language="php">
{`public function saveChanges(): void;
`}
</CodeBlock>
</TabItem>

### Example

<TabItem value="saving_changes_2" label="saving_changes_2">
<CodeBlock language="php">
{`$employee = new Employee();
$employee->setFirstName("John");
$employee->setLastName("Doe");

$session->store($employee);
$session->saveChanges();;
`}
</CodeBlock>
</TabItem>

## Waiting for Indexes

You can request the server to wait until the indexes are caught up with changes made within 
the current session before `saveChanges` returns.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout (default: `false`).
* You can specify indexes that you want to wait for. If you don't specify anything here, RavenDB will automatically select just the indexes that are impacted 
by this write.

<TabItem value="saving_changes_3" label="saving_changes_3">
<CodeBlock language="php">
{`$session->advanced()->waitForIndexesAfterSaveChanges(function ($builder) use ($session) \{
    $builder->withTimeout(Duration::ofSeconds(30))
        ->throwOnTimeout(true)
        ->waitForIndexes("index/1", "index/2");

    $employee = new Employee();
    $employee->setFirstName("John");
    $employee->setLastName("Doe");

    $session->store($employee);

    $session->saveChanges();
\});
`}
</CodeBlock>
</TabItem>



## Transaction Mode - Cluster Wide

Setting `TransactionMode` to `TransactionMode.clusterWide` will enable the [Cluster Transactions](../../server/clustering/cluster-transactions.mdx) feature.

With this feature enabled the [session](../../client-api/session/what-is-a-session-and-how-does-it-work.mdx) will support the following _write_ commands:

- `store`
- `delete`
- `createCompareExchangeValue`
- `updateCompareExchangeValue`
- `deleteCompareExchangeValue`

Here is an example of creating a unique user with cluster wide.

<TabItem value="cluster_store_with_compare_exchange" label="cluster_store_with_compare_exchange">
<CodeBlock language="php">
{`$session = $store->openSession();
try \{
    $sessionOptions = new SessionOptions();
    // default is: TransactionMode::singleNode();
    $sessionOptions->setTransactionMode(TransactionMode::clusterWide());
    $session = $store->openSession($sessionOptions);
    try \{
        $user = new Employee();
        $user->setFirstName("John");
        $user->setLastName("Doe");

        $session->store($user);

        // this transaction is now conditional on this being
        // successfully created (so, no other users with this name)
        // it also creates an association to the new user's id
        $session->advanced()->clusterTransaction()
            ->createCompareExchangeValue("usernames/John", $user->getId());

        $session->saveChanges();
    \} finally \{
        $session->close();
    \}
\} finally \{
    $store->close();
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="nodejs">


Pending session operations like `store()`, `delete()`, and many others, will not be sent to the server until `saveChanges()` is called.

<Admonition type="info" title="Info">

Whenever you execute `saveChanges()` to send a batch of operations like put, update, or delete in a request,  
the server will wrap these operations in a [transaction](../../client-api/faq/transaction-support.mdx) upon execution in the database.

Either all operations will be saved as a single, atomic transaction or none of them will be.  
Once `saveChanges()` returns successfully, it is guaranteed that all changes are persisted in the database.

</Admonition>

## Syntax

<TabItem value="saving_changes_1" label="saving_changes_1">
<CodeBlock language="js">
{`session.saveChanges();
`}
</CodeBlock>
</TabItem>

| Return Value | |
| ------------- | ----- |
| `Promise` | A `Promise` resolved once session changes are persisted to the server |

### Example

<TabItem value="saving_changes_2" label="saving_changes_2">
<CodeBlock language="js">
{`const employee = new Employee("John", "Doe");
await session.store(employee);
await session.saveChanges();
`}
</CodeBlock>
</TabItem>

## Waiting for Indexes

You can ask the server to wait until the indexes are caught up with changes made within the current session before the `saveChanges()` returns.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout (default: `false`).
* You can specify indexes that you want to wait for. If you don't specify anything here, RavenDB will automatically select just the indexes that are impacted 
by this write.

<TabItem value="saving_changes_3" label="saving_changes_3">
<CodeBlock language="js">
{`session.advanced.waitForIndexesAfterSaveChanges(\{
    indexes: ["index/1", "index/2"],
    throwOnTimeout: true,
    timeout: 30 * 1000 // 30 seconds in ms
\});

const employee = new Employee("John", "Doe");
await session.store(employee);
await session.saveChanges();
`}
</CodeBlock>
</TabItem>



## Waiting for Replication - Write Assurance

Sometimes you might need to ensure that changes made in the session will be replicated to more than one node of the cluster before the `saveChanges()` returns.
It can be useful if you have some writes that are really important so you want to be sure the stored values will reside on multiple machines. Also it might be necessary to use
when you customize [the read balance behavior](../../client-api/configuration/load-balance/read-balance-behavior.mdx) and need to ensure the next request from the user 
will be able to read what he or she just wrote (the next open session might access a different node).

You can ask the server to wait until the replication is caught up with those particular changes.

* You can set a timeout (default: 15 seconds).
* You can specify whether you want to throw on timeout, which may happen in case of network issues (default: `true`).
* You can specify to how many replicas (nodes) the currently saved write must be replicated, before the `saveChanges` returns (default: 1).
* You can specify whether the `saveChanges()` will return only when the current write was replicated to majority of the nodes (default: `false`).

<TabItem value="saving_changes_4" label="saving_changes_4">
<CodeBlock language="js">
{`session.advanced
    .waitForReplicationAfterSaveChanges(\{
        throwOnTimeout: false, // default true
        timeout: 30000,
        replicas: 2, // minimum replicas to replicate
        majority: false
    \});

const employee = new Employee("John", "Doe");
await session.store(employee);
await session.saveChanges();
`}
</CodeBlock>
</TabItem>

<Admonition type="warning" title="Important" id="important" href="#important">
The `waitForReplicationAfterSaveChanges` method waits only for replicas which are part of the cluster. It means that external replication destinations are not counted towards the number specified in `replicas` parameter, since they are not part of the cluster.
</Admonition>

<Admonition type="warning" title="Important" id="important" href="#important">

The usage of `waitForReplicationAfterSaveChanges` doesn't involve a distributed transaction (those are not supported since RavenDB 4.0). Even if RavenDB was not able
to write your changes to the number of replicas you specified, the data has been already written to some nodes. You will get an error but data is already there.

This is a powerful feature, but you need to be aware of the possible pitfalls of using it.

</Admonition>

 


</LanguageContent>

<!---
### Transactions
- [Transaction Support](../../client-api/faq/transaction-support)
- [Cluster Transactions](../../server/clustering/cluster-transactions)

### Session
- [What is a Session and How Does it Work](../../client-api/session/what-is-a-session-and-how-does-it-work)
- [Opening a Session](../../client-api/session/opening-a-session)
- [Deleting Entities](../../client-api/session/deleting-entities)
- [Loading Entities](../../client-api/session/loading-entities)

### Querying
- [Query Overview](../../client-api/session/querying/how-to-query)
- [Basics](../../indexes/querying/query-index)

### Document Store
- [What is a Document Store](../../client-api/what-is-a-document-store)


-->