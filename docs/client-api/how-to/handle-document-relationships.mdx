---
title: "How to Handle Document Relationships"
sidebar_label: ...handle document relationships
sidebar_position: 2
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# How to Handle Document Relationships
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


One of the design principles that RavenDB adheres to is the idea that documents are independent,
meaning all data required to process a document is stored within the document itself. 
However, this doesn't mean there should not be relations between objects.

There are valid scenarios where we need to define relationships between objects.
By doing so, we expose ourselves to one major problem: whenever we load the containing entity,
we are going to need to load data from the referenced entities as well (unless we are not interested in them).
While the alternative of storing the whole entity in every object graph it is referenced in seems cheaper at first,
this proves to be quite costly in terms of database resources and network traffic.

RavenDB offers three elegant approaches to solve this problem. Each scenario will need to use one or more of them.
When applied correctly, they can drastically improve performance, reduce network bandwidth, and speed up development.
<Admonition type="note" title="Note">

* In this page:  
  * [Denormalization](../../client-api/how-to/handle-document-relationships#denormalization)  
  * [Includes](../../client-api/how-to/handle-document-relationships#includes)  
     * [One to many includes](../../client-api/how-to/handle-document-relationships#one-to-many-includes)  
     * [Secondary level includes](../../client-api/how-to/handle-document-relationships#secondary-level-includes)  
     * [Dictionary includes](../../client-api/how-to/handle-document-relationships#dictionary-includes)  
     * [Dictionary includes: complex types](../../client-api/how-to/handle-document-relationships#dictionary-includes-complex-types)  
  * [Combining approaches](../../client-api/how-to/handle-document-relationships#combining-approaches)  
  * [Summary](../../client-api/how-to/handle-document-relationships#summary)  
</Admonition>
## Denormalization

The easiest solution is to denormalize the data within the containing entity,
forcing it to contain the actual value of the referenced entity in addition to (or instead of) the foreign key.

Take this JSON document for example:

<TabItem value="something" label="json">
<CodeBlock language="json">
{`// Order document with ID: orders/1-A
\{
    "Customer": \{
        "Name": "Itamar",
        "Id": "customers/1-A"
    \},
    "Items": [
        \{
            "Product": \{
                "Id": "products/1-A",
                "Name": "Milk",
                "Cost": 2.3
            \},
            "Quantity": 3
        \}
    ]
\}
`}
</CodeBlock>
</TabItem>

As you can see, the `Order` document now contains denormalized data from both the `Customer` and the `Product` documents which are saved elsewhere in full.
Note we won't have copied all the customer properties into the order;
instead we just clone the ones that we care about when displaying or processing an order.
This approach is called *denormalized reference*.

The denormalization approach avoids many cross document lookups and results in only the necessary data being transmitted over the network,
but it makes other scenarios more difficult. For example, consider the following entity structure as our start point:

<TabItem value="something" label="order">
<CodeBlock language="csharp">
{`public class Order
\{
    public string CustomerId \{ get; set; \}

    public string[] SupplierIds \{ get; set; \}

    public Referral Referral \{ get; set; \}

    public LineItem[] LineItems \{ get; set; \}

    public double TotalPrice \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something" label="customer">
<CodeBlock language="csharp">
{`public class Customer
\{
    public string Id \{ get; set; \}

    public string Name \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

If we know that whenever we load an `Order` from the database we will need to know the customer's name and address,
we could decide to create a denormalized `Order.Customer` field and store those details directly in the `Order` object.
Obviously, the password and other irrelevant details will not be denormalized:

<TabItem value="something" label="denormalized_customer">
<CodeBlock language="csharp">
{`public class DenormalizedCustomer
\{
    public string Id \{ get; set; \}

    public string Name \{ get; set; \}

    public string Address \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

There wouldn't be a direct reference between the `Order` and the `Customer`.
Instead, `Order` holds a `DenormalizedCustomer`, which contains the interesting bits from `Customer` that we need whenever we process `Order` objects.

But what happens when the user's address is changed? We will have to perform an aggregate operation to update all orders this customer has made.
What if the customer has a lot of orders or changes their address frequently? Keeping these details in sync could become very demanding on the server.
What if another process that works with orders needs a different set of customer properties?
The `DenormalizedCustomer` will need to be expanded, possibly to the point that the majority of the customer record is cloned.

<Admonition type="info" title="Tip" id="tip" href="#tip">
**Denormalization** is a viable solution for rarely changing data or for data that must remain the same despite the underlying referenced data changing over time.
</Admonition>



## Includes

The **Includes** feature addresses the limitations of denormalization.  
Instead of one object containing copies of the properties from another object, 
it is only necessary to hold a reference to the second object, which can be:  

* a Document (as described below)  
* a [Document Revision](../../document-extensions/revisions/client-api/session/including)  
* a [Counter](../../document-extensions/counters/counters-and-other-features#including-counters)  
* a [Time series](../../document-extensions/timeseries/client-api/session/include/overview)  
* a [Compare exchange value](../../client-api/operations/compare-exchange/include-compare-exchange)  

The server can then be instructed to pre-load the referenced object at the same time that the root object is retrieved, using:

<TabItem value="something" label="includes_1_0">
<CodeBlock language="csharp">
{`Order order = session
    .Include<Order>(x => x.CustomerId)
    .Load("orders/1-A");

// this will not require querying the server!
Customer customer = session
    .Load<Customer>(order.CustomerId);
`}
</CodeBlock>
</TabItem>

Above we are asking RavenDB to retrieve the `Order` `orders/1-A`, and at the same time "include" the `Customer` referenced by the `Order.CustomerId` property.
The second call to `Load()` is resolved completely client side (i.e. without a second request to the RavenDB server)
because the relevant `Customer` object has already been retrieved (this is the full `Customer` object not a denormalized version). 

There is also a possibility to load multiple documents:

<TabItem value="something" label="includes_2_0">
<CodeBlock language="csharp">
{`Dictionary<string, Order> orders = session
    .Include<Order>(x => x.CustomerId)
    .Load("orders/1-A", "orders/2-A");

foreach (Order order in orders.Values)
\{
    // this will not require querying the server!
    Customer customer = session.Load<Customer>(order.CustomerId);
\}
`}
</CodeBlock>
</TabItem>

You can also use Includes with queries:

<Tabs groupId='languageSyntax'>
<TabItem value="Query(Embedded)" label="Query(Embedded)">
<CodeBlock language="csharp">
{`IList<Order> orders = session
    .Query<Order>()
    .Include(o => o.CustomerId)
    .Where(x => x.TotalPrice > 100)
    .ToList();

foreach (Order order in orders)
{
    // this will not require querying the server!
    Customer customer = session
        .Load<Customer>(order.CustomerId);
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query(Builder)" label="Query(Builder)">
<CodeBlock language="csharp">
{`IList<Order> orders = session
    .Query<Order>()
       .Include(i => i
         .IncludeDocuments<Customer>(x => x.CustomerId) //single document
         .IncludeCounter("OrderUpdateCount")) //fluent builder can include counters as well 
    .Where(x => x.TotalPrice > 100)
    .ToList();

foreach (Order order in orders)
{
    // this will not require querying the server!
    Customer customer = session
        .Load<Customer>(order.CustomerId);
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Order> orders = session
    .Advanced
    .DocumentQuery<Order>()
    .Include(x => x.CustomerId)
    .WhereGreaterThan(x => x.TotalPrice, 100)
    .ToList();

foreach (Order order in orders)
{
    // this will not require querying the server!
    Customer customer = session
        .Load<Customer>(order.CustomerId);
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL(Embedded)" label="RQL(Embedded)">
<CodeBlock language="sql">
{`from Orders
where TotalPrice > 100
include CustomerId
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL(Builder)" label="RQL(Builder)">
<CodeBlock language="sql">
{`from Orders as o
where TotalPrice > 100
include CustomerId,counters(o,'OrderUpdateCount')
`}
</CodeBlock>
</TabItem>
</Tabs>

This works because RavenDB has two channels through which it can return information in response to a load request.
The first is the Results channel, through which the root object retrieved by the `Load()` method call is returned.
The second is the Includes channel, through which any included documents are sent back to the client.
Client side, those included documents are not returned from the `Load()` method call, but they are added to the session unit of work,
and subsequent requests to load them are served directly from the session cache, without requiring any additional queries to the server.

<Admonition type="note" title="Note">
Embedded and builder variants of Include clause are essentially syntax sugar and are equivalent at the server side.
</Admonition>

<Admonition type="info" title="Info">
Streaming query results does not support the includes feature.  
Learn more in [How to Stream Query Results](../../client-api/session/querying/how-to-stream-query-results#stream-related-documents).  
</Admonition>
### One to many includes

Include can be used with a many to one relationship.
In the above classes, an `Order` has a property `SupplierIds` which contains an array of references to `Supplier` documents.
The following code will cause the suppliers to be pre-loaded:

<TabItem value="something" label="includes_4_0">
<CodeBlock language="csharp">
{`Order order = session
    .Include<Order>(x => x.SupplierIds)
    .Load("orders/1-A");

foreach (string supplierId in order.SupplierIds)
\{
    // this will not require querying the server!
    Supplier supplier = session.Load<Supplier>(supplierId);
\}
`}
</CodeBlock>
</TabItem>

Alternatively, it is possible to use the fluent builder syntax.

<TabItem value="something" label="includes_4_0_builder">
<CodeBlock language="csharp">
{`var order = session.Load<Order>(
    "orders/1-A",
    i => i.IncludeDocuments(x => x.SupplierIds));

foreach (string supplierId in order.SupplierIds)
\{
    // this will not require querying the server!
    var supplier = session.Load<Supplier>(supplierId);
\}
`}
</CodeBlock>
</TabItem>

The calls to `Load()` within the `foreach` loop will not require a call to the server as the `Supplier` objects will already be loaded into the session cache.

Multi-loads are also possible:

<TabItem value="something" label="includes_5_0">
<CodeBlock language="csharp">
{`Dictionary<string, Order> orders = session
    .Include<Order>(x => x.SupplierIds)
    .Load("orders/1-A", "orders/2-A");

foreach (Order order in orders.Values)
\{
    foreach (string supplierId in order.SupplierIds)
    \{
        // this will not require querying the server!
        Supplier supplier = session.Load<Supplier>(supplierId);
    \}
\}
`}
</CodeBlock>
</TabItem>
### Secondary level includes

An Include does not need to work only on the value of a top level property within a document.
It can be used to load a value from a secondary level.
In the classes above, the `Order` contains a `Referral` property which is of the type:

<TabItem value="something" label="referral">
<CodeBlock language="csharp">
{`public class Referral
\{
    public string CustomerId \{ get; set; \}

    public double CommissionPercentage \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

This class contains an identifier for a `Customer`.  
The following code will include the document referenced by that secondary level identifier:

<TabItem value="something" label="includes_6_0">
<CodeBlock language="csharp">
{`Order order = session
    .Include<Order>(x => x.Referral.CustomerId)
    .Load("orders/1-A");

// this will not require querying the server!
Customer customer = session.Load<Customer>(order.Referral.CustomerId);
`}
</CodeBlock>
</TabItem>

It is possible to execute the same code with the fluent builder syntax:

<TabItem value="something" label="includes_6_0_builder">
<CodeBlock language="csharp">
{`var order = session.Load<Order>(
    "orders/1-A", 
    i => i.IncludeDocuments(x => x.Referral.CustomerId));

// this will not require querying the server!
Customer customer = session.Load<Customer>(order.Referral.CustomerId);
`}
</CodeBlock>
</TabItem>

The alternative way is to provide a string-based path:

<TabItem value="something" label="includes_6_2">
<CodeBlock language="csharp">
{`Order order = session.Include("Referral.CustomerId")
    .Load<Order>("orders/1-A");

// this will not require querying the server!
Customer customer = session.Load<Customer>(order.Referral.CustomerId);
`}
</CodeBlock>
</TabItem>

With the fluent builder syntax, it is also possible to use a string-based path:

<TabItem value="something" label="includes_6_2_builder">
<CodeBlock language="csharp">
{`var order = session.Load<Order>(
    "orders/1-A", 
    i => i.IncludeDocuments("Referral.CustomerId"));

// this will not require querying the server!
Customer customer = session.Load<Customer>(order.Referral.CustomerId);
`}
</CodeBlock>
</TabItem>

This secondary level include will also work with collections.
The `Order.LineItems` property holds a collection of `LineItem` objects which each contain a reference to a `Product`:

<TabItem value="something" label="line_item">
<CodeBlock language="csharp">
{`public class LineItem
\{
    public string ProductId \{ get; set; \}

    public string Name \{ get; set; \}

    public int Quantity \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

The `Product` documents can be included using the following syntax:

<TabItem value="something" label="includes_7_0">
<CodeBlock language="csharp">
{`Order order = session
    .Include<Order>(x => x.LineItems.Select(l => l.ProductId))
    .Load("orders/1-A");

foreach (LineItem lineItem in order.LineItems)
\{
    // this will not require querying the server!
    Product product = session.Load<Product>(lineItem.ProductId);
\}
`}
</CodeBlock>
</TabItem>

The fluent builder syntax works here too.

<TabItem value="something" label="includes_7_0_builder">
<CodeBlock language="csharp">
{`var order = session.Load<Order>(
    "orders/1-A",
    i => i.IncludeDocuments(x => x.LineItems.Select(l => l.ProductId)));

foreach (LineItem lineItem in order.LineItems)
\{
    // this will not require querying the server!
    Product product = session.Load<Product>(lineItem.ProductId);
\}
`}
</CodeBlock>
</TabItem>

The `Select()` within the Include tells RavenDB which property of secondary level objects to use as a reference.

<Admonition type="warning" title="Warning">
### String path conventions

When using string-based includes like:

<TabItem value="something" label="includes_6_2">
<CodeBlock language="csharp">
{`Order order = session.Include("Referral.CustomerId")
    .Load<Order>("orders/1-A");

// this will not require querying the server!
Customer customer = session.Load<Customer>(order.Referral.CustomerId);
`}
</CodeBlock>
</TabItem>

you must remember to follow certain rules that must apply to the provided string path:

1.	**Dots** are used to separate properties
    e.g. `"Referral.CustomerId"` in the example above means that our `Order` contains property `Referral` and that property contains another property called `CustomerId`.

2.	**Indexer operator** is used to indicate that property is a collection type.
    So if our `Order` has a list of LineItems and each `LineItem` contains a `ProductId` property, then we can create string path as follows: `"LineItems[].ProductId"`.

3.	**Prefixes** can be used to indicate the prefix of the identifier of the document that is going to be included.
    It can be useful when working with custom or semantic identifiers.
    For example, if you have a customer stored under `customers/login@domain.com` then you can include it using `"Referral.CustomerEmail(customers/)"` (`customers/` is the prefix here).

Learning string path rules may be useful when you will want to query database using HTTP API.

<TabItem value="something" label="json">
<CodeBlock language="json">
{`curl -X GET "http://localhost:8080/databases/Northwind/docs?id=orders/1-A&include=Lines[].Product"
`}
</CodeBlock>
</TabItem>

</Admonition>
### Dictionary includes

Dictionary keys and values can also be used when doing includes. Consider following scenario:

<TabItem value="something" label="person_1">
<CodeBlock language="csharp">
{`public class Person
\{
    public string Id \{ get; set; \}

    public string Name \{ get; set; \}

    public Dictionary<string, string> Attributes \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something" label="includes_10_0">
<CodeBlock language="csharp">
{`session.Store(
    new Person
    \{
        Id = "people/1-A",
        Name = "John Doe",
        Attributes = new Dictionary<string, string>
        \{
            \{ "Mother", "people/2" \},
            \{ "Father", "people/3" \}
        \}
    \});

session.Store(
    new Person
    \{
        Id = "people/2",
        Name = "Helen Doe",
        Attributes = new Dictionary<string, string>()
    \});

session.Store(
    new Person
    \{
        Id = "people/3",
        Name = "George Doe",
        Attributes = new Dictionary<string, string>()
    \});
`}
</CodeBlock>
</TabItem>

Now we want to include all documents that are under dictionary values:

<TabItem value="something" label="includes_10_1">
<CodeBlock language="csharp">
{`var person = session
    .Include<Person>(x => x.Attributes.Values)
    .Load("people/1-A");

var mother = session
    .Load<Person>(person.Attributes["Mother"]);

var father = session
    .Load<Person>(person.Attributes["Father"]);

Assert.Equal(1, session.Advanced.NumberOfRequests);
`}
</CodeBlock>
</TabItem>

The code above can be also rewritten with fluent builder syntax:

<TabItem value="something" label="includes_10_1_builder">
<CodeBlock language="csharp">
{`var person = session.Load<Person>(
    "people/1-A",
    i => i.IncludeDocuments<Person>(x => x.Attributes.Values));

var mother = session
    .Load<Person>(person.Attributes["Mother"]);

var father = session
    .Load<Person>(person.Attributes["Father"]);

Assert.Equal(1, session.Advanced.NumberOfRequests);
`}
</CodeBlock>
</TabItem>

You can also include values from dictionary keys:

<TabItem value="something" label="includes_10_3">
<CodeBlock language="csharp">
{`var person = session
    .Include<Person>(x => x.Attributes.Keys)
    .Load("people/1-A");
`}
</CodeBlock>
</TabItem>

Here, as well, this can be written with fluent builder syntax:

<TabItem value="something" label="includes_10_3_builder">
<CodeBlock language="csharp">
{`var person = session                        
    .Load<Person>("people/1-A",
     i => i.IncludeDocuments<Person>(x => x.Attributes.Keys));
`}
</CodeBlock>
</TabItem>
### Dictionary includes: complex types

If values in dictionary are more complex, e.g.

<TabItem value="something" label="person_2">
<CodeBlock language="csharp">
{`public class PersonWithAttribute
\{
    public string Id \{ get; set; \}

    public string Name \{ get; set; \}

    public Dictionary<string, Attribute> Attributes \{ get; set; \}
\}

public class Attribute
\{
    public string Ref \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something" label="includes_11_0">
<CodeBlock language="csharp">
{`session.Store(
    new PersonWithAttribute
    \{
        Id = "people/1-A",
        Name = "John Doe",
        Attributes = new Dictionary<string, Attribute>
        \{
            \{ "Mother", new Attribute \{ Ref = "people/2" \} \},
            \{ "Father", new Attribute \{ Ref = "people/3" \} \}
        \}
    \});

session.Store(
    new Person
    \{
        Id = "people/2",
        Name = "Helen Doe",
        Attributes = new Dictionary<string, string>()
    \});

session.Store(
    new Person
    \{
        Id = "people/3",
        Name = "George Doe",
        Attributes = new Dictionary<string, string>()
    \});
`}
</CodeBlock>
</TabItem>

We can also do includes on specific properties:

<TabItem value="something" label="includes_11_1">
<CodeBlock language="csharp">
{`var person = session
    .Include<PersonWithAttribute>(x => x.Attributes.Values.Select(v => v.Ref))
    .Load("people/1-A");

var mother = session
    .Load<Person>(person.Attributes["Mother"].Ref);

var father = session
    .Load<Person>(person.Attributes["Father"].Ref);

Assert.Equal(1, session.Advanced.NumberOfRequests);
`}
</CodeBlock>
</TabItem>



## Combining approaches

It is possible to combine the above techniques.  
Using the `DenormalizedCustomer` from above and creating an order that uses it:

<TabItem value="something" label="order_3">
<CodeBlock language="csharp">
{`public class Order3
\{
    public DenormalizedCustomer Customer \{ get; set; \}

    public string[] SupplierIds \{ get; set; \}

    public Referral Referral \{ get; set; \}

    public LineItem[] LineItems \{ get; set; \}

    public double TotalPrice \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

We have the advantages of a denormalization, a quick and simple load of an `Order`,
and the fairly static `Customer` details that are required for most processing.
But we also have the ability to easily and efficiently load the full `Customer` object when necessary using:

<TabItem value="something" label="includes_9_0">
<CodeBlock language="csharp">
{`Order3 order = session
    .Include<Order3, Customer>(x => x.Customer.Id)
    .Load("orders/1-A");

// this will not require querying the server!
Customer customer = session.Load<Customer>(order.Customer.Id);
`}
</CodeBlock>
</TabItem>

This combining of denormalization and Includes could also be used with a list of denormalized objects.

It is possible to use Include on a query being a projection.
Includes are evaluated after the projection has been evaluated.
This opens up the possibility of implementing Tertiary Includes (i.e. retrieving documents that are referenced by documents that are referenced by the root document). 

RavenDB can support Tertiary Includes, but before resorting to them you should re-evaluate your document model.
Needing Tertiary Includes can be an indication that you are designing your documents along "Relational" lines.



## Summary

There are no strict rules as to when to use which approach, but the general idea is to give it a lot of thought and consider the implications each approach has.

As an example, in an e-commerce application it might be better to denormalize product names and prices into an order line object
since you want to make sure the customer sees the same price and product title in the order history.
But the customer name and addresses should probably be references rather than denormalized into the order entity.

For most cases where denormalization is not an option, Includes are probably the answer.




</LanguageContent>
<LanguageContent language="java">


One of the design principles that RavenDB adheres to is the idea that documents are independent,
meaning all data required to process a document is stored within the document itself.
However, this doesn't mean there should not be relations between objects.

There are valid scenarios where we need to define relationships between objects.
By doing so, we expose ourselves to one major problem: whenever we load the containing entity,
we are going to need to load data from the referenced entities as well (unless we are not interested in them).
While the alternative of storing the whole entity in every object graph it is referenced in seems cheaper at first,
this proves to be quite costly in terms of database resources and network traffic.

RavenDB offers three elegant approaches to solve this problem. Each scenario will need to use one or more of them.
When applied correctly, they can drastically improve performance, reduce network bandwidth, and speed up development.

## Denormalization

The easiest solution is to denormalize the data within the containing entity,
forcing it to contain the actual value of the referenced entity in addition to (or instead of) the foreign key.

Take this JSON document for example:

<TabItem value="something" label="json">
<CodeBlock language="json">
{`// Order document with ID: orders/1-A
\{
    "Customer": \{
        "Name": "Itamar",
        "Id": "customers/1-A"
    \},
    "Items": [
        \{
            "Product": \{
                "Id": "products/1-A",
                "Name": "Milk",
                "Cost": 2.3
            \},
            "Quantity": 3
        \}
    ]
\}
`}
</CodeBlock>
</TabItem>

As you can see, the `Order` document now contains denormalized data from both the `Customer` and the `Product` documents which are saved elsewhere in full.
Note we won't have copied all the customer fields into the order; instead we just clone the ones that we care about when displaying or processing an order.
This approach is called *denormalized reference*.

The denormalization approach avoids many cross document lookups and results in only the necessary data being transmitted over the network,
but it makes other scenarios more difficult. For example, consider the following entity structure as our start point:

<TabItem value="something-something" label="order">
<CodeBlock language="java">
{`public class Order \{
    private String customerId;
    private String[] supplierIds;
    private Referral referral;
    private LineItem[] lineItems;
    private double totalPrice;

    public String getCustomerId() \{
        return customerId;
    \}

    public void setCustomerId(String customerId) \{
        this.customerId = customerId;
    \}

    public String[] getSupplierIds() \{
        return supplierIds;
    \}

    public void setSupplierIds(String[] supplierIds) \{
        this.supplierIds = supplierIds;
    \}

    public Referral getReferral() \{
        return referral;
    \}

    public void setReferral(Referral referral) \{
        this.referral = referral;
    \}

    public LineItem[] getLineItems() \{
        return lineItems;
    \}

    public void setLineItems(LineItem[] lineItems) \{
        this.lineItems = lineItems;
    \}

    public double getTotalPrice() \{
        return totalPrice;
    \}

    public void setTotalPrice(double totalPrice) \{
        this.totalPrice = totalPrice;
    \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something-something" label="customer">
<CodeBlock language="java">
{`public class Customer \{
    private String id;
    private String name;

    public String getId() \{
        return id;
    \}

    public void setId(String id) \{
        this.id = id;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}
\}
`}
</CodeBlock>
</TabItem>

If we know that whenever we load an `Order` from the database we will need to know the customer's name and address,
we could decide to create a denormalized `Order.Customer` field and store those details directly in the `Order` object.
Obviously, the password and other irrelevant details will not be denormalized:

<TabItem value="something-something" label="denormalized_customer">
<CodeBlock language="java">
{`public class DenormalizedCustomer \{
    private String id;
    private String name;
    private String address;

    public String getId() \{
        return id;
    \}

    public void setId(String id) \{
        this.id = id;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}

    public String getAddress() \{
        return address;
    \}

    public void setAddress(String address) \{
        this.address = address;
    \}
\}
`}
</CodeBlock>
</TabItem>

There wouldn't be a direct reference between the `Order` and the `Customer`.
Instead, `Order` holds a `DenormalizedCustomer`, which contains the interesting bits from `Customer` that we need whenever we process `Order` objects.

But what happens when the user's address is changed?
We will have to perform an aggregate operation to update all orders this customer has made.
What if the customer has a lot of orders or changes their address frequently?
Keeping these details in sync could become very demanding on the server.
What if another process that works with orders needs a different set of customer fields?
The `DenormalizedCustomer` will need to be expanded, possibly to the point that the majority of the customer record is cloned.

<Admonition type="info" title="Tip" id="tip" href="#tip">
**Denormalization** is a viable solution for rarely changing data or for data that must remain the same despite the underlying referenced data changing over time.
</Admonition>

## Includes

The **Includes** feature addresses the limitations of denormalization.
Instead of one object containing copies of the fields from another object, it is only necessary to hold a reference to the second object.
Then the server can be instructed to pre-load the referenced document at the same time that the root object is retrieved. We do this using:

<TabItem value="something-something" label="includes_1_0">
<CodeBlock language="java">
{`Order order = session
    .include("CustomerId")
    .load(Order.class, "orders/1-A");

// this will not require querying the server!
Customer customer = session.load(Customer.class, order.getCustomerId());
`}
</CodeBlock>
</TabItem>

Above we are asking RavenDB to retrieve the `Order` `orders/1-A`, and at the same time "include" the `Customer` referenced by the `Order.CustomerId` field.
The second call to `load()` is resolved completely client side (i.e. without a second request to the RavenDB server)
because the relevant `Customer` object has already been retrieved (this is the full `Customer` object not a denormalized version). 

There is also a possibility to load multiple documents:

<TabItem value="something-something" label="includes_2_0">
<CodeBlock language="java">
{`Map<String, Order> orders = session
    .include("CustomerId")
    .load(Order.class, "orders/1-A", "orders/2-A");

for (Order order : orders.values()) \{
    Customer customer = session.load(Customer.class, order.getCustomerId());
\}
`}
</CodeBlock>
</TabItem>

You can also use Includes with queries:

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`List<Order> orders = session
    .query(Order.class)
    .include("CustomerId")
    .whereGreaterThan("TotalPrice", 100)
    .toList();

for (Order order : orders) {
    // this will not require querying the server!
    Customer customer = session
        .load(Customer.class, order.getCustomerId());
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery(Builder)" label="DocumentQuery(Builder)">
<CodeBlock language="java">
{`List<Order> orders = session
    .query(Order.class)
    .include(i -> i.
        includeDocuments("CustomerId").
        includeCounter("OrderUpdateCount"))
    .whereGreaterThan("TotalPrice", 100)
    .toList();

for (Order order : orders) {
    // this will not require querying the server!
    Customer customer = session
        .load(Customer.class, order.getCustomerId());
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL(Embedded)" label="RQL(Embedded)">
<CodeBlock language="sql">
{`from Orders
where TotalPrice > 100
include CustomerId
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL(Builder)" label="RQL(Builder)">
<CodeBlock language="sql">
{`from Orders as o
where TotalPrice > 100
include CustomerId,counters(o,'OrderUpdateCount')
`}
</CodeBlock>
</TabItem>
</Tabs>

This works because RavenDB has two channels through which it can return information in response to a load request.
The first is the Results channel, through which the root object retrieved by the `load()` method call is returned.
The second is the Includes channel, through which any included documents are sent back to the client.
Client side, those included documents are not returned from the `load()` method call, but they are added to the session unit of work,
and subsequent requests to load them are served directly from the session cache, without requiring any additional queries to the server.

<Admonition type="note" title="Note">
Embedded and builder variants of Include clause are essentially syntax sugar and are equivalent at the server side.
</Admonition>

<Admonition type="info" title="Info">
Streaming query results does not support the includes feature.  
Learn more in [How to Stream Query Results](../../client-api/session/querying/how-to-stream-query-results#stream-related-documents).  
</Admonition>

### One to many includes

Include can be used with a many to one relationship.
In the above classes, an `Order` has a field `SupplierIds` which contains an array of references to `Supplier` documents.
The following code will cause the suppliers to be pre-loaded:

<TabItem value="something-something" label="includes_4_0">
<CodeBlock language="java">
{`Order order = session
    .include("SupplierIds")
    .load(Order.class, "orders/1-A");

for (String supplierId : order.getSupplierIds()) \{
    // this will not require querying the server!
    Supplier supplier = session.load(Supplier.class, supplierId);
\}
`}
</CodeBlock>
</TabItem>

Alternatively, it is possible to use the fluent builder syntax.

<TabItem value="something-something" label="includes_4_0_builder">
<CodeBlock language="java">
{`Order order = session.load(Order.class, "orders/1-A",
    i -> i.includeDocuments("SupplierIds"));

for (String supplierId : order.getSupplierIds()) \{
    // this will not require querying the server!
    Supplier supplier = session.load(Supplier.class, supplierId);
\}
`}
</CodeBlock>
</TabItem>

The calls to `load()` within the `foreach` loop will not require a call to the server as the `Supplier` objects will already be loaded into the session cache.

Multi-loads are also possible:

<TabItem value="something-something" label="includes_5_0">
<CodeBlock language="java">
{`Map<String, Order> orders = session
    .include("SupplierIds")
    .load(Order.class, "orders/1-A", "orders/2-A");

for (Order order : orders.values()) \{
    for (String supplierId : order.getSupplierIds()) \{
        // this will not require querying the server!

        Supplier supplier = session.load(Supplier.class, supplierId);
    \}
\}
`}
</CodeBlock>
</TabItem>

### Secondary level includes

An Include does not need to work only on the value of a top level field within a document.
It can be used to load a value from a secondary level.
In the classes above, the `Order` contains a `Referral` field which is of the type:

<TabItem value="something-something" label="referral">
<CodeBlock language="java">
{`public class Referral \{
    private String customerId;
    private double commissionPercentage;

    public String getCustomerId() \{
        return customerId;
    \}

    public void setCustomerId(String customerId) \{
        this.customerId = customerId;
    \}

    public double getCommissionPercentage() \{
        return commissionPercentage;
    \}

    public void setCommissionPercentage(double commissionPercentage) \{
        this.commissionPercentage = commissionPercentage;
    \}
\}
`}
</CodeBlock>
</TabItem>

This class contains an identifier for a `Customer`. The following code will include the document referenced by that secondary level identifier:

<TabItem value="something-something" label="includes_6_0">
<CodeBlock language="java">
{`Order order = session
    .include("Referral.CustomerId")
    .load(Order.class, "orders/1-A");

// this will not require querying the server!
Customer customer = session.load(Customer.class, order.getReferral().getCustomerId());
`}
</CodeBlock>
</TabItem>

It is possible to execute the same code with the fluent builder syntax:

<TabItem value="something-something" label="includes_6_0_builder">
<CodeBlock language="java">
{`Order order = session
    .load(Order.class, "orders/1-A",
        i -> i.includeDocuments("Referral.CustomerId"));

// this will not require querying the server!
Customer customer = session.load(Customer.class, order.getReferral().getCustomerId());
`}
</CodeBlock>
</TabItem>

This secondary level include will also work with collections.
The `Order.LineItems` field holds a collection of `LineItem` objects which each contain a reference to a `Product`:

<TabItem value="something-something" label="line_item">
<CodeBlock language="java">
{`public class LineItem \{
    private String productId;
    private String name;
    private int quantity;

    public String getProductId() \{
        return productId;
    \}

    public void setProductId(String productId) \{
        this.productId = productId;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}

    public int getQuantity() \{
        return quantity;
    \}

    public void setQuantity(int quantity) \{
        this.quantity = quantity;
    \}
\}
`}
</CodeBlock>
</TabItem>

The `Product` documents can be included using the following syntax:

<TabItem value="something-something" label="includes_7_0">
<CodeBlock language="java">
{`Order order = session
    .include("LineItems[].ProductId")
    .load(Order.class, "orders/1-A");

for (LineItem lineItem : order.getLineItems()) \{
    // this will not require querying the server!
    Product product = session.load(Product.class, lineItem.getProductId());
\}
`}
</CodeBlock>
</TabItem>

The fluent builder syntax works here too.

<TabItem value="something-something" label="includes_7_0_builder">
<CodeBlock language="java">
{`Order order = session.load(Order.class, "orders/1-A",
    i -> i.includeDocuments("LineItems[].ProductId"));

for (LineItem lineItem : order.getLineItems()) \{
    // this will not require querying the server!
    Product product = session.load(Product.class, lineItem.getProductId());
\}
`}
</CodeBlock>
</TabItem>

The `[]` within the `include` tells RavenDB which field of secondary level objects to use as a reference.

<Admonition type="warning" title="Warning">
### String path conventions

When using string-based includes like:

<TabItem value="something-something" label="includes_6_0">
<CodeBlock language="java">
{`Order order = session
    .include("Referral.CustomerId")
    .load(Order.class, "orders/1-A");

// this will not require querying the server!
Customer customer = session.load(Customer.class, order.getReferral().getCustomerId());
`}
</CodeBlock>
</TabItem>

you must remember to follow certain rules that must apply to the provided string path:

1.	**Dots** are used to separate fields
    e.g. `"Referral.CustomerId"` in the example above means that our `Order` contains field `Referral` and that field contains another field called `CustomerId`.

2.	**Indexer operator** is used to indicate that field is a collection type.
    So if our `Order` has a list of LineItems and each `LineItem` contains a `ProductId` field, then we can create string path as follows: `"LineItems[].ProductId"`.

3.	**Prefixes** can be used to indicate the prefix of the identifier of the document that is going to be included.
    It can be useful when working with custom or semantic identifiers.
    For example, if you have a customer stored under `customers/login@domain.com` then you can include it
    using `"Referral.CustomerEmail(customers/)"` (`customers/` is the prefix here).

Learning string path rules may be useful when you will want to query database using HTTP API.

<TabItem value="something" label="json">
<CodeBlock language="json">
{`curl -X GET "http://localhost:8080/databases/Northwind/docs?id=orders/1-A&include=lines[].product"
`}
</CodeBlock>
</TabItem>

</Admonition>

### Dictionary includes

Dictionary keys and values can also be used when doing includes. Consider following scenario:

<TabItem value="something-something" label="person_1">
<CodeBlock language="java">
{`public class Person \{
    private String id;
    private String name;
    private Map<String, String> attributes;

    public String getId() \{
        return id;
    \}

    public void setId(String id) \{
        this.id = id;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}

    public Map<String, String> getAttributes() \{
        return attributes;
    \}

    public void setAttributes(Map<String, String> attributes) \{
        this.attributes = attributes;
    \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something-something" label="includes_10_0">
<CodeBlock language="java">
{`HashMap<String, String> attributes1 = new HashMap<>();
attributes1.put("Mother", "people/2");
attributes1.put("Father", "people/3");

Person person1 = new Person();
person1.setId("people/1-A");
person1.setName("John Doe");
person1.setAttributes(attributes1);

session.store(person1);

Person person2 = new Person();
person2.setId("people/2");
person2.setName("Helen Doe");
person2.setAttributes(Collections.emptyMap());

session.store(person2);

Person person3 = new Person();
person3.setId("people/3");
person3.setName("George Doe");
person3.setAttributes(Collections.emptyMap());

session.store(person3);
`}
</CodeBlock>
</TabItem>

Now we want to include all documents that are under dictionary values:

<TabItem value="something-something" label="includes_10_1">
<CodeBlock language="java">
{`Person person = session.include("Attributes.Values")
    .load(Person.class, "people/1-A");

Person mother = session
    .load(Person.class, person.getAttributes().get("Mother"));

Person father = session
    .load(Person.class, person.getAttributes().get("Father"));

Assert.assertEquals(1, session.advanced().getNumberOfRequests());
`}
</CodeBlock>
</TabItem>

The code above can be also rewritten with fluent builder syntax:

<TabItem value="something-something" label="includes_10_1_builder">
<CodeBlock language="java">
{`Person person = session.load(Person.class, "people/1-A",
    i -> i.includeDocuments("Attributes.Values"));

Person mother = session
    .load(Person.class, person.getAttributes().get("Mother"));

Person father = session
    .load(Person.class, person.getAttributes().get("Father"));

Assert.assertEquals(1, session.advanced().getNumberOfRequests());
`}
</CodeBlock>
</TabItem>

You can also include values from dictionary keys:

<TabItem value="something-something" label="includes_10_3">
<CodeBlock language="java">
{`Person person = session
    .include("Attributes.Keys")
    .load(Person.class, "people/1-A");
`}
</CodeBlock>
</TabItem>

Here, as well, this can be written with fluent builder syntax:

<TabItem value="something-something" label="includes_10_3_builder">
<CodeBlock language="java">
{`Person person = session
    .load(Person.class, "people/1-A",
        i -> i.includeDocuments("Attributes.Keys"));
`}
</CodeBlock>
</TabItem>

#### Complex types

If values in dictionary are more complex e.g.

<TabItem value="something-something" label="person_2">
<CodeBlock language="java">
{`public class PersonWithAttribute \{
    private String id;
    private String name;
    private Map<String, Attribute> attributes;

    public String getId() \{
        return id;
    \}

    public void setId(String id) \{
        this.id = id;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}

    public Map<String, Attribute> getAttributes() \{
        return attributes;
    \}

    public void setAttributes(Map<String, Attribute> attributes) \{
        this.attributes = attributes;
    \}
\}

public class Attribute \{
    private String ref;

    public Attribute() \{
    \}

    public Attribute(String ref) \{
        this.ref = ref;
    \}

    public String getRef() \{
        return ref;
    \}

    public void setRef(String ref) \{
        this.ref = ref;
    \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something-something" label="includes_11_0">
<CodeBlock language="java">
{`HashMap<String, Attribute> attributes = new HashMap<>();
attributes.put("Mother", new Attribute("people/2"));
attributes.put("Father", new Attribute("people/3"));

PersonWithAttribute person1 = new PersonWithAttribute();
person1.setId("people/1-A");
person1.setName("John Doe");
person1.setAttributes(attributes);

session.store(person1);

Person person2 = new Person();
person2.setId("people/2");
person2.setName("Helen Doe");
person2.setAttributes(Collections.emptyMap());

session.store(person2);

Person person3 = new Person();
person3.setId("people/3");
person3.setName("George Doe");
person3.setAttributes(Collections.emptyMap());

session.store(person3);
`}
</CodeBlock>
</TabItem>

We can also do includes on specific fields:

<TabItem value="something-something" label="includes_11_1">
<CodeBlock language="java">
{`PersonWithAttribute person = session
    .include("Attributes[].Ref")
    .load(PersonWithAttribute.class, "people/1-A");

Person mother = session
    .load(Person.class, person.getAttributes().get("Mother").getRef());

Person father = session
    .load(Person.class, person.getAttributes().get("Father").getRef());

Assert.assertEquals(1, session.advanced().getNumberOfRequests());
`}
</CodeBlock>
</TabItem>

## Combining approaches

It is possible to combine the above techniques.  
Using the `DenormalizedCustomer` from above and creating an order that uses it:

<TabItem value="something-something" label="order_3">
<CodeBlock language="java">
{`public class Order3 \{
    private DenormalizedCustomer customer;
    private String[] supplierIds;
    private Referral referral;
    private LineItem[] lineItems;
    private double totalPrice;

    public DenormalizedCustomer getCustomer() \{
        return customer;
    \}

    public void setCustomer(DenormalizedCustomer customer) \{
        this.customer = customer;
    \}

    public String[] getSupplierIds() \{
        return supplierIds;
    \}

    public void setSupplierIds(String[] supplierIds) \{
        this.supplierIds = supplierIds;
    \}

    public Referral getReferral() \{
        return referral;
    \}

    public void setReferral(Referral referral) \{
        this.referral = referral;
    \}

    public LineItem[] getLineItems() \{
        return lineItems;
    \}

    public void setLineItems(LineItem[] lineItems) \{
        this.lineItems = lineItems;
    \}

    public double getTotalPrice() \{
        return totalPrice;
    \}

    public void setTotalPrice(double totalPrice) \{
        this.totalPrice = totalPrice;
    \}
\}
`}
</CodeBlock>
</TabItem>

We have the advantages of a denormalization, a quick and simple load of an `Order`, and the fairly static `Customer` details that are required for most processing.
But we also have the ability to easily and efficiently load the full `Customer` object when necessary using:

<TabItem value="something-something" label="includes_9_0">
<CodeBlock language="java">
{`Order3 order = session
    .include("Customer.Id")
    .load(Order3.class, "orders/1-A");

// this will not require querying the server!
Customer customer = session.load(Customer.class, order.getCustomer().getId());
`}
</CodeBlock>
</TabItem>

This combining of denormalization and Includes could also be used with a list of denormalized objects.

It is possible to use Include on a query being a projection. Includes are evaluated after the projection has been evaluated.
This opens up the possibility of implementing Tertiary Includes
(i.e. retrieving documents that are referenced by documents that are referenced by the root document). 

RavenDB can support Tertiary Includes, but before resorting to them you should re-evaluate your document model.
Needing Tertiary Includes can be an indication that you are designing your documents along "Relational" lines.

## Summary

There are no strict rules as to when to use which approach,
but the general idea is to give it a lot of thought and consider the implications each approach has.

As an example, in an e-commerce application it might be better to denormalize product names and prices into an order line object
since you want to make sure the customer sees the same price and product title in the order history.
But the customer name and addresses should probably be references rather than denormalized into the order entity.

For most cases where denormalization is not an option, Includes are probably the answer.


</LanguageContent>
<LanguageContent language="nodejs">


One of the design principles that RavenDB adheres to is the idea that documents are independent,
meaning all data required to process a document is stored within the document itself. 
However, this doesn't mean there should not be relations between objects.

There are valid scenarios where we need to define relationships between objects.
By doing so, we expose ourselves to one major problem: whenever we load the containing entity,
we are going to need to load data from the referenced entities as well (unless we are not interested in them).
While the alternative of storing the whole entity in every object graph it is referenced in seems cheaper at first,
this proves to be quite costly in terms of database resources and network traffic.

RavenDB offers three elegant approaches to solve this problem. Each scenario will need to use one or more of them.
When applied correctly, they can drastically improve performance, reduce network bandwidth, and speed up development.
<Admonition type="note" title="Note">

* In this page:  
  * [Denormalization](../../client-api/how-to/handle-document-relationships#denormalization)  
  * [Includes](../../client-api/how-to/handle-document-relationships#includes)  
     * [One to many includes](../../client-api/how-to/handle-document-relationships#one-to-many-includes)  
     * [Secondary level includes](../../client-api/how-to/handle-document-relationships#secondary-level-includes)  
     * [Dictionary includes](../../client-api/how-to/handle-document-relationships#dictionary-includes)  
     * [Dictionary includes: complex types](../../client-api/how-to/handle-document-relationships#dictionary-includes-complex-types)  
  * [Combining approaches](../../client-api/how-to/handle-document-relationships#combining-approaches)  
  * [Summary](../../client-api/how-to/handle-document-relationships#summary)  
</Admonition>
## Denormalization

The easiest solution is to denormalize the data within the containing entity,
forcing it to contain the actual value of the referenced entity in addition to (or instead of) the foreign key.

Take this JSON document for example:

<TabItem value="something" label="json">
<CodeBlock language="json">
{`// Order document with ID: orders/1-A
\{
    "customer": \{
        "id": "customers/1-A",
        "name": "Itamar"
    \},
    "items": [
        \{
            "product": \{
                "id": "products/1-A",
                "name": "Milk",
                "cost": 2.3
            \},
            "quantity": 3
        \}
    ]
\}
`}
</CodeBlock>
</TabItem>

As you can see, the `Order` document now contains denormalized data from both the `Customer` and the `Product` documents which are saved elsewhere in full.
Note we won't have copied all the customer properties into the order;
instead we just clone the ones that we care about when displaying or processing an order.
This approach is called _denormalized reference_.

The denormalization approach avoids many cross document lookups and results in only the necessary data being transmitted over the network,
but it makes other scenarios more difficult. For example, consider the following entity structure as our start point:

<TabItem value="something-something" label="order">
<CodeBlock language="nodejs">
{`class Order \{
    constructor(
        customerId = '',
        supplierIds = [],
        referral = null,
        lineItems = [],
        totalPrice = 0
    ) \{
        Object.assign(this, \{
            customerId,
            supplierIds,
            referral,
            lineItems,
            totalPrice
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something-something" label="customer">
<CodeBlock language="nodejs">
{`class Customer \{
    constructor(
        id = '',
        name = ''
    ) \{
        Object.assign(this, \{
            id,
            name
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

If we know that whenever we load an `Order` from the database we will need to know the customer's name and address,
we could decide to create a denormalized `Order.customer` field and store those details directly in the `Order` object.
Obviously, the password and other irrelevant details will not be denormalized:

<TabItem value="something-something" label="denormalized_customer">
<CodeBlock language="nodejs">
{`class DenormalizedCustomer \{
    constructor(
        id = '',
        name = '',
        address = ''
    ) \{
        Object.assign(this, \{
            id,
            name,
            address
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

There wouldn't be a direct reference between the `Order` and the `Customer`.
Instead, `Order` holds a `DenormalizedCustomer`, which contains the interesting bits from `Customer` that we need whenever we process `Order` objects.

But what happens when the user's address is changed? We will have to perform an aggregate operation to update all orders this customer has made.
What if the customer has a lot of orders or changes their address frequently? Keeping these details in sync could become very demanding on the server.
What if another process that works with orders needs a different set of customer properties?
The `DenormalizedCustomer` will need to be expanded, possibly to the point that the majority of the customer record is cloned.

<Admonition type="info" title="Tip" id="tip" href="#tip">
**Denormalization** is a viable solution for rarely changing data or for data that must remain the same despite the underlying referenced data changing over time.
</Admonition>



## Includes

The **Includes** feature addresses the limitations of denormalization.  
Instead of one object containing copies of the properties from another object, 
it is only necessary to hold a reference to the second object, which can be:  

* a Document (as described below)  
* a [Document Revision](../../document-extensions/revisions/client-api/session/including)  
* a [Counter](../../document-extensions/counters/counters-and-other-features#including-counters)  
* a [Time series](../../document-extensions/timeseries/client-api/session/include/overview)  
* a [Compare exchange value](../../client-api/operations/compare-exchange/include-compare-exchange)  

The server can then be instructed to pre-load the referenced object at the same time that the root object is retrieved, using:

<TabItem value="something-something" label="includes_1_0">
<CodeBlock language="nodejs">
{`const order = await session
     // Call 'include'
     // Pass the path of the document property that holds document to include
    .include("customerId")
    .load("orders/1-A");

const customer = await session
     // This call to 'load' will not require querying the server
     // No server request will be made
    .load(order.customerId);
`}
</CodeBlock>
</TabItem>

Above we are asking RavenDB to retrieve the `Order` `orders/1-A`, and at the same time "include" the `Customer` referenced by the `customerId` property.
The second call to `load()` is resolved completely client side (i.e. without a second request to the RavenDB server)
because the relevant `Customer` object has already been retrieved (this is the full `Customer` object not a denormalized version). 

There is also a possibility to load multiple documents:

<TabItem value="something-something" label="includes_2_0">
<CodeBlock language="nodejs">
{`const orders = await session
    .include("customerId")
    .load(["orders/1-A", "orders/2-A"]);

const orderEntities = Object.entries(orders);

for (let i = 0; i < orderEntities.length; i++) \{
    // This will not require querying the server
    const customer = await session.load(orderEntities[i][1].customerId);
\}
`}
</CodeBlock>
</TabItem>

You can also use Includes with queries:

<Tabs groupId='languageSyntax'>
<TabItem value="Query(Embedded)" label="Query(Embedded)">
<CodeBlock language="nodejs">
{`const orders = await session
    .query({ collection: "orders" })
    .whereGreaterThan("totalPrice", 100)
    .include("customerId")
    .all();

for (let i = 0; i < orders.length; i++) {
    // This will not require querying the server
    const customer = await session.load(orders[i].customerId);
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query(Builder)" label="Query(Builder)">
<CodeBlock language="nodejs">
{`const orders = await session
    .query({ collection: "orders" })
    .whereGreaterThan("totalPrice", 100)
    .include(i => i
        .includeDocuments("customerId")        // include document
        .includeCounter("OrderUpdateCounter")) // builder can include counters as well 
    .all();

for (let i = 0; i < orders.length; i++) {
    // This will not require querying the server
    const customer = await session.load(orders[i].customerId);
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL(Embedded)" label="RQL(Embedded)">
<CodeBlock language="sql">
{`from "orders"
where totalPrice > 100
include customerId
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL(Builder)" label="RQL(Builder)">
<CodeBlock language="sql">
{`from "orders" as o
where totalPrice > 100
include customerId, counters(o,'OrderUpdateCount')
`}
</CodeBlock>
</TabItem>
</Tabs>

This works because RavenDB has two channels through which it can return information in response to a load request.
The first is the Results channel, through which the root object retrieved by the `load()` method call is returned.
The second is the Includes channel, through which any included documents are sent back to the client.
Client side, those included documents are not returned from the `load()` method call, but they are added to the session unit of work,
and subsequent requests to load them are served directly from the session cache, without requiring any additional queries to the server.

<Admonition type="note" title="Note">
Embedded and builder variants of `include` clause are essentially syntax sugar and are equivalent at the server side.
</Admonition>

<Admonition type="info" title="Info">
Streaming query results does not support the includes feature.  
Learn more in [How to Stream Query Results](../../client-api/session/querying/how-to-stream-query-results#stream-related-documents).  
</Admonition>
### One to many includes

Include can be used with a many to one relationship.
In the above classes, an `Order` has a property `supplierIds` which contains an array of references to `Supplier` documents.
The following code will cause the suppliers to be pre-loaded:

<TabItem value="something-something" label="includes_4_0">
<CodeBlock language="nodejs">
{`const order = await session
    .include("supplierIds")
    .load("orders/1-A");

for (let i = 0; i < order.supplierIds.length; i++) \{
    // This will not require querying the server
    const supplier = await session.load(order.supplierIds[i]);
\}
`}
</CodeBlock>
</TabItem>

Alternatively, it is possible to use the fluent builder syntax.

<TabItem value="something-something" label="includes_4_0_builder">
<CodeBlock language="nodejs">
{`const order = await session
    .load("orders/1-A", \{
        includes: i => i.includeDocuments("supplierIds")
    \});

for (let i = 0; i < order.supplierIds.length; i++) \{
    // This will not require querying the server
    const supplier = await session.load(order.supplierIds[i]);
\}
`}
</CodeBlock>
</TabItem>

The calls to `load()` within the `for` loop will not require a call to the server as the `Supplier` objects will already be loaded into the session cache.

Multi-loads are also possible:

<TabItem value="something-something" label="includes_5_0">
<CodeBlock language="nodejs">
{`const orders = await session
    .include("supplierIds")
    .load(["orders/1-A", "orders/2-A"]);

const orderEntities = Object.entries(orders);

for (let i = 0; i < orderEntities.length; i++) \{
    const suppliers = orderEntities[i][1].supplierIds;
    
    for (let j = 0; j < suppliers.length; j++) \{
        // This will not require querying the server
        const supplier = await session.load(suppliers[j]);
    \}
\}
`}
</CodeBlock>
</TabItem>
### Secondary level includes

An Include does not need to work only on the value of a top level property within a document.
It can be used to load a value from a secondary level.
In the classes above, the `Order` contains a `referral` property which is of the type:

<TabItem value="something-something" label="referral">
<CodeBlock language="nodejs">
{`class Referral \{
    constructor(
        customerId = '',
        commissionPercentage = 0
    ) \{
        Object.assign(this, \{
            customerId,
            commissionPercentage
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

This class contains an identifier for a `Customer`.  
The following code will include the document referenced by that secondary level identifier:

<TabItem value="something-something" label="includes_6_0">
<CodeBlock language="nodejs">
{`const order = await session
    .include("referral.customerId")
    .load("orders/1-A");

// This will not require querying the server
const customer = await session.load(order.referral.customerId);
`}
</CodeBlock>
</TabItem>

It is possible to execute the same code with the fluent builder syntax:

<TabItem value="something-something" label="includes_6_0_builder">
<CodeBlock language="nodejs">
{`const order = await session
    .load("orders/1-A", \{
        includes: i => i.includeDocuments("referral.customerId")
    \});

// This will not require querying the server
const customer = await session.load(order.referral.customerId);
`}
</CodeBlock>
</TabItem>

This secondary level include will also work with collections.  
The `lineItems` property holds a collection of `LineItem` objects which each contain a reference to a `Product`:

<TabItem value="something-something" label="line_item">
<CodeBlock language="nodejs">
{`class LineItem \{
    constructor(
        productId = '',
        name = '',
        quantity = 0
    ) \{
        Object.assign(this, \{
            productId,
            name,
            quantity
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

The `Product` documents can be included using the following syntax:

<TabItem value="something-something" label="includes_7_0">
<CodeBlock language="nodejs">
{`const order = await session
    .include("lineItems[].productId")
    .load("orders/1-A");

for (let i = 0; i < order.lineItems.length; i++) \{
    // This will not require querying the server
    const product = await session.load(order.lineItems[i].productId);
\}
`}
</CodeBlock>
</TabItem>

The fluent builder syntax works here too.

<TabItem value="something-something" label="includes_7_0_builder">
<CodeBlock language="nodejs">
{`const order = await session
    .load("orders/1-A", \{
        includes: i => i.includeDocuments("lineItems[].productId")
    \});

for (let i = 0; i < order.lineItems.length; i++) \{
    // This will not require querying the server
    const product = await session.load(order.lineItems[i].productId);
\}
`}
</CodeBlock>
</TabItem>

<Admonition type="warning" title="Warning">
### String path conventions

When using string-based includes like:

<TabItem value="something-something" label="includes_6_0">
<CodeBlock language="nodejs">
{`const order = await session
    .include("referral.customerId")
    .load("orders/1-A");

// This will not require querying the server
const customer = await session.load(order.referral.customerId);
`}
</CodeBlock>
</TabItem>

you must remember to follow certain rules that must apply to the provided string path:

1.	**Dots** are used to separate properties
    e.g. `"referral.customerId"` in the example above means that our `Order` contains property `referral` and that property contains another property called `customerId`.

2. **Indexer operator** is used to indicate that property is a collection type.
    So if our `Order` has a list of LineItems and each `lineItem` contains a `productId` property, then we can create string path as follows: `"lineItems[].productId"`.

3. **Prefixes** can be used to indicate the prefix of the identifier of the document that is going to be included.
    It can be useful when working with custom or semantic identifiers.
    For example, if you have a customer stored under `customers/login@domain.com` then you can include it using `"referral.customerEmail(customers/)"` (`customers/` is the prefix here).

Learning string path rules may be useful when you will want to query database using HTTP API.

<TabItem value="something" label="json">
<CodeBlock language="json">
{`curl -X GET "http://localhost:8080/databases/Northwind/docs?id=orders/1-A&include=Lines[].Product"
`}
</CodeBlock>
</TabItem>

</Admonition>
### Dictionary includes

Dictionary keys and values can also be used when doing includes. Consider following scenario:

<TabItem value="something-something" label="person_1">
<CodeBlock language="nodejs">
{`class Person \{
    constructor(
        id = '',
        name = '',
        // attributes will be assigned a plain object containing key-value pairs
        attributes = \{\}
    ) \{
        Object.assign(this, \{
            id,
            name,
            attributes
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something-something" label="includes_10_0">
<CodeBlock language="nodejs">
{`const person1 = new Person();
person1.name = "John Doe";
person1.id = "people/1";
person1.attributes = \{
    "mother": "people/2",
    "father": "people/3"
\}

const person2 = new Person();
person2.name = "Helen Doe";
person2.id = "people/2";

const person3 = new Person();
person3.name = "George Doe";
person3.id = "people/3";

await session.store(person1);
await session.store(person2);
await session.store(person3);

await session.saveChanges();
`}
</CodeBlock>
</TabItem>

Now we want to include all documents that are under dictionary values:

<TabItem value="something-something" label="includes_10_1">
<CodeBlock language="nodejs">
{`const person = await session
    .include("attributes.$Values")
    .load("people/1");

const mother = await session
    .load(person.attributes["mother"]);

const father = await session
    .load(person.attributes["father"]);

assert.equal(session.advanced.numberOfRequests, 1);
`}
</CodeBlock>
</TabItem>

The code above can be also rewritten with fluent builder syntax:

<TabItem value="something-something" label="includes_10_1_builder">
<CodeBlock language="nodejs">
{`const person = await session
    .load("people/1", \{
        includes: i => i.includeDocuments("attributes.$Values")
    \});

const mother = await session
    .load(person.attributes["mother"]);

const father = await session
    .load(person.attributes["father"]);

assert.equal(session.advanced.numberOfRequests, 1);
`}
</CodeBlock>
</TabItem>

You can also include values from dictionary keys:

<TabItem value="something-something" label="includes_10_3">
<CodeBlock language="nodejs">
{`const person = await session
    .include("attributes.$Keys")
    .load("people/1");
`}
</CodeBlock>
</TabItem>

Here, as well, this can be written with fluent builder syntax:

<TabItem value="something-something" label="includes_10_3_builder">
<CodeBlock language="nodejs">
{`const person = await session
    .load("people/1", \{
        includes: i => i.includeDocuments("attributes.$Keys")
    \});
`}
</CodeBlock>
</TabItem>
### Dictionary includes: complex types

If values in dictionary are more complex, e.g.

<TabItem value="something-something" label="person_2">
<CodeBlock language="nodejs">
{`class PersonWithAttribute \{
    constructor(
        id = '',
        name = '',
        // attributes will be assigned a complex object
        attributes = \{\}
    ) \{
        Object.assign(this, \{
            id,
            name,
            attributes
        \});
    \}
\}

class Attribute \{
    constructor(
        ref = ''
    ) \{
        Object.assign(this, \{
            ref
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="something-something" label="includes_11_0">
<CodeBlock language="nodejs">
{`const attr2 = new Attribute();
attr2.ref = "people/2";
const attr3 = new Attribute();
attr3.ref = "people/3";

const person1 = new PersonWithAttribute();
person1.name = "John Doe";
person1.id = "people/1";
person1.attributes = \{
    "mother": attr2,
    "father": attr3
\}

const person2 = new Person();
person2.name = "Helen Doe";
person2.id = "people/2";

const person3 = new Person();
person3.name = "George Doe";
person3.id = "people/3";

await session.store(person1);
await session.store(person2);
await session.store(person3);

await session.saveChanges();
`}
</CodeBlock>
</TabItem>

We can also do includes on specific properties:

<TabItem value="something-something" label="includes_11_1">
<CodeBlock language="nodejs">
{`const person = await session
    .include("attributes.$Values[].ref")
    .load("people/1");

const mother = await session
    .load(person.attributes["mother"].ref);

const father = await session
    .load(person.attributes["father"].ref);

assert.equal(session.advanced.numberOfRequests, 1);
`}
</CodeBlock>
</TabItem>



## Combining approaches

It is possible to combine the above techniques.  
Using the `DenormalizedCustomer` from above and creating an order that uses it:

<TabItem value="something-something" label="order_2">
<CodeBlock language="nodejs">
{`class Order2 \{
    constructor(
        customer = \{\},
        supplierIds = '',
        referral = null,
        lineItems = [],
        totalPrice = 0
    ) \{
        Object.assign(this, \{
            customer,
            supplierIds,
            referral,
            lineItems,
            totalPrice
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

We have the advantages of a denormalization, a quick and simple load of an `Order`,
and the fairly static `Customer` details that are required for most processing.
But we also have the ability to easily and efficiently load the full `Customer` object when necessary using:

<TabItem value="something-something" label="includes_9_0">
<CodeBlock language="nodejs">
{`const order = await session
    .include("customer.id")
    .load("orders/1-A");

// This will not require querying the server
const customer = await session.load(order.customer.id);
`}
</CodeBlock>
</TabItem>

This combining of denormalization and Includes could also be used with a list of denormalized objects.

It is possible to use Include on a query being a projection.
Includes are evaluated after the projection has been evaluated.
This opens up the possibility of implementing Tertiary Includes (i.e. retrieving documents that are referenced by documents that are referenced by the root document). 

RavenDB can support Tertiary Includes, but before resorting to them you should re-evaluate your document model.
Needing Tertiary Includes can be an indication that you are designing your documents along "Relational" lines.



## Summary

There are no strict rules as to when to use which approach, but the general idea is to give it a lot of thought and consider the implications each approach has.

As an example, in an e-commerce application it might be better to denormalize product names and prices into an order line object
since you want to make sure the customer sees the same price and product title in the order history.
But the customer name and addresses should probably be references rather than denormalized into the order entity.

For most cases where denormalization is not an option, Includes are probably the answer.




</LanguageContent>

<!---
### Client API
- [Include Compare Exchange Values](../../client-api/operations/compare-exchange/include-compare-exchange)

### Indexes
- [Indexing Basics](../../indexes/indexing-basics)
- [Indexing Related Documents](../../indexes/indexing-related-documents)

### Querying
- [Query Overview](../../client-api/session/querying/how-to-query)
- [Querying an Index](../../indexes/querying/query-index)

### Document Extensions
- [Include Time Series](../../document-extensions/timeseries/client-api/session/include/overview)
- [Including Counters](../../document-extensions/counters/counters-and-other-features#including-counters)


-->