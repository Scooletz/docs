---
title: "Indexing Spatial Data"
sidebar_label: Indexing Spatial Data
sidebar_position: 15
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/language-switcher";
import LanguageContent from "@site/src/components/language-content";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Indexing Spatial Data
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Documents that contain spatial data can be queried by spatial queries that employ geographical criteria.  
  There are two options: **dynamic** spatial query, and spatial **index** query.  

  * **Dynamic spatial query**  
    A dynamic spatial query can be made on a collection (see [how to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query)).  
    An auto-index will be created by the server.  
  
  * **Spatial index query**  
    Documents' spatial data can be indexed in a static index (**described in this article**),  
    and a spatial query can then be executed over this index (see [query a spatial index](../indexes/querying/spatial)).  

* In this page:
  * [Create index with spatial field](../indexes/indexing-spatial-data#create-index-with-spatial-field)
  * [Customize coordinate system and strategy](../indexes/indexing-spatial-data#customize-coordinate-system-and-strategy)
  * [Spatial indexing strategies](../indexes/indexing-spatial-data#spatial-indexing-strategies)

</Admonition>
## Create index with spatial field

* Use `CreateSpatialField` to index spatial data in a static-index.

* You can then retrieve documents based on geographical criteria when making a spatial query on this index-field.

* A spatial index can also be defined from [Studio](../studio/database/indexes/create-map-index#spatial-field-options). 

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Indexing_coordinates" label="Indexing_coordinates">
<CodeBlock language="csharp">
{`// Define an index with a spatial field
public class Events_ByNameAndCoordinates : AbstractIndexCreationTask<Event>
{
    public Events_ByNameAndCoordinates()
    {
        Map = events => from e in events
            select new
            {
                Name = e.Name,
                // Call 'CreateSpatialField' to create a spatial index-field
                // Field 'Coordinates' will be composed of lat & lng supplied from the document
                Coordinates = CreateSpatialField(e.Latitude, e.Longitude)
                
                // Documents can be retrieved
                // by making a spatial query on the 'Coordinates' index-field
            };
    }
}

public class Event
{
    public string Id { get; set; }
    public string Name { get; set; }
    public double Latitude { get; set; }
    public double Longitude { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Indexing_WKT" label="Indexing_WKT">
<CodeBlock language="csharp">
{`// Define an index with a spatial field
public class EventsWithWKT_ByNameAndWKT : AbstractIndexCreationTask<EventWithWKT>
{
    public EventsWithWKT_ByNameAndWKT()
    {
        Map = events => from e in events
            select new
            {
                Name = e.Name,
                // Call 'CreateSpatialField' to create a spatial index-field
                // Field 'WKT' will be composed of the WKT string supplied from the document
                WKT = CreateSpatialField(e.WKT)

                // Documents can be retrieved
                // by making a spatial query on the 'WKT' index-field
            };
    }
}

public class EventWithWKT
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string WKT { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="csharp">
{`public class Events_ByNameAndCoordinates_JS : AbstractJavaScriptIndexCreationTask
{
    public Events_ByNameAndCoordinates_JS()
    {
        Maps = new HashSet<string>
        {
            @"map('events', function (e) {
                    return { 
                        Name: e.Name,
                        Coordinates: createSpatialField(e.Latitude, e.Longitude)
                    };
            })"
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="something" label="spatial_syntax_1">
<CodeBlock language="csharp">
{`object CreateSpatialField(double? lat, double? lng); // Latitude/Longitude coordinates
object CreateSpatialField(string shapeWkt);          // Shape in WKT string format
`}
</CodeBlock>
</TabItem>



## Customize coordinate system and strategy

* For each spatial index-field, you can specify the **coordinate system** and **strategy** to be used  
  during indexing and when processing the data at query time.

* RavenDB supports both the `Geography` and `Cartesian` systems with the following strategies:

  * Geography system:
      * BoundingBox
      * GeoHashPrefixTree
      * QuadPrefixTree

  * Cartesian system:
      * BoundingBox
      * QuadPrefixTree

* **By default**, the `GeoHashPrefixTree` strategy is used with `GeoHashLevel` set to **9**.  
  Use the `Spatial` method from `AbstractIndexCreationTask` to modify this setting.

* The performance cost of spatial indexing is directly related to the tree level chosen.  
  Learn more about each strategy [below](../indexes/indexing-spatial-data#spatial-indexing-strategies).

* Note: Modifying the strategy after the index has been created & deployed will trigger the re-indexing.

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Events_ByNameAndCoordinates_Custom : AbstractIndexCreationTask<Event>
{
    public Events_ByNameAndCoordinates_Custom()
    {
        Map = events => from e in events
                        select new
                        {
                            Name = e.Name,
                            // Define a spatial index-field
                            Coordinates = CreateSpatialField(e.Latitude, e.Longitude)
                        };

        // Set the spatial indexing strategy for the spatial field 'Coordinates' 
        Spatial("Coordinates", factory => factory.Cartesian.BoundingBoxIndex());
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="csharp">
{`public class Events_ByNameAndCoordinates_Custom_JS : AbstractJavaScriptIndexCreationTask
{
    public Events_ByNameAndCoordinates_Custom_JS()
    {
        // Define index fields
        Maps = new HashSet<string>
        {
            @"map('events', function (e) {
                    return { 
                        Name: e.Name,
                        Coordinates: createSpatialField(e.Latitude, e.Longitude)
                    };
            })"
        };
        
        // Customize index fields
        Fields = new Dictionary<string, IndexFieldOptions>
        {
            ["Coordinates"] = new IndexFieldOptions
            {
                Spatial = new SpatialOptions
                {
                    Type = SpatialFieldType.Cartesian,
                    Strategy = SpatialSearchStrategy.BoundingBox
                }
            }
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="something" label="spatial_syntax_2">
<CodeBlock language="csharp">
{`public class SpatialOptionsFactory
\{
    public GeographySpatialOptionsFactory Geography;
    public CartesianSpatialOptionsFactory Cartesian;
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="csharp">
{`// Default is GeohashPrefixTree strategy with maxTreeLevel set to 9
SpatialOptions Default(SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);

SpatialOptions BoundingBoxIndex(SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);

SpatialOptions GeohashPrefixTreeIndex(int maxTreeLevel,
    SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);

SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel,
    SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="csharp">
{`SpatialOptions BoundingBoxIndex();
SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel, SpatialBounds bounds);

public class SpatialBounds
{
    public double MinX;
    public double MaxX;
    public double MinY;
    public double MaxY;
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Spatial indexing strategies

#### BoundingBox strategy

* The bounding box strategy is the simplest.  
  Given a spatial shape, such as a point, circle, or polygon, the shape's bounding box is computed  
  and the spatial coordinates (minX, minY, maxX, maxY) that enclose the shape are indexed.

* When making a query,  
  RavenDB translates the query criteria to the same bounding box system used for indexing. 

* Bounding box strategy is cheaper at indexing time and can produce quick queries,  
  but that's at the expense of the level of accuracy you can get.  

* Read more about bounding box [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).
#### GeoHashPrefixTree strategy

* Geohash is a latitude/longitude representation system that describes Earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. 
  Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

* E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) 
  and it represents the `40.7144 -74.0060` coordinates. 
  Removing characters from the end of the geohash will decrease the precision level.

* The `maxTreeLevel` determines the length of the geohash used for the indexing, which in turn affects accuracy.  
  By default, it is set to **9**, providing a resolution of approximately 2.5 meters.

* More information about geohash uses, decoding algorithm, and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).

<Admonition type="note" title="Geohash precision values:" id="geohash-precision-values" href="#geohash-precision-values">

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |

</Admonition>
#### QuadPrefixTree strategy

* The QuadTree represents Earth as a grid consisting of four cells (also known as buckets).
  Similar to GeoHash, each cell is assigned a letter, and is recursively divided into four more cells, creating a hierarchical structure. 

* By default, the precision level (`maxTreeLevel`) for QuadPrefixTree is **23**.

* More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).

<Admonition type="note" title="Quadtree precision values:" id="quadtree-precision-values" href="#quadtree-precision-values">

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |

</Admonition>



## Remarks

<Admonition type="info" title="Info">

Distance is measured by default in **kilometers**.

</Admonition>


</LanguageContent>
<LanguageContent language="java">


To support the ability to retrieve the data based on spatial coordinates, the spatial search has been introduced.

<Admonition type="info" title="Info">
This article describes how to setup a spatial field in static index. If you are interested in an automatic approach, please visit relevant spatial querying article that can be found [here](../indexes/querying/spatial).
</Admonition>

## Creating Indexes

To take an advantage of the spatial search, first we need to create an index with a spatial field. To mark field as the spatial field, we need to use the `CreateSpatialField` method:

<TabItem value="something-something" label="spatial_search_0">
<CodeBlock language="java">
{`object CreateSpatialField(double? lat, double? lng);

object CreateSpatialField(string shapeWkt);
`}
</CodeBlock>
</TabItem>

Where:   
     
*	**lat/lng** are latitude/longitude coordinates   
*	**shapeWKT** is a shape in the [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) format    

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Coordinates" label="Coordinates">
<CodeBlock language="java">
{`public static class Event {
    private String id;
    private String name;
    private double latitude;
    private double longitude;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getLatitude() {
        return latitude;
    }

    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }
}

public static class Events_ByNameAndCoordinates extends AbstractIndexCreationTask {
    public Events_ByNameAndCoordinates() {
        map = "docs.Events.Select(e => new { " +
            "    name = e.name, " +
            "    coordinates = this.CreateSpatialField(((double ? ) e.latitude), ((double ? ) e.longitude)) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="WKT" label="WKT">
<CodeBlock language="java">
{`public static class EventWithWKT {
    private String id;
    private String name;
    private String wkt;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getWkt() {
        return wkt;
    }

    public void setWkt(String wkt) {
        this.wkt = wkt;
    }
}

public static class EventsWithWKT_ByNameAndWKT extends AbstractIndexCreationTask {
    public EventsWithWKT_ByNameAndWKT() {
        map = "docs.EventWithWKTs.Select(e => new { " +
            "    name = e.name, " +
            "    wkt = this.CreateSpatialField(e.wkt) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Events_ByNameAndCoordinates extends AbstractJavaScriptIndexCreationTask {
    public Events_ByNameAndCoordinates() {
        setMaps(Sets.newHashSet("map('events', function (e){\\n" +
            "    return {\\n" +
            "        name: e.name  ,\\n" +
            "        coordinates: createSpatialField(e.latitude, e.longitude)\\n" +
            "    };\\n" +
            "})"));
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Options

RavenDB supports both the `Geography` and `Cartesian` systems and multiple strategies for each one of them.

<TabItem value="something-something" label="spatial_search_enhancements_3">
<CodeBlock language="java">
{`public static class SpatialOptionsFactory \{
    public GeographySpatialOptionsFactory geography()

    public CartesianSpatialOptionsFactory cartesian()
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="java">
{`public SpatialOptions defaultOptions()

public SpatialOptions defaultOptions(SpatialUnits circleRadiusUnits)

public SpatialOptions boundingBoxIndex()

public SpatialOptions boundingBoxIndex(SpatialUnits circleRadiusUnits)

public SpatialOptions geohashPrefixTreeIndex(int maxTreeLevel)

public SpatialOptions geohashPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits)

public SpatialOptions quadPrefixTreeIndex(int maxTreeLevel)

public SpatialOptions quadPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits)
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="java">
{`public SpatialOptions boundingBoxIndex()

public SpatialOptions quadPrefixTreeIndex(int maxTreeLevel, SpatialBounds bounds)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Changing Default Behavior

By default, if no action is taken, the `GeohashPrefixTree` strategy is used with `GeohashLevel` set to **9**. This behavior can be changed by using the `spatial()` method from `AbstractIndexCreationTask`

<TabItem value="something-something" label="spatial_search_3">
<CodeBlock language="java">
{`public static class Events_ByNameAndCoordinates_Custom extends AbstractIndexCreationTask \{
    public Events_ByNameAndCoordinates_Custom() \{
        map = "docs.Events.Select(e => new \{ " +
            "    name = e.name, " +
            "    coordinates = this.CreateSpatialField(((double ? ) e.latitude), ((double ? ) e.longitude)) " +
            "\})";

        spatial("coordinates", f -> f.cartesian().boundingBoxIndex());
    \}
\}
`}
</CodeBlock>
</TabItem>

## Spatial search strategies

## GeohashPrefixTree
Geohash is a latitude/longitude representation system that describes earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) and it represents the `40.7144 -74.0060` coordinates. Removing characters from the end of geohash will decrease the precision level.

More information about geohash uses, decoding algorithm and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).


## QuadPrefixTree
QuadTree represents the earth as a grid with exactly four cells and similarly to geohash, each grid cell (sometimes called a bucket) has a letter assigned, and is divided further into 4 more cells and so on.

More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).


## BoundingBox
More information about BoundingBox can be found [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).


<Admonition type="warning" title="Warning">
`GeohashPrefixTree` is a default `SpatialSearchStrategy`. Doing any changes to the strategy after an index has been created will trigger the re-indexation process.
</Admonition>

### Precision

By default, the precision level (`maxTreeLevel`) for GeohashPrefixTree is set to **9** and for QuadPrefixTree the value is **23**. This means that the coordinates are represented by a 9 or 23 character string. The difference exists because the `QuadTree` representation would be much less precise if the level would be the same.

## Geohash precision values
Source: unterbahn.com

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |



## Quadtree precision values

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |



## Remarks

<Admonition type="info" title="Info">
You can read more about **spatial search** in a **dedicated querying article** available [here](../indexes/querying/spatial).
</Admonition>

<Admonition type="warning" title="Warning">
Distance by default is measured in **kilometers**.
</Admonition>


</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* Documents that contain spatial data can be queried by spatial queries that employ geographical criteria.  
  There are two options: **dynamic** spatial query, and spatial **index** query.  

  * **Dynamic spatial query**  
    A dynamic spatial query can be made on a collection (see [how to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query)).  
    An auto-index will be created by the server.  
  
  * **Spatial index query**  
    Documents' spatial data can be indexed in a static index (**described in this article**),  
    and a spatial query can then be executed over this index (see [query a spatial index](../indexes/querying/spatial)).  

* In this page:
  * [Create index with spatial field](../indexes/indexing-spatial-data#create-index-with-spatial-field)
  * [Customize coordinate system and strategy](../indexes/indexing-spatial-data#customize-coordinate-system-and-strategy)
  * [Spatial indexing strategies](../indexes/indexing-spatial-data#spatial-indexing-strategies)

</Admonition>
## Create index with spatial field

* Use `CreateSpatialField` to index spatial data in a static-index.

* You can then retrieve documents based on geographical criteria when making a spatial query on this index-field.

* A spatial index can also be defined from [Studio](../studio/database/indexes/create-map-index#spatial-field-options). 

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Indexing_coordinates" label="Indexing_coordinates">
<CodeBlock language="python">
{`# Define an index with a spatial field
class Events_ByNameAndCoordinates(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        # Call 'CreateSpatialField' to create a spatial index-field
        # Field 'coordinates' will be composed of lat & lng supplied from the document
        self.map = (
            "from e in docs.Events select new {"
            "    name = e.name,"
            "    coordinates = CreateSpatialField(e.latitude, e.longitude)"
            "}"
        )
        # Documents can be retrieved
        # by making a spatial query on the 'coordinates' index-field


class Event:
    def __init__(self, Id: str = None, name: str = None, latitude: float = None, longitude: float = None):
        self.Id = Id
        self.name = name
        self.latitude = latitude
        self.longitude = longitude
`}
</CodeBlock>
</TabItem>
<TabItem value="Indexing_WKT" label="Indexing_WKT">
<CodeBlock language="python">
{`# Define an index with a spatial field
class EventsWithWKT_ByNameAndWKT(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from e in docs.Events select new {" "    name = e.name," "    WKT = CreateSpatialField(e.WKT)" "}"


class EventWithWKT:
    def __init__(self, Id: str = None, name: str = None, WKT: str = None):
        self.Id = Id
        self.name = name
        self.WKT = WKT
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="python">
{`class Events_ByNameAndCoordinates_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            """
            map('events', function (e) {
                    return { 
                        name: e.name,
                        coordinates: createSpatialField(e.latitude, e.longitude)
                    };
            })
            """
        }
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="something-something" label="spatial_syntax_1">
<CodeBlock language="python">
{`class DynamicSpatialField(ABC):
    def __init__(self, round_factor: float = 0): ...
class PointField(DynamicSpatialField):  # Latitude/Longitude coordinates
    def __init__(self, latitude: str, longitude: str): ...


class WktField(DynamicSpatialField):  # Shape in WKT string format
    def __init__(self, wkt: str): ...
`}
</CodeBlock>
</TabItem>



## Customize coordinate system and strategy

* For each spatial index-field, you can specify the **coordinate system** and **strategy** to be used  
  during indexing and when processing the data at query time.

* RavenDB supports both the **Geography** and **Cartesian** systems with the following strategies:

  * Geography system:
      * `bounding_box_index`
      * `geohash_prefix_tree_index`
      * `quad_prefix_tree_index`

  * Cartesian system:
      * `bounding_box_index`
      * `quad_prefix_tree_index`

* **By default**, the `geohash_prefix_tree_index` strategy is used with `geohash_level` set to **9**.  

* The performance cost of spatial indexing is directly related to the tree level chosen.  
  Learn more about each strategy [below](../indexes/indexing-spatial-data#spatial-indexing-strategies).

* Note: Modifying the strategy after the index has been created & deployed will trigger the re-indexing.

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Events_ByNameAndCoordinates_Custom(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from e in docs.Events select new { name = e.name, coordinates = CreateSpatialField(e.latitude, e.longitude)}"

        # Set the spatial indexing strategy for the spatial field 'coordinates'
        self._spatial("coordinates", lambda factory: factory.cartesian.bounding_box_index())
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="python">
{`class Event_ByNameAndCoordinates_Custom_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = """
        map('events', function (e) {
                return { 
                    Name: e.Name,
                    Coordinates: createSpatialField(e.Latitude, e.Longitude)
                };
        })
        """

        # Customize index fields
        self.fields = {
            "coordinates": IndexFieldOptions(
                spatial=SpatialOptions(
                    field_type=SpatialFieldType.CARTESIAN, strategy=SpatialSearchStrategy.BOUNDING_BOX
                )
            )
        }
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="something-something" label="spatial_syntax_2">
<CodeBlock language="python">
{`class SpatialOptionsFactory:
    def geography(self) -> GeographySpatialOptionsFactory:
        return SpatialOptionsFactory.GeographySpatialOptionsFactory()

    def cartesian(self) -> CartesianSpatialOptionsFactory:
        return SpatialOptionsFactory.CartesianSpatialOptionsFactory()
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="python">
{`# Default is GeohashPrefixTree strategy with max_tree_level set to 9
def default_option(self, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS) -> SpatialOptions: ...

def bounding_box_index(self, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS) -> SpatialOptions: ...
def geohash_prefix_tree_index(
    self, max_tree_level: int, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS
) -> SpatialOptions: ...
def quad_prefix_tree_index(
    self, max_tree_level: int, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS
) -> SpatialOptions: ...
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="python">
{`def bounding_box_index(self) -> SpatialOptions: ...
def quad_prefix_tree_index(
    self, max_tree_level: int, bounds: SpatialOptionsFactory.SpatialBounds
) -> SpatialOptions: ...

class SpatialBounds:
    def __init__(self, min_x: float, min_y: float, max_x: float, max_y: float): ...
`}
</CodeBlock>
</TabItem>
</Tabs>



## Spatial indexing strategies

#### BoundingBox strategy

* The bounding box strategy is the simplest.  
  Given a spatial shape, such as a point, circle, or polygon, the shape's bounding box is computed  
  and the spatial coordinates (minX, minY, maxX, maxY) that enclose the shape are indexed.

* When making a query,  
  RavenDB translates the query criteria to the same bounding box system used for indexing. 

* Bounding box strategy is cheaper at indexing time and can produce quick queries,  
  but that's at the expense of the level of accuracy you can get.  

* Read more about bounding box [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).
#### GeoHashPrefixTree strategy

* Geohash is a latitude/longitude representation system that describes Earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. 
  Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

* E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) 
  and it represents the `40.7144 -74.0060` coordinates. 
  Removing characters from the end of the geohash will decrease the precision level.

* The `max_tree_level` determines the length of the geohash used for the indexing, which in turn affects accuracy.  
  By default, it is set to **9**, providing a resolution of approximately 2.5 meters.

* More information about geohash uses, decoding algorithm, and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).

<Admonition type="note" title="Geohash precision values:" id="geohash-precision-values" href="#geohash-precision-values">

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |

</Admonition>
#### QuadPrefixTree strategy

* The QuadTree represents Earth as a grid consisting of four cells (also known as buckets).
  Similar to GeoHash, each cell is assigned a letter, and is recursively divided into four more cells, creating a hierarchical structure. 

* By default, the precision level (`max_tree_level`) for QuadPrefixTree is **23**.

* More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).

<Admonition type="note" title="Quadtree precision values:" id="quadtree-precision-values" href="#quadtree-precision-values">

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |

</Admonition>



## Remarks

<Admonition type="info" title="Info">

Distance is measured by default in `KILOMETERS`.

</Admonition>


</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* Documents that contain spatial data can be queried by spatial queries that employ geographical criteria.  
  There are two options: **dynamic** spatial query, and spatial **index** query.  

  * **Dynamic spatial query**  
    A dynamic spatial query can be made on a collection (see [how to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query)).  
    An auto-index will be created by the server.  
  
  * **Spatial index query**  
    Documents' spatial data can be indexed in a static index (**described in this article**),  
    and a spatial query can then be executed over this index (see [query a spatial index](../indexes/querying/spatial)).  

* In this page:
  * [Create index with spatial field](../indexes/indexing-spatial-data#create-index-with-spatial-field)
  * [Customize coordinate system and strategy](../indexes/indexing-spatial-data#customize-coordinate-system-and-strategy)
  * [Spatial indexing strategies](../indexes/indexing-spatial-data#spatial-indexing-strategies)

</Admonition>
## Create index with spatial field

* Use `CreateSpatialField` to index spatial data in a static-index.

* You can then retrieve documents based on geographical criteria when making a spatial query on this index-field.

* A spatial index can also be defined from [Studio](../studio/database/indexes/create-map-index#spatial-field-options). 

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Indexing_coordinates" label="Indexing_coordinates">
<CodeBlock language="php">
{`class Event
{
    private ?string $id = null;
    private ?string $name = null;
    private ?float $latitude = null;
    private ?float $longitude = null;

    public function getId(): ?string
    {
        return $this->id;
    }

    public function setId(?string $id): void
    {
        $this->id = $id;
    }

    public function getName(): ?string
    {
        return $this->name;
    }

    public function setName(?string $name): void
    {
        $this->name = $name;
    }

    public function getLatitude(): ?float
    {
        return $this->latitude;
    }

    public function setLatitude(?float $latitude): void
    {
        $this->latitude = $latitude;
    }

    public function getLongitude(): ?float
    {
        return $this->longitude;
    }

    public function setLongitude(?float $longitude): void
    {
        $this->longitude = $longitude;
    }
}

class Events_ByNameAndCoordinates extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.Events.Select(e => new { " .
            "    name = e.name, " .
            "    coordinates = this.CreateSpatialField(((double ? ) e.latitude), ((double ? ) e.longitude)) " .
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Indexing_WKT" label="Indexing_WKT">
<CodeBlock language="php">
{`class EventWithWKT {
    private ?string $id = null;
    private ?string $name = null;
    private ?string $wkt = null;

    public function getId(): ?string
    {
        return $this->id;
    }

    public function setId(?string $id): void
    {
        $this->id = $id;
    }

    public function getName(): ?string
    {
        return $this->name;
    }

    public function setName(?string $name): void
    {
        $this->name = $name;
    }

    public function getWkt(): ?string
    {
        return $this->wkt;
    }

    public function setWkt(?string $wkt): void
    {
        $this->wkt = $wkt;
    }
}

class EventsWithWKT_ByNameAndWKT extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.EventWithWKTs.Select(e => new { " .
            "    name = e.name, " .
            "    wkt = this.CreateSpatialField(e.wkt) " .
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="php">
{`class Events_ByNameAndCoordinates_JS extends AbstractJavaScriptIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->setMaps([
            "map('events', function (e) {
                        return { 
                            Name: e.Name,
                            Coordinates: createSpatialField(e.Latitude, e.Longitude)
                        };
                })"
        ]);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="something-something" label="spatial_syntax_1">
<CodeBlock language="php">
{`object CreateSpatialField(double? lat, double? lng); // Latitude/Longitude coordinates
object CreateSpatialField(string shapeWkt);          // Shape in WKT string format
`}
</CodeBlock>
</TabItem>



## Customize coordinate system and strategy

* For each spatial index-field, you can specify the **coordinate system** and **strategy** to be used  
  during indexing and when processing the data at query time.

* RavenDB supports both the **Geography** and **Cartesian** systems with the following strategies:

  * Geography system:
      * `boundingBoxIndex`
      * `geohashPrefixTreeIndex`
      * `quadPrefixTreeIndex`

  * Cartesian system:
      * `boundingBoxIndex`
      * `quadPrefixTreeIndex`

* **By default**, the `geohashPrefixTreeIndex` strategy is used with `geohashLevel` set to **9**.  

* The performance cost of spatial indexing is directly related to the tree level chosen.  
  Learn more about each strategy [below](../indexes/indexing-spatial-data#spatial-indexing-strategies).

* Note: Modifying the strategy after the index has been created & deployed will trigger the re-indexing.

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Events_ByNameAndCoordinates_Custom extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.Events.Select(e => new { " .
            "    name = e.name, " .
            "    coordinates = this.CreateSpatialField(((double ? ) e.latitude), ((double ? ) e.longitude)) " .
            "})";

        $this->spatial("coordinates", function($factory) { return $factory->cartesian()->boundingBoxIndex(); });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="php">
{`class Events_ByNameAndCoordinates_Custom_JS extends AbstractJavaScriptIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        // Define index fields
        $this->setMaps([
            "map('events', function (e) {
                    return { 
                        Name: e.Name,
                        Coordinates: createSpatialField(e.Latitude, e.Longitude)
                    };
            })"
        ]);


        // Customize index fields
        $options = new IndexFieldOptions();

        $spatialOptions = new SpatialOptions();
        $spatialOptions->setType(SpatialFieldType::cartesian());
        $spatialOptions->setStrategy(SpatialSearchStrategy::boundingBox());
        $options->setSpatial($spatialOptions);

        $this->setFields([
            "Coordinates" => $options
        ]);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="something-something" label="spatial_syntax_2">
<CodeBlock language="php">
{`class SpatialOptionsFactory
\{
    public function geography(): GeographySpatialOptionsFactory
    \{
        return new GeographySpatialOptionsFactory();
    \}

    public function cartesian(): CartesianSpatialOptionsFactory
    \{
        return new CartesianSpatialOptionsFactory();
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="php">
{`interface GeographySpatialOptionsFactory
{
    // if $circleRadiusUnits is not set SpatialUnits::kilometers() will be used

    // Default is GeohashPrefixTree strategy with maxTreeLevel set to 9
    public function defaultOptions(?SpatialUnits $circleRadiusUnits = null): SpatialOptions;

    public function boundingBoxIndex(?SpatialUnits $circleRadiusUnits = null): SpatialOptions;

    public function geohashPrefixTreeIndex(int $maxTreeLevel, ?SpatialUnits $circleRadiusUnits = null): SpatialOptions;

    public function quadPrefixTreeIndex(int $maxTreeLevel, ?SpatialUnits $circleRadiusUnits = null): SpatialOptions;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="php">
{`interface CartesianSpatialOptionsFactory
{
    public function boundingBoxIndex(): SpatialOptions;
    public function quadPrefixTreeIndex(int $maxTreeLevel, SpatialBounds $bounds): SpatialOptions;
}

class SpatialBounds
{
    private float $minX;
    private float $maxX;
    private float $minY;
    private float $maxY;

    // ... getters and setters
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Spatial indexing strategies

#### BoundingBox strategy

* The bounding box strategy is the simplest.  
  Given a spatial shape, such as a point, circle, or polygon, the shape's bounding box is computed  
  and the spatial coordinates (minX, minY, maxX, maxY) that enclose the shape are indexed.

* When making a query,  
  RavenDB translates the query criteria to the same bounding box system used for indexing. 

* Bounding box strategy is cheaper at indexing time and can produce quick queries,  
  but that's at the expense of the level of accuracy you can get.  

* Read more about bounding box [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).
#### GeoHashPrefixTree strategy

* Geohash is a latitude/longitude representation system that describes Earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. 
  Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

* E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) 
  and it represents the `40.7144 -74.0060` coordinates. 
  Removing characters from the end of the geohash will decrease the precision level.

* The `max_tree_level` determines the length of the geohash used for the indexing, which in turn affects accuracy.  
  By default, it is set to **9**, providing a resolution of approximately 2.5 meters.

* More information about geohash uses, decoding algorithm, and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).

<Admonition type="note" title="Geohash precision values:" id="geohash-precision-values" href="#geohash-precision-values">

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |

</Admonition>
#### QuadPrefixTree strategy

* The QuadTree represents Earth as a grid consisting of four cells (also known as buckets).
  Similar to GeoHash, each cell is assigned a letter, and is recursively divided into four more cells, creating a hierarchical structure. 

* By default, the precision level (`maxTreeLevel`) for QuadPrefixTree is **23**.

* More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).

<Admonition type="note" title="Quadtree precision values:" id="quadtree-precision-values" href="#quadtree-precision-values">

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |

</Admonition>



## Remarks

<Admonition type="info" title="Info">

Distance is measured by default in `KILOMETERS`.

</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Documents that contain spatial data can be queried by spatial queries that employ geographical criteria.  
  There are two options: **dynamic** spatial query, and spatial **index** query.  

  * **Dynamic spatial query**  
    A dynamic spatial query can be made on a collection (see [how to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query)).  
    An auto-index will be created by the server.  
  
  * **Spatial index query**  
    Documents' spatial data can be indexed in a static index (**described in this article**),  
    and a spatial query can then be executed over this index (see [query a spatial index](../indexes/querying/spatial)).  

* In this page:
  * [Create index with spatial field](../indexes/indexing-spatial-data#create-index-with-spatial-field)
  * [Customize coordinate system and strategy](../indexes/indexing-spatial-data#customize-coordinate-system-and-strategy)
  * [Spatial indexing strategies](../indexes/indexing-spatial-data#spatial-indexing-strategies)

</Admonition>
## Create index with spatial field

* Use `createSpatialField` to index spatial data in a static-index.

* You can then retrieve documents based on geographical criteria when making a spatial query on this index-field.

* A spatial index can also be defined from [Studio](../studio/database/indexes/create-map-index#spatial-field-options). 

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Indexing_coordinates" label="Indexing_coordinates">
<CodeBlock language="nodejs">
{`// Define an index with a spatial field
class Events_ByNameAndCoordinates extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();
        const { createSpatialField } = this.mapUtils();

        this.map('events', e => {
            return {
                name: e.Name,
                // Call 'createSpatialField' to create a spatial index-field
                // Field 'coordinates' will be composed of lat & lng supplied from the document
                coordinates: createSpatialField(
                    e.latitude,
                    e.longitude
                )
                
                // Documents can be retrieved
                // by making a spatial query on the 'coordinates' index-field
            };
        });
    }
}

class Event {
    constructor(id, name, latitude, longitude) {
        this.id = id;
        this.name = name;
        this.latitude = latitude
        this.longitude = longitude;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Indexing_WKT" label="Indexing_WKT">
<CodeBlock language="nodejs">
{`// Define an index with a spatial field
class EventsWithWKT_ByNameAndWKT extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();
        const { createSpatialField } = this.mapUtils();

        this.map('events', e => {
            return {
                name: e.Name,
                // Call 'createSpatialField' to create a spatial index-field
                // Field 'wkt' will be composed of the WKT string supplied from the document
                wkt: createSpatialField(e.wkt)

                // Documents can be retrieved by
                // making a spatial query on the 'wkt' index-field
            };
        });
    }
}

class EventWithWKT {
    constructor(id, name, wkt) {
        this.id = id;
        this.name = name;
        this.wkt = wkt;
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="something-something" label="spatial_syntax_1">
<CodeBlock language="nodejs">
{`createSpatialField(lat, lng);
createSpatialField(wkt);
`}
</CodeBlock>
</TabItem>

| Parameters | Type     | Description                |
|------------|----------|----------------------------|
| **lat**    | `number` | Latitude coordinate        |
| **lng**    | `number` | Longitude coordinate       |
| **wkt**    | `string` | Shape in WKT string format |



## Customize coordinate system and strategy

* For each spatial index-field, you can specify the **coordinate system** and **strategy** to be used  
  during indexing and when processing the data at query time.

* RavenDB supports both the `Geography` and `Cartesian` systems with the following strategies:

  * Geography system:
      * BoundingBox
      * GeoHashPrefixTree
      * QuadPrefixTree

  * Cartesian system:
      * BoundingBox
      * QuadPrefixTree

* **By default**, the `GeoHashPrefixTree` strategy is used with `GeoHashLevel` set to **9**.  
  Use the `spatial` method to modify this setting.

* The performance cost of spatial indexing is directly related to the tree level chosen.  
  Learn more about each strategy [below](../indexes/indexing-spatial-data#spatial-indexing-strategies).

* Note: Modifying the strategy after the index has been created & deployed will trigger the re-indexing.

#### Exmaple:

<TabItem value="something-something" label="spatial_index_3">
<CodeBlock language="nodejs">
{`class Events_ByNameAndCoordinates_Custom extends AbstractJavaScriptIndexCreationTask \{
    constructor() \{
        super();
        const \{ createSpatialField \} = this.mapUtils();

        this.map('events', e => \{
            return \{
                name: e.Name,
                // Define a spatial index-field
                coordinates: createSpatialField(
                    e.latitude,
                    e.longitude
                )

                // Documents can be retrieved
                // by making a spatial query on the 'coordinates' index-field
            \};
        \});

        // Set the spatial indexing strategy for the spatial field 'coordinates' 
        this.spatial("coordinates", factory => factory.cartesian().boundingBoxIndex());
    \}
\}
`}
</CodeBlock>
</TabItem>

#### Syntax:

<TabItem value="something-something" label="spatial_syntax_2">
<CodeBlock language="nodejs">
{`class SpatialOptionsFactory \{
    geography(): GeographySpatialOptionsFactory;
    cartesian(): CartesianSpatialOptionsFactory;
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="nodejs">
{`defaultOptions(circleRadiusUnits);
boundingBoxIndex(circleRadiusUnits);
geohashPrefixTreeIndex(maxTreeLevel, circleRadiusUnits);
quadPrefixTreeIndex(maxTreeLevel, circleRadiusUnits);
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="nodejs">
{`boundingBoxIndex(): SpatialOptions;
quadPrefixTreeIndex(maxTreeLevel, bounds);

class SpatialBounds {
    minX; // number
    maxX; // number
    minY; // number
    maxY; // number
}
`}
</CodeBlock>
</TabItem>
</Tabs>

| Parameters            | Type            | Description                                       |
|-----------------------|-----------------|---------------------------------------------------|
| **circleRadiusUnits** | `string`        | "Kilometers" or "Miles"                           |
| **maxTreeLevel**      | `number`        | Controls precision level                          |
| **bounds**            | `SpatialBounds` | Coordinates for the cartesian quadPrefixTreeIndex |



## Spatial indexing strategies

#### BoundingBox strategy

* The bounding box strategy is the simplest.  
  Given a spatial shape, such as a point, circle, or polygon, the shape's bounding box is computed  
  and the spatial coordinates (minX, minY, maxX, maxY) that enclose the shape are indexed.

* When making a query,  
  RavenDB translates the query criteria to the same bounding box system used for indexing. 

* Bounding box strategy is cheaper at indexing time and can produce quick queries,  
  but that's at the expense of the level of accuracy you can get.  

* Read more about bounding box [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).
#### GeoHashPrefixTree strategy

* Geohash is a latitude/longitude representation system that describes Earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. 
  Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

* E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) 
  and it represents the `40.7144 -74.0060` coordinates. 
  Removing characters from the end of the geohash will decrease the precision level.

* The `maxTreeLevel` determines the length of the geohash used for the indexing, which in turn affects accuracy.  
  By default, it is set to **9**, providing a resolution of approximately 2.5 meters.

* More information about geohash uses, decoding algorithm, and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).

<Admonition type="note" title="Geohash precision values:" id="geohash-precision-values" href="#geohash-precision-values">

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |

</Admonition>
#### QuadPrefixTree strategy

* The QuadTree represents Earth as a grid consisting of four cells (also known as buckets).
  Similar to GeoHash, each cell is assigned a letter, and is recursively divided into four more cells, creating a hierarchical structure. 

* By default, the precision level (`maxTreeLevel`) for QuadPrefixTree is **23**.

* More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).

<Admonition type="note" title="Quadtree precision values:" id="quadtree-precision-values" href="#quadtree-precision-values">

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |

</Admonition>



## Remarks

<Admonition type="info" title="Info">

Distance is measured by default in **kilometers**.

</Admonition>


</LanguageContent>