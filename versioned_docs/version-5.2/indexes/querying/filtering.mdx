---
title: "Filter Query Results"
hide_table_of_contents: true
sidebar_label: Filtering
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Filter Query Results
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

One of the most basic functionalities of querying is the ability to filter out data and return records that match a given condition. 
There are a couple of ways to do this and they all depend on the querying approach you want to use: 

* [Query](../../client-api/session/querying/how-to-query.mdx) from basic session operations
* [DocumentQuery](../../client-api/session/querying/document-query/what-is-document-query.mdx) from `advanced` session operations 
* [RQL](../../client-api/session/querying/what-is-rql.mdx) - Raven Query Language 

The following examples demonstrate how to add various filtering conditions to a query.

* In this page:
   * [Where](../../indexes/querying/filtering.mdx#where)
   * [Where - Numeric Property](../../indexes/querying/filtering.mdx#where---numeric-property)
   * [Where - Nested Property](../../indexes/querying/filtering.mdx#where---nested-property)
   * [Where + Any](../../indexes/querying/filtering.mdx#where--any)
   * [Where + In](../../indexes/querying/filtering.mdx#where--in)
   * [Where + ContainsAny](../../indexes/querying/filtering.mdx#where--containsany)
   * [Where + ContainsAll](../../indexes/querying/filtering.mdx#where--containsall)
   * [Where - StartsWith](../../indexes/querying/filtering.mdx#where---startswith)
   * [Where - EndsWith](../../indexes/querying/filtering.mdx#where---endswith)
   * [Where - Identifier Property](../../indexes/querying/filtering.mdx#where---identifier-property)
   * [Where - Exists](../../indexes/querying/filtering.mdx#where---exists)
   * [Remarks](../../indexes/querying/filtering.mdx#remarks)

</Admonition>

## Where

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Employee> results = session
    .Query<Employee, Employees_ByFirstAndLastName>()                // query 'Employees/ByFirstAndLastName' index
    .Where(x => x.FirstName == "Robert" && x.LastName == "King")    // filtering predicates
    .ToList();                                                      // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Employee> results = session
    .Advanced
    .DocumentQuery<Employee, Employees_ByFirstAndLastName>()    // query 'Employees/ByFirstAndLastName' index
    .WhereEquals(x => x.FirstName, "Robert")                    // filtering predicates
    .AndAlso()                                                  // by default OR is between each condition
    .WhereEquals(x => x.LastName, "King")                       // filtering predicates
    .ToList();                                                  // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastName()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               LastName = employee.LastName
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
where FirstName = 'Robert' and LastName = 'King'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - Numeric Property

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Product> results = session
    .Query<Product, Products_ByUnitsInStock>()  // query 'Products/ByUnitsInStock' index
    .Where(x => x.UnitsInStock > 50)            // filtering predicates
    .ToList();                                  // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Product> results = session
    .Advanced
    .DocumentQuery<Product, Products_ByUnitsInStock>()  // query 'Products/ByUnitsInStock' index
    .WhereGreaterThan(x => x.UnitsInStock, 50)          // filtering predicates
    .ToList();                                          // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`private class Products_ByUnitsInStock : AbstractIndexCreationTask<Product>
{
    public Products_ByUnitsInStock()
    {
        Map = products => from product in products
                          select new
                          {
                              product.UnitsInStock
                          };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Products/ByUnitsInStock'
where UnitsInStock > 50
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - Nested Property

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// return all orders that were shipped to 'Albuquerque'
IList<Order> results = session
    .Query<Order>()
    .Where(x => x.ShipTo.City == "Albuquerque")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// return all orders that were shipped to 'Albuquerque'
IList<Order> results = session
    .Advanced
    .DocumentQuery<Order>()
    .WhereEquals(x => x.ShipTo.City, "Albuquerque")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders
where ShipTo.City = 'Albuquerque'
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Order> results = session
    .Query<Order, Order_ByOrderLinesCount>()    // query 'Order/ByOrderLinesCount' index
    .Where(x => x.Lines.Count > 50)             // filtering predicates
    .ToList();                                  // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Order> results = session
    .Advanced
    .DocumentQuery<Order, Order_ByOrderLinesCount>()    // query 'Order/ByOrderLinesCount' index
    .WhereGreaterThan(x => x.Lines.Count, 50)           // filtering predicates
    .ToList();                                          // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`private class Order_ByOrderLinesCount : AbstractIndexCreationTask<Order>
{
    public Order_ByOrderLinesCount()
    {
        Map = orders => from order in orders
                        select new
                        {
                            Lines_Count = order.Lines.Count
                        };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Order/ByOrderLinesCount'
where Lines.Count > 50
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where + Any

`Any` is useful when you have a collection of items (e.g. `Order` contains `OrderLines`) and you want to filter out based on values from this collection. For example, let's retrieve all orders that contain an `OrderLine` with a given product.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Order> results = session
    .Query<Order, Order_ByOrderLines_ProductName>()                                 // query 'Order/ByOrderLines/ProductName' index
    .Where(x => x.Lines.Any(l => l.ProductName == "Teatime Chocolate Biscuits"))    // filtering predicates
    .ToList();                                                                      // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Order> results = session
    .Advanced
    .DocumentQuery<Order, Order_ByOrderLines_ProductName>()         // query 'Order/ByOrderLines/ProductName' index
    .WhereEquals("Lines_ProductName", "Teatime Chocolate Biscuits") // filtering predicates
    .ToList();                                                      // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Order_ByOrderLines_ProductName : AbstractIndexCreationTask<Order>
{
    public Order_ByOrderLines_ProductName()
    {
        Map = orders => from order in orders
                        select new
                        {
                            Lines_ProductName = order.Lines.Select(x => x.ProductName)
                        };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Order/ByOrderLinesCount'
where Lines_ProductName = 'Teatime Chocolate Biscuits'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where + In

When you want to check a single value against multiple values, the `In` operator can become handy. To retrieve all employees where `FirstName` is either `Robert` or `Nancy`, we can issue the following query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Employee> results = session
    .Query<Employee, Employees_ByFirstAndLastName>()    // query 'Employees/ByFirstAndLastName' index
    .Where(x => x.FirstName.In("Robert", "Nancy"))      // filtering predicates (remember to add \`Raven.Client.Linq\` namespace to usings)
    .ToList();                                          // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Employee> results = session
    .Advanced
    .DocumentQuery<Employee, Employees_ByFirstAndLastName>()    // query 'Employees/ByFirstAndLastName' index
    .WhereIn(x => x.FirstName, new[] { "Robert", "Nancy" })     // filtering predicates
    .ToList();                                                  // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastName()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               LastName = employee.LastName
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
where FirstName IN ('Robert', 'Nancy')
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="warning" title="Important" id="important" href="#important">
Remember to add the `Raven.Client.Documents.Linq` namespace to usings if you want to use `In` extension method.
</Admonition>

## Where + ContainsAny

To check if enumeration contains **any** of the values from a specified collection, you can use the `ContainsAny` method.

Let's assume that we want to return all `BlogPosts` that contain any of the specified `Tags`.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<BlogPost> results = session
    .Query<BlogPost, BlogPosts_ByTags>()                                    // query 'BlogPosts/ByTags' index
    .Where(x => x.Tags.ContainsAny(new[] { "Development", "Research" }))    // filtering predicates (remember to add \`Raven.Client.Linq\` namespace to usings)
    .ToList();                                                              // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<BlogPost> results = session
    .Advanced
    .DocumentQuery<BlogPost, BlogPosts_ByTags>()                // query 'BlogPosts/ByTags' index
    .ContainsAny("Tags", new[] { "Development", "Research" })   // filtering predicates
    .ToList();                                                  // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class BlogPosts_ByTags : AbstractIndexCreationTask<BlogPost>
{
    public BlogPosts_ByTags()
    {
        Map = posts => from post in posts
                       select new
                       {
                           post.Tags
                       };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'BlogPosts/ByTags'
where Tags IN ('Development', 'Research')
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="warning" title="Important" id="important" href="#important">
Remember to add the `Raven.Client.Documents.Linq` namespace to usings if you want to use the `ContainsAny` extension method.
</Admonition>

## Where + ContainsAll

To check if an enumeration contains **all** of the values from a specified collection, you can use the `ContainsAll` method.

Let's assume that we want to return all the `BlogPosts` that contain all of the specified `Tags`.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<BlogPost> results = session
    .Query<BlogPost, BlogPosts_ByTags>()                                    // query 'BlogPosts/ByTags' index
    .Where(x => x.Tags.ContainsAll(new[] { "Development", "Research" }))    // filtering predicates (remember to add \`Raven.Client.Linq\` namespace to usings)
    .ToList();                                                              // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<BlogPost> results = session
    .Advanced
    .DocumentQuery<BlogPost, BlogPosts_ByTags>()                // query 'BlogPosts/ByTags' index
    .ContainsAll("Tags", new[] { "Development", "Research" })   // filtering predicates
    .ToList();                                                  // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class BlogPosts_ByTags : AbstractIndexCreationTask<BlogPost>
{
    public BlogPosts_ByTags()
    {
        Map = posts => from post in posts
                       select new
                       {
                           post.Tags
                       };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'BlogPosts/ByTags'
where Tags ALL IN ('Development', 'Research')
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="warning" title="Important" id="important" href="#important">
Remember to add the `Raven.Client.Documents.Linq` namespace to usings if you want to use the `ContainsAll` extension method.
</Admonition>

## Where - StartsWith

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// return all products which name starts with 'ch'
IList<Product> results = session
    .Query<Product>()
    .Where(x => x.Name.StartsWith("ch"))
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// return all products which name starts with 'ch'
IList<Product> results = session
    .Advanced
    .DocumentQuery<Product>()
    .WhereStartsWith(x => x.Name, "ch")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Products 
where startsWith(Name, 'ch')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - EndsWith

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// return all products which name ends with 'ra'
IList<Product> results = session
    .Query<Product>()
    .Where(x => x.Name.EndsWith("ra"))
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// return all products which name ends with 'ra'
IList<Product> results = session
    .Advanced
    .DocumentQuery<Product>()
    .WhereEndsWith(x => x.Name, "ra")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Products 
where endsWith(Name, 'ra')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - Identifier Property

Once a property used in the `Where` clause is recognized as an identity property of a given entity type 
(according to [`FindIdentityProperty` convention](../../client-api/configuration/identifier-generation/global.mdx#findidentityproperty))
and there aren't any other fields involved in the query, then it is called a "collection query". 
Simple collection queries that ask about documents with given IDs or where identifiers start with a given prefix
and don't require any additional handling like ordering, full-text searching, etc, are handled directly by the storage engine. 
It means that querying by ID doesn't create an auto-index and has no extra cost. In terms of efficiency, it is the same as
loading documents with [`session.Load`](../../client-api/session/loading-entities.mdx) usage.


<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Order order = session
    .Query<Order>()
    .Where(x => x.Id == "orders/1-A")
    .FirstOrDefault();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Order order = session
    .Advanced
    .DocumentQuery<Order>()
    .WhereEquals(x => x.Id, "orders/1-A")
    .FirstOrDefault();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders
where id() = 'orders/1-A'
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Order> orders = session
    .Query<Order>()
    .Where(x => x.Id.StartsWith("orders/1"))
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Order> orders = session
    .Advanced
    .DocumentQuery<Order>()
    .WhereStartsWith(x => x.Id, "orders/1")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders
where startsWith(id(), 'orders/1')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - Exists

To find all documents in a collection that have a specified field, see [How to Filter by Field Presence](../../client-api/session/querying/how-to-filter-by-field.mdx).  

To find all documents in a collection that don't have a specified field, see [How to Filter by Non-Existing Field](../../client-api/session/querying/how-to-filter-by-non-existing-field.mdx).

## Remarks

<Admonition type="info" title="">
Underneath, `Query` and `DocumentQuery` are converting predicates to the `IndexQuery` class so they can issue a query from a **low-level operation method**.
</Admonition>


</LanguageContent>
<LanguageContent language="java">


One of the most basic functionalities of querying is the ability to filter out data and return records that match a given condition. There are couple of ways to do this. 

The following examples demonstrate how to add simple conditions to a query using all of those methods.

## Where

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Employee> results = session
    .query(Employee.class, Employees_ByFirstAndLastName.class) // query 'Employees/ByFirstAndLastName' index
    .whereEquals("FirstName", "Robert") // filtering predicates
    .andAlso()   // by default OR is between each condition
    .whereEquals("LastName", "King") // materialize query by sending it to server for processing
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastName() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
where FirstName = 'Robert' and LastName = 'King'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - Numeric Property

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Product> results = session
    .query(Product.class, Products_ByUnitsInStock.class) // query 'Products/ByUnitsInStock' index
    .whereGreaterThan("UnitsInStock", 50) // filtering predicates
    .toList(); // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public class Products_ByUnitsInStock extends AbstractIndexCreationTask {
    public Products_ByUnitsInStock() {
        map = "docs.Products.Select(product => new {" +
            "        UnitsInStock = product.UnitsInStock" +
            "    })";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Products/ByUnitsInStock'
where UnitsInStock > 50
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - Nested Property

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`// return all orders that were shipped to 'Albuquerque'
List<Order> results = session
    .query(Order.class)
    .whereEquals("ShipTo_city", "Albuquerque")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Orders
where ShipTo.City = 'Albuquerque'
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Order> results = session
    .query(Order.class, Order_ByOrderLinesCount.class) // query 'Order/ByOrderLinesCount' index
    .whereGreaterThan("Lines_count", 50) // filtering predicates
    .toList();   // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public class Order_ByOrderLinesCount extends AbstractIndexCreationTask {
    public Order_ByOrderLinesCount() {
        map = "docs.Orders.Select(order => new {" +
            "    Lines_count = order.Lines.Count" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Order/ByOrderLinesCount'
where Lines.Count > 50
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where + Any

`Any` is useful when you have a collection of items (e.g. `Order` contains `OrderLines`) and you want to filter out based on values from this collection. For example, let's retrieve all orders that contain an `OrderLine` with a given product.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`session
    .query(Order.class, Order_ByOrderLines_ProductName.class) // query 'Order/ByOrderLines/ProductName' index
    .whereEquals("Lines_productName", "Teatime Chocolate Biscuits") // filtering predicates
    .toList(); // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public class Order_ByOrderLines_ProductName extends AbstractIndexCreationTask {
    public Order_ByOrderLines_ProductName() {
        map = "docs.Orders.Select(order => new {" +
            "    Lines_productName = order.Lines.Select(x => x.ProductName)" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Order/ByOrderLinesCount'
where Lines_ProductName = 'Teatime Chocolate Biscuits'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where + In

When you want to check a single value against multiple values, the `In` operator can become handy. To retrieve all employees where `FirstName` is either `Robert` or `Nancy`, we can issue the following query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Employee> results = session
    .query(Employee.class, Employees_ByFirstAndLastName.class) // query 'Employees/ByFirstAndLastName' index
    .whereIn("FirstName", Arrays.asList("Robert", "Nancy")) // filtering predicates
    .toList();// materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastName() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
where FirstName IN ('Robert', 'Nancy')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where + ContainsAny

To check if enumeration contains **any** of the values from a specified collection, you can use the `containsAny` method.

Let's assume that we want to return all `BlogPosts` that contain any of the specified `tags`.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<BlogPost> results = session
    .query(BlogPost.class, BlogPosts_ByTags.class)  // query 'BlogPosts/ByTags' index
    .containsAny("tags", Arrays.asList("Development", "Research")) // filtering predicates
    .toList(); // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public class BlogPosts_ByTags extends AbstractIndexCreationTask {
    public BlogPosts_ByTags() {
        map = "docs.BlogPosts.Select(post => new {" +
            "    tags = post.tags" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'BlogPosts/ByTags'
where Tags IN ('Development', 'Research')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where + ContainsAll

To check if an enumeration contains **all** of the values from a specified collection, you can use the `containsAll` method.

Let's assume that we want to return all the `BlogPosts` that contain all of the specified `tags`.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<BlogPost> results = session
    .query(BlogPost.class, BlogPosts_ByTags.class) // query 'BlogPosts/ByTags' index
    .containsAll("tags", Arrays.asList("Development", "Research")) // filtering predicates
    .toList(); // materialize query by sending it to server for processing
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public class BlogPosts_ByTags extends AbstractIndexCreationTask {
    public BlogPosts_ByTags() {
        map = "docs.BlogPosts.Select(post => new {" +
            "    tags = post.tags" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'BlogPosts/ByTags'
where Tags ALL IN ('Development', 'Research')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - StartsWith

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`// return all products which name starts with 'ch'
List<Product> results = session
    .query(Product.class)
    .whereStartsWith("Name", "ch")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Products 
where startsWith(Name, 'ch')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Where - EndsWith

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`// return all products which name ends with 'ra'
List<Product> results = session
    .query(Product.class)
    .whereEndsWith("Name", "ra")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Products 
where endsWith(Name, 'ra')
`}
</CodeBlock>
</TabItem>
</Tabs>


## Remarks

<Admonition type="info" title="">
Underneath, `Query` is converting predicates to the `IndexQuery` class so they can issue a query from a **low-level operation method**.
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">

* One of the most basic functionalities of querying is the ability to filter out data and return records that match a given condition.

* The following examples demonstrate how to add simple conditions to a query:
  * [Where - equals](../../indexes/querying/filtering.mdx#where---equals)
  * [Where - numeric property](../../indexes/querying/filtering.mdx#where---numeric-property)
  * [Where - nested property](../../indexes/querying/filtering.mdx#where---nested-property)
  * [Where - multiple values](../../indexes/querying/filtering.mdx#where---multiple-values)
  * [Where - in](../../indexes/querying/filtering.mdx#where---in)
  * [Where - containsAny](../../indexes/querying/filtering.mdx#where---containsany)
  * [Where - containsAll](../../indexes/querying/filtering.mdx#where---containsall)
  * [Where - startsWith](../../indexes/querying/filtering.mdx#where---startswith)
  * [Where - endsWith](../../indexes/querying/filtering.mdx#where---endswith)
  * [Where - exists](../../indexes/querying/filtering.mdx#where---exists)
  * [Where - filter by ID](../../indexes/querying/filtering.mdx#where---filter-by-id)

</Admonition>
## Where - equals

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Basic filtering using "whereEquals":
// ====================================

const filteredEmployees = await session
     // Query an index 
    .query({ indexName: "Employees/ByFirstAndLastName" })
     // The filtering predicate
    .whereEquals("FirstName", "Robert")
     // By default AND is applied between both 'where' predicates
    .whereEquals("LastName", "King")
     // Execute the query, send it to the server for processing
    .all();

// Results will include all Employee documents 
// with FirstName equals to 'Robert' AND LastName equal to 'King'
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstAndLastName extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("employees", employee => {
            return {
                FirstName: employee.FirstName,
                LastName: employee.LastName
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByFirstAndLastName"
where FirstName == "Robert" and LastName == "King"
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - numeric Property

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter with "whereGreaterThan":
// ===============================

const filteredProducts = await session
     // Query an index 
    .query({ indexName: "Products/ByUnitsInStock" })
     // The filtering predicate
    .whereGreaterThan("UnitsInStock", 20)
    .all();

// Results will include all Product documents having 'UnitsInStock' > 20
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Products_ByUnitsInStock extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("products", product => {
            return {
                UnitsInStock: product.UnitsInStock
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 20
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter with "whereLessThan":
// ============================

const filteredProducts = await session
     // Query an index 
    .query({ indexName: "Products/ByUnitsInStock" })
     // The filtering predicate
    .whereLessThan("UnitsInStock", 20)
    .all();

// Results will include all Product documents having 'UnitsInStock'< 20
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Products_ByUnitsInStock extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("products", product => {
            return {
                UnitsInStock: product.UnitsInStock
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock < 20
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - nested property

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter by a nested property:
// ============================

const filteredOrders = await session
     // Query a collection
    .query({ collection: "Orders" })
     // Filter by the nested property 'ShipTo.City' from the Order document
    .whereEquals("ShipTo.City", "Albuquerque")
    .all();

// * Results will include all Order documents with an order that ships to 'Albuquerque'
// * An auto-index will be created
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
where ShipTo.City == "Albuquerque"
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - multiple values

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter by multiple values:
// ==========================

const filteredOrders = await session
     // Query an index 
    .query({ indexName: "Orders/ByProductNamesPerOrderLine" })
     // Filter by multiple values 
    .whereEquals("ProductName", "Teatime Chocolate Biscuits")
    .all();

// Results will include all Order documents that contain ALL values in "Teatime Chocolate Biscuits"
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Orders_ByProductNamesPerOrderLine extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("orders", order => {
            return {
                // Index field 'ProductNames' will contain the product names per Order Line
                ProductNames: order.Lines.map(x => x.ProductName)
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByProductNamesPerOrderLine"
where ProductNames == "Teatime Chocolate Biscuits"
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - in

Use `whereIn` when you want to filter by a single value out of multiple given values.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter with "whereIn":
// ======================

const filteredEmployees = await session
     // Query an index 
    .query({ indexName: "Employees/ByFirstAndLastName" })
     // The filtering predicate
    .whereIn("FirstName", [ "Robert", "Nancy" ]) 
    .all();

// Results will include all Employee documents that have either 'Robert' OR 'Nancy' in their 'FirstName' field
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstAndLastName extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("employees", employee => {
            return {
                FirstName: employee.FirstName,
                LastName: employee.LastName
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByFirstAndLastName"
where FirstName in ("Robert", "Nancy")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - containsAny

Use `containsAny` to check if an enumeration contains any of the values from the specified list.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter with "containsAny":
// ==========================

const filteredOrders = await session
     // Query an index 
    .query({ indexName: "Orders/ByProductNames" })
     // The filtering predicate
    .containsAny("ProductNames", ["Ravioli", "Coffee"])
    .all();

// Results will include all Order documents that have either 'Ravioli' OR 'Coffee' in their order
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Orders_ByProductNames extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("orders", order => {
            return {
                // Index field 'ProductNames' will contain a list of all product names
                ProductNames: order.Lines.flatMap(x => x.ProductName.split(" "))
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByProductNames"
where ProductNames in ("ravioli", "coffee")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - containsAll

Use `containsAll` to check if an enumeration contains all of the values from the specified list.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter with "containsAll":
// ==========================

const filteredOrders = await session
     // Query an index 
    .query({ indexName: "Orders/ByProductNames" })
     // The filtering predicate
    .containsAll("ProductNames", ["Ravioli", "Pepper"])
    .all();

// Results will include all Order documents that have both 'Ravioli' AND 'Pepper' in their order
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Orders_ByProductNames extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("orders", order => {
            return {
                // Index field 'ProductNames' will contain a list of all product names
                ProductNames: order.Lines.flatMap(x => x.ProductName.split(" "))
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByProductNames"
where ProductNames all in ("ravioli", "pepper")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - startsWith

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter with "whereStartsWith":
// ==============================

const filteredProducts = await session
     // Query a collection
    .query({ collection: "Products" })
     // The filtering predicate
    .whereStartsWith("Name", "ch")
    .all();

// * Results will include all Product documents with a name that starts with 'ch'
// * An auto-index will be created
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Products" 
where startsWith(Name, "ch")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - endsWith

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter with "whereEndsWith":
// ===========================

const filteredProducts = await session
     // Query a collection
    .query({ collection: "Products" })
     // The filtering predicate
    .whereEndsWith("Name", "es")
    .all();

// * Results will include all Product documents with a name that ends with 'es'
// * An auto-index will be created
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Products 
where endsWith(Name, 'ra')
`}
</CodeBlock>
</TabItem>
</Tabs>



## Where - exists

* To find all documents in a collection that have a specified field,  
  see [How to Filter by Field Presence](../../client-api/session/querying/how-to-filter-by-field.mdx).
  
* To find all documents in a collection that don't have a specified field,  
  see [How to Filter by Non-Existing Field](../../client-api/session/querying/how-to-filter-by-non-existing-field.mdx).



## Where - filter by ID

* Once the property used in the `whereEquals` clause is recognized as an identity property of a given entity type,  
  and there aren't any other fields involved in the query predicate, then this query is considered a "Collection Query".

* Such collection queries that ask about documents with given IDs, or where identifiers start with a given prefix
  and don't require any additional handling like ordering, full-text searching, etc, are handled directly by the storage engine.

* This means that querying by ID doesn't create an auto-index and has no extra cost.  
  In terms of efficiency, it is the same as loading documents with [`session.load`](../../client-api/session/loading-entities.mdx) usage.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter by id:
// =============

const order = await session
     // Query a collection
    .query({ collection: "Orders" })
     // The filtering predicate
    .whereEquals("id", "orders/1-A")
    .firstOrNull();

// * Results will include the Order document having ID 'orders/1-A'
// * An auto-index is NOT created
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
where id() == "orders/1-A"
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Filter by whereStartsWith id:
// =============================

const filteredOrders = await session
    // Query a collection
    .query({ collection: "Orders" })
    // The filtering predicate
    .whereStartsWith("id", "orders/1")
    .all();

// * Results will include all Order documents having ID that starts with 'orders/1'
// * An auto-index is NOT created
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
where startsWith(id(), "orders/1")
`}
</CodeBlock>
</TabItem>
</Tabs>



</LanguageContent>

<!---
### Client API
- [Query Overview](../../client-api/session/querying/how-to-query)

### Indexes
- [Indexing Basics](../../indexes/indexing-basics)

### Querying
- [Query an Index](../../indexes/querying/query-index)
- [Paging](../../indexes/querying/paging)
- [Sorting](../../indexes/querying/sorting)


-->