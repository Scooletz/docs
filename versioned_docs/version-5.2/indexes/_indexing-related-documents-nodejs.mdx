import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* As described in [modeling considerations in RavenDB](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#summary),  
  it is recommended for documents to be: independent, isolated, and coherent.  
  However, to accommodate varied models, __documents can reference other documents__.

* The related data from a referenced (related) document can be indexed,  
  this will allow querying the collection by the indexed related data.

* The related documents that are loaded in the index definition can be either __Tracked__ or __Not-Tracked__.

* In this page:

    * [What are related documents](../indexes/indexing-related-documents.mdx#what-are-related-documents)


    * [Index related documents - With tracking](../indexes/indexing-related-documents.mdx#index-related-documents---with-tracking)
        * [Example I - basic](../indexes/indexing-related-documents.mdx#example-i---basic)
        * [Example II - list](../indexes/indexing-related-documents.mdx#example-ii---list)
        * [Tracking implications](../indexes/indexing-related-documents.mdx#tracking-implications)
    * [Index related documents - No tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
        * [Example III - no tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
        * [No-tracking implications](../indexes/indexing-related-documents.mdx#no-tracking-implications)
    * [Document changes that cause re-indexing](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)
    * [LoadDocument Syntax](../indexes/indexing-related-documents.mdx#loaddocument-syntax)

</Admonition>

## What are related documents

* Whenever a document references another document, the referenced document is called a __Related Document__.

* In the image below, document `products/34-A` references documents `categories/1-A` & `suppliers/16-A`,  
  which are considered Related Documents.

![Referencing related documents](./assets/index-related-documents.png)



## Index related documents - With tracking

<Admonition type="note" title="">
#### Example I - basic
__What is tracked__:

* Both the documents from the __indexed collection__ and the __indexed related documents__ are tracked for changes.  
  Re-indexing will be triggered per any change in either collection.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

__The index__:

* Following the above `Product - Category` relationship from the Northwind sample database,  
  an index defined on the Products collection can index data from the related Category document.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="js">
{`class Products_ByCategoryName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();
        
        // Call LoadDocument to load the related Category document
        // The document ID to load is specified by 'product.Category'
        // The Name field from the related Category document will be indexed
        
        this.map = \`docs.Products.Select(product => new {
            CategoryName = (this.LoadDocument(product.Category, "Categories")).Name 
        })\`;

        // Since NoTracking was Not specified,
        // then any change to either Products or Categories will trigger reindexing 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="js">
{`class Products_ByCategoryName_JS extends AbstractJavaScriptIndexCreationTask {
    constructor () {
        super();

        const { load } = this.mapUtils();

        this.map("Products", product => {
            return {
                // Call method 'load' to load the related Category document
                // The document ID to load is specified by 'product.Category'
                // The Name field from the related Category document will be indexed                
                categoryName: load(product.Category, "Categories").Name

                // Since NoTracking was Not specified,
                // then any change to either Products or Categories will trigger reindexing
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

__The query__:

* We can now query the index for Product documents by `CategoryName`,  
  i.e. get all matching Products that reference a Category that has the specified name term.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query({indexName: "Products/ByCategoryName"})
    .whereEquals("CategoryName", "Beverages")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">
#### Example II - list
__The documents__:

<TabItem value="indexing_related_documents_3" label="indexing_related_documents_3">
<CodeBlock language="js">
{`// The referencing document
class Author \{
    constructor(id, name, bookIds) \{
        this.id = id;
        this.name = name;
        
        // Referencing a list of related document IDs
        this.bookIds = bookIds;
    \}
\}
// The related document
class Book \{
    constructor(id, name) \{
        this.id = id;
        this.name = name;
    \}
\}
`}
</CodeBlock>
</TabItem>

__The index__:

* This index will index all names of the related Book documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="js">
{`class Authors_ByBooks extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        // For each Book ID, call LoadDocument and index the book's name
        this.map = \`docs.Authors.Select(author => new {
            BookNames = author.bookIds.Select(x => (this.LoadDocument(x, "Books")).name) 
        })\`;

        // Since NoTracking was Not specified,
        // then any change to either Authors or Books will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="js">
{`class Authors_ByBooks_JS extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        const { load } = this.mapUtils();

        this.map("Authors", author => {
            return {
                // For each Book ID, call 'load' and index the book's name
                BookNames: author.bookIds.map(x => load(x, "Books").name)

                // Since NoTracking was Not specified,
                // then any change to either Products or Categories will trigger reindexing
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

__The query__:

* We can now query the index for Author documents by a book's name,  
  i.e. get all Authors that have the specified book's name in their list.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query({indexName: "Authors/ByBooks"})
    .whereEquals("BookNames", "The Witcher")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Get all authors that have books with title: "The Witcher"
from index "Authors/ByBooks"
where BookNames = "The Witcher"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="info" title="">
#### Tracking implications

* Indexing related data with tracking can be a useful way to query documents by their related data.  
  However, that may come with performance costs.

* __Re-indexing__ will be triggered whenever any document in the collection that is referenced by `LoadDocument` is changed.
  Even when indexing just a single field from the related document, any change to any other field will cause re-indexing.
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* Frequent re-indexing will increase CPU usage and reduce performance,  
  and index results may be stale for prolonged periods.

* Tracking indexed related data is more useful when the indexed related collection is known not to change much.

</Admonition>



## Index related documents - No tracking

<Admonition type="note" title="">
#### Example III - no tracking
__What is tracked__:

* Only the documents from the __indexed collection__ are tracked for changes and can trigger re-indexing.  
  Any change done to any document in the __indexed related documents__ will Not trigger re-indexing.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

__The index__:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="js">
{`class Products_ByCategoryName_NoTracking extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        // Call NoTracking.LoadDocument to load the related Category document w/o tracking
        this.map = \`docs.Products.Select(product => new {
            CategoryName = (this.NoTracking.LoadDocument(product.Category, "Categories")).Name 
        })\`;

        // Since NoTracking is used -
        // then only the changes to Products will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="js">
{`class Products_ByCategoryName_NoTracking_JS extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        const { noTracking } = this.mapUtils();

        this.map("Products", product => {
            return {
                // Call 'noTracking.load' to load the related Category document w/o tracking
                categoryName: noTracking.load(product.Category, "Categories").Name
            };
        });
        
        // Since noTracking is used -
        // then only the changes to Products will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

__The query__:

* When querying the index for Product documents by `CategoryName`,   
  results will be based on the related data that was __first indexed__ when the index was deployed.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query({indexName: "Products/ByCategoryName/NoTracking"})
    .whereEquals("CategoryName", "Beverages")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName/NoTracking"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="info" title="">
#### No-tracking implications

* Indexing related data with no-tracking can be a useful way to query documents by their related data.  
  However, that may come with some data accuracy costs.

* __Re-indexing__ will Not be triggered when documents in the collection that is referenced by `LoadDocument` are changed.
  Although this may save system resources, the index entries and the indexed terms may not be updated with the current state of data.

* Indexing related data without tracking is useful when the indexed related data is fixed and not supposed to change.

</Admonition>



## Document changes that cause re-indexing

* The following changes done to a document will trigger re-indexing:

    * Any modification to any document field (not just to the indexed fields)
    * Adding/Deleting an attachment
    * Creating a new Time series (modifying existing will not trigger)
    * Creating a new Counter (modifying existing will not trigger)

* Any such change done on any document in the __indexed collection__ will trigger re-indexing.

* Any such change done on any document in the __indexed related documents__ will trigger re-indexing  
  only if `NoTracking` was Not used in the index definition.



## LoadDocument syntax

#### Syntax for LINQ-index:

<TabItem value="syntax" label="syntax">
<CodeBlock language="csharp">
{`T LoadDocument<T>(string relatedDocumentId);

T LoadDocument<T>(string relatedDocumentId, string relatedCollectionName);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds, string relatedCollectionName);
`}
</CodeBlock>
</TabItem>

#### Syntax for JavaScript-index:

<TabItem value="syntax_JS" label="syntax_JS">
<CodeBlock language="js">
{`object load(relatedDocumentId, relatedCollectionName);
`}
</CodeBlock>
</TabItem>

| Parameters                |                       |                                        |
|---------------------------|-----------------------|----------------------------------------|
| **relatedDocumentId**     | `string`              | ID of the related document to load     |
| **relatedCollectionName** | `string`              | The related collection name            |
| **relatedDocumentIds**    | `IEnumerable<string>` | A list of related document IDs to load |




