---
title: "Indexing Nested data"
hide_table_of_contents: true
sidebar_label: Indexing Nested Data
sidebar_position: 12
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexing Nested data
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* JSON documents can have nested structures, where one document contains other objects or arrays of objects.

* Use a static-index to facilitate querying for documents based on the nested data.

* In this page:
 
  * [Sample data](../indexes/indexing-nested-data.mdx#sample-data)

  * [Simple index - SINGLE index-entry per document](../indexes/indexing-nested-data.mdx#simple-index---single-index-entry-per-document)    
      * [The index](../indexes/indexing-nested-data.mdx#theIndex)
      * [The index-entries](../indexes/indexing-nested-data.mdx#theIndexEntries)
      * [Querying the index](../indexes/indexing-nested-data.mdx#queryingTheIndex)
      * [When to use](../indexes/indexing-nested-data.mdx#whenToUse)

  * [Fanout index - MULTIPLE index-entries per document](../indexes/indexing-nested-data.mdx#fanout-index---multiple-index-entries-per-document)   
      * [What is a fanout index](../indexes/indexing-nested-data.mdx#whatIsFanoutIndex)
      * [Fanout index - Map index example](../indexes/indexing-nested-data.mdx#fanoutMapIndex)
      * [Fanout index - Map-Reduce index example](../indexes/indexing-nested-data.mdx#fanoutMapReduceIndex)
      * [Performance hints](../indexes/indexing-nested-data.mdx#performanceHints)
      * [Paging](../indexes/indexing-nested-data.mdx#paging)

</Admonition>
## Sample data

* The examples in this article are based on the following __Classes__ and __Sample Data__:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class OnlineShop
{
    public string ShopName { get; set; }
    public string Email { get; set; }
    public List<TShirt> TShirts { get; set; } // Nested data
}

public class TShirt
{
    public string Color { get; set; }
    public string Size { get; set; }
    public string Logo { get; set; }
    public decimal Price { get; set; }
    public int Sold { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="csharp">
{`// Creating sample data for the examples in this article:
// ======================================================

var onlineShops = new[]
{
  // Shop1
  new OnlineShop { ShopName = "Shop1", Email = "sales@shop1.com", TShirts = new List<TShirt> {
      new TShirt { Color = "Red", Size = "S", Logo = "Bytes and Beyond", Price = 25, Sold = 2 },
      new TShirt { Color = "Red", Size = "M", Logo = "Bytes and Beyond", Price = 25, Sold = 4 },
      new TShirt { Color = "Blue", Size = "M", Logo = "Query Everything", Price = 28, Sold = 5 },
      new TShirt { Color = "Green", Size = "L", Logo = "Data Driver", Price = 30, Sold = 3}
  }},
  // Shop2
  new OnlineShop { ShopName = "Shop2", Email = "sales@shop2.com", TShirts = new List<TShirt> {
      new TShirt { Color = "Blue", Size = "S", Logo = "Coffee, Code, Repeat", Price = 22, Sold = 12 },
      new TShirt { Color = "Blue", Size = "M", Logo = "Coffee, Code, Repeat", Price = 22, Sold = 7 },
      new TShirt { Color = "Green", Size = "M", Logo = "Big Data Dreamer", Price = 25, Sold = 9 },
      new TShirt { Color = "Black", Size = "L", Logo = "Data Mining Expert", Price = 20, Sold = 11 }
  }},
  // Shop3
  new OnlineShop { ShopName = "Shop3", Email = "sales@shop3.com", TShirts = new List<TShirt> {
      new TShirt { Color = "Red", Size = "S", Logo = "Bytes of Wisdom", Price = 18, Sold = 2 },
      new TShirt { Color = "Blue", Size = "M", Logo = "Data Geek", Price = 20, Sold = 6 },
      new TShirt { Color = "Black", Size = "L", Logo = "Data Revolution", Price = 15, Sold = 8 },
      new TShirt { Color = "Black", Size = "XL", Logo = "Data Revolution", Price = 15, Sold = 10 }
  }}
};

using (var session = store.OpenSession())
{
    foreach (var shop in onlineShops)
    {
        session.Store(shop);
    }

    session.SaveChanges();
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Simple index - Single index-entry per document


<a id="theIndex"/> __The index__:

<TabItem value="simple_index" label="simple_index">
<CodeBlock language="csharp">
{`public class Shops_ByTShirt_Simple : AbstractIndexCreationTask<OnlineShop>
\{
    public class IndexEntry
    \{
        // The index-fields:
        public IEnumerable<string> Colors \{ get; set; \}
        public IEnumerable<string> Sizes \{ get; set; \}
        public IEnumerable<string> Logos \{ get; set; \}
    \}
    
    public Shops_ByTShirt_Simple()
    \{
        Map = shops => from shop in shops
            // Creating a SINGLE index-entry per document:
            select new IndexEntry
            \{
                // Each index-field will hold a collection of nested values from the document
                Colors = shop.TShirts.Select(x => x.Color),
                Sizes = shop.TShirts.Select(x => x.Size),
                Logos = shop.TShirts.Select(x => x.Logo)
            \};
    \}
\}
`}
</CodeBlock>
</TabItem>
<a id="theIndexEntries"/> __The index-entries__:

![Simple - index-entries](./assets/indexing-nested-data-1.png)

1. The index-entries content is visible from the Studio [Query view](../studio/database/queries/query-view.mdx).

2. Check option: _Show raw index-entries instead of Matching documents_.

3. Each row represents an __index-entry__.  
   The index has a single index-entry per document (3 entries in this example).  

4. The index-field contains a collection of ALL nested values from the document.  
   e.g. The third __index-entry__ has the following values in the _Colors_ __index-field__:  
   `{"black", "blue", "red"}`
<a id="queryingTheIndex"/> __Querying the index__:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Query for all shop documents that have a red TShirt
var shopsThatHaveRedShirts = session
    .Query<Shops_ByTShirt_Simple.IndexEntry, Shops_ByTShirt_Simple>()
     // Filter query results by a nested value
    .Where(x => x.Colors.Contains("red"))
    .OfType<OnlineShop>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Query for all shop documents that have a red TShirt
var shopsThatHaveRedShirts = await asyncSession
    .Query<Shops_ByTShirt_Simple.IndexEntry, Shops_ByTShirt_Simple>()
     // Filter query results by a nested value
    .Where(x => x.Colors.Contains("red"))
    .OfType<OnlineShop>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Query for all shop documents that have a red TShirt
var shopsThatHaveRedShirts = session.Advanced
    .DocumentQuery<Shops_ByTShirt_Simple.IndexEntry, Shops_ByTShirt_Simple>()
     // Filter query results by a nested value
    .ContainsAny(x => x.Colors, new[] { "Red" })
    .OfType<OnlineShop>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Shops/ByTShirt/Simple"
where Colors == "red"
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="results_1" label="results_1">
<CodeBlock language="csharp">
{`// Results will include the following shop documents:
// ==================================================
// * Shop1
// * Shop3
`}
</CodeBlock>
</TabItem>
<a id="whenToUse"/> __When to use__:

* This type of index structure is effective for retrieving documents when filtering the query by any of the inner nested values that were indexed.

* However, due to the way the index-entries are generated, this index __cannot__ provide results for a query searching for documents that contain 
  specific sub-objects which satisfy some `AND` condition.   
  For example:   

<TabItem value="results_2" label="results_2">
<CodeBlock language="csharp">
{`// You want to query for shops containing "Large Green TShirts",
// aiming to get only "Shop1" as a result since it has such a combination,
// so you attempt this query:
var GreenAndLarge = session
    .Query<Shops_ByTShirt_Simple.IndexEntry, Shops_ByTShirt_Simple>()
    .Where(x => x.Colors.Contains("green") && x.Sizes.Contains("L"))
    .OfType<OnlineShop>()
    .ToList();

// But, the results of this query will include BOTH "Shop1" & "Shop2"
// since the index-entries do not keep the original sub-objects structure.
`}
</CodeBlock>
</TabItem>

* To address this, you must use a __Fanout index__ - as described below.



## Fanout index - Multiple index-entries per document

<Admonition type="note" title="Note">

<a id="whatIsFanoutIndex"/> __What is a Fanout index__:

* A fanout index is an index that outputs multiple index-entries per document.  
  A separate index-entry is created for each nested sub-object from the document.
 
* The fanout index is useful when you need to retrieve documents matching query criteria  
  that search for specific sub-objects that comply with some logical conditions.

</Admonition>

<Admonition type="note" title="Note">

<a id="fanoutMapIndex"/> __Fanout index - Map index example__:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
<CodeBlock language="csharp">
{`// A fanout map-index:
// ===================
public class Shops_ByTShirt_Fanout : AbstractIndexCreationTask<OnlineShop>
{
    public class IndexEntry
    {
        // The index-fields:
        public string Color { get; set; }
        public string Size { get; set; }
        public string Logo { get; set; }
    }
    
    public Shops_ByTShirt_Fanout()
    {
        Map = shops =>
            from shop in shops
            from shirt in shop.TShirts
            // Creating MULTIPLE index-entries per document,
            // an index-entry for each sub-object in the TShirts list
            select new IndexEntry
            {
                Color = shirt.Color,
                Size = shirt.Size,
                Logo = shirt.Logo
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="csharp">
{`public class Shops_ByTShirt_JS : AbstractJavaScriptIndexCreationTask
{
    public Shops_ByTShirt_JS()
    {
        Maps = new HashSet<string>
        {
            @"map('OnlineShops', function (shop){ 
                   var res = [];
                   shop.TShirts.forEach(shirt => {
                       res.push({
                           Color: shirt.Color,
                           Size: shirt.Size,
                           Logo: shirt.Logo
                       })
                    });
                    return res;
                })"
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Query the fanout index:
// =======================
var shopsThatHaveMediumRedShirts = session
    .Query<Shops_ByTShirt_Fanout.IndexEntry, Shops_ByTShirt_Fanout>()
     // Query for documents that have a "Medium Red TShirt"
    .Where(x => x.Color == "red" && x.Size == "M")
    .OfType<OnlineShop>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Query the fanout index:
// =======================
var shopsThatHaveMediumRedShirts = await asyncSession
    .Query<Shops_ByTShirt_Fanout.IndexEntry, Shops_ByTShirt_Fanout>()
     // Query for documents that have a "Medium Red TShirt"
    .Where(x => x.Color == "red" && x.Size == "M")
    .OfType<OnlineShop>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Query the fanout index:
// =======================
var shopsThatHaveMediumRedShirts = session.Advanced
    .DocumentQuery<Shops_ByTShirt_Fanout.IndexEntry, Shops_ByTShirt_Fanout>()
     // Query for documents that have a "Medium Red TShirt"
    .WhereEquals(x => x.Color, "red")
    .AndAlso()
    .WhereEquals(x=> x.Size, "M")
    .OfType<OnlineShop>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Shops/ByTShirt/Fanout" 
where Color == "red" and Size == "M"
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="results_3" label="results_3">
<CodeBlock language="csharp">
{`// Query results:
// ==============

// Only the 'Shop1' document will be returned,
// since it is the only document that has the requested combination within the TShirt list.
`}
</CodeBlock>
</TabItem>
<a id="fanoutMapIndexIndexEntries"/> __The index-entries__:

![Fanout - index-entries](./assets/indexing-nested-data-2.png)

1. The index-entries content is visible from the Studio [Query view](../studio/database/queries/query-view.mdx).

2. Check option: _Show raw index-entries instead of Matching documents_.

3. Each row represents an __index-entry__.  
   Each index-entry corresponds to an inner item in the TShirt list.

4. In this example, the total number of index-entries is __12__,  
   which is the total number of inner items in the TShirt list in all __3__ documents in the collection.

</Admonition>

<Admonition type="note" title="Note">

<a id="fanoutMapReduceIndex"/> __Fanout index - Map-Reduce index example__:

* The fanout index concept applies to map-reduce indexes as well:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
<CodeBlock language="csharp">
{`// A fanout map-reduce index:
// ==========================
public class Sales_ByTShirtColor_Fanout : 
    AbstractIndexCreationTask<OnlineShop, Sales_ByTShirtColor_Fanout.IndexEntry>
{
    public class IndexEntry
    {
        // The index-fields:
        public string Color { get; set; }
        public int ItemsSold { get; set; }
        public decimal TotalSales { get; set; }
    }

    public Sales_ByTShirtColor_Fanout()
    {
        Map = shops => 
            from shop in shops
            from shirt in shop.TShirts
            // Creating MULTIPLE index-entries per document,
            // an index-entry for each sub-object in the TShirts list
            select new IndexEntry
            {
                Color = shirt.Color,
                ItemsSold = shirt.Sold,
                TotalSales = shirt.Price * shirt.Sold
            };

        Reduce = results => from result in results
            group result by result.Color
            into g
            select new
            {
                // Calculate sales per color
                Color = g.Key,
                ItemsSold = g.Sum(x => x.ItemsSold),
                TotalSales = g.Sum(x => x.TotalSales)
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="csharp">
{`public class Product_Sales : AbstractJavaScriptIndexCreationTask
{
    public class Result
    {
        public string Product { get; set; }

        public int Count { get; set; }

        public decimal Total { get; set; }
    }

    public Product_Sales()
    {
        Maps = new HashSet<string>()
        {
            @"map('orders', function(order){
                    var res = [];
                    order.Lines.forEach(l => {
                        res.push({
                            Product: l.Product,
                            Count: 1,
                            Total:  (l.Quantity * l.PricePerUnit) * (1- l.Discount)
                        })
                    });
                    return res;
                })"
        };

        Reduce = @"groupBy(x => x.Product)
            .aggregate(g => {
                return {
                    Product : g.key,
                    Count: g.values.reduce((sum, x) => x.Count + sum, 0),
                    Total: g.values.reduce((sum, x) => x.Total + sum, 0)
                }
            })";
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Query the fanout index:
// =======================
var queryResult = session
    .Query<Sales_ByTShirtColor_Fanout.IndexEntry, Sales_ByTShirtColor_Fanout>()
     // Query for index-entries that contain "black"
    .Where(x => x.Color == "black")
    .FirstOrDefault();

// Get total sales for black TShirts
var blackShirtsSales = queryResult?.TotalSales ?? 0;
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Query the fanout index:
// =======================
var queryResult = await asyncSession
    .Query<Sales_ByTShirtColor_Fanout.IndexEntry, Sales_ByTShirtColor_Fanout>()
     // Query for index-entries that contain "black"
    .Where(x => x.Color == "black")
    .FirstOrDefaultAsync();

// Get total sales for black TShirts
var blackShirtsSales = queryResult?.TotalSales ?? 0;
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Query the fanout index:
// =======================
var queryResult = session.Advanced
    .DocumentQuery<Sales_ByTShirtColor_Fanout.IndexEntry, Sales_ByTShirtColor_Fanout>()
    // Query for index-entries that contain "black"
    .WhereEquals(x => x.Color, "black")
    .FirstOrDefault();

// Get total sales for black TShirts
var blackShirtsSales = queryResult?.TotalSales ?? 0;
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Sales/ByTShirtColor/Fanout"
where Color == "black"
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="results_4" label="results_4">
<CodeBlock language="csharp">
{`// Query results:
// ==============

// With the sample data used in this article,
// The total sales revenue from black TShirts sold (in all shops) is 490.0
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

<a id="performanceHints"/> __Fanout index - Performance hints__:

* Fanout indexes are typically more resource-intensive than other indexes as RavenDB has to index a large number of index-entries. 
  This increased workload can lead to higher CPU and memory utilization, potentially causing a decline in the overall performance of the index.

* When the number of index-entries generated from a single document exceeds a configurable limit,  
  RavenDB will issue a __High indexing fanout ratio__ alert in the Studio notification center.

* You can control when this performance hint is created by setting the 
  [PerformanceHints.Indexing.MaxIndexOutputsPerDocument](../server/configuration/performance-hints-configuration.mdx#performancehintsindexingmaxindexoutputsperdocument) configuration key 
  (default is 1024).

* So, for example, adding another OnlineShop document with a `tShirt` object containing 1025 items  
  will trigger the following alert:  

    ![Figure 1. High indexing fanout ratio notification](./assets/fanout-index-performance-hint-1.png)

* Clicking the 'Details' button will show the following info:  

    ![Figure 2. Fanout index, performance hint details](./assets/fanout-index-performance-hint-2.png)

</Admonition>

<Admonition type="note" title="Note">

<a id="paging"/> __Fanout index - Paging__:

* A fanout index has more index-entries than the number of documents in the collection indexed.  
  Multiple index-entries "point" to the same document from which they originated,  
  as can be seen in the above [index-entries](../indexes/indexing-nested-data.mdx#fanoutMapIndexIndexEntries) example.

* When making a fanout index query that should return full documents (without projecting results),  
  then in this case, the `TotalResults` property (available via the `QueryStatistics` object) will contain  
  the total number of index-entries and Not the total number of resulting documents.

* __To overcome this when paging results__, you must take into account the number of "duplicate"  
  index-entries that are skipped internally by the server when serving the resulting documents.  

* Please refer to [paging through tampered results](../indexes/querying/paging.mdx#paging-through-tampered-results) for further explanation and examples. 

</Admonition>




</LanguageContent>
<LanguageContent language="java">


The fanout index is the index that outputs multiple index entries per each document. Here is an example of such one:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="java">
{`public static class Orders_ByProduct extends AbstractIndexCreationTask {
    public Orders_ByProduct() {
        map = "docs.Orders.SelectMany(order => order.Lines, (order, orderLine) => new { " +
            "    Product = orderLine.Product, " +
            "    ProductName = orderLine.ProductName " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Orders_ByProduct extends AbstractJavaScriptIndexCreationTask {
    public Orders_ByProduct() {
        setMaps(Sets.newHashSet("map('Orders', function (order){\\n" +
            "    var res = [];\\n" +
            "    order.Lines.forEach(l => {\\n" +
            "        res.push({\\n" +
            "            Product: l.Product,\\n" +
            "            ProductName: l.ProductName\\n" +
            "        })\\n" +
            "    });\\n" +
            "    return res;\\n" +
            "})"));
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

A large order, having a lot of line items, will create an index entry per each `OrderLine` item from the `Lines` collection. A single document can generate hundreds of index entries.

The fanout index concept is not specific for map-only indexes. It also applies to map-reduce indexes:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="java">
{`public static class Product_Sales extends AbstractIndexCreationTask {
    public Product_Sales() {
        map = "docs.Orders.SelectMany(order => order.Lines, (order, line) => new { " +
            "    Product = line.Product, " +
            "    Count = 1, " +
            "    Total = (((decimal) line.Quantity) * line.PricePerUnit) * (1M - line.Discount) " +
            "})";

        reduce = "results.GroupBy(result => result.Product).Select(g => new {\\n" +
            "    Product = g.Key,\\n" +
            "    Count = Enumerable.Sum(g, x => ((int) x.Count)),\\n" +
            "    Total = Enumerable.Sum(g, x0 => ((decimal) x0.Total))\\n" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Product_Sales extends AbstractJavaScriptIndexCreationTask {
    public Product_Sales() {
        setMaps(Sets.newHashSet("map('orders', function(order){\\n" +
            "            var res = [];\\n" +
            "            order.Lines.forEach(l => {\\n" +
            "              res.push({\\n" +
            "                Product: l.Product,\\n" +
            "                Count: 1,\\n" +
            "                Total:  (l.Quantity * l.PricePerUnit) * (1- l.Discount)\\n" +
            "              })\\n" +
            "            });\\n" +
            "            return res;\\n" +
            "        })"));

        setReduce("groupBy(x => x.Product)\\n" +
            "    .aggregate(g => {\\n" +
            "        return {\\n" +
            "            Product : g.key,\\n" +
            "            Count: g.values.reduce((sum, x) => x.Count + sum, 0),\\n" +
            "            Total: g.values.reduce((sum, x) => x.Total + sum, 0)\\n" +
            "        }\\n" +
            "    })");
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

The above index definitions are correct. In both cases this is actually what we want. However, you need to be aware that fanout indexes are typically more expensive than regular ones.
RavenDB has to index many more entries than usual. What can result is higher utilization of CPU and memory, and overall declining performance of the index.

<Admonition type="note" title="Note" id="note" href="#note">
Starting from version 4.0, the fanout indexes won't error when the number of index entries created from a single document exceeds the configured limit. The configuration options from 3.x:

- `Raven/MaxSimpleIndexOutputsPerDocument` 
- `Raven/MaxMapReduceIndexOutputsPerDocument` 

are no longer valid.

RavenDB will give you a performance hint regarding high fanout ratio using the Studio's notification center.
</Admonition>


## Performance Hints

Once RavenDB notices that the number of indexing outputs created from a document is high, the notification that will appear in the Studio:

![Figure 1. High indexing fanout ratio notification](./assets/fanout-index-performance-hint-1.png)

The details will give you the following info:

![Figure 2. Fanout index, performance hint details](./assets/fanout-index-performance-hint-2.png)

You can control when a performance hint should be created using the `PerformanceHints.Indexing.MaxIndexOutputsPerDocument` setting (default: 1024).

## Paging 

Since the fanout index creates multiple entries for a single document and queries return documents by default (it can change if the query defines the projection) the paging of query results
is a bit more complex. Please read the dedicated article about [paging through tampered results](../indexes/querying/paging.mdx#paging-through-tampered-results).


</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* JSON documents can have nested structures, where one document contains other objects or arrays of objects.

* Use a static-index to facilitate querying for documents based on the nested data.

* In this page:
 
  * [Sample data](../indexes/indexing-nested-data.mdx#sample-data)

  * [Simple index - SINGLE index-entry per document](../indexes/indexing-nested-data.mdx#simple-index---single-index-entry-per-document)    
      * [The index](../indexes/indexing-nested-data.mdx#theIndex)
      * [The index-entries](../indexes/indexing-nested-data.mdx#theIndexEntries)
      * [Querying the index](../indexes/indexing-nested-data.mdx#queryingTheIndex)
      * [When to use](../indexes/indexing-nested-data.mdx#whenToUse)

  * [Fanout index - MULTIPLE index-entries per document](../indexes/indexing-nested-data.mdx#fanout-index---multiple-index-entries-per-document)   
      * [What is a fanout index](../indexes/indexing-nested-data.mdx#whatIsFanoutIndex)
      * [Fanout index - Map index example](../indexes/indexing-nested-data.mdx#fanoutMapIndex)
      * [Fanout index - Map-Reduce index example](../indexes/indexing-nested-data.mdx#fanoutMapReduceIndex)
      * [Performance hints](../indexes/indexing-nested-data.mdx#performanceHints)
      * [Paging](../indexes/indexing-nested-data.mdx#paging)

</Admonition>
## Sample data

* The examples in this article are based on the following __Classes__ and __Sample Data__:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="js">
{`class OnlineShop {
    constructor(
        shopName = '',
        email = '',
        tShirts = {} // Will contain the nested data
    ) {
        Object.assign(this, { shopName, email, tShirts });
    }
}

class TShirt {
    constructor(
        color = '',
        size = '',
        logo = '',
        price = 0,
        sold = 0
    ) {
        Object.assign(this, { color, size, logo, price, sold });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="js">
{`// Creating sample data for the examples in this article:
// ======================================================

const bulkInsert = store.bulkInsert();

const onlineShops = [
    new OnlineShop("Shop1", "sales@shop1.com", [
        new TShirt("Red", "S", "Bytes and Beyond", 25, 2),
        new TShirt("Red", "M", "Bytes and Beyond", 25, 4),
        new TShirt("Blue", "M", "Query Everything", 28, 5),
        new TShirt("Green", "L", "Data Driver", 30, 3)
    ]),
    new OnlineShop("Shop2", "sales@shop2.com", [
        new TShirt("Blue", "S", "Coffee, Code, Repeat", 22, 12),
        new TShirt("Blue", "M", "Coffee, Code, Repeat", 22, 7),
        new TShirt("Green", "M", "Big Data Dreamer", 25, 9),
        new TShirt("Black", "L", "Data Mining Expert", 20, 11)
    ]),
    new OnlineShop("Shop3", "sales@shop3.com", [
        new TShirt("Red", "S", "Bytes of Wisdom", 18, 2),
        new TShirt("Blue", "M", "Data Geek", 20, 6),
        new TShirt("Black", "L", "Data Revolution", 15, 8),
        new TShirt("Black", "XL", "Data Revolution", 15, 10)
    ])
];

for (const shop of onlineShops ) {
    await bulkInsert.store(shop);
}

await bulkInsert.finish();
`}
</CodeBlock>
</TabItem>
</Tabs>



## Simple index - Single index-entry per document


<a id="theIndex"/> __The index__:

<TabItem value="simple_index" label="simple_index">
<CodeBlock language="js">
{`class Shops_ByTShirt_Simple extends AbstractJavaScriptIndexCreationTask \{
    constructor () \{
        super();

        // Creating a SINGLE index-entry per document:
        this.map("OnlineShops", shop => \{
            return \{
                // Each index-field will hold a collection of nested values from the document
                colors: shop.tShirts.map(x => x.color),
                sizes: shop.tShirts.map(x => x.size),
                logos: shop.tShirts.map(x => x.logo)
            \};
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>
<a id="theIndexEntries"/> __The index-entries__:

![Simple - index-entries](./assets/indexing-nested-data-1.png)

1. The index-entries content is visible from the Studio [Query view](../studio/database/queries/query-view.mdx).

2. Check option: _Show raw index-entries instead of Matching documents_.

3. Each row represents an __index-entry__.  
   The index has a single index-entry per document (3 entries in this example).  

4. The index-field contains a collection of ALL nested values from the document.  
   e.g. The third __index-entry__ has the following values in the _Colors_ __index-field__:  
   `{"black", "blue", "red"}`
<a id="queryingTheIndex"/> __Querying the index__:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Query for all shop documents that have a red TShirt
const results = await session
    .query({ indexName: "Shops/ByTShirt/Simple" })
     // Filter query results by a nested value
    .containsAny("colors", ["red"])
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Shops/ByTShirt/Simple"
where colors == "red"
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="results_1" label="results_1">
<CodeBlock language="js">
{`// Results will include the following shop documents:
// ==================================================
// * Shop1
// * Shop3
`}
</CodeBlock>
</TabItem>
<a id="whenToUse"/> __When to use__:

* This type of index structure is effective for retrieving documents when filtering the query by any of the inner nested values that were indexed.

* However, due to the way the index-entries are generated, this index __cannot__ provide results for a query searching for documents that contain 
  specific sub-objects which satisfy some `AND` condition.  
  For example:  

<TabItem value="results_2" label="results_2">
<CodeBlock language="js">
{`// You want to query for shops containing "Large Green TShirts",
// aiming to get only "Shop1" as a result since it has such a combination,
// so you attempt this query:
const greenAndLarge = await session
    .query(\{ indexName: "Shops/ByTShirt/Simple" \})
    .containsAny("colors", ["green"])
    .andAlso()
    .containsAny("sizes", ["L"])
    .all();

// But, the results of this query will include BOTH "Shop1" & "Shop2"
// since the index-entries do not keep the original sub-objects structure.
`}
</CodeBlock>
</TabItem>

* To address this, you must use a __Fanout index__ - as described below.



## Fanout index - Multiple index-entries per document

<Admonition type="note" title="Note">

<a id="whatIsFanoutIndex"/> __What is a Fanout index__:

* A fanout index is an index that outputs multiple index-entries per document.  
  A separate index-entry is created for each nested sub-object from the document.
 
* The fanout index is useful when you need to retrieve documents matching query criteria  
  that search for specific sub-objects that comply with some logical conditions.

</Admonition>

<Admonition type="note" title="Note">

<a id="fanoutMapIndex"/> __Fanout index - Map index example__:

<TabItem value="fanout_index_1" label="fanout_index_1">
<CodeBlock language="js">
{`// A fanout map-index:
// ===================
class Shops_ByTShirt_Fanout extends AbstractJavaScriptIndexCreationTask \{
    constructor () \{
        super();

        // Creating MULTIPLE index-entries per document,
        // an index-entry for each sub-object in the tShirts list
        this.map("OnlineShops", shop => \{
            return shop.tShirts.map(shirt => \{
                return \{
                    color: shirt.color,
                    size: shirt.size,
                    logo: shirt.logo
                \};
            \});
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Query the fanout index:
// =======================
const shopsThatHaveMediumRedShirts = await session
    .query({ indexName: "Shops/ByTShirt/Fanout" })
     // Query for documents that have a "Medium Red TShirt"
    .whereEquals("color", "red")
    .andAlso()
    .whereEquals("size", "M")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Shops/ByTShirt/Fanout" 
where color == "red" and size == "M"
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="results_3" label="results_3">
<CodeBlock language="js">
{`// Query results:
// ==============

// Only the 'Shop1' document will be returned,
// since it is the only document that has the requested combination within the tShirt list.
`}
</CodeBlock>
</TabItem>
<a id="fanoutMapIndexIndexEntries"/> __The index-entries__:

![Fanout - index-entries](./assets/indexing-nested-data-2.png)

1. The index-entries content is visible from the Studio [Query view](../studio/database/queries/query-view.mdx).

2. Check option: _Show raw index-entries instead of Matching documents_.

3. Each row represents an __index-entry__.  
   Each index-entry corresponds to an inner item in the TShirt list.

4. In this example, the total number of index-entries is __12__,  
   which is the total number of inner items in the TShirt list in all __3__ documents in the collection.

</Admonition>

<Admonition type="note" title="Note">

<a id="fanoutMapReduceIndex"/> __Fanout index - Map-Reduce index example__:

* The fanout index concept applies to map-reduce indexes as well:

<TabItem value="fanout_index_2" label="fanout_index_2">
<CodeBlock language="js">
{`// A fanout map-reduce index:
// ==========================
class Sales_ByTShirtColor_Fanout extends AbstractJavaScriptIndexCreationTask \{
    constructor () \{
        super();

        this.map("OnlineShops", shop => \{
            return shop.tShirts.map(shirt => \{
                return \{
                    // Define the index-fields:
                    color: shirt.color,
                    itemsSold: shirt.sold,
                    totalSales: shirt.price * shirt.sold
                \};
            \});
        \});

        this.reduce(results => results
            .groupBy(shirt => shirt.color)
            .aggregate(g => \{
                return \{
                    // Calculate sales per color
                    color: g.key,
                    itemsSold: g.values.reduce((p, c) => p + c.itemsSold, 0),
                    totalSales: g.values.reduce((p, c) => p + c.totalSales, 0),
                \}
            \}));
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Query the fanout index:
// =======================
const queryResult = await session
    .query({ indexName: "Sales/ByTShirtColor/Fanout" })
     // Query for index-entries that contain "black"
    .whereEquals("color", "black")
    .firstOrNull();

// Get total sales for black TShirts
const blackShirtsSales = queryResult?.totalSales ?? 0;
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Sales/ByTShirtColor/Fanout"
where color == "black"
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="results_4" label="results_4">
<CodeBlock language="js">
{`// Query results:
// ==============

// With the sample data used in this article,
// The total sales revenue from black TShirts sold (in all shops) is 490
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

<a id="performanceHints"/> __Fanout index - Performance hints__:

* Fanout indexes are typically more resource-intensive than other indexes as RavenDB has to index a large number of index-entries. 
  This increased workload can lead to higher CPU and memory utilization, potentially causing a decline in the overall performance of the index.

* When the number of index-entries generated from a single document exceeds a configurable limit,  
  RavenDB will issue a __High indexing fanout ratio__ alert in the Studio notification center.

* You can control when this performance hint is created by setting the 
  [PerformanceHints.Indexing.MaxIndexOutputsPerDocument](../server/configuration/performance-hints-configuration.mdx#performancehintsindexingmaxindexoutputsperdocument) configuration key 
  (default is 1024).

* So, for example, adding another OnlineShop document with a `tShirt` object containing 1025 items  
  will trigger the following alert: 

    ![Figure 1. High indexing fanout ratio notification](./assets/fanout-index-performance-hint-1.png)

* Clicking the 'Details' button will show the following info:

    ![Figure 2. Fanout index, performance hint details](./assets/fanout-index-performance-hint-2.png)

</Admonition>

<Admonition type="note" title="Note">

<a id="paging"/> __Fanout index - Paging__:

* A fanout index has more index-entries than the number of documents in the collection indexed.  
  Multiple index-entries "point" to the same document from which they originated,  
  as can be seen in the above [index-entries](../indexes/indexing-nested-data.mdx#fanoutMapIndexIndexEntries) example.

* When making a fanout index query that should return full documents (without projecting results),  
  then in this case, the `totalResults` property (available when calling the query `statistics()` method)  
  will contain the total number of index-entries and Not the total number of resulting documents.

* __To overcome this when paging results__, you must take into account the number of "duplicate"  
  index-entries that are skipped internally by the server when serving the resulting documents.  

* Please refer to [paging through tampered results](../indexes/querying/paging.mdx#paging-through-tampered-results) for further explanation and examples. 

</Admonition>




</LanguageContent>

<!---
### Indexes
- [What are Indexes](../indexes/what-are-indexes)

### Querying
- [Intersect queries](../indexes/querying/intersection)


-->