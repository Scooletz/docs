---
title: "Data Subscriptions: Common Data Subscription Creation Examples"
hide_table_of_contents: true
sidebar_label: Examples
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp"];


# Data Subscriptions: Common Data Subscription Creation Examples
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

* In this page:  
   * [Create subscription on all documents in a collection](../../../client-api/data-subscriptions/creation/examples.mdx#create-subscription-on-all-documents-in-a-collection)  
   * [Create subscription with filtering](../../../client-api/data-subscriptions/creation/examples.mdx#create-subscription-with-filtering)  
   * [Create subscription with filtering and projection](../../../client-api/data-subscriptions/creation/examples.mdx#create-subscription-with-filtering-and-projection)  
   * [Create subscription with load document in filter projection](../../../client-api/data-subscriptions/creation/examples.mdx#create-subscription-with-load-document-in-filter-projection)  
   * [Create subscription with include statement](../../../client-api/data-subscriptions/creation/examples.mdx#create-subscription-with-include-statement)  
      * [Including counters](../../../client-api/data-subscriptions/creation/examples.mdx#including-counters)  
   * [Create revisions enabled subscription](../../../client-api/data-subscriptions/creation/examples.mdx#create-revisions-enabled-subscription)  
   * [Update existing subscription](../../../client-api/data-subscriptions/creation/examples.mdx#update-existing-subscription)  
</Admonition>
## Create subscription on all documents in a collection

Here we create a plain subscription on the Orders collection, without any constraint or transformation.
<Tabs groupId='languageSyntax'>
<TabItem value="Generic-syntax" label="Generic-syntax">
<CodeBlock language="csharp">
{`name = await store.Subscriptions.CreateAsync(new SubscriptionCreationOptions<Order>
{
    Name = "OrdersProcessingSumbscription"
});
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL-syntax" label="RQL-syntax">
<CodeBlock language="csharp">
{`name = await store.Subscriptions.CreateAsync(new SubscriptionCreationOptions()
{
    Query = "From Orders"
});
`}
</CodeBlock>
</TabItem>
</Tabs>



## Create subscription with filtering

Here we create a subscription on Orders collection, which total order revenue is greater than 100.
<Tabs groupId='languageSyntax'>
<TabItem value="Generic-syntax" label="Generic-syntax">
<CodeBlock language="csharp">
{`name = await store.Subscriptions.CreateAsync<Order>(x =>
    x.Lines.Sum(line => line.PricePerUnit * line.Quantity) > 100);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL-syntax" label="RQL-syntax">
<CodeBlock language="csharp">
{`name = await store.Subscriptions.CreateAsync(new SubscriptionCreationOptions()
{
    Query = @"
                declare function getOrderLinesSum(doc){
                    var sum = 0;
                    for (var i in doc.Lines) { sum += doc.Lines[i];}
                    return sum;
                }
                From Orders as o 
                Where getOrderLinesSum(o) > 100"
});
`}
</CodeBlock>
</TabItem>
</Tabs>



## Create subscription with filtering and projection

Here we create a subscription on Orders collection, which total order revenue is greater than 100, and return only ID and total revenue.
<Tabs groupId='languageSyntax'>
<TabItem value="Generic-syntax" label="Generic-syntax">
<CodeBlock language="csharp">
{`name = store.Subscriptions.Create(
    new SubscriptionCreationOptions<Order>()
    {
        Filter = x => x.Lines.Sum(line => line.PricePerUnit * line.Quantity) > 100,
        Projection = x => new
        {
            Id = x.Id,
            Total = x.Lines.Sum(line => line.PricePerUnit * line.Quantity)
        }
    });
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL-syntax" label="RQL-syntax">
<CodeBlock language="csharp">
{`name = await store.Subscriptions.CreateAsync(new SubscriptionCreationOptions()
{
    Query = @"declare function getOrderLinesSum(doc){
                    var sum = 0;
                    for (var i in doc.Lines) { sum += doc.Lines[i];}
                    return sum;
                }

                declare function projectOrder(doc){
                    return {
                        Id: order.Id,
                        Total: getOrderLinesSum(order)
                    };
                }

                From Orders as o 
                Where getOrderLinesSum(o) > 100
                Select projectOrder(o)"
});
`}
</CodeBlock>
</TabItem>
</Tabs>



## Create subscription with load document in filter projection

Here we create a subscription on Orders collection, which total order revenue is greater than 100, and return ID, total revenue, shipping address and responsible employee name.
<Tabs groupId='languageSyntax'>
<TabItem value="Generic-syntax" label="Generic-syntax">
<CodeBlock language="csharp">
{`name = store.Subscriptions.Create(
    new SubscriptionCreationOptions<Order>()
    {
        Filter = x => x.Lines.Sum(line => line.PricePerUnit * line.Quantity) > 100,
        Projection = x => new
        {
            Id = x.Id,
            Total = x.Lines.Sum(line => line.PricePerUnit * line.Quantity),
            ShipTo = x.ShipTo,
            EmployeeName = RavenQuery.Load<Employee>(x.Employee).FirstName + " " +
                           RavenQuery.Load<Employee>(x.Employee).LastName
        }
    });
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL-syntax" label="RQL-syntax">
<CodeBlock language="csharp">
{`name = await store.Subscriptions.CreateAsync(new SubscriptionCreationOptions()
{
    Query = @"declare function getOrderLinesSum(doc){
                    var sum = 0;
                    for (var i in doc.Lines) { sum += doc.Lines[i];}
                    return sum;
                }

                declare function projectOrder(doc){
                    var employee = load(doc.Employee);
                    return {
                        Id: order.Id,
                        Total: getOrderLinesSum(order),
                        ShipTo: order.ShipTo,
                        EmployeeName: employee.FirstName + ' ' + employee.LastName

                    };
                }

                From Orders as o 
                Where getOrderLinesSum(o) > 100
                Select projectOrder(o)"
});
`}
</CodeBlock>
</TabItem>
</Tabs>



## Create subscription with include statement

Here we create a subscription on the collection Orders, which returns the orders and brings along all products mentioned in the order as included documents. 
See the usage example [here](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-uses-included-documents).

Include statements can be added to a subscription in the raw RQL, or with the **`ISubscriptionIncludeBuilder`**.  

The subscription include builder is assigned to the option **Includes** in `SubscriptionCreationOptions<T>` 
(see [subscription API overview](../../../client-api/data-subscriptions/creation/api-overview.mdx)). It 
supports methods for including documents as well as counters. These methods can be chained.  

In raw RQL, include statements come in two forms, like in any other RQL statements:  
1. Include statement in the end of the query, starting with the `include` keyword, followed by paths to the field containing the IDs of the documents to include.  
If projection is performed, the mechanism will look for the paths in the projected result, rather then the original document.  
It is recommended to prefer this approach when possible both because of clarity of the query and slightly better performance.  
2. Include function call inside a 'declared' function.  

<Tabs groupId='languageSyntax'>
<TabItem value="Builder-syntax" label="Builder-syntax">
<CodeBlock language="csharp">
{`store.Subscriptions.Create(new SubscriptionCreationOptions<Order>()
{
    Includes = builder => builder
        .IncludeDocuments(x => x.Lines.Select(y => y.Product))
});
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL-path-syntax" label="RQL-path-syntax">
<CodeBlock language="csharp">
{`store.Subscriptions.Create(new SubscriptionCreationOptions()
{
    Query = @"from Orders include Lines[].Product"
});
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL-javascript-syntax" label="RQL-javascript-syntax">
<CodeBlock language="csharp">
{`store.Subscriptions.Create(new SubscriptionCreationOptions()
{
    Query = @"
                declare function includeProducts(doc) 
                {
                    doc.IncludedFields=0;
                    doc.LinesCount = doc.Lines.length;
                    for (let i=0; i< doc.Lines.length; i++)
                    {
                        doc.IncludedFields++;
                        include(doc.Lines[i].Product);
                    }
                    return doc;
                }
                from Orders as o select includeProducts(o)"
});
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Including Counters

`ISubscriptionIncludeBuilder` has three methods for including counters:  

<TabItem value="include_builder_counter_methods" label="include_builder_counter_methods">
<CodeBlock language="csharp">
{`// Include a single counter
ISubscriptionIncludeBuilder<T> IncludeCounter(string name);

// Include multiple counters
ISubscriptionIncludeBuilder<T> IncludeCounters(string[] names);

// Include ALL counters from ALL documents that match the subscription criteria
ISubscriptionIncludeBuilder<T> IncludeAllCounters();
`}
</CodeBlock>
</TabItem>

`IncludeCounter` is used to specify a single counter, and `IncludeCounters` for multiple counters. `IncludeAllCounters` 
retrieves all counters from all subscribed documents.  

| Parameters | Type | Description |
| - | - | - |
| **name** | `string` | The name of a counter. The subscription will include all counters with this name that are contained in the documents the subscription retrieves. |
| **names** | `string[]` | Array of counter names. |

In this example, we create a subscription that uses all three methods to include counters. This demonstrates 
how the methods can be chained (needless to say, calling `IncludeAllCounters()` makes the other two methods 
redundant).  

<TabItem value="create_subscription_include_counters_builder" label="create_subscription_include_counters_builder">
<CodeBlock language="csharp">
{`subscriptionName = store.Subscriptions.Create<Order>(new SubscriptionCreationOptions<Order>()
\{
    Includes = builder => builder
         // Values for the specified counters will be included in the batch
        .IncludeCounters(new[] \{ "Pros", "Cons" \})
\});
`}
</CodeBlock>
</TabItem>




## Create revisions enabled subscription

Here we create a subscription on Orders collection, which returns current and previous version of the subscriptions. 
Please see the [page](../../../client-api/data-subscriptions/advanced-topics/subscription-with-revisioning.mdx) dedicated to subscriptions with revisions for more details and examples.

<Tabs groupId='languageSyntax'>
<TabItem value="Generic-syntax" label="Generic-syntax">
<CodeBlock language="csharp">
{`name = store.Subscriptions.Create(
    new SubscriptionCreationOptions<Revision<Order>>());
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL-syntax" label="RQL-syntax">
<CodeBlock language="csharp">
{`name = await store.Subscriptions.CreateAsync(new SubscriptionCreationOptions()
{
    Query = @"From Orders (Revisions = true)"
});
`}
</CodeBlock>
</TabItem>
</Tabs>



## Update existing subscription

Here we update the filter query of an existing data subscription named "my subscription".  

<TabItem value="update_subscription_example_0" label="update_subscription_example_0">
<CodeBlock language="csharp">
{`subscriptionName = store.Subscriptions.Update(new SubscriptionUpdateOptions()
\{
    // Specify the subscription you wish to modify
    Name = "my subscription",
    
    // Provide a new query
    Query = "from Products where PricePerUnit > 50" 
\});
`}
</CodeBlock>
</TabItem>

In addition to names, subscriptions also have a **subscription ID** on the server side. The 
ID can be used to identify the subscription instead of using its name. This allows use to change 
an existing subscription's name by specifying the subscription with the ID, and submitting 
a new string in the `Name` field of the `SubscriptionUpdateOptions`.  

<TabItem value="update_subscription_example_1" label="update_subscription_example_1">
<CodeBlock language="csharp">
{`// Get the subscription's ID
SubscriptionState mySubscription = store.Subscriptions.GetSubscriptionState("my subscription");
long subscriptionId = mySubscription.SubscriptionId;

// Update the subscription
subscriptionName = store.Subscriptions.Update(new SubscriptionUpdateOptions()
\{
    Id = subscriptionId,
    Query = "from Products where PricePerUnit > 50" 
\});
`}
</CodeBlock>
</TabItem>




</LanguageContent>

<!---
### Data Subscriptions:
- [What are Data Subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions)
- [How to Create a Data Subscription](../../../client-api/data-subscriptions/creation/how-to-create-data-subscription)
- [How to Consume a Data Subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription)

### Knowledge Base:
- [JavaScript Engine](../../../server/kb/javascript-engine)


-->