---
title: "Indexing Spatial Data"
hide_table_of_contents: true
sidebar_label: Indexing Spatial Data
sidebar_position: 15
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexing Spatial Data
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Documents that contain spatial data can be queried by spatial queries that employ geographical criteria.  
  You have two options:  

  * __Dynamic spatial query__  
    Either make a dynamic spatial query on a collection (see [how to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query.mdx)).  
    An auto-index will be created by the server.  
  
  * __Spatial index query__  
    Or, index your documents' spatial data in a static-index ( __described in this article__ ),  
    and then make a spatial query on this index (see [query a spatial index](../indexes/querying/spatial.mdx)).

* In this page:
  * [Create index with spatial field](../indexes/indexing-spatial-data.mdx#create-index-with-spatial-field)
  * [Customize coordinate system and strategy](../indexes/indexing-spatial-data.mdx#customize-coordinate-system-and-strategy)
  * [Spatial indexing strategies](../indexes/indexing-spatial-data.mdx#spatial-indexing-strategies)

</Admonition>
## Create index with spatial field

* Use `CreateSpatialField` to index spatial data in a static-index.

* You can then retrieve documents based on geographical criteria when making a spatial query on this index-field.

* A spatial index can also be defined from the [Studio](../studio/database/indexes/create-map-index.mdx#spatial-field-options). 

<Admonition type="note" title="Note">

__Exmaple__:

<Tabs groupId='languageSyntax'>
<TabItem value="Indexing_coordinates" label="Indexing_coordinates">
<CodeBlock language="csharp">
{`// Define an index with a spatial field
public class Events_ByNameAndCoordinates : AbstractIndexCreationTask<Event>
{
    public Events_ByNameAndCoordinates()
    {
        Map = events => from e in events
            select new
            {
                Name = e.Name,
                // Call 'CreateSpatialField' to create a spatial index-field
                // Field 'Coordinates' will be composed of lat & lng supplied from the document
                Coordinates = CreateSpatialField(e.Latitude, e.Longitude)
                
                // Documents can be retrieved
                // by making a spatial query on the 'Coordinates' index-field
            };
    }
}

public class Event
{
    public string Id { get; set; }
    public string Name { get; set; }
    public double Latitude { get; set; }
    public double Longitude { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Indexing_WKT" label="Indexing_WKT">
<CodeBlock language="csharp">
{`// Define an index with a spatial field
public class EventsWithWKT_ByNameAndWKT : AbstractIndexCreationTask<EventWithWKT>
{
    public EventsWithWKT_ByNameAndWKT()
    {
        Map = events => from e in events
            select new
            {
                Name = e.Name,
                // Call 'CreateSpatialField' to create a spatial index-field
                // Field 'WKT' will be composed of the WKT string supplied from the document
                WKT = CreateSpatialField(e.WKT)

                // Documents can be retrieved
                // by making a spatial query on the 'WKT' index-field
            };
    }
}

public class EventWithWKT
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string WKT { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="csharp">
{`public class Events_ByNameAndCoordinates_JS : AbstractJavaScriptIndexCreationTask
{
    public Events_ByNameAndCoordinates_JS()
    {
        Maps = new HashSet<string>
        {
            @"map('events', function (e) {
                    return { 
                        Name: e.Name,
                        Coordinates: createSpatialField(e.Latitude, e.Longitude)
                    };
            })"
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">

__Syntax__:

<TabItem value="spatial_syntax_1" label="spatial_syntax_1">
<CodeBlock language="csharp">
{`object CreateSpatialField(double? lat, double? lng); // Latitude/Longitude coordinates
object CreateSpatialField(string shapeWkt);          // Shape in WKT string format
`}
</CodeBlock>
</TabItem>

</Admonition>



## Customize coordinate system and strategy

* For each spatial index-field, you can specify the __coordinate system__ and __strategy__ to be used  
  during indexing and when processing the data at query time.

* RavenDB supports both the `Geography` and `Cartesian` systems with the following strategies:

  * Geography system:
      * BoundingBox
      * GeoHashPrefixTree
      * QuadPrefixTree

  * Cartesian system:
      * BoundingBox
      * QuadPrefixTree

* __By default__, the `GeoHashPrefixTree` strategy is used with `GeoHashLevel` set to __9__.  
  Use the `Spatial` method from `AbstractIndexCreationTask` to modify this setting.

* The performance cost of spatial indexing is directly related to the tree level chosen.  
  Learn more about each strategy [below](../indexes/indexing-spatial-data.mdx#spatial-indexing-strategies).

* Note: Modifying the strategy after the index has been created & deployed will trigger the re-indexing.

<Admonition type="note" title="Note">

__Exmaple__:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Events_ByNameAndCoordinates_Custom : AbstractIndexCreationTask<Event>
{
    public Events_ByNameAndCoordinates_Custom()
    {
        Map = events => from e in events
                        select new
                        {
                            Name = e.Name,
                            // Define a spatial index-field
                            Coordinates = CreateSpatialField(e.Latitude, e.Longitude)
                        };

        // Set the spatial indexing strategy for the spatial field 'Coordinates' 
        Spatial("Coordinates", factory => factory.Cartesian.BoundingBoxIndex());
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="csharp">
{`public class Events_ByNameAndCoordinates_Custom_JS : AbstractJavaScriptIndexCreationTask
{
    public Events_ByNameAndCoordinates_Custom_JS()
    {
        // Define index fields
        Maps = new HashSet<string>
        {
            @"map('events', function (e) {
                    return { 
                        Name: e.Name,
                        Coordinates: createSpatialField(e.Latitude, e.Longitude)
                    };
            })"
        };
        
        // Customize index fields
        Fields = new Dictionary<string, IndexFieldOptions>
        {
            ["Coordinates"] = new IndexFieldOptions
            {
                Spatial = new SpatialOptions
                {
                    Type = SpatialFieldType.Cartesian,
                    Strategy = SpatialSearchStrategy.BoundingBox
                }
            }
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">

__Syntax__:

<TabItem value="spatial_syntax_2" label="spatial_syntax_2">
<CodeBlock language="csharp">
{`public class SpatialOptionsFactory
\{
    public GeographySpatialOptionsFactory Geography;
    public CartesianSpatialOptionsFactory Cartesian;
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="csharp">
{`// Default is GeohashPrefixTree strategy with maxTreeLevel set to 9
SpatialOptions Default(SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);

SpatialOptions BoundingBoxIndex(SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);

SpatialOptions GeohashPrefixTreeIndex(int maxTreeLevel,
    SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);

SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel,
    SpatialUnits circleRadiusUnits = SpatialUnits.Kilometers);
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="csharp">
{`SpatialOptions BoundingBoxIndex();
SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel, SpatialBounds bounds);

public class SpatialBounds
{
    public double MinX;
    public double MaxX;
    public double MinY;
    public double MaxY;
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



## Spatial indexing strategies

<Admonition type="note" title="BoundingBox" id="boundingbox" href="#boundingbox">

* The bounding box strategy is the simplest.  
  Given a spatial shape, such as a point, circle, or polygon, the shape's bounding box is computed  
  and the spatial coordinates (minX, minY, maxX, maxY) that enclose the shape are indexed.

* When making a query,  
  RavenDB translates the query criteria to the same bounding box system used for indexing. 

* Bounding box strategy is cheaper at indexing time and can produce quick queries,  
  but that's at the expense of the level of accuracy you can get.  

* Read more about bounding box [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).

</Admonition>

<Admonition type="note" title="GeoHashPrefixTree" id="geohashprefixtree" href="#geohashprefixtree">

* Geohash is a latitude/longitude representation system that describes Earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. 
  Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

* E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) 
  and it represents the `40.7144 -74.0060` coordinates. 
  Removing characters from the end of the geohash will decrease the precision level.

* The `maxTreeLevel` determines the length of the geohash used for the indexing, which in turn affects accuracy. 
  By default, it is set to __9__, providing a resolution of approximately 2.5 meters.

* More information about geohash uses, decoding algorithm, and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).

__Geohash precision values__:

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |

</Admonition>

<Admonition type="note" title="QuadPrefixTree" id="quadprefixtree" href="#quadprefixtree">

* The QuadTree represents Earth as a grid consisting of four cells (also known as buckets).
  Similar to GeoHash, each cell is assigned a letter, and is recursively divided into four more cells, creating a hierarchical structure. 

* By default, the precision level (`maxTreeLevel`) for QuadPrefixTree is __23__.

* More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).

__Quadtree precision values__:

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |

</Admonition>



## Remarks

<Admonition type="info" title="Info">

Distance by default is measured in __kilometers__.

</Admonition>


</LanguageContent>
<LanguageContent language="java">


To support the ability to retrieve the data based on spatial coordinates, the spatial search has been introduced.

<Admonition type="info" title="Info">
This article describes how to setup a spatial field in static index. If you are interested in an automatic approach, please visit relevant spatial querying article that can be found [here](../indexes/querying/spatial.mdx).
</Admonition>

## Creating Indexes

To take an advantage of the spatial search, first we need to create an index with a spatial field. To mark field as the spatial field, we need to use the `CreateSpatialField` method:

<TabItem value="spatial_search_0" label="spatial_search_0">
<CodeBlock language="java">
{`object CreateSpatialField(double? lat, double? lng);

object CreateSpatialField(string shapeWkt);
`}
</CodeBlock>
</TabItem>

Where:   
     
*	**lat/lng** are latitude/longitude coordinates   
*	**shapeWKT** is a shape in the [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) format    

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Coordinates" label="Coordinates">
<CodeBlock language="java">
{`public static class Event {
    private String id;
    private String name;
    private double latitude;
    private double longitude;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getLatitude() {
        return latitude;
    }

    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }
}

public static class Events_ByNameAndCoordinates extends AbstractIndexCreationTask {
    public Events_ByNameAndCoordinates() {
        map = "docs.Events.Select(e => new { " +
            "    name = e.name, " +
            "    coordinates = this.CreateSpatialField(((double ? ) e.latitude), ((double ? ) e.longitude)) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="WKT" label="WKT">
<CodeBlock language="java">
{`public static class EventWithWKT {
    private String id;
    private String name;
    private String wkt;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getWkt() {
        return wkt;
    }

    public void setWkt(String wkt) {
        this.wkt = wkt;
    }
}

public static class EventsWithWKT_ByNameAndWKT extends AbstractIndexCreationTask {
    public EventsWithWKT_ByNameAndWKT() {
        map = "docs.EventWithWKTs.Select(e => new { " +
            "    name = e.name, " +
            "    wkt = this.CreateSpatialField(e.wkt) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Events_ByNameAndCoordinates extends AbstractJavaScriptIndexCreationTask {
    public Events_ByNameAndCoordinates() {
        setMaps(Sets.newHashSet("map('events', function (e){\\n" +
            "    return {\\n" +
            "        name: e.name  ,\\n" +
            "        coordinates: createSpatialField(e.latitude, e.longitude)\\n" +
            "    };\\n" +
            "})"));
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Options

RavenDB supports both the `Geography` and `Cartesian` systems and multiple strategies for each one of them.

<TabItem value="spatial_search_enhancements_3" label="spatial_search_enhancements_3">
<CodeBlock language="java">
{`public static class SpatialOptionsFactory \{
    public GeographySpatialOptionsFactory geography()

    public CartesianSpatialOptionsFactory cartesian()
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="java">
{`public SpatialOptions defaultOptions()

public SpatialOptions defaultOptions(SpatialUnits circleRadiusUnits)

public SpatialOptions boundingBoxIndex()

public SpatialOptions boundingBoxIndex(SpatialUnits circleRadiusUnits)

public SpatialOptions geohashPrefixTreeIndex(int maxTreeLevel)

public SpatialOptions geohashPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits)

public SpatialOptions quadPrefixTreeIndex(int maxTreeLevel)

public SpatialOptions quadPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits)
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="java">
{`public SpatialOptions boundingBoxIndex()

public SpatialOptions quadPrefixTreeIndex(int maxTreeLevel, SpatialBounds bounds)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Changing Default Behavior

By default, if no action is taken, the `GeohashPrefixTree` strategy is used with `GeohashLevel` set to **9**. This behavior can be changed by using the `spatial()` method from `AbstractIndexCreationTask`

<TabItem value="spatial_search_3" label="spatial_search_3">
<CodeBlock language="java">
{`public static class Events_ByNameAndCoordinates_Custom extends AbstractIndexCreationTask \{
    public Events_ByNameAndCoordinates_Custom() \{
        map = "docs.Events.Select(e => new \{ " +
            "    name = e.name, " +
            "    coordinates = this.CreateSpatialField(((double ? ) e.latitude), ((double ? ) e.longitude)) " +
            "\})";

        spatial("coordinates", f -> f.cartesian().boundingBoxIndex());
    \}
\}
`}
</CodeBlock>
</TabItem>

## Spatial search strategies

## GeohashPrefixTree
Geohash is a latitude/longitude representation system that describes earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) and it represents the `40.7144 -74.0060` coordinates. Removing characters from the end of geohash will decrease the precision level.

More information about geohash uses, decoding algorithm and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).


## QuadPrefixTree
QuadTree represents the earth as a grid with exactly four cells and similarly to geohash, each grid cell (sometimes called a bucket) has a letter assigned, and is divided further into 4 more cells and so on.

More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).


## BoundingBox
More information about BoundingBox can be found [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).


<Admonition type="warning" title="Warning">
`GeohashPrefixTree` is a default `SpatialSearchStrategy`. Doing any changes to the strategy after an index has been created will trigger the re-indexation process.
</Admonition>

### Precision

By default, the precision level (`maxTreeLevel`) for GeohashPrefixTree is set to **9** and for QuadPrefixTree the value is **23**. This means that the coordinates are represented by a 9 or 23 character string. The difference exists because the `QuadTree` representation would be much less precise if the level would be the same.

## Geohash precision values
Source: unterbahn.com

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |



## Quadtree precision values

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |



## Remarks

<Admonition type="info" title="Info">
You can read more about **spatial search** in a **dedicated querying article** available [here](../indexes/querying/spatial.mdx).
</Admonition>

<Admonition type="warning" title="Warning">
Distance by default is measured in **kilometers**.
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Documents that contain spatial data can be queried by spatial queries that employ geographical criteria.  
  You have two options:  

  * __Dynamic spatial query__  
    Either make a dynamic spatial query on a collection (see [how to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query.mdx)).  
    An auto-index will be created by the server.  
  
  * __Spatial index query__  
    Or, index your documents' spatial data in a static-index ( __described in this article__ ),  
    and then make a spatial query on this index (see [query a spatial index](../indexes/querying/spatial.mdx)).

* In this page:
  * [Create index with spatial field](../indexes/indexing-spatial-data.mdx#create-index-with-spatial-field)
  * [Customize coordinate system and strategy](../indexes/indexing-spatial-data.mdx#customize-coordinate-system-and-strategy)
  * [Spatial indexing strategies](../indexes/indexing-spatial-data.mdx#spatial-indexing-strategies)

</Admonition>
## Create index with spatial field

* Use `createSpatialField` to index spatial data in a static-index.

* You can then retrieve documents based on geographical criteria when making a spatial query on this index-field.

* A spatial index can also be defined from the [Studio](../studio/database/indexes/create-map-index.mdx#spatial-field-options). 

<Admonition type="note" title="Note">

__Exmaple__:

<Tabs groupId='languageSyntax'>
<TabItem value="Indexing_coordinates" label="Indexing_coordinates">
<CodeBlock language="js">
{`// Define an index with a spatial field
class Events_ByNameAndCoordinates extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();
        const { createSpatialField } = this.mapUtils();

        this.map('events', e => {
            return {
                name: e.Name,
                // Call 'createSpatialField' to create a spatial index-field
                // Field 'coordinates' will be composed of lat & lng supplied from the document
                coordinates: createSpatialField(
                    e.latitude,
                    e.longitude
                )
                
                // Documents can be retrieved
                // by making a spatial query on the 'coordinates' index-field
            };
        });
    }
}

class Event {
    constructor(id, name, latitude, longitude) {
        this.id = id;
        this.name = name;
        this.latitude = latitude
        this.longitude = longitude;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Indexing_WKT" label="Indexing_WKT">
<CodeBlock language="js">
{`// Define an index with a spatial field
class EventsWithWKT_ByNameAndWKT extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();
        const { createSpatialField } = this.mapUtils();

        this.map('events', e => {
            return {
                name: e.Name,
                // Call 'createSpatialField' to create a spatial index-field
                // Field 'wkt' will be composed of the WKT string supplied from the document
                wkt: createSpatialField(e.wkt)

                // Documents can be retrieved by
                // making a spatial query on the 'wkt' index-field
            };
        });
    }
}

class EventWithWKT {
    constructor(id, name, wkt) {
        this.id = id;
        this.name = name;
        this.wkt = wkt;
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">

__Syntax__:

<TabItem value="spatial_syntax_1" label="spatial_syntax_1">
<CodeBlock language="js">
{`createSpatialField(lat, lng);
createSpatialField(wkt);
`}
</CodeBlock>
</TabItem>

| Parameters | Type     | Description                |
|------------|----------|----------------------------|
| __lat__    | `number` | Latitude coordinate        |
| __lng__    | `number` | Longitude coordinate       |
| __wkt__    | `string` | Shape in WKT string format |

</Admonition>



## Customize coordinate system and strategy

* For each spatial index-field, you can specify the __coordinate system__ and __strategy__ to be used  
  during indexing and when processing the data at query time.

* RavenDB supports both the `Geography` and `Cartesian` systems with the following strategies:

  * Geography system:
      * BoundingBox
      * GeoHashPrefixTree
      * QuadPrefixTree

  * Cartesian system:
      * BoundingBox
      * QuadPrefixTree

* __By default__, the `GeoHashPrefixTree` strategy is used with `GeoHashLevel` set to __9__.  
  Use the `spatial` method to modify this setting.

* The performance cost of spatial indexing is directly related to the tree level chosen.  
  Learn more about each strategy [below](../indexes/indexing-spatial-data.mdx#spatial-indexing-strategies).

* Note: Modifying the strategy after the index has been created & deployed will trigger the re-indexing.

<Admonition type="note" title="Note">

__Exmaple__:

<TabItem value="spatial_index_3" label="spatial_index_3">
<CodeBlock language="js">
{`class Events_ByNameAndCoordinates_Custom extends AbstractJavaScriptIndexCreationTask \{
    constructor() \{
        super();
        const \{ createSpatialField \} = this.mapUtils();

        this.map('events', e => \{
            return \{
                name: e.Name,
                // Define a spatial index-field
                coordinates: createSpatialField(
                    e.latitude,
                    e.longitude
                )

                // Documents can be retrieved
                // by making a spatial query on the 'coordinates' index-field
            \};
        \});

        // Set the spatial indexing strategy for the spatial field 'coordinates' 
        this.spatial("coordinates", factory => factory.cartesian().boundingBoxIndex());
    \}
\}
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

__Syntax__:

<TabItem value="spatial_syntax_2" label="spatial_syntax_2">
<CodeBlock language="js">
{`class SpatialOptionsFactory \{
    geography(): GeographySpatialOptionsFactory;
    cartesian(): CartesianSpatialOptionsFactory;
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="js">
{`defaultOptions(circleRadiusUnits);
boundingBoxIndex(circleRadiusUnits);
geohashPrefixTreeIndex(maxTreeLevel, circleRadiusUnits);
quadPrefixTreeIndex(maxTreeLevel, circleRadiusUnits);
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="js">
{`boundingBoxIndex(): SpatialOptions;
quadPrefixTreeIndex(maxTreeLevel, bounds);

class SpatialBounds {
    minX; // number
    maxX; // number
    minY; // number
    maxY; // number
}
`}
</CodeBlock>
</TabItem>
</Tabs>

| Parameters            | Type            | Description                                       |
|-----------------------|-----------------|---------------------------------------------------|
| __circleRadiusUnits__ | `string`        | "Kilometers" or "Miles"                           |
| __maxTreeLevel__      | `number`        | Controls precision level                          |
| __bounds__            | `SpatialBounds` | Coordinates for the cartesian quadPrefixTreeIndex |

</Admonition>



## Spatial indexing strategies

<Admonition type="note" title="BoundingBox" id="boundingbox" href="#boundingbox">

* The bounding box strategy is the simplest.  
  Given a spatial shape, such as a point, circle, or polygon, the shape's bounding box is computed  
  and the spatial coordinates (minX, minY, maxX, maxY) that enclose the shape are indexed.

* When making a query,  
  RavenDB translates the query criteria to the same bounding box system used for indexing. 

* Bounding box strategy is cheaper at indexing time and can produce quick queries,  
  but that's at the expense of the level of accuracy you can get.  

* Read more about bounding box [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).

</Admonition>

<Admonition type="note" title="GeoHashPrefixTree" id="geohashprefixtree" href="#geohashprefixtree">

* Geohash is a latitude/longitude representation system that describes Earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. 
  Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

* E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) 
  and it represents the `40.7144 -74.0060` coordinates. 
  Removing characters from the end of the geohash will decrease the precision level.

* The `maxTreeLevel` determines the length of the geohash used for the indexing, which in turn affects accuracy. 
  By default, it is set to __9__, providing a resolution of approximately 2.5 meters.

* More information about geohash uses, decoding algorithm, and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).

__Geohash precision values__:

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |

</Admonition>

<Admonition type="note" title="QuadPrefixTree" id="quadprefixtree" href="#quadprefixtree">

* The QuadTree represents Earth as a grid consisting of four cells (also known as buckets).
  Similar to GeoHash, each cell is assigned a letter, and is recursively divided into four more cells, creating a hierarchical structure. 

* By default, the precision level (`maxTreeLevel`) for QuadPrefixTree is __23__.

* More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).

__Quadtree precision values__:

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |

</Admonition>



## Remarks

<Admonition type="info" title="Info">

Distance by default is measured in __kilometers__.

</Admonition>


</LanguageContent>

<!---
### Client API
- [How to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query)

### Indexes
- [Query a spatial index](../indexes/querying/spatial)

### Studio
- [Spatial query view](../studio/database/queries/spatial-queries-map-view)

### Querying
- [Spatial](../indexes/querying/spatial)


-->