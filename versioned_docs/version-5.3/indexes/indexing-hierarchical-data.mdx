---
title: "Indexes: Indexing Hierarchical Data"
hide_table_of_contents: true
sidebar_label: Indexing Hierarchical Data
sidebar_position: 13
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["java", "nodejs", "csharp"];


# Indexes: Indexing Hierarchical Data
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="java">


One of the greatest advantages of a document database is that we have very few limits on how we structure our data. One very common scenario is the usage of hierarchical data structures. The most trivial of them is the comment thread:

<TabItem value="indexes_1" label="indexes_1">
<CodeBlock language="java">
{`public static class BlogPost \{
    private String author;
    private String title;
    private String text;
    private List<BlogPostComment> comments;

    public String getAuthor() \{
        return author;
    \}

    public void setAuthor(String author) \{
        this.author = author;
    \}

    public String getTitle() \{
        return title;
    \}

    public void setTitle(String title) \{
        this.title = title;
    \}

    public String getText() \{
        return text;
    \}

    public void setText(String text) \{
        this.text = text;
    \}

    public List<BlogPostComment> getComments() \{
        return comments;
    \}

    public void setComments(List<BlogPostComment> comments) \{
        this.comments = comments;
    \}
\}

public static class BlogPostComment \{
    private String author;
    private String text;
    private List<BlogPostComment> comments;


    public String getAuthor() \{
        return author;
    \}

    public void setAuthor(String author) \{
        this.author = author;
    \}

    public String getText() \{
        return text;
    \}

    public void setText(String text) \{
        this.text = text;
    \}

    public List<BlogPostComment> getComments() \{
        return comments;
    \}

    public void setComments(List<BlogPostComment> comments) \{
        this.comments = comments;
    \}
\}
`}
</CodeBlock>
</TabItem>

While it is very easy to work with such a structure in all respects, it does bring up an interesting question, namely how can we search for all blog posts that were commented by specified author?

The answer to that is that RavenDB contains built-in support for indexing hierarchies, and you can take advantage of the `Recurse` method to define an index using the following syntax:

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="java">
{`public static class BlogPosts_ByCommentAuthor extends AbstractIndexCreationTask {
    public BlogPosts_ByCommentAuthor() {
        map = "docs.BlogPosts.Select(post => new { " +
            "    authors = this.Recurse(post, x => x.comments).Select(x0 => x0.author) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="java">
{`IndexDefinition indexDefinition = new IndexDefinition();
indexDefinition.setName("BlogPosts/ByCommentAuthor");
indexDefinition.setMaps(Collections.singleton(
    "from post in docs.Posts" +
        "  from comment in Recurse(post, (Func<dynamic, dynamic>)(x => x.comments)) " +
        "  select new " +
        "  { " +
        "      author = comment.author " +
        "  }"
));
store.maintenance().send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class BlogPosts_ByCommentAuthor extends AbstractJavaScriptIndexCreationTask {
    public BlogPosts_ByCommentAuthor() {
        setMaps(Sets.newHashSet("map('BlogPosts', function(b){\\n" +
            "            var names = [];\\n" +
            "            b.comments.forEach(x => getNames(x, names));\\n" +
            "                return {\\n" +
            "                   authors : names\\n" +
            "                };" +
            "            })"));

        java.util.Map<String, String> additionalSources = new HashMap<>();
        additionalSources.put("The Script", "function getNames(x, names){\\n" +
            "        names.push(x.author);\\n" +
            "        x.comments.forEach(x => getNames(x, names));\\n" +
            "    }");

        setAdditionalSources(additionalSources);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

This will index all the comments in the thread, regardless of their location in the hierarchy.

<TabItem value="indexes_4" label="indexes_4">
<CodeBlock language="java">
{`List<BlogPost> results = session
    .query(BlogPost.class, BlogPosts_ByCommentAuthor.class)
    .whereEquals("authors", "Ayende Rahien")
    .toList();
`}
</CodeBlock>
</TabItem>


</LanguageContent>
<LanguageContent language="nodejs">


One of the greatest advantages of a document database is that we have very few limits on how we structure our data. One very common scenario is the usage of hierarchical data structures. The most trivial of them is the comment thread:

<TabItem value="indexes_1" label="indexes_1">
<CodeBlock language="js">
{`class BlogPost \{
    constructor(title, author, text, comments) \{
        this.title = title;
        this.author = author;
        this.text = text;
        this.comments = comments;
    \}
\}

class BlogPostComment \{
    constructor(author, text, comments) \{
        this.author = author;
        this.text = text;
        this.comments = comments;
    \}
\}
`}
</CodeBlock>
</TabItem>

While it is very easy to work with such a structure in all respects, it does bring up an interesting question, namely how can we search for all blog posts that were commented by specified author?

The answer to that is that RavenDB contains built-in support for indexing hierarchies, and you can take advantage of the `Recurse` method to define an index using the following syntax:

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="js">
{`class BlogPosts_ByCommentAuthor extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();
        this.map = "docs.BlogPosts.Select(post => new {\\n" +
            "    authors = this.Recurse(post, x => x.comments).Select(x0 => x0.author)\\n" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="js">
{`const indexDefinition = new IndexDefinition();
indexDefinition.name = "BlogPosts/ByCommentAuthor";
indexDefinition.maps = new Set([
        "from post in docs.Posts" +
        "  from comment in Recurse(post, (Func<dynamic, dynamic>)(x => x.comments)) " +
        "  select new " +
        "  { " +
        "      author = comment.author " +
        "  }"
]);

await store.maintenance.send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

This will index all the comments in the thread, regardless of their location in the hierarchy.

<TabItem value="indexes_4" label="indexes_4">
<CodeBlock language="js">
{`const results = session
    .query(\{ indexName: "BlogPosts/ByCommentAuthor" \})
    .whereEquals("authors", "Ayende Rahien")
    .all();
`}
</CodeBlock>
</TabItem>


</LanguageContent>
<LanguageContent language="csharp">

<Admonition type="note" title="">

Use the indexing `Recurse` method to recurse through the layers of a hierarchical document 
and index its elements.  

* In this Page:  
   * [Hierarchical Data](../indexes/indexing-hierarchical-data.mdx#hierarchical-data)  
   * [Indexing Hierarchical Data](../indexes/indexing-hierarchical-data.mdx#indexing-hierarchical-data)  

</Admonition>
## Hierarchical Data

One of the significant advantages offered by document databases is their tendency not to force 
limits upon data structuring. **Hierarchical data structures** demonstrate this quality beautifully: 
take, for example, the commonly-used **Comment thread**, implemented using objects such as:  
<TabItem value="indexes_1" label="indexes_1">
<CodeBlock language="csharp">
{`private class BlogPost
\{
    public string Author \{ get; set; \}
    public string Title \{ get; set; \}
    public string Text \{ get; set; \}

    // Blog post readers can leave comments
    public List<BlogPostComment> Comments \{ get; set; \}
\}

public class BlogPostComment
\{
    public string Author \{ get; set; \}
    public string Text \{ get; set; \}

    // Comments can be left recursively
    public List<BlogPostComment> Comments \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

Readers of a post created using the above `BlogPost` structure, can add `BlogPostComment` comments 
to its Comments field. And readers of these comments can reply with comments of their own, creating 
a recursive hierarchical structure.  

`BlogPosts/1-A`, for example, is a blog entry posted by John, that contains several layers of 
comments left by various authors.  

`BlogPosts/1-A`:
<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{
    "Author ": "John",
    "Comments": [
        \{
            "Author": "Moon",
            "Comments": [
                \{
                    "Author": "Bob"
                \},
                \{
                    "Author": "Adel",
                    "Comments": \{
                        "Author": "Moon"
                    \}
                \}
            ]
        \}
    ],
    "@metadata": \{
        "@collection": "BlogPosts"
    \}
\}
`}
</CodeBlock>
</TabItem>



## Indexing Hierarchical Data

To index the elements of a hierarchical structure like the one demonstrated above, 
use RavenDB's `Recurse` method.  

In the sample below, we use `Recurse` to go through comments in the post thread 
and index them by their authors.  
<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="csharp">
{`private class BlogPosts_ByCommentAuthor : 
    AbstractIndexCreationTask<BlogPost, BlogPosts_ByCommentAuthor.Result>
{
    public class Result
    {
        public IEnumerable<string> Authors { get; set; }
    }

    public BlogPosts_ByCommentAuthor()
    {
        Map = blogposts => from blogpost in blogposts
                           let authors = Recurse(blogpost, x => x.Comments)
                           select new Result
                           {
                               Authors = authors.Select(x => x.Author)
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="csharp">
{`store.Maintenance.Send(new PutIndexesOperation(
    new IndexDefinition
    {
        Name = "BlogPosts/ByCommentAuthor",
        Maps =
        {
            @"from blogpost in docs.BlogPosts
              from comment in Recurse(blogpost, (Func<dynamic, dynamic>)(x => x.Comments))
              select new
              {
                  Author = comment.Author
              }"
        }
    }));
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="csharp">
{`public class BlogPosts_ByCommentAuthor_JS : AbstractJavaScriptIndexCreationTask
{
    public class Result
    {
        public string[] Authors { get; set; }
    }

    public BlogPosts_ByCommentAuthor_JS()
    {
        Maps = new HashSet<string>
        {
            @"map('BlogPosts', function (blogpost) {
                return recurse(blogpost, x => x.Comments).map(function (comment) {
                    if (comment.Author != null) {
                        return {
                            Authors: comment.Author
                        };
                    }
                });
            });"
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>
### Querying the created index

* The index we created can be queried using code.  
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<BlogPost> results = session
    .Query<BlogPosts_ByCommentAuthor.Result, BlogPosts_ByCommentAuthor>()
    .Where(x => x.Authors.Any(a => a == "John"))
    .OfType<BlogPost>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<BlogPost> results = session
    .Advanced
    .DocumentQuery<BlogPost, BlogPosts_ByCommentAuthor>()
    .WhereEquals("Authors", "John")
    .ToList();
`}
</CodeBlock>
</TabItem>
  </Tabs>

* The index can also be queried using Studio.  

   * Use Studio's [List of Indexes](../studio/database/indexes/indexes-list-view.mdx#indexes-list-view) 
     view to define and query the index.  
     
         !["List of Indexes view"](./assets/list-of-indexes-view.png)

   * Use the **Query** view to see the results and the list of [terms](../studio/database/indexes/indexes-list-view.mdx#indexes-list-view---actions) 
     indexed by the `Recurse` method.  
     
         !["Query View"](./assets/query-view.png)

         !["Click to View Index Terms"](./assets/click-to-view-terms.png)

         !["Index Terms"](./assets/index-terms.png)




</LanguageContent>

<!---
### Indexes
- [Indexing Basics](../indexes/indexing-basics)
- [Indexing Related Documents](../indexes/indexing-related-documents)
- [Indexing Spatial Data](../indexes/indexing-spatial-data)
- [Indexing Polymorphic Data](../indexes/indexing-polymorphic-data)

### Querying
- [Basics](../indexes/querying/query-index)
- [Query Overview](../client-api/session/querying/how-to-query)


-->