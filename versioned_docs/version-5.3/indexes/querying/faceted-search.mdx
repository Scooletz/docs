---
title: "Query by Facets"
hide_table_of_contents: true
sidebar_label: Faceted Search
sidebar_position: 12
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Query by Facets
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

* A __Faceted Search__ provides an efficient way to explore and navigate through large datasets or search results.
 
* Multiple filters (facets) are applied to narrow down the search results according to different attributes or categories.

![Facets](./assets/CNET_faceted_search.jpg)
* In this page
  
  * [Define an index](../../indexes/querying/faceted-search.mdx#define-an-index)
  
  * [Facets - Basics](../../indexes/querying/faceted-search.mdx#facets---basics)
  
  * [Facets - Options](../../indexes/querying/faceted-search.mdx#facets---options)
   
  * [Facets - Aggregations](../../indexes/querying/faceted-search.mdx#facets---aggregations)
  
  * [Storing facets definition in a document](../../indexes/querying/faceted-search.mdx#storing-facets-definition-in-a-document)
  
  * [Syntax](../../indexes/querying/faceted-search.mdx#syntax)
   
</Admonition>
## Define an index

* In order to make a faceted search, __a static-index must be defined__ for the fields you want to query and apply facets on.

* The examples in this article will be based on the following Class, Index, and Sample Data:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class Camera
{
    public string Manufacturer { get; set; }
    public double Cost { get; set; }
    public double MegaPixels { get; set; }
    public int MaxFocalLength { get; set; }
    public int UnitsInStock { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Cameras_ByFeatures : AbstractIndexCreationTask<Camera>
{
    public class IndexEntry
    {
        public string Brand { get; set; }
        public double Price { get; set; }
        public double MegaPixels { get; set; }
        public int MaxFocalLength { get; set; }
        public int UnitsInStock { get; set; }
    }
    
    public Cameras_ByFeatures()
    {
        Map = cameras => from camera in cameras
            select new
            {
                Brand = camera.Manufacturer,
                Price = camera.Cost,
                MegaPixels = camera.MegaPixels,
                MaxFocalLength = camera.MaxFocalLength,
                UnitsInStock = camera.UnitsInStock
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="csharp">
{`// Creating sample data for the examples in this article:
// ======================================================

var cameras = new[]
{
  new Camera { Manufacturer = "Sony", Cost = 100, MegaPixels = 20.1, MaxFocalLength = 200, UnitsInStock = 10 },
  new Camera { Manufacturer = "Sony", Cost = 200, MegaPixels = 29, MaxFocalLength = 250, UnitsInStock = 15 },
  new Camera { Manufacturer = "Nikon", Cost = 120, MegaPixels = 22.3, MaxFocalLength = 300, UnitsInStock = 2 },
  new Camera { Manufacturer = "Nikon", Cost = 180, MegaPixels = 32, MaxFocalLength = 300, UnitsInStock = 5 },
  new Camera { Manufacturer = "Nikon", Cost = 220, MegaPixels = 40, MaxFocalLength = 300, UnitsInStock = 20 },
  new Camera { Manufacturer = "Canon", Cost = 200, MegaPixels = 30.4, MaxFocalLength = 400, UnitsInStock = 30 },
  new Camera { Manufacturer = "Olympus", Cost = 250, MegaPixels = 32.5, MaxFocalLength = 600, UnitsInStock = 4 },
  new Camera { Manufacturer = "Olympus", Cost = 390, MegaPixels = 40, MaxFocalLength = 600, UnitsInStock = 6 },
  new Camera { Manufacturer = "Fuji", Cost = 410, MegaPixels = 45, MaxFocalLength = 700, UnitsInStock = 1 },
  new Camera { Manufacturer = "Fuji", Cost = 590, MegaPixels = 45, MaxFocalLength = 700, UnitsInStock = 5 },
  new Camera { Manufacturer = "Fuji", Cost = 650, MegaPixels = 61, MaxFocalLength = 800, UnitsInStock = 17 },
  new Camera { Manufacturer = "Fuji", Cost = 850, MegaPixels = 102, MaxFocalLength = 800, UnitsInStock = 19 }
};

using (var session = store.OpenSession())
{
    foreach (var camera in cameras)
    {
        session.Store(camera);
    }

    session.SaveChanges();
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Facets - Basics

<Admonition type="note" title="">

__Facets definition__:
* Define a list of facets by which to aggregate the data.

* There are two __Facet types__:
    * `Facet` - returns a count for each unique term found in the specified index-field.
    * `RangeFacet` - returns a count per range within the specified index-field.
  
<TabItem value="facets_1" label="facets_1">
<CodeBlock language="csharp">
{`// Define a list of facets to query by:
// ====================================
List<FacetBase> facets = new List<FacetBase>
\{
    // Define a Facet:
    // ===============
    new Facet
    \{
        // Specify the index-field for which to get count of documents per unique ITEM
        // e.g. get the number of Camera documents for each unique Brand
        FieldName = "Brand",
        // Set a display name for this field in the results (optional) 
        DisplayFieldName = "Camera Brand"
    \},

    // Define a RangeFacet:
    // ====================
    new RangeFacet<Cameras_ByFeatures.IndexEntry>
    \{
        Ranges =
        \{
            // Specify ranges within an index-field in order to get count per RANGE
            // e.g. get the number of Camera documents that cost below 200, between 200 & 400, etc...
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800
        \},
        // Set a display name for this field in the results (optional) 
        DisplayFieldName = "Camera Price"
    \}
\};
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query the index for facets results__:
* Query the index to get the aggregated facets information.  

* Either:  

  * Pass the facets definition from above directly to the query  
  
  * Or - construct a facet using a builder with the Fluent API option, as shown below.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index    
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facets)
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index    
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index    
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .AggregateBy(builder => builder
         // Specify the index-field (e.g. 'Brand') for which to get count per unique ITEM
        .ByField(x => x.Brand)
         // Set a display name for the field in the results (optional) 
        .WithDisplayName("Camera Brand"))
    .AndAggregateBy(builder => builder
         // Specify ranges within an index field (e.g. 'Price') in order to get count per RANGE
        .ByRanges(
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800)
         // Set a display name for the field in the results (optional) 
        .WithDisplayName("Camera Price"))
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
      // Query the index
      // Provide the RQL string to the RawQuery method
     .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                         select 
                             facet(Brand) as 'Camera Brand',
                             facet(Price < 200.0,
                                   Price >= 200.0 and Price < 400.0,
                                   Price >= 400.0 and Price < 600.0,
                                   Price >= 600.0 and Price < 800.0,
                                   Price >= 800.0) as 'Camera Price'")
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand) as "Camera Brand",
    facet(Price < 200.0,
          Price >= 200.0 and Price < 400.0,
          Price >= 400.0 and Price < 600.0,
          Price >= 600.0 and Price < 800.0,
          Price >= 800.0) as "Camera Price"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">

__Query results__:
* __Query results__ are Not the collection documents, they are of type:  
  `Dictionary<string, FacetResult>` which is the facets results per index-field specified.  

* Using the sample data from this article, the resulting aggregations will be:

<TabItem value="facets_6" label="facets_6">
<CodeBlock language="csharp">
{`// The resulting aggregations per display name will contain:
// =========================================================

// For the "Camera Brand" Facet:
//     "canon"   - Count: 1
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2
//     "sony"    - Count: 2

// For the "Camera Price" Ranges:
//     "Price < 200"                      - Count: 3
//     "Price >= 200.0 and Price < 400.0" - Count: 5
//     "Price >= 400.0 and Price < 600.0" - Count: 2
//     "Price >= 600.0 and Price < 800.0" - Count: 1
//     "Price >= 800.0"                   - Count: 1
`}
</CodeBlock>
</TabItem>
<TabItem value="facets_7" label="facets_7">
<CodeBlock language="csharp">
{`// Get facets results for index-field 'Brand' using the display name specified:
// ============================================================================
var brandFacets = results["Camera Brand"];
var numberOfBrands = brandFacets.Values.Count; // 5 unique brands

// Get the aggregated facet value for a specific Brand:
var facetValue = brandFacets.Values[0];
// The brand name is available in the 'Range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index
Assert.Equal("canon", facetValue.Range);
// Number of documents for 'Canon' is available in the 'Count' property
Assert.Equal(1, facetValue.Count);

// Get facets results for index-field 'Price' using the display name specified:
// ============================================================================
var priceFacets = results["Camera Price"];
var numberOfRanges = priceFacets.Values.Count; // 5 different ranges

// Get the aggregated facet value for a specific Range:
facetValue = priceFacets.Values[0];
Assert.Equal("Price < 200", facetValue.Range); // The range string
Assert.Equal(3, facetValue.Count); // Number of documents in this range
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="info" title="">

__Query further__:
* Typically, after presenting users with the initial facets results which show the available options,  
  users can select specific categories to explore further.

* For example, if the user selects Fuji and Nikon,  
  then your next query can include a filter to focus only on those selected brands.

<TabItem value="facets_8" label="facets_8">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> filteredResults = session
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Limit query results to the selected brands: 
    .Where(x => x.Brand.In("Fuji", "Nikon"))
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Options

<Admonition type="note" title="">

__Facets definition__:
* __Options__ are available only for the `Facet` type.  

* Available options:  

    * `Start` - The position from which to send items (how many to skip).  
    * `PageSize` - Number of items to return.  
    * `IncludeRemainingTerms` - Show summary of items that didn't make it into the requested PageSize.  
    * `TermSortMode` - Set the sort order on the resulting items. 

<TabItem value="facets_9" label="facets_9">
<CodeBlock language="csharp">
{`// Define the list of facets to query by:
// ======================================
List<FacetBase> facetsWithOptions = new List<FacetBase>
\{
    // Define a Facet:
    new Facet
    \{
        // Specify the index-field for which to get count of documents per unique ITEM
        FieldName = "Brand",
        // Set some facets options
        Options = new FacetOptions
        \{
            // Return the top 3 brands with most items count:
            PageSize = 3,
            TermSortMode = FacetTermSortMode.CountDesc
        \}
    \}
\};
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query the index for facets results__:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithOptions)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithOptions)
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithOptions)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .AggregateBy(builder => builder
         // Specify an index-field (e.g. 'Brand') for which to get count per unique ITEM
        .ByField(x => x.Brand)
         // Specify the facets options
        .WithOptions(new FacetOptions
        {
            // Return the top 3 brands with most items count:
            PageSize = 3,
            TermSortMode = FacetTermSortMode.CountDesc
        }))
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
     // Provide the RQL string to the RawQuery method
    .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                        select facet(Brand, $p0)")
     // Add the facet options to the "p0" parameter
    .AddParameter("p0", new { PageSize = 3, TermSortMode = FacetTermSortMode.CountDesc })
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(Brand, $p0)
{"p0": { "TermSortMode": "CountDesc", "PageSize": 3 }}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">

__Query results__:
<TabItem value="facets_14" label="facets_14">
<CodeBlock language="csharp">
{`// The resulting items will contain:
// =================================

// For the "Brand" Facet:
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2

// As requested, only 3 unique items are returned, ordered by documents count descending:
`}
</CodeBlock>
</TabItem>
<TabItem value="facets_15" label="facets_15">
<CodeBlock language="csharp">
{`// Get facets results for index-field 'Brand':
// ===========================================
var brandFacets = results["Brand"];
var numberOfBrands = brandFacets.Values.Count; // 3 brands

// Get the aggregated facet value for a specific Brand:
var facetValue = brandFacets.Values[0];
// The brand name is available in the 'Range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index
Assert.Equal("fuji", facetValue.Range);
// Number of documents for 'Fuji' is available in the 'Count' property
Assert.Equal(4, facetValue.Count);
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Aggregations

<Admonition type="note" title="">

__Facets definition__:
* Aggregation of data is available for an index-field per unique Facet or Range item.  
  For example:  
  * Get the total number of UnitsInStock per Brand  
  * Get the highest MegaPixels value for documents that cost between 200 & 400   

* The following aggregation operations are available:  
  * Sum
  * Average
  * Min
  * Max

* Multiple operations can be added on each facet, for multiple fields.

<TabItem value="facets_16" label="facets_16">
<CodeBlock language="csharp">
{`// Define the list of facets to query by:
// ======================================
List<FacetBase> facetsWithAggregations = new List<FacetBase>
\{
    // Define a Facet:
    // ===============
    new Facet
    \{
        FieldName = "Brand",
        Aggregations =
        \{
            \{
                // Set the aggregation operation:
                FacetAggregation.Sum,
                // Create a HasSet specifying the index-fields for which to perform the aggregation
                new HashSet<FacetAggregationField>
                \{
                    // Get total number of UnitsInStock per Brand
                    new FacetAggregationField \{Name = "UnitsInStock"\}
                \}
            \},
            \{
                FacetAggregation.Average, new HashSet<FacetAggregationField>
                \{
                    // Get average Price per Brand
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Min, new HashSet<FacetAggregationField>
                \{
                    // Get min Price per Brand
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Max, new HashSet<FacetAggregationField>
                \{
                    // Get max MegaPixels per Brand
                    new FacetAggregationField \{Name = "MegaPixels"\},
                    // Get max MaxFocalLength per Brand
                    new FacetAggregationField \{Name = "MaxFocalLength"\}
                \}
            \}
        \}
    \},

    // Define a RangeFacet:
    // ====================
    new RangeFacet<Cameras_ByFeatures.IndexEntry>
    \{
        Ranges =
        \{
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800
        \},
        Aggregations =
        \{
            \{
                FacetAggregation.Sum, new HashSet<FacetAggregationField>
                \{
                    // Get total number of UnitsInStock for each group of documents per range specified
                    new FacetAggregationField \{Name = "UnitsInStock"\}
                \}
            \},
            \{
                FacetAggregation.Average, new HashSet<FacetAggregationField>
                \{
                    // Get average Price of each group of documents per range specified
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Min, new HashSet<FacetAggregationField>
                \{
                    // Get min Price of each group of documents per range specified
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Max, new HashSet<FacetAggregationField>
                \{
                    // Get max MegaPixels for each group of documents per range specified
                    new FacetAggregationField \{Name = "MegaPixels"\},
                    // Get max MaxFocalLength for each group of documents per range specified
                    new FacetAggregationField \{Name = "MaxFocalLength"\}
                \}
            \}
        \}
    \}
\};
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query the index for facets results__:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithAggregations)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithAggregations)
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithAggregations)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .AggregateBy(builder => builder
         // Specify an index-field (e.g. 'Brand') for which to get count per unique ITEM
        .ByField(x => x.Brand)
         // Specify the aggregations per the Brand facet:
        .SumOn(x => x.UnitsInStock)
        .AverageOn(x => x.Price)
        .MinOn(x => x.Price)
        .MaxOn(x => x.MegaPixels)
        .MaxOn(x => x.MaxFocalLength))
    .AndAggregateBy(builder => builder
         // Specify ranges within an index field (e.g. 'Price') in order to get count per RANGE
        .ByRanges(
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800)
         // Specify the aggregations per the Price range:
        .SumOn(x => x.UnitsInStock)
        .AverageOn(x => x.Price)
        .MinOn(x => x.Price)
        .MaxOn(x => x.MegaPixels)
        .MaxOn(x => x.MaxFocalLength))
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
     // Provide the RQL string to the RawQuery method
    .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                        select
                            facet(Brand,
                                  sum(UnitsInStock),
                                  avg(Price),
                                  min(Price),
                                  max(MegaPixels),
                                  max(MaxFocalLength)),
                            facet(Price < $p0,
                                  Price >= $p1 and Price < $p2,
                                  Price >= $p3 and Price < $p4,
                                  Price >= $p5 and Price < $p6,
                                  Price >= $p7,
                                  sum(UnitsInStock),
                                  avg(Price),
                                  min(Price),
                                  max(MegaPixels),
                                  max(MaxFocalLength))")
     // Add the parameters' values
    .AddParameter("p0", 200.0)
    .AddParameter("p1", 200.0)
    .AddParameter("p2", 400.0)
    .AddParameter("p3", 400.0)
    .AddParameter("p4", 600.0)
    .AddParameter("p5", 600.0)
    .AddParameter("p6", 800.0)
    .AddParameter("p7", 800.0)
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength)),
    facet(Price < $p0,
          Price >= $p1 and Price < $p2,
          Price >= $p3 and Price < $p4,
          Price >= $p5 and Price < $p6,
          Price >= $p7,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength))
{"p0":200.0,"p1":200.0,"p2":400.0,"p3":400.0,"p4":600.0,"p5":600.0,"p6":800.0,"p7":800.0}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">

__Query results__:
<TabItem value="facets_21" label="facets_21">
<CodeBlock language="csharp">
{`// The resulting items will contain (Showing partial results):
// ===========================================================

// For the "Brand" Facet:
//     "canon" Count:1, Sum: 30, Name: UnitsInStock
//     "canon" Count:1, Min: 200, Average: 200, Name: Price
//     "canon" Count:1, Max: 30.4, Name: MegaPixels
//     "canon" Count:1, Max: 400, Name: MaxFocalLength
//
//     "fuji" Count:4, Sum: 42, Name: UnitsInStock
//     "fuji" Count:4, Min: 410, Name: Price
//     "fuji" Count:4, Max: 102, Name: MegaPixels
//     "fuji" Count:4, Max: 800, Name: MaxFocalLength
//     
//     etc.....

// For the "Price" Ranges:
//     "Price < 200.0" Count:3, Sum: 17, Name: UnitsInStock
//     "Price < 200.0" Count:3, Min: 100, Average: 133.33, Name: Price
//     "Price < 200.0" Count:3, Max: 32, Name: MegaPixels
//     "Price < 200.0" Count:3, Max: 300, Name: MaxFocalLength
//
//     "Price < 200.0 and Price > 400.0" Count:5, Sum: 75, Name: UnitsInStock
//     "Price < 200.0 and Price > 400.0" Count:5, Min: 200, Average: 252, Name: Price
//     "Price < 200.0 and Price > 400.0" Count:5, Max: 40, Name: MegaPixels
//     "Price < 200.0 and Price > 400.0" Count:5, Max: 600, Name: MaxFocalLength
//     
//     etc.....
`}
</CodeBlock>
</TabItem>
<TabItem value="facets_22" label="facets_22">
<CodeBlock language="csharp">
{`// Get results for the 'Brand' Facets:
// ==========================================
var brandFacets = results["Brand"];

// Get the aggregated facet value for a specific Brand:
var facetValue = brandFacets.Values[0];
// The brand name is available in the 'Range' property:
Assert.Equal("canon", facetValue.Range);
// The index-field on which aggregation was done is in the 'Name' property:
Assert.Equal("UnitsInStock", facetValue.Name);
// The requested aggregation result:
Assert.Equal(30, facetValue.Sum);

// Get results for the 'Price' RangeFacets:
// =======================================
var priceRangeFacets = results["Price"];

// Get the aggregated facet value for a specific Brand:
facetValue = priceRangeFacets.Values[0];
// The range string is available in the 'Range' property:
Assert.Equal("Price < 200.0", facetValue.Range);
// The index-field on which aggregation was done is in the 'Name' property:
Assert.Equal("UnitsInStock", facetValue.Name);
// The requested aggregation result:
Assert.Equal(17, facetValue.Sum);
`}
</CodeBlock>
</TabItem>

</Admonition>



## Storing facets definition in a document



<Admonition type="note" title="">

__Define and store facets in a document__:
* The facets definitions can be stored in a document.

* That document can then be used by a faceted search query.

<TabItem value="facets_23" label="facets_23">
<CodeBlock language="csharp">
{`// Create a FacetSetup object:
// ===========================
FacetSetup facetSetup = new FacetSetup
\{
    // Provide the ID of the document in which the facet setup will be stored.
    // This is optional -
    // if not provided then the session will assign an ID for the stored document.
    Id = "customDocumentID",

    // Define Facets and RangeFacets to query by:
    Facets = new List<Facet> \{
        new Facet()
        \{
            FieldName = "Brand"
        \}\},
    
    RangeFacets = new List<RangeFacet>
    \{
        new RangeFacet<Cameras_ByFeatures.IndexEntry>
        \{
            Ranges =
            \{
                x => x.MegaPixels < 20,
                x => x.MegaPixels >= 20 && x.MegaPixels < 30,
                x => x.MegaPixels >= 30 && x.MegaPixels < 50,
                x => x.MegaPixels >= 50
            \}
        \}
    \}
\};

// Store the facet setup document and save changes:
// ================================================
session.Store(facetSetup);
session.SaveChanges();

// The document will be stored under the 'FacetSetups' collection
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query using facets from document__:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateUsing'
     // Pass the ID of the document that contains your facets setup
    .AggregateUsing("customDocumentID")
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateUsing'
     // Pass the ID of the document that contains your facets setup
    .AggregateUsing("customDocumentID")
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateUsing'
     // Pass the ID of the document that contains your facets setup
    .AggregateUsing("customDocumentID")
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
     // Provide the RQL string to the RawQuery method
    .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                        select facet(id('customDocumentID'))")
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(id("customDocumentID"))
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



## Syntax

<TabItem value="syntax_1" label="syntax_1">
<CodeBlock language="csharp">
{`IAggregationQuery<T> AggregateBy<T>(FacetBase facet);
IAggregationQuery<T> AggregateBy<T>(IEnumerable<FacetBase> facets);
IAggregationQuery<T> AggregateBy<T>(Action<IFacetBuilder<T>> builder);
IAggregationQuery<T> AggregateUsing<T>(string facetSetupDocumentKey);
`}
</CodeBlock>
</TabItem>

| Parameter                | Type                       | Description                                                                                       |
|--------------------------|----------------------------|---------------------------------------------------------------------------------------------------|
| __facet__                | `FacetBase`                | `FacetBase` implementation defining the facet and its options.<br/>Either `Facet` or `RangeFacet`. |
| __facets__               | `IEnumerable<FacetBase>`   | Enumerable containing `FacetBase` implementations.                                                |
| __builder__              | `Action<IFacetFactory<T>>` | Builder with a fluent API that constructs a `FacetBase` instance.                                 |
| __facetSetupDocumentId__ | string                     | ID of a document containing `FacetSetup`.                                                         |

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="csharp">
{`public class Facet
{
    public string FieldName { get; set; }
    public FacetOptions Options { get; set; }
}

public class Facet<T>
{
    public Expression<Func<T, object>> FieldName { get; set; }
    public FacetOptions Options { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="csharp">
{`public class RangeFacet
{
    public List<string> Ranges { get; set; }
    public FacetOptions Options { get; set; }
}

public class RangeFacet<T>
{
    public List<Expression<Func<T, bool>>> Ranges { get; set; }
    public FacetOptions Options { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetBase" label="FacetBase">
<CodeBlock language="csharp">
{`public class FacetBase
{
    public Dictionary<FacetAggregation, HashSet<FacetAggregationField>> Aggregations { get; set; }
    public string DisplayFieldName { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetAggregation" label="FacetAggregation">
<CodeBlock language="csharp">
{`public enum FacetAggregation
{
    None,
    Max,
    Min,
    Average,
    Sum
}
`}
</CodeBlock>
</TabItem>
</Tabs>

__Fluent API builder methods__:

<TabItem value="syntax_6" label="syntax_6">
<CodeBlock language="csharp">
{`IFacetOperations<T> ByField(string fieldName);
IFacetOperations<T> ByField(Expression<Func<T, object>> path);
IFacetOperations<T> ByRanges(Expression<Func<T, bool>> path, params Expression<Func<T, bool>>[] paths);
IFacetOperations<T> WithDisplayName(string displayName);
IFacetOperations<T> WithOptions(FacetOptions options);
IFacetOperations<T> SumOn(Expression<Func<T, object>> path);
IFacetOperations<T> MinOn(Expression<Func<T, object>> path);
IFacetOperations<T> MaxOn(Expression<Func<T, object>> path);
IFacetOperations<T> AverageOn(Expression<Func<T, object>> path);
`}
</CodeBlock>
</TabItem>

| Parameter       | Type                        | Description                                                                                                                            |
|-----------------|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| __fieldName__   | string                      | The index-field to use for the facet                                                                                                   |
| __path__        | `Expression<Func<T, bool>>` | Points to the index-field to use for the facet (`ByRanges`, `ByField`) or for the aggregation (`SumOn`, `MinOn`, `MaxOn`, `AverageOn`) |
| __displayName__ | string                      | If set, results of a facet will be returned under this name                                                                            |
| __options__     | `FacetOptions`              | Non-default options to use in the facet definition                                                                                     |

__Options__:

<TabItem value="syntax_7" label="syntax_7">
<CodeBlock language="csharp">
{`public class FacetOptions
\{
    public FacetTermSortMode TermSortMode \{ get; set; \} = FacetTermSortMode.ValueAsc;
    public bool IncludeRemainingTerms \{ get; set; \}
    public int Start \{ get; set; \}
    public int PageSize \{ get; set; \} = int.MaxValue;
\}
`}
</CodeBlock>
</TabItem>

| Option                    | Type                | Description                                                                                                 |
|---------------------------|---------------------|-------------------------------------------------------------------------------------------------------------|
| __TermSortMode__          | `FacetTermSortMode` | Set the sort order on the resulting items<br/>(`ValueAsc` (Default), `ValueDesc`, `CountAsc`, `CountDesc`)   |
| __Start__                 | int                 | The position from which to send items (how many to skip)                                                    |
| __PageSize__              | int                 | Number of items to return                                                                                   |
| __IncludeRemainingTerms__ | bool                | Indicates if remaining terms that didn't make it into the requested PageSize should be included in results  |




</LanguageContent>
<LanguageContent language="java">


When displaying a large amount of data, paging is often used to make viewing the data manageable. It's also useful to give some context of the entire data-set and a easy way to drill-down into particular categories. The common approach to doing this is a "faceted search", as shown in the image below. __Note__ how the count of each category within the current search is across the top.

![Facets](./assets/CNET_faceted_search.jpg)

&lt;br /&gt;
Let's start with defining a document like this:

<TabItem value="camera" label="camera">
<CodeBlock language="java">
{`public class Camera \{
    private Date dateOfListing;
    private String model;
    private double cost;
    private int zoom;
    private double megapixels;
    private boolean imageStabilizer;
    private String manufacturer;

    public Date getDateOfListing() \{
        return dateOfListing;
    \}

    public void setDateOfListing(Date dateOfListing) \{
        this.dateOfListing = dateOfListing;
    \}

    public String getModel() \{
        return model;
    \}

    public void setModel(String model) \{
        this.model = model;
    \}

    public double getCost() \{
        return cost;
    \}

    public void setCost(double cost) \{
        this.cost = cost;
    \}

    public int getZoom() \{
        return zoom;
    \}

    public void setZoom(int zoom) \{
        this.zoom = zoom;
    \}

    public double getMegapixels() \{
        return megapixels;
    \}

    public void setMegapixels(double megapixels) \{
        this.megapixels = megapixels;
    \}

    public boolean isImageStabilizer() \{
        return imageStabilizer;
    \}

    public void setImageStabilizer(boolean imageStabilizer) \{
        this.imageStabilizer = imageStabilizer;
    \}

    public String getManufacturer() \{
        return manufacturer;
    \}

    public void setManufacturer(String manufacturer) \{
        this.manufacturer = manufacturer;
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 1

Create an index to work against. 

<TabItem value="step_2" label="step_2">
<CodeBlock language="java">
{`public class Cameras_ByManufacturerModelCostDateOfListingAndMegapixels extends AbstractIndexCreationTask \{
    public Cameras_ByManufacturerModelCostDateOfListingAndMegapixels() \{
        map = "from camera in docs.Cameras " +
            "select new \{" +
            "   camera.manufacturer," +
            "   camera.model," +
            "   camera.cost," +
            "   camera.dateOfListing," +
            "   camera.megapixels" +
            "\} ";
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 2

Setup your facet definitions:

<TabItem value="step_1" label="step_1">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>

This tells RavenDB that you would like to get the following facets:

* For the **manufacturer** field, look at the documents and return a count for each unique Term found.

* For the **cost** field, return the count of the following ranges:

 * cost &lt; 200.0
 * 200.0 &lt;= cost &lt; 400.0
 * 400.0 &lt;= cost &lt; 600.0
 * 600.0 &lt;= cost &lt; 800.0
 * cost &gt;= 800.0
* For the **megapixels** field, return the count of the following ranges:
 * megapixels &lt;= 3.0
 * 3.0 &lt;= megapixels &lt; 7.0
 * 7.0 &lt;= megapixels &lt; 10.0
 * megapixels &gt;= 10.0

## Step 3

You can write the following code to get back the data below:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`Map<String, FacetResult> facetResults = session
    .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
    .whereBetween("cost", 100, 300)
    .aggregateBy(facets)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(manufacturer), facet(cost <= 200, cost between 200 and 400, cost between 400 and 600, cost between 600 and 800, cost >= 800), facet(megapixels <= 3, megapixels between 3 and 7, megapixels between 7 and 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

This data represents the sample faceted data that satisfies the above query:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`[
    \{
        "Name": "manufacturer",
        "Values": [
            \{
                "Count": 1,
                "Range": "canon"
            \},
            \{
                "Count": 2,
                "Range": "jessops"
            \},
            \{
                "Count": 1,
                "Range": "nikon"
            \},
            \{
                "Count": 1,
                "Range": "phillips"
            \},
            \{
                "Count": 3,
                "Range": "sony"
            \}
        ]
    \},
    \{
        "Name": "cost",
        "Values": [
            \{
                "Count": 6,
                "Range": "cost <= 200"
            \},
            \{
                "Count": 2,
                "Range": "cost between 200 and 400"
            \},
            \{
                "Count": 0,
                "Range": "cost between 400 and 600"
            \},
            \{
                "Count": 0,
                "Range": "cost between 600 and 800"
            \},
            \{
                "Count": 0,
                "Range": "cost >= 800"
            \}
        ]
    \},
    \{
        "Name": "megapixels",
        "Values": [
            \{
                "Count": 0,
                "Range": "megapixels <= 3"
            \},
            \{
                "Count": 6,
                "Range": "megapixels between 3 and 7"
            \},
            \{
                "Count": 1,
                "Range": "megapixels between 7 and 10"
            \},
            \{
                "Count": 1,
                "Range": "megapixels >= 10"
            \}
        ]
    \}
]
`}
</CodeBlock>
</TabItem>

### Storing Facets

If you do not have to change your facets dynamically, you can store your facets as a `FacetSetup` document and pass the document ID instead of the list each time:

<TabItem value="step_4_0" label="step_4_0">
<CodeBlock language="java">
{`FacetSetup facetSetup = new FacetSetup();
facetSetup.setFacets(facets);
facetSetup.setRangeFacets(rangeFacets);

session.store(facetSetup, "facets/CameraFacets");
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`Map<String, FacetResult> facetResults = session
    .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
    .whereBetween("cost", 100, 300)
    .aggregateUsing("facets/CameraFacets")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

### Stale Results

The faceted search does not take into account a staleness of an index. You can wait for non stale results by customizing your query with the `waitForNonStaleResults` method.

### Fluent API

As an alternative for creating a list of facets and passing it to the `aggregateBy` method, RavenDB also exposes a dynamic API where you can create your facets using a builder. You can read more about those methods in our dedicated Client API article [here](../../client-api/session/querying/how-to-perform-a-faceted-search.mdx).


</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">

* A __Faceted Search__ provides an efficient way to explore and navigate through large datasets or search results.
 
* Multiple filters (facets) are applied to narrow down the search results according to different attributes or categories.

![Facets](./assets/CNET_faceted_search.jpg)
* In this page
  
  * [Define an index](../../indexes/querying/faceted-search.mdx#define-an-index)
  
  * [Facets - Basics](../../indexes/querying/faceted-search.mdx#facets---basics)
  
  * [Facets - Options](../../indexes/querying/faceted-search.mdx#facets---options)
   
  * [Facets - Aggregations](../../indexes/querying/faceted-search.mdx#facets---aggregations)
  
  * [Storing facets definition in a document](../../indexes/querying/faceted-search.mdx#storing-facets-definition-in-a-document)
  
  * [Syntax](../../indexes/querying/faceted-search.mdx#syntax)
   
</Admonition>
## Define an index

* In order to make a faceted search, __a static-index must be defined__ for the fields you want to query and apply facets on.

* The examples in this article will be based on the following Class, Index, and Sample Data:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="js">
{`class Camera {
    constructor(
        manufacturer = '',
        cost = 0,
        megaPixels = 0,
        maxFocalLength = 0,
        unitsInStock = 0
    ) {
        Object.assign(this, {
            manufacturer,
            cost,
            megaPixels,
            maxFocalLength,
            unitsInStock
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Cameras_ByFeatures extends AbstractJavaScriptIndexCreationTask {
    constructor () {
        super();

        this.map("Cameras", camera => {
            return {
                brand: camera.manufacturer,
                price: camera.cost,
                megaPixels: camera.megaPixels,
                maxFocalLength: camera.maxFocalLength,
                unitsInStock: camera.unitsInStock
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="js">
{`// Creating sample data for the examples in this article:
// ======================================================
const bulkInsert = store.bulkInsert();

const cameras = [
    new Camera("Sony", 100, 20.1, 200, 10),
    new Camera("Sony", 200, 29, 250, 15),
    new Camera("Nikon", 120, 22.3, 300, 2),
    new Camera("Nikon", 180, 32, 300, 5),
    new Camera("Nikon", 220, 40, 300, 20),
    new Camera("Canon", 200, 30.4, 400, 30),
    new Camera("Olympus", 250, 32.5, 600, 4),
    new Camera("Olympus", 390, 40, 600, 6),
    new Camera("Fuji", 410, 45, 700, 1),
    new Camera("Fuji", 590, 45, 700, 5),
    new Camera("Fuji", 650, 61, 800, 17),
    new Camera("Fuji", 850, 102, 800, 19)
];

for (const camera of cameras) {
    await bulkInsert.store(camera);
}

await bulkInsert.finish();
`}
</CodeBlock>
</TabItem>
</Tabs>



## Facets - Basics

<Admonition type="note" title="">

__Facets definition__:
* Define a list of facets by which to aggregate the data.

* There are two __Facet types__:
    * `Facet` - returns a count for each unique term found in the specified index-field.
    * `RangeFacet` - returns a count per range within the specified index-field.
  
<TabItem value="facets_1" label="facets_1">
<CodeBlock language="js">
{`// Define a Facet:
// ===============
const brandFacet = new Facet();
// Specify the index-field for which to get count of documents per unique ITEM
// e.g. get the number of Camera documents for each unique brand
brandFacet.fieldName = "brand";
// Set a display name for this field in the results (optional) 
brandFacet.displayFieldName = "Camera Brand";

// Define a RangeFacet:
// ====================
const priceRangeFacet = new RangeFacet();
// Specify ranges within an index-field in order to get count per RANGE
// e.g. get the number of Camera documents that cost below 200, between 200 & 400, etc...
priceRangeFacet.ranges = [
    "price < 200",
    "price >= 200 and price < 400",
    "price >= 400 and price < 600",
    "price >= 600 and price < 800",
    "price >= 800"
];
// Set a display name for this field in the results (optional) 
priceRangeFacet.displayFieldName = "Camera Price";

const facets = [brandFacet, priceRangeFacet];
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query the index for facets results__:
* Query the index to get the aggregated facets information.  

* Either:  

  * Pass the facets definition from above directly to the query  
  
  * Or - construct a facet using a builder with the Fluent API option, as shown below.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
     // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .aggregateBy(...facets)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="js">
{`// Define the index-field (e.g. 'price') that will be used by the range-facet in the query below 
const range = RangeBuilder.forPath("price");

const results = await session
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .aggregateBy(builder => builder
         // Specify the index-field (e.g. 'brand') for which to get count per unique ITEM
        .byField("brand"))
         // Set a display name for the field in the results (optional) 
        .withDisplayName("Camera Brand"))
     // Call 'andAggregateBy' to aggregate the data by also by range-facets
     // Use a builder as follows:
    .andAggregateBy(builder => builder                
        .byRanges(
            // Specify the ranges within index field 'price' in order to get count per RANGE
            range.isLessThan(200),
            range.isGreaterThanOrEqualTo(200).isLessThan(400),
            range.isGreaterThanOrEqualTo(400).isLessThan(600),
            range.isGreaterThanOrEqualTo(600).isLessThan(800),
            range.isGreaterThanOrEqualTo(800))
         // Set a display name for the field in the results (optional) 
        .withDisplayName("Camera Brand"))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="js">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select
                   facet(brand) as "Camera Brand",
                   facet(price < 200,
                         price >= 200 and price < 400,
                         price >= 400 and price < 600,
                         price >= 600 and price < 800,
                         price >= 800) as "Camera Price"\`)
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(brand) as "Camera Brand",
    facet(price < 200,
          price >= 200 and price < 400,
          price >= 400 and price < 600,
          price >= 600 and price < 800,
          price >= 800) as "Camera Price"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">

__Query results__:
* __Query results__ are Not the collection documents, they are of type `FacetResultObject`  
  which is the facets results per index-field specified.  

* Using the sample data from this article, the resulting aggregations will be:

<TabItem value="facets_4" label="facets_4">
<CodeBlock language="js">
{`// The resulting aggregations per display name will contain:
// =========================================================

// For the "Camera Brand" Facet:
//     "canon"   - Count: 1
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2
//     "sony"    - Count: 2

// For the "Camera Price" Ranges:
//     "Price < 200"                      - Count: 3
//     "Price >= 200.0 and Price < 400.0" - Count: 5
//     "Price >= 400.0 and Price < 600.0" - Count: 2
//     "Price >= 600.0 and Price < 800.0" - Count: 1
//     "Price >= 800.0"                   - Count: 1
`}
</CodeBlock>
</TabItem>
<TabItem value="facets_5" label="facets_5">
<CodeBlock language="js">
{`// Get facets results for index-field 'brand' using the display name specified:
// ============================================================================
const brandFacets = results["Camera Brand"];
const numberOfBrands = brandFacets.values.length; // 5 unique brands

// Get the aggregated facet value for a specific Brand:
let facetValue = brandFacets.values[0];
// The brand name is available in the 'range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index
assert.equal(facetValue.range, "canon");
// Number of documents for 'Canon' is available in the 'count' property
assert.equal(facetValue.count, 1);

// Get facets results for index-field 'price' using the display name specified:
// ============================================================================
const priceFacets = results["Camera Price"];
const numberOfRanges = priceFacets.values.length; // 5 different ranges

// Get the aggregated facet value for a specific Range:
facetValue = priceFacets.values[0];
assert.equal(facetValue.range, "price < 200"); // The range string
assert.equalfacetValue.count, 3); // Number of documents in this range
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="info" title="">

__Query further__:
* Typically, after presenting users with the initial facets results which show the available options,  
  users can select specific categories to explore further.

* For example, if the user selects Fuji and Nikon,  
  then your next query can include a filter to focus only on those selected brands.

<TabItem value="facets_6" label="facets_6">
<CodeBlock language="js">
{`const filteredResults = await session
    .query(\{ indexName: "Cameras/ByFeatures" \})
     // Limit query results to the selected brands: 
    .whereIn("brand", ["Fuji", "Nikon"])
    .aggregateBy(...facets)
    .execute();
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Options

<Admonition type="note" title="">

__Facets definition__:
* __Options__ are available only for the `Facet` type.  

* Available options:  

    * `start` - The position from which to send items (how many to skip).  
    * `pageSize` - Number of items to return.  
    * `includeRemainingTerms` - Show summary of items that didn't make it into the requested pageSize.  
    * `termSortMode` - Set the sort order on the resulting items. 

<TabItem value="facets_7" label="facets_7">
<CodeBlock language="js">
{`// Define a Facet:
// ===============
const facet = new Facet();

// Specify the index-field for which to get count of documents per unique ITEM
facet.fieldName = "brand";

// Set some facet options 
// E.g.: Return top 3 brands with most items count
const facetOptions = new FacetOptions();
facetOptions.pageSize = 3;
facetOptions.termSortMode = "CountDesc";

facet.options = facetOptions;
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query the index for facets results__:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
     // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Pass the defined facet from above
    .aggregateBy(facet)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="js">
{`// Set facet options to use in the following query 
// E.g.: Return top 3 brands with most items count
const facetOptions = new FacetOptions();
facetOptions.pageSize = 3;
facetOptions.termSortMode = "CountDesc";

const results = await session
     //Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .aggregateBy(builder => builder
         // Specify the index-field (e.g. 'brand') for which to get count per unique ITEM
        .byField("brand")
         // Call 'withOptions', pass the facets options
        .withOptions(facetOptions))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="js">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select facet(brand, $p0)\`)
     // Add the facet options to the "p0" parameter
    .addParameter("p0", { "termSortMode": "CountDesc", "pageSize": 3 })
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(brand, $p0)
{"p0": { "termSortMode": "CountDesc", "pageSize": 3 }}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">

__Query results__:
<TabItem value="facets_10" label="facets_10">
<CodeBlock language="js">
{`// The resulting items will contain:
// =================================

// For the "brand" Facet:
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2

// As requested, only 3 unique items are returned, ordered by documents count descending:
`}
</CodeBlock>
</TabItem>
<TabItem value="facets_11" label="facets_11">
<CodeBlock language="js">
{`// Get facets results for index-field 'brand':
// ===========================================
const brandFacets = results["brand"];
const numberOfBrands = brandFacets.values.length; // 3 brands

// Get the aggregated facet value for a specific Brand:
const facetValue = brandFacets.values[0];
// The brand name is available in the 'range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index 
assert.equal(facetValue.range, "fuji");
// Number of documents for 'Fuji' is available in the 'count' property
assert.equal(facetValue.count, 4);
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Aggregations

<Admonition type="note" title="">

__Facets definition__:
* Aggregation of data is available for an index-field per unique Facet or Range item.  
  For example:  
  * Get the total number of unitsInStock per Brand  
  * Get the highest megaPixels value for documents that cost between 200 & 400   

* The following aggregation operations are available:  
  * Sum
  * Average
  * Min
  * Max

* Multiple operations can be added on each facet, for multiple fields.

<TabItem value="facets_12" label="facets_12">
<CodeBlock language="js">
{`// Define a Facet:
// ===============
const facet = new Facet();
facet.fieldName = "brand";

// Define the index-fields to aggregate:
const unitsInStockAggregationField = new FacetAggregationField();
unitsInStockAggregationField.name = "unitsInStock";

const priceAggregationField = new FacetAggregationField();
priceAggregationField.name = "price";

const megaPixelsAggregationField = new FacetAggregationField();
megaPixelsAggregationField.name = "megaPixels";

const maxFocalLengthAggregationField = new FacetAggregationField();
maxFocalLengthAggregationField.name = "maxFocalLength";

// Define the aggregation operations:
facet.aggregations.set("Sum", [unitsInStockAggregationField]);
facet.aggregations.set("Average", [priceAggregationField]);
facet.aggregations.set("Min", [priceAggregationField]);
facet.aggregations.set("Max", [megaPixelsAggregationField, maxFocalLengthAggregationField]);

// Define a RangeFacet:
// ====================
const rangeFacet = new RangeFacet();
rangeFacet.ranges = [
    "price < 200",
    "price >= 200 and price < 400",
    "price >= 400 and price < 600",
    "price >= 600 and price < 800",
    "price >= 800"
];

// Define the aggregation operations:
rangeFacet.aggregations.set("Sum", [unitsInStockAggregationField]);
rangeFacet.aggregations.set("Average", [priceAggregationField]);
rangeFacet.aggregations.set("Min", [priceAggregationField]);
rangeFacet.aggregations.set("Max", [megaPixelsAggregationField, maxFocalLengthAggregationField]);

const facetsWithAggregations = [facet, rangeFacet];
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query the index for facets results__:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
     // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Pass the defined facet from above
    .aggregateBy(...facetsWithAggregations)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="js">
{`// Define the index-field (e.g. 'price') that will be used by the range-facet in the query below 
const range = RangeBuilder.forPath("price");

const results = await session
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .aggregateBy(builder => builder
         // Specify the index-field (e.g. 'brand') for which to get count per unique ITEM
        .byField("brand")
         // Specify the aggregations per the brand facet:
        .sumOn("unitsInStock")
        .averageOn("price")
        .minOn("price")
        .maxOn("megaPixesls")
        .maxOn("maxFocalLength"))
     // Call 'andAggregateBy' to aggregate the data by also by range-facets
     // Use a builder as follows:
    .andAggregateBy(builder => builder
        .byRanges(
            // Specify the ranges within index field 'price' in order to get count per RANGE
            range.isLessThan(200),
            range.isGreaterThanOrEqualTo(200).isLessThan(400),
            range.isGreaterThanOrEqualTo(400).isLessThan(600),
            range.isGreaterThanOrEqualTo(600).isLessThan(800),
            range.isGreaterThanOrEqualTo(800))
         // Specify the aggregations per the price range:
        .sumOn("unitsInStock")
        .averageOn("price")
        .minOn("price")
        .maxOn("megaPixesls")
        .maxOn("maxFocalLength"))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="js">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select
                   facet(brand,
                         sum(unitsInStock),
                         avg(price),
                         min(price),
                         max(megaPixels),
                         max(maxFocalLength)),
                   facet(price < $p0,
                         price >= $p1 and price < $p2,
                         price >= $p3 and price < $p4,
                         price >= $p5 and price < $p6,
                         price >= $p7,
                         sum(unitsInStock),
                         avg(price),
                         min(price),
                         max(megaPixels),
                         max(maxFocalLength))\`)
     // Add the parameters' values
    .addParameter("p0", 200)
    .addParameter("p1", 200)
    .addParameter("p2", 400)
    .addParameter("p3", 400)
    .addParameter("p4", 600)
    .addParameter("p5", 600)
    .addParameter("p6", 800)
    .addParameter("p7", 800)
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(brand,
          sum(unitsInStock),
          avg(price),
          min(price),
          max(megaPixels),
          max(maxFocalLength)),
    facet(price < 200,
          price >= 200 and price < 400,
          price >= 400 and price < 600,
          price >= 600 and price < 800,
          price >= 800,
          sum(unitsInStock),
          avg(price),
          min(price),
          max(megaPixels),
          max(maxFocalLength))
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">

__Query results__:
<TabItem value="facets_15" label="facets_15">
<CodeBlock language="js">
{`// The resulting items will contain (Showing partial results):
// ===========================================================

// For the "brand" Facet:
//     "canon" Count:1, Sum: 30, Name: unitsInStock
//     "canon" Count:1, Min: 200, Average: 200, Name: price
//     "canon" Count:1, Max: 30.4, Name: megaPixels
//     "canon" Count:1, Max: 400, Name: maxFocalLength
//
//     "fuji" Count:4, Sum: 42, Name: unitsInStock
//     "fuji" Count:4, Min: 410, Name: price
//     "fuji" Count:4, Max: 102, Name: megaPixels
//     "fuji" Count:4, Max: 800, Name: maxFocalLength
//     
//     etc.....

// For the "price" Ranges:
//     "Price < 200" Count:3, Sum: 17, Name: unitsInStock
//     "Price < 200" Count:3, Min: 100, Average: 133.33, Name: price
//     "Price < 200" Count:3, Max: 32, Name: megaPixels
//     "Price < 200" Count:3, Max: 300, Name: maxFocalLength
//
//     "Price < 200 and Price > 400" Count:5, Sum: 75, Name: unitsInStock
//     "Price < 200 and Price > 400" Count:5, Min: 200, Average: 252, Name: price
//     "Price < 200 and Price > 400" Count:5, Max: 40, Name: megaPixels
//     "Price < 200 and Price > 400" Count:5, Max: 600, Name: maxFocalLength
//     
//     etc.....
`}
</CodeBlock>
</TabItem>
<TabItem value="facets_16" label="facets_16">
<CodeBlock language="js">
{`// Get results for the 'brand' Facets:
// ==========================================
const brandFacets = results["brand"];

// Get the aggregated facet value for a specific brand:
let facetValue = brandFacets.values[0];
// The brand name is available in the 'range' property:
assert.equal(facetValue.range, "canon");
// The index-field on which aggregation was done is in the 'name' property:
assert.equal(facetValue.name, "unitsInStock");
// The requested aggregation result:
assert.equal(facetValue.sum, 30);

// Get results for the 'price' RangeFacets:
// =======================================
const priceRangeFacets = results["price"];

// Get the aggregated facet value for a specific Brand:
facetValue = priceRangeFacets.values[0];
// The range string is available in the 'range' property:
assert.equal(facetValue.range, "price < 200");
// The index-field on which aggregation was done is in the 'name' property:
assert.equal(facetValue.name, "unitsInStock");
// The requested aggregation result:
assert.equal(facetValue.sum, 17);
`}
</CodeBlock>
</TabItem>

</Admonition>



## Storing facets definition in a document



<Admonition type="note" title="">

__Define and store facets in a document__:
* The facets definitions can be stored in a document.

* That document can then be used by a faceted search query.

<TabItem value="facets_17" label="facets_17">
<CodeBlock language="js">
{`// Create a FacetSetup object:
// ===========================
const facetSetup = new FacetSetup();

// Provide the ID of the document in which the facet setup will be stored.
// This is optional -
// if not provided then the session will assign an ID for the stored document.
facetSetup.id = "customDocumentID";

// Define Facets and RangeFacets to query by:
const facet = new Facet();
facet.fieldName = 'brand';

facetSetup.facets = [facet];

const rangeFacet = new RangeFacet();
rangeFacet.ranges = [
    "megaPixels < 20",
    "megaPixels >= 20 and megaPixels < 30",
    "megaPixels >= 30 and megaPixels < 50",
    "megaPixels >= 50"
];

facetSetup.rangeFacets = [rangeFacet];

// Store the facet setup document and save changes:
// ================================================
await session.store(facetSetup);
await session.saveChanges();

// The document will be stored under the 'FacetSetups' collection
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="">

__Query using facets from document__:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
    // Call 'aggregateUsing'
    // Pass the ID of the document that contains your facets setup
    .aggregateUsing("customDocumentID")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="js">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select facet(id("customDocumentID"))\`)
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(id("customDocumentID"))
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



## Syntax

<TabItem value="syntax_1" label="syntax_1">
<CodeBlock language="js">
{`// Aggregate data by Facets:
aggregateBy(facet);
aggregateBy(...facet);
aggregateBy(action);

// Aditional aggregation for another Facet/RangeFacet (use with fluent API) 
andAggregateBy(facet);
andAggregateBy(builder);

// Aggregate data by Facets stored in a document 
aggregateUsing(facetSetupDocumentId);
`}
</CodeBlock>
</TabItem>

| Parameter                | Type                       | Description                                                                                       |
|--------------------------|----------------------------|---------------------------------------------------------------------------------------------------|
| __facet__                | `FacetBase`                | `FacetBase` implementation defining the facet and its options.<br/>Either `Facet` or `RangeFacet`. |
| __...facet__             | `FacetBase[]`              | List containing `FacetBase` implementations.                                                      |
| __action__ / __builder__ | `(builder) => void`        | Builder with a fluent API that constructs a `FacetBase` instance.                                 |
| __facetSetupDocumentId__ | string                     | ID of a document containing `FacetSetup`.                                                         |

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="js">
{`class Facet {
    fieldName;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="js">
{`class RangeFacet {
    ranges;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetBase" label="FacetBase">
<CodeBlock language="js">
{`class FacetBase {
    displayFieldName;
    options;
    aggregations; // "None" | "Max" | "Min" | "Average" | "Sum"
}
`}
</CodeBlock>
</TabItem>
</Tabs>

__builder methods__:

<TabItem value="syntax_5" label="syntax_5">
<CodeBlock language="js">
{`byField(fieldName);
byRanges(range, ...ranges);

withDisplayName(displayName);
withOptions(options);

sumOn(path);
sumOn(path, displayName);

minOn(path);
minOn(path, displayName);

maxOn(path);
maxOn(path, displayName);

averageOn(path);
averageOn(path, displayName);
`}
</CodeBlock>
</TabItem>

| Parameter       | Type           | Description                                                                                                                  |
|-----------------|----------------|------------------------------------------------------------------------------------------------------------------------------|
| __fieldName__   | string         | The index-field to use for the facet                                                                                         |
| __path__        | string         | The index-field to use for the facet (`byRanges`, `byField`) or for the aggregation (`sumOn`, `minOn`, `maxOn`, `averageOn`) |
| __displayName__ | string         | If set, results of a facet will be returned under this name                                                                  |
| __options__     | `FacetOptions` | Non-default options to use in the facet definition                                                                           |

__Options__:

<TabItem value="syntax_6" label="syntax_6">
<CodeBlock language="js">
{`class FacetOptions \{
    termSortMode;
    includeRemainingTerms; 
    start;
    pageSize;
\}
`}
</CodeBlock>
</TabItem>

| Option                    | Type                | Description                                                                                                 |
|---------------------------|---------------------|-------------------------------------------------------------------------------------------------------------|
| __termSortMode__          | `FacetTermSortMode` | Set the sort order on the resulting items<br/>(`ValueAsc` (Default), `ValueDesc`, `CountAsc`, `CountDesc`)   |
| __start__                 | number              | The position from which to send items (how many to skip)                                                    |
| __pageSize__              | number              | Number of items to return                                                                                   |
| __includeRemainingTerms__ | boolean             | Indicates if remaining terms that didn't make it into the requested PageSize should be included in results  |




</LanguageContent>

<!---
### Client API
- [Query Overview](../../client-api/session/querying/how-to-query)
- [How to Perform a Faceted Search](../../client-api/session/querying/how-to-perform-a-faceted-search)


-->