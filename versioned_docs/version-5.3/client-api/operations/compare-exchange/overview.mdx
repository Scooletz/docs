---
title: "Compare Exchange Overview"
hide_table_of_contents: true
sidebar_label: Overview
sidebar_position: 0
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];


# Compare Exchange Overview 
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

* Compare Exchange items are __key/value pairs__ where the key is unique across your database. 

* Compare-exchange operations require cluster consensus to ensure consistency across all nodes.  
  Once a consensus is reached, the compare-exchange items are distributed through the Raft algorithm to all nodes in the database group.

* Compare-exchange items can be used to coordinate work between sessions that are trying to modify a shared resource (such as a document) at the same time.

* Compare-exchange items are [not replicated externally](../../../client-api/operations/compare-exchange/overview.mdx#why-compare-exchange-items-are-not-replicated-to-external-databases) to other databases.

* In this page:  
* [What Compare Exchange Items Are](../../../client-api/operations/compare-exchange/overview.mdx#what-compare-exchange-items-are)  
* [Creating and Managing Compare-Exchange Items](../../../client-api/operations/compare-exchange/overview.mdx#creating-and-managing-compare-exchange-items)  
* [Why Compare-Exchange Items are Not Replicated to External Databases](../../../client-api/operations/compare-exchange/overview.mdx#why-compare-exchange-items-are-not-replicated-to-external-databases)  
* [Example I - Email Address Reservation](../../../client-api/operations/compare-exchange/overview.mdx#example-i---email-address-reservation)  
* [Example II - Reserve a Shared Resource](../../../client-api/operations/compare-exchange/overview.mdx#example-ii---reserve-a-shared-resource)  
* [Example III - Ensuring Unique Values without Using Compare Exchange](../../../client-api/operations/compare-exchange/overview.mdx#example-iii---ensuring-unique-values-without-using-compare-exchange)  

</Admonition>
## What Compare Exchange Items Are

Compare Exchange items are key/value pairs where the key servers a unique value across your database.

* Each compare-exchange item contains: 
  * **A key** - A unique string identifier in the database scope.
  * **A value** - Can be any object (a number, string, array, or any valid JSON object). 
  * **Metadata** - Data that is associated with the compare-exchange item.
    Must be a valid JSON object.
     * For example, the metadata can be used to set expiration time for the compare-exchange item.  
       Learn more in [compare-exchange expiration](../../../client-api/operations/compare-exchange/compare-exchange-expiration.mdx).  
  * **Raft index** - The compare-exchange item's version.  
    Any change to the value or metadata will increase this number.  

* Creating and modifying a compare-exchange item is an atomic, thread-safe [compare-and-swap](https://en.wikipedia.org/wiki/Compare-and-swap) interlocked 
  compare-exchange operation.



## Creating and Managing Compare-Exchange Items
  
Compare exchange items are created and managed with any of the following approaches:

* **Document Store Operations**  
  You can manage a compare-exchange item as an [Operation on the document store](../../../client-api/operations/compare-exchange/put-compare-exchange-value.mdx).  
  This can be done within or outside of a session (cluster-wide or single-node session).
   * When inside a session:  
     If the session fails, the compare-exchange operation can still succeed
     because store Operations do not rely on the success of the session.  
     You will need to delete the compare-exchange item explicitly upon session failure if you don't want the compare-exchange item to persist.

* **Cluster-Wide Sessions**  
  You can manage a compare-exchange item from inside a [Cluster-Wide session](../../../client-api/session/cluster-transaction/compare-exchange.mdx).  
  If the session fails, the compare-exchange item creation also fails.  
  None of the nodes in the group will have the new compare-exchange item.


* **Atomic Guards**  
  When creating documents using a cluster-wide session RavenDB automatically creates [Atomic Guards](../../../client-api/session/cluster-transaction/atomic-guards.mdx),  
  which are compare-exchange items that guarantee ACID transactions.  
  See [Cluster-wide vs. Single-node](../../../client-api/session/cluster-transaction/overview.mdx#cluster-wide-transaction-vs-single-node-transaction) for a session comparision overview.

* **Studio**  
  Compare-exchange items can be created from the [Studio](../../../studio/database/documents/compare-exchange-view.mdx#the-compare-exchange-view) as well.



## Why Compare-Exchange Items are Not Replicated to External Databases 

* Each cluster defines its policies and configurations, and should ideally have sole responsibility for managing its own documents. 
  Read [Consistency in a Globally Distributed System](https://ayende.com/blog/196769-B/data-ownership-in-a-distributed-system) 
  to learn more about why global database modeling is more efficient this way.
   
* When creating a compare-exchange item a Raft consensus is required from the nodes in the database group.
  Externally replicating such data is problematic as the target database may reside within a cluster that is in an
  unstable state where Raft decisions cannot be made. In such a state, the compare-exchange item will not be persisted in the target database.

* Conflicts between documents that occur between two databases are solved with the help of the documents
  Change-Vector. Compare-exchange conflicts cannot be handled properly as they do not have a similar
  mechanism to resolve conflicts.

* To ensure unique values between two databases without using compare-exchange items see [Example III](../../../client-api/operations/compare-exchange/overview.mdx#example-iii---ensuring-unique-values-without-using-compare-exchange).



## Example I - Email Address Reservation  

The following example shows how to use compare-exchange to create documents with unique values.  
The scope is within the database group on a single cluster. 

Compare-exchange items are not externally replicated to other databases.  
To establish uniqueness without using compare-exchange see [Example III](../../../client-api/operations/compare-exchange/overview.mdx#example-iii---ensuring-unique-values-without-using-compare-exchange).

<TabItem value="email" label="email">
<CodeBlock language="csharp">
{`string email = "user@example.com";

User user = new User
\{
    Email = email
\};

using (IDocumentSession session = store.OpenSession())
\{
    session.Store(user);
    // At this point, the user document has an Id assigned

    // Try to reserve a new user email 
    // Note: This operation takes place outside of the session transaction, 
    //       It is a cluster-wide reservation
    CompareExchangeResult<string> cmpXchgResult
        = store.Operations.Send(
            new PutCompareExchangeValueOperation<string>("emails/" + email, user.Id, 0));

    if (cmpXchgResult.Successful == false)
        throw new Exception("Email is already in use");

    // At this point we managed to reserve/save the user email -
    // The document can be saved in SaveChanges
    session.SaveChanges();
\}
`}
</CodeBlock>
</TabItem>  

**Implications**:

* The `User` object is saved as a document, hence it can be indexed, queried, etc.  

* This compare-exchange item was [created as an operation](../../../client-api/operations/compare-exchange/put-compare-exchange-value.mdx)
  rather than with a [cluster-wide session](../../../client-api/session/cluster-transaction/overview.mdx).  
  Thus, if `session.SaveChanges` fails, then the email reservation is _not_ rolled back automatically.  
  It is your responsibility to do so.  

* The compare-exchange value that was saved can be accessed in a query using `CmpXchg`:  
<Tabs groupId='languageSyntax'>
<TabItem value="Query-LINQ" label="Query-LINQ">
<CodeBlock language="csharp">
{`var query = from u in session.Query<User>()
            where u.Id == RavenQuery.CmpXchg<string>("emails/ayende@ayende.com")
            select u;
`}
</CodeBlock>
</TabItem>  
<TabItem value="Document-Query" label="Document-Query">
<CodeBlock language="csharp">
{`var q = session.Advanced
    .DocumentQuery<User>()
    .WhereEquals("Id", CmpXchg.Value("emails/ayende@ayende.com"));
`}
</CodeBlock>
</TabItem>  
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users as s where id() == cmpxchg("emails/ayende@ayende.com")
`}
</CodeBlock>
</TabItem>
    </Tabs>
    

## Example II - Reserve a Shared Resource  

In the following example, we use compare-exchange to reserve a shared resource.  
The scope is within the database group on a single cluster.

The code also checks for clients who never release resources (i.e. due to failure) by using timeout.  

<TabItem value="shared_resource" label="shared_resource">
<CodeBlock language="csharp">
{`private class SharedResource
\{
    public DateTime? ReservedUntil \{ get; set; \}
\}

public void PrintWork() 
\{
    // Try to get hold of the printer resource
    long reservationIndex = LockResource(store, "Printer/First-Floor", TimeSpan.FromMinutes(20));

    try
    \{
        // Do some work for the duration that was set.
        // Don't exceed the duration, otherwise resource is available for someone else.
    \}
    finally
    \{
        ReleaseResource(store, "Printer/First-Floor", reservationIndex);
    \}
\}

public long LockResource(IDocumentStore store, string resourceName, TimeSpan duration)
\{
    while (true)
    \{
        DateTime now = DateTime.UtcNow;

        SharedResource resource = new SharedResource
        \{
            ReservedUntil = now.Add(duration)
        \};

        CompareExchangeResult<SharedResource> saveResult = store.Operations.Send(
                new PutCompareExchangeValueOperation<SharedResource>(resourceName, resource, 0));

        if (saveResult.Successful)
        \{
            // resourceName wasn't present - we managed to reserve
            return saveResult.Index;
        \}

        // At this point, Put operation failed - someone else owns the lock or lock time expired
        if (saveResult.Value.ReservedUntil < now)
        \{
            // Time expired - Update the existing key with the new value
            CompareExchangeResult<SharedResource> takeLockWithTimeoutResult = store.Operations.Send(
                new PutCompareExchangeValueOperation<SharedResource>(resourceName, resource, saveResult.Index));

            if (takeLockWithTimeoutResult.Successful)
            \{
                return takeLockWithTimeoutResult.Index;
            \}
        \}

        // Wait a little bit and retry
        Thread.Sleep(20);
    \}
\}

public void ReleaseResource(IDocumentStore store, string resourceName, long index)
\{
    CompareExchangeResult<SharedResource> deleteResult
        = store.Operations.Send(new DeleteCompareExchangeValueOperation<SharedResource>(resourceName, index));

    // We have 2 options here:
    // deleteResult.Successful is true - we managed to release resource
    // deleteResult.Successful is false - someone else took the lock due to timeout 
\}
`}
</CodeBlock>
</TabItem>



## Example III - Ensuring Unique Values without Using Compare Exchange  

Unique values can also be ensured without using compare-exchange.

The below example shows how to achieve that by using **reference documents**.  
The reference documents' IDs will contain the unique values instead of the compare-exchange items.

Using reference documents is especially useful when [External Replication](../../../server/ongoing-tasks/external-replication.mdx) 
is defined between two databases that need to be synced with unique values.  
The reference documents will replicate to the destination database, 
as opposed to compare-exchange items, which are not externally replicated.

<Admonition type="note" title="">
Sessions which process fields that must be unique should be set to [TransactionMode.ClusterWide](../../../client-api/session/cluster-transaction/overview.mdx).  
</Admonition>

<TabItem value="create_uniqueness_control_documents" label="create_uniqueness_control_documents">
<CodeBlock language="csharp">
{`// When you create documents that must contain a unique value such as a phone or email, etc.,
// you can create reference documents that will have that unique value in their IDs.
// To know if a value already exists, all you need to do is check whether a reference document with such ID exists.

// The reference document class
class UniquePhoneReference
\{
    public class PhoneReference
    \{
        public string Id;
        public string CompanyId;
    \}

    static void Main(string[] args)
    \{
        // A company document class that must be created with a unique 'Phone' field
        Company newCompany = new Company
        \{
            Name = "companyName",
            Phone = "phoneNumber",
            Contact = new Contact
            \{
                Name = "contactName",
                Title = "contactTitle"
            \},
        \};

        void CreateCompanyWithUniquePhone(Company newCompany)
        \{
            // Open a cluster-wide session in your document store
            using var session = DocumentStoreHolder.Store.OpenSession(
                    new SessionOptions \{ TransactionMode = TransactionMode.ClusterWide \}
                );

            // Check whether the new company phone already exists
            // by checking if there is already a reference document that has the new phone in its ID.
            var phoneRefDocument = session.Load<PhoneReference>("phones/" + newCompany.Phone);
            if (phoneRefDocument != null)
            \{
                var msg = $"Phone '\{newCompany.Phone\}' already exists in ID: \{phoneRefDocument.CompanyId\}";
                throw new ConcurrencyException(msg);
            \}

            // If the new phone number doesn't already exist, store the new entity
            session.Store(newCompany);
            // Store a new reference document with the new phone value in its ID for future checks.
            session.Store(new PhoneReference \{ CompanyId = newCompany.Id \}, "phones/" + newCompany.Phone);

            // May fail if called concurrently with the same phone number
            session.SaveChanges();
        \}
    \}
\}
`}
</CodeBlock>
</TabItem>



</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="">

* The **Compare Exchange** feature allows you to perform cluster-wide _interlocked_ distributed operations.  

* Unique **Keys** can be reserved in the [Database Group](../../../studio/database/settings/manage-database-group.mdx) accross the cluster.  
  Each key has an associated **Value**.  

* Modifying these values is an ***interlocked compare exchange*** operation.  

* Once defined, the Compare Exchange Values can be accessed via [GetCompareExchangeValuesOperation](../../../client-api/operations/compare-exchange/get-compare-exchange-values.mdx),  
  or by using RQL in a query (see example-I below)  

<Admonition type="info" title="">
Compare exchange key/value pairs can be created and managed explicitly in your code.  
Starting from RavenDB 5.2, they can also be created and managed automatically by RavenDB.  
Compare exchange entries that are automatically administered by RavenDB are called 
**Atomic Guards**, read more about them [here](../../../client-api/session/cluster-transaction/atomic-guards.mdx).  
</Admonition>


* In this page:  
  * [Compare Exchange Transaction Scope](../../../client-api/operations/compare-exchange/overview.mdx#compare-exchange-transaction-scope)  
  * [Creating a Key](../../../client-api/operations/compare-exchange/overview.mdx#creating-a-key)  
  * [Updating a Key](../../../client-api/operations/compare-exchange/overview.mdx#updating-a-key)  
  * [Example I - Email Address Reservation](../../../client-api/operations/compare-exchange/overview.mdx#example-i---email-address-reservation)  
  * [Example II- Reserve a Shared Resource](../../../client-api/operations/compare-exchange/overview.mdx#example-ii---reserve-a-shared-resource)  
</Admonition>
## Compare Exchange Transaction Scope

* Since the compare-exchange operations guarantee atomicity across the entire cluster, 
  the feature is **not** using the transaction associated with a session object, as a session transaction spans only a single node.  

* So if a compare-exchange operation has failed when used inside a session block, it will **not** be rolled back automatically upon a session transaction failure.  


## Creating a Key

* Provide the following when saving a **key**:

| Parameter | Description |
| ------------- | ---- |
| **Key** | A string under which _Value_ is saved, unique in the database scope across the cluster. This string can be up to 512 bytes. |
| **Value** | The Value that is associated with the _Key_. 
Can be a number, string, boolean, array or any JSON formatted object. |
| **Index** | The _Index_ number is indicating the version of _Value_.
The _Index_ is used for the concurrency control, similar to documents Etags. |

* When creating a _new_ 'Compare Exchange Key', the index should be set to `0`.  

* The [Put](../../../client-api/operations/compare-exchange/put-compare-exchange-value.mdx) operation will succeed only if this key doesn't exist yet.  

* Note: Two different keys _can_ have the same values as long as the keys are unique.  


## Updating a Key

* Updating a 'Compare Exchange' key can be divided into 2 phases:

  1. [Get](../../../client-api/operations/compare-exchange/get-compare-exchange-value.mdx) the existing _Key_. The associated _Value_ and _Index_ are received.  

  2. The _Index_ obtained from the read operation is provided to the [Put](../../../client-api/operations/compare-exchange/put-compare-exchange-value.mdx) operation along with the new _Value_ to be saved.  
     This save will succeed only if the index that is provided to the 'Put' operation is the **same** as the index that was received from the server in the previous 'Get', 
     which means that the _Value_ was not modified by someone else between the read and write operations.


## Example I - Email Address Reservation  

* Compare Exchange can be used to maintain uniqueness across users emails accounts.  

* First try to reserve a new user email.  
  If the email is successfully reserved then save the user account document.  

<TabItem value="email" label="email">
<CodeBlock language="java">
{`String email = "user@example.com";

User user = new User();
user.setEmail(email);

try (IDocumentSession session = store.openSession()) \{
    session.store(user);

    // At this point, the user document has an Id assigned

    // Try to reserve a new user email
    // Note: This operation takes place outside of the session transaction,
    //       It is a cluster-wide reservation
    CompareExchangeResult<String> cmpXchgResult = store
        .operations().send(
            new PutCompareExchangeValueOperation<>(
                "emails/" + email, user.getId(), 0));

    if (!cmpXchgResult.isSuccessful()) \{
        throw new RuntimeException("Email is already in use");
    \}

    // At this point we managed to reserve/save the user email -
    // The document can be saved in SaveChanges
    session.saveChanges();
\}
`}
</CodeBlock>
</TabItem>  

**Implications**:

* The `User` object is saved as a document, hence it can be indexed, queried, etc.  

* If `session.saveChanges` fails, the email reservation is _not_ rolled back automatically. It is your responsibility to do so.  

* The compare exchange value that was saved can be accessed from `RQL` in a query:  

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="java">
{`try (IDocumentSession session = store.openSession()) {
    List<User> query = session.advanced().rawQuery(User.class,
        "from Users as s where id() == cmpxchg(\\"emails/ayende@ayende.com\\")")
        .toList();

    IDocumentQuery<User> q = session.advanced()
        .documentQuery(User.class)
        .whereEquals("id", CmpXchg.value("emails/ayende@ayende.com"));
}
`}
</CodeBlock>
</TabItem>  
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users as s where id() == cmpxchg("emails/ayende@ayende.com")
`}
</CodeBlock>
</TabItem>
</Tabs>


## Example II - Reserve a Shared Resource  

* Use compare exchange for a shared resource reservation.  

* The code also checks for clients who never release resources (i.e. due to failure) by using timeout.  

<TabItem value="shared_resource" label="shared_resource">
<CodeBlock language="java">
{`private class SharedResource \{
    private LocalDateTime reservedUntil;

    public LocalDateTime getReservedUntil() \{
        return reservedUntil;
    \}

    public void setReservedUntil(LocalDateTime reservedUntil) \{
        this.reservedUntil = reservedUntil;
    \}
\}

public void printWork() throws InterruptedException \{
    // Try to get hold of the printer resource
    long reservationIndex = lockResource(store, "Printer/First-Floor", Duration.ofMinutes(20));

    try \{
        // Do some work for the duration that was set.
        // Don't exceed the duration, otherwise resource is available for someone else.
    \} finally \{
        releaseResource(store, "Printer/First-Floor", reservationIndex);
    \}
\}

public long lockResource(IDocumentStore store, String resourceName, Duration duration) throws InterruptedException \{
    while (true) \{
        LocalDateTime now = LocalDateTime.now();

        SharedResource resource = new SharedResource();
        resource.setReservedUntil(now.plus(duration));

        CompareExchangeResult<SharedResource> saveResult =
            store.operations().send(
                new PutCompareExchangeValueOperation<SharedResource>(resourceName, resource, 0));

        if (saveResult.isSuccessful()) \{
            // resourceName wasn't present - we managed to reserve
            return saveResult.getIndex();
        \}

        // At this point, Put operation failed - someone else owns the lock or lock time expired
        if (saveResult.getValue().reservedUntil.isBefore(now)) \{
            // Time expired - Update the existing key with the new value
            CompareExchangeResult<SharedResource> takeLockWithTimeoutResult =
                store.operations().send(
                    new PutCompareExchangeValueOperation<>(resourceName, resource, saveResult.getIndex()));

            if (takeLockWithTimeoutResult.isSuccessful()) \{
                return takeLockWithTimeoutResult.getIndex();
            \}
        \}

        // Wait a little bit and retry
        Thread.sleep(20);
    \}
\}

public void releaseResource(IDocumentStore store, String resourceName, long index) \{
    CompareExchangeResult<SharedResource> deleteResult = store
        .operations().send(
            new DeleteCompareExchangeValueOperation<>(SharedResource.class, resourceName, index));

    // We have 2 options here:
    // deleteResult.Successful is true - we managed to release resource
    // deleteResult.Successful is false - someone else took the lock due to timeout
\}
`}
</CodeBlock>
</TabItem>



</LanguageContent>

<!---
### Client API
- [Get a Compare-Exchange Value](../../../client-api/operations/compare-exchange/get-compare-exchange-value)
- [Get Compare-Exchange Values](../../../client-api/operations/compare-exchange/get-compare-exchange-values)
- [Put a Compare-Exchange Value](../../../client-api/operations/compare-exchange/delete-compare-exchange-value)
- [Atomic Guards](../../../client-api/session/cluster-transaction/atomic-guards)
- [Resolving Document Conflicts](../../../client-api/cluster/document-conflicts-in-client-side)

### Studio
- [Compare Exchange View](../../../studio/database/documents/compare-exchange-view)

### Server
- [Conflict Resolution](../../../server/clustering/replication/replication-conflicts)
- [Cluster-Wide Transactions](../../../server/clustering/cluster-transactions)

### Code Walkthrough
- [Create CmpXchg Item](https://demo.ravendb.net/demos/csharp/compare-exchange/create-compare-exchange)
- [Index CmpXchg Values](https://demo.ravendb.net/demos/csharp/compare-exchange/index-compare-exchange)

### Ayende @ Rahien Blog
- [Consistency in a Globally Distributed System](https://ayende.com/blog/196769-B/data-ownership-in-a-distributed-system)

### Compare Exchange
- [Get a Compare-Exchange Value](../../../client-api/operations/compare-exchange/get-compare-exchange-value)
- [Get Compare-Exchange Values](../../../client-api/operations/compare-exchange/get-compare-exchange-values)
- [Put a Compare-Exchange Value](../../../client-api/operations/compare-exchange/delete-compare-exchange-value)
- [Atomic Guards](../../../client-api/session/cluster-transaction/atomic-guards)


-->