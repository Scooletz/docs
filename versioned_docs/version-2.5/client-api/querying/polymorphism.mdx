---
title: "Polymorphic indexes"
hide_table_of_contents: true
sidebar_label: Polymorphism
sidebar_position: 5
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Polymorphic indexes

By default, RavenDB indexes operate only on a specific entity type, or a Collection, and it ignores the inheritance hierarchy when it does so.

For example, let us assume that we have the following inheritance hierarchy:

![Figure 1: Polymorphic indexes](./assets/polymorphic_indexes_faq.png)

If we saved a `Cat`, it would have an Entity-Name of "Cats" and if we saved a `Dog`, it would have an Entity-Name of "Dogs".

If we wanted to index cats by name, we would write:

```csharp 
    from cat in docs.Cats
    select new { cat.Name }
{CODE-END/}

And for dogs:

```csharp 
    from dog in docs.Dogs
    select new { dog.Name }
{CODE-END/}

This works, but each index would only give us results for the animal it has been defined on. But what if we wanted to query across all animals?

## Multi-map indexes

The easiest way to do this is by writing a multi-map index like this one:

<TabItem value="multi_map_1" label="multi_map_1">
<CodeBlock language="csharp">
{`public class AnimalsIndex : AbstractMultiMapIndexCreationTask
\{
	public AnimalsIndex()
	\{
		AddMap<Cat>(cats => from c in cats
							select new \{ c.Name \});

		AddMap<Dog>(dogs => from d in dogs
							select new \{ d.Name \});
	\}
\}
`}
</CodeBlock>
</TabItem>

And query it like this:

<TabItem value="multi_map_2" label="multi_map_2">
<CodeBlock language="csharp">
{`var results = session.Advanced.LuceneQuery<object>("AnimalsIndex").WhereEquals("Name", "Mitzy");
`}
</CodeBlock>
</TabItem>

You can also use the Linq provider if your objects implement an interface, IAnimal for instance:

<TabItem value="multi_map_3" label="multi_map_3">
<CodeBlock language="csharp">
{`session.Query<IAnimal>("AnimalsIndex").Where(x => x.Name == "Mitzy");
`}
</CodeBlock>
</TabItem>

## Other ways

Another option would be to modify the way we generate the Entity-Name for subclasses of Animal, like so:

<TabItem value="other_ways_1" label="other_ways_1">
<CodeBlock language="csharp">
{`var documentStore = new DocumentStore()
\{
	Conventions =
	\{
		FindTypeTagName = type =>
		\{
			if (typeof(Animal).IsAssignableFrom(type))
				return "Animals";
			return DocumentConvention.DefaultTypeTagName(type);
		\}
	\}
\};
`}
</CodeBlock>
</TabItem>

Using this method, we can now index on all animals using:

```csharp 
    from animal in docs.Animals
    select new { animal.Name }
{CODE-END/}

But what happen when you don't want to modify the entity name of an entity?

You can create a polymorphic index using:

```csharp 
     from animal in docs.WhereEntityIs("Cats", "Dogs")
     select new { animal.Name }
{CODE-END/}

That would generate an index that would match both Cats and Dogs.
