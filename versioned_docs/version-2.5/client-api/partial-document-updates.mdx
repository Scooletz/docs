---
title: "Partial document updates using the Patching API"
hide_table_of_contents: true
sidebar_label: Partial document updates using the Patching API
sidebar_position: 4
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Partial document updates using the Patching API

The process of document patching allows for modifying a document on the server without having to load it in full and saving it back. This is usually useful for updating denormalized data in entities.

In a normal use case, the client would issue a Load command to the server, deserialize the response into an entity, make changes to that entity, and then send it back for the server serialized. Using the Patching API the client can issue a single Patch command and the server will perform the requested operation on the JSON representation of the document. This can save bandwidth and be faster, but it is not a transactional operation, and as such only the last patching command is actually going to be persisted.

<Admonition type="note" title="">
Since this feature involves low-level document manipulation, it is considered to be an expert feature and generally should not be used as a general purpose solution. If you have reached a scenario where you are considering using this, you might want to recheck your data model and see if it can be optimized to prevent usage of the Patching API. The only exception is updating denormalized data, where this approach is valid but not always recommended.
</Admonition>

The patching API is exposed through RavenDB's `DatabaseCommands`, available from the document store object and `session.Advanced`. A patch command is issued by calling a single function `Patch`, accepting three parameters: the document key, an array of PatchRequests and an optional Etag:

<TabItem value="patching1" label="patching1">
<CodeBlock language="csharp">
{`var comment = new BlogComment
\{
	Title = "Foo",
	Content = "Bar"
\};

documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new[]
		\{
			new PatchRequest
				\{
					Type = PatchCommandType.Add,
					Name = "Comments",
					Value = RavenJObject.FromObject(comment)
				\}
		\});
`}
</CodeBlock>
</TabItem>

The document key is the unique key for the document in the current database, on which this patch command will be performed. Specifying an Etag would ensure changes are only made if no writes were performed since the client acquired the specified Etag.

Following are a description of the `PatchRequest` object, and the different options available through the Patching API. We will be using a simplistic example of a blog engine, using these classes:

<TabItem value="blogpost_classes" label="blogpost_classes">
<CodeBlock language="csharp">
{`public class BlogPost
\{
	public string Id \{ get; set; \}
	public string Title \{ get; set; \}
	public string Category \{ get; set; \}
	public string Content \{ get; set; \}
	public DateTime PublishedAt \{ get; set; \}
	public string[] Tags \{ get; set; \}
	public BlogComment[] Comments \{ get; set; \}
\}

public class BlogComment
\{
	public string Title \{ get; set; \}
	public string Content \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

## The PatchRequest object

When creating a PatchRequest object to be used in a patch command, at least 2 properties have to be specified: `Name` and `Type`.

Given the object graph stored under a given key, `Name` is the path from the root to a property (or properties) within that object graph. The syntax is similar to how XPath operates on XML, only more simplistic.

`Type` is what defines the patch command. It can be one of the following:

* **Set** - Set a property
* **Unset** - Unset (remove) a property
* **Inc** - Increment a property by a specified value
* **Rename** - Rename a property
* **Copy** - Copy a property value to another property
* **Modify** - Modify a property value by providing a nested set of patch operation
* **Add** - Add an item to an array
* **Insert** - Insert an item to an array at a specified position
* **Remove** - Remove an item from an array at a specified position

## Performing simple updates

A property in a stored document is a field from an entity. To change it's value using the Patching API, provide its path in `Name`, and initialize `Type` with `PatchCommandType.Set`. Then, serialize the object you want to save into that property, and pass it as `Value`.

The new value you set can be anything: a native type, an object, or a collection of entities. You can use `RavenJObject.FromObject(object)` to easily serialize it:

<TabItem value="patching2" label="patching2">
<CodeBlock language="csharp">
{`// Setting a native type value
documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new[]
		\{
			new PatchRequest
				\{
					Type = PatchCommandType.Set,
					Name = "Title",
					Value = RavenJObject.FromObject("New title")
				\}
		\});

// Setting an object as a property value
documentStore.DatabaseCommands.Patch(
	"blogposts/4321",
	new[]
		\{
			new PatchRequest
				\{
					Type = PatchCommandType.Set,
					Name = "Author",
					Value = RavenJObject.FromObject(
						new BlogAuthor
							\{
								Name = "Itamar",
								ImageUrl = "/author_images/itamar.jpg"
							\})
				\}
		\});
`}
</CodeBlock>
</TabItem>

Removing a property is done by simply passing `PatchCommandType.Unset` as `Type`.

To rename a property, or copy its value to another property, specify the new path as the `Value`:

<TabItem value="patching3" label="patching3">
<CodeBlock language="csharp">
{`// This is how you rename a property; copying works
// exactly the same, but with Type = PatchCommandType.Copy
documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new[]
		\{
			new PatchRequest
				\{
					Type = PatchCommandType.Rename,
					Name = "Comments",
					Value = new RavenJValue("cmts")
				\}
		\});
`}
</CodeBlock>
</TabItem>

Numeric values used as counters can be incremented or decremented, without worrying about their actual value. Use positive values to increment, and negative values to have it decremented:

<TabItem value="patching4" label="patching4">
<CodeBlock language="csharp">
{`// Assuming we have a Views counter in our entity
documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new[]
		\{
			new PatchRequest
				\{
					Type = PatchCommandType.Inc,
					Name = "Views",
					Value = new RavenJValue(1)
				\}
		\});
`}
</CodeBlock>
</TabItem>

## Conditional updates

If `PrevVal` is set, it's value will be compared against the current value of the property to verify a change isn't overwriting new values. If the value is `null`, the operation is always successful.

## Working with arrays

Any collection in your entity will be serialized into an array in the resulting JSON document. You can perform collection-specific operations on it easily, by using the `Position` property:

<TabItem value="patching_arrays1" label="patching_arrays1">
<CodeBlock language="csharp">
{`// Append a new comment; Insert operation is supported
// as well, by using PatchCommandType.Add and
// specifying a Position to insert at
documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new[]
		\{
			new PatchRequest
				\{
					Type = PatchCommandType.Add,
					Name = "Comments",
					Value =
						RavenJObject.FromObject(new BlogComment
						                        	\{Content = "FooBar"\})
				\}
		\});

// Remove the first comment
documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new[]
		\{
			new PatchRequest
				\{
					Type = PatchCommandType.Remove,
					Name = "Comments",
					Position = 0
				\}
		\});
`}
</CodeBlock>
</TabItem>

Being a JSON object, you can treat the entire array as value like shown above. Sometimes, however, you want to access certain items in the array

## Working with nested operations

The nested operations are only valid of the 'Type' is `PatchCommandType.Modify`.  
If we want to change all items in a collection we could do that by setting the AllPositions property to 'true'

**Here are a few examples of nested operations:**

Set value in a nested element:

<TabItem value="nested1" label="nested1">
<CodeBlock language="csharp">
{`var addToPatchedDoc = new JsonPatcher(doc).Apply(
	new[]
\{
	new PatchRequest
	\{
		Type = PatchCommandType.Modify,
		Name = "user",
		Nested = new[]
		\{
			new PatchRequest \{Type = PatchCommandType.Set, Name = "name", Value = new RavenJValue("rahien")\},
		\}
	\},
\});
`}
</CodeBlock>
</TabItem>

Remove value in a nested element:

<TabItem value="nested2" label="nested2">
<CodeBlock language="csharp">
{`var removeFromPatchedDoc = new JsonPatcher(doc).Apply(
new[]
\{
	new PatchRequest
	\{
		Type = PatchCommandType.Modify,
		Name = "user",
		PrevVal = RavenJObject.Parse(@"\{ ""name"": ""ayende"", ""id"": 13\}"),
		Nested = new[]
		\{
			new PatchRequest \{Type = PatchCommandType.Unset, Name = "name" \},
		\}
	\},
\});
`}
</CodeBlock>
</TabItem>

## Concurrency

If we wanted to we could run several batch operations in parallel, but we will not be able to set which one will end first.

## Performing complex updates
If you need to deal with more complex patching algorithm, using the methods shown above, might become cumbersome.

That's where the `ScriptedPatchRequest` comes in handy. It allows you to send a JavaScript snippet to the database which is executed against the JSON of the document which should be updated.

Adding a new `BlogComment` is as simple as this:

<TabItem value="scriptedpatching1" label="scriptedpatching1">
<CodeBlock language="csharp">
{`var blogComment = new BlogComment()
\{
	Title = "Awesome Feature",
	Content = @"ScriptedPatchRequest is the greatest thing since sliced bread."
\};

documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = @"this.Comments.push(newComment)",
		Values = \{ \{ "newComment", blogComment \} \}
	\});
`}
</CodeBlock>
</TabItem>

As you can see you can inject the values into the script by using _Values_ collection. In order to get the id of the current document use:

<TabItem value="scriptedpatching_get_id" label="scriptedpatching_get_id">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = "var currentDocId = this.__document_id;"
	\});
`}
</CodeBlock>
</TabItem>

Of course, `ScriptedPatchRequest` allows you to use any arbitrary JavaScript functionality like for-loops. Additionally there are a few custom methods available that you can use in your scripts:

#### Remove
An easy way to remove items from an array:

<TabItem value="scriptedpatching_remove" label="scriptedpatching_remove">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = "this.Tags.Remove(tagToRemove)",
		Values = \{ \{ "tagToRemove", "Interesting" \} \}
	\});
`}
</CodeBlock>
</TabItem>

#### RemoveWhere

Often, you don't simply want to remove items from arrays but remove them conditionally instead:

<TabItem value="scriptedpatching_remove_where" label="scriptedpatching_remove_where">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = @"
			this.Comments.RemoveWhere(function(comment) \{ 
				return comment.Content === 'Spam' 
			\});
		"
	\});
`}
</CodeBlock>
</TabItem>

#### Map

It is used to modify the collection of elements:

<TabItem value="scriptedpatching_map" label="scriptedpatching_map">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = @"
			this.Comments.Map(function(comment) \{   
				if(comment.Content.indexOf(""Raven"") != -1)
				\{
					comment.Title = ""[Raven] "" + comment.Title;
				\}
				return comment;
			\});
		"
	\});
`}
</CodeBlock>
</TabItem>

#### LoadDocument

It allows to load a separate document and update a current document based on it's values:

<TabItem value="scriptedpatching_load" label="scriptedpatching_load">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = @"
			var author = LoadDocument(this.Author.Id);
			this.AuthorName = author.FirstName + ' ' + author.LastName;
		"
	\});
`}
</CodeBlock>
</TabItem>

#### PutDocument

By using this you can even create a new document or update an another existing one:

<TabItem value="scriptedpatching_put" label="scriptedpatching_put">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = @"
			PutDocument('titles/' + this.Title,
						\{ 'PostId' : this.Id \}, 
						\{ 'MetadataAuthorValue' : this.Author \}
			);
		"
	\});
`}
</CodeBlock>
</TabItem>

The following parameters are passed to this method (according to the order):

* key of a document 
	* you can specify just a prefix e.g. 'Titles/' 
	* if `null` is provided then a database will create it as GUID
* document body as JSON
* metadata as JSON (optionally)
	* if you specify 'etag' property here then it will do the check to ensure that it matches an Etag of an updated document (if not `ConcurrencyException` will be thrown)

#### trim

A small but very helpful helper:

<TabItem value="scriptedpatching_trim" label="scriptedpatching_trim">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = @"
			this.Title = this.Title.trim();
		"
	\});
`}
</CodeBlock>
</TabItem>

#### output

It allows to retrieve debug information from a script execution. In order to extract this info, get the _Debug_ array of the returned result:

<TabItem value="scriptedpatching_debug" label="scriptedpatching_debug">
<CodeBlock language="csharp">
{`var patchOutput = documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest
	\{
		Script = @"
			output(this.AuthorName);

			this.NumberOfViews += 1;
			output(this.NumberOfViews);
		"
	\});

var debugInfo = patchOutput.Value<RavenJArray>("Debug");

foreach (var debug in debugInfo)
\{
	Console.WriteLine("Patch debug: " + debug);
\}
`}
</CodeBlock>
</TabItem>

#### lodash.js

You can also take advantage of any function from [Lo-Dash](https://lodash.com/) library which is included into Raven script engine by default. Example with &lt;em&gt;forEach&lt;/em&gt; usage:

<TabItem value="scriptedpatching_lodash" label="scriptedpatching_lodash">
<CodeBlock language="csharp">
{`documentStore.DatabaseCommands.Patch(
	"blogposts/1234",
	new ScriptedPatchRequest()
	\{
		Script = @"_(this.Comments).forEach(function(comment)\{
			PutDocument('CommentAuthors/', \{ 'Author' : comment.Author \}
			);
		\});"
	\});
`}
</CodeBlock>
</TabItem>

### Script limitations

Raven limits the number of statements in a script to execute. By default it is 10.000 steps, you can control it by using _Raven/MaxStepsForScript_ setting. 

Additionally you can change a value of a setting
_Raven/AdditionalStepsForScriptBasedOnDocumentSize_ that allows to perform a few additional steps calculated as &lt;em&gt;sizeOfDocument * specifiedValue&lt;/em&gt; (default is 5).

We also limit a recursion to 50 calls.
