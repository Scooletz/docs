import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* In this section, we explain how to use [RavenDB.TestDriver](https://www.nuget.org/packages/RavenDB.TestDriver/) 
  to write RavenDB unit tests.  

* TestDriver uses an [Embedded Server](../server/embedded.mdx) package with the same set of 
  [prerequisites](../server/embedded.mdx#prerequisite) as embedded servers to run the tests.  

* In this page: 
   - [`RavenTestDriver`](../start/test-driver.mdx#raventestdriver)
   - [Pre-initializing the store: `PreInitialize`](../start/test-driver.mdx#pre-initializing-the-store:-preinitialize)
   - [Configure the server: `ConfigureServer`](../start/test-driver.mdx#configure-the-server:-configureserver)
   - [Unit test](../start/test-driver.mdx#unit-test)
   - [Complete example](../start/test-driver.mdx#complete-example)
   - [Continuous Integration (CI) Servers](../start/test-driver.mdx#continuous-integration-(ci)-servers)
   - [Licensing](../start/test-driver.mdx#licensing)

</Admonition>

## `RavenTestDriver`

Start by creating a class that derives from `RavenTestDriver`.  
Find below a list of test driver methods, followed by [samples](../start/test-driver.mdx#complete-example).  

### TestDriver Methods

#### `DatabaseDumpFilePath`
Override the path to the database dump file that is loaded when calling ImportDatabase.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual string DatabaseDumpFilePath => null;
`}
</CodeBlock>
</TabItem>  

#### `DatabaseDumpFileStream`
Allow overriding the stream containing the database dump loaded when calling ImportDatabase.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual Stream DatabaseDumpFileStream => null;
`}
</CodeBlock>
</TabItem>  

#### `GetDocumentStore`
Get an IDocumentStore instance for the requested database.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public IDocumentStore GetDocumentStore([CallerMemberName] string database = null, 
                                                TimeSpan? waitForIndexingTimeout = null)
`}
</CodeBlock>
</TabItem>  
  
#### `PreInitialize`
Pre-initialize IDocumentStore.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void PreInitialize(IDocumentStore documentStore)
`}
</CodeBlock>
</TabItem>  

#### `PreConfigureDatabase`
Pre configure the database record before creating it.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void PreConfigureDatabase(DatabaseRecord databaseRecord)
`}
</CodeBlock>
</TabItem>  

#### `SetupDatabase`
Initialize the database  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void SetupDatabase(IDocumentStore documentStore)
`}
</CodeBlock>
</TabItem>  

#### `DriverDisposed`  
An event raised when the test driver is disposed of  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected event EventHandler DriverDisposed;
`}
</CodeBlock>
</TabItem>  

#### `ConfigureServer`  
Configure the server before running it
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public static void ConfigureServer(TestServerOptions options)
`}
</CodeBlock>
</TabItem>  

#### `WaitForIndexing`
Wait for indexes to become non-stale  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public void WaitForIndexing(IDocumentStore store, string database = null, 
                                                    TimeSpan? timeout = null)
`}
</CodeBlock>
</TabItem>  

#### `WaitForUserToContinueTheTest`  
Pause the test and launch Studio to examine database state  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public void WaitForUserToContinueTheTest(IDocumentStore store)
`}
</CodeBlock>
</TabItem>  

#### `OpenBrowser`  
Open browser  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void OpenBrowser(string url)
`}
</CodeBlock>
</TabItem>  

#### `Dispose`  
Dispose of the server  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public virtual void Dispose()
`}
</CodeBlock>
</TabItem>  



## Pre-initializing the store: `PreInitialize`

Pre-Initializing the IDocumentStore allows you to mutate the conventions used by the document store.

### Example

<TabItem value="test_driver_PreInitialize" label="test_driver_PreInitialize">
<CodeBlock language="csharp">
{`//This allows us to modify the conventions of the store we get from 'GetDocumentStore'
protected override void PreInitialize(IDocumentStore documentStore)
\{
    documentStore.Conventions.MaxNumberOfRequestsPerSession = 50;
\}
`}
</CodeBlock>
</TabItem>



## Configure the server: `ConfigureServer`

The `ConfigureServer` method allows you to be more in control of your server.  
You can use it with `TestServerOptions` to change the path to the Raven server binaries, specify data storage path, adjust .NET framework versions, etc.

* `ConfigureServer` can only be set once per test run.  
  It needs to be set before `GetDocumentStore` is called.  
  See an [example](../start/test-driver.mdx#complete-example) below.  

* If it is called twice, or within the `DocumentStore` scope, you will get the following error message:
  `System.InvalidOperationException : Cannot configure server after it was started. Please call 'ConfigureServer' method before any 'GetDocumentStore' is called.`  

<Admonition type="info" title="TestServerOptions" id="testserveroptions" href="#testserveroptions">

Defining TestServerOptions allows you to be more in control of 
how the embedded server is going to run with just a minor [definition change](../start/test-driver.mdx#example-2).

* To see the complete list of `TestServerOptions`, which inherits from embedded servers, go to embedded [ServerOptions](../server/Embedded.mdx#serveroptions).  
* It's important to be sure that the correct [.NET FrameworkVersion](../server/embedded.mdx#net-frameworkversion) is set.

</Admonition>

#### Example

<TabItem value="test_driver_ConfigureServer" label="test_driver_ConfigureServer">
<CodeBlock language="csharp">
{`var testServerOptions = new TestServerOptions
\{
    // Looks for the newest version on your machine including 3.1.15 and any newer patches
    // but not major new releases (default is .NET version at time of server release).
    FrameworkVersion = "3.1.15+",

    // Specifies where ravendb server binaries are located (Optional)
    ServerDirectory = "PATH_TO_RAVENDB_SERVER",

    // Specifies where ravendb data will be placed/located (Optional)
    DataDirectory = "PATH_TO_RAVENDB_DATADIR", 
\};

ConfigureServer(testServerOptions);
`}
</CodeBlock>
</TabItem>



## Unit test

We use [xunit](https://www.nuget.org/packages/xunit/) for the test framework in the below example.  

<Admonition type="note" title="">
Note that the test itself is meant to show different capabilities of the test driver and is not meant to be the most efficient.  
</Admonition>

The example below depends on the `TestDocumentByName` index and `TestDocument` class that can be seen in the [full example](../start/test-driver.mdx#complete-example)

#### Example

In the example, we get an `IDocumentStore` object to our test database, deploy an index, and insert two documents into the document store.  

We then use `WaitForUserToContinueTheTest(store)` which launches the Studio so we can verify that the documents 
and index are deployed (we can remove this line after the test succeeds).  

Finally, we use `session.Query` to query for "TestDocument" where the name contains the word 'hello', 
and we assert that we have only one such document.

<TabItem value="test_driver_MyFirstTest" label="test_driver_MyFirstTest">
<CodeBlock language="csharp">
{`[Fact]
public void MyFirstTest()
\{
    using (var store = GetDocumentStore())
    \{
        store.ExecuteIndex(new TestDocumentByName());
        using (var session = store.OpenSession())
        \{
            session.Store(new TestDocument \{ Name = "Hello world!" \});
            session.Store(new TestDocument \{ Name = "Goodbye..." \});
            session.SaveChanges();
        \}
        // If we want to query documents, sometimes we need to wait for the indexes to catch up  
        // to prevent using stale indexes.
        WaitForIndexing(store);

        // Sometimes we want to debug the test itself. This method redirects us to the studio
        // so that we can see if the code worked as expected (in this case, created two documents).
        WaitForUserToContinueTheTest(store);

        using (var session = store.OpenSession())
        \{
            var query = session.Query<TestDocument, TestDocumentByName>().Where(x => x.Name == "hello").ToList();
            Assert.Single(query);
        \}
    \}
\}
`}
</CodeBlock>
</TabItem>



## Complete example

This is a full unit test using [Xunit](https://www.nuget.org/packages/xunit/).

In the test, we get an `IDocumentStore` object to our test database, deploy an index, and insert two documents into the document store.  

We then use `WaitForUserToContinueTheTest(store)` which launches the Studio so we can verify that the documents 
and index are deployed (we can remove this line after the test succeeds).  

Finally, we use `session.Query` to query for "TestDocument" where the name contains the word 'hello', 
and we assert that we have only one such document.

<TabItem value="test_full_example" label="test_full_example">
<CodeBlock language="csharp">
{`using Raven.Client.Documents;
using Raven.TestDriver;
using Xunit;
using System.Linq;
using Raven.Client.Documents.Indexes;

namespace RavenDBTestDriverFullExample
\{

    public class RavenDBTestDriver : RavenTestDriver
    \{
        static RavenDBTestDriver()
        \{
            // ConfigureServer() must be set before calling GetDocumentStore()
            // and can only be set once per test run.
            ConfigureServer(new TestServerOptions
            \{
                DataDirectory = "C:\\\\RavenDBTestDir"
            \});
        \}
        // This allows us to modify the conventions of the store we get from 'GetDocumentStore'
        protected override void PreInitialize(IDocumentStore documentStore)
        \{
            documentStore.Conventions.MaxNumberOfRequestsPerSession = 50;
        \}

        [Fact]
        public void MyFirstTest()
        \{
            // GetDocumentStore() evokes the Document Store, which establishes and manages communication
            // between your client application and a RavenDB cluster via HTTP requests.
            using (var store = GetDocumentStore())
            \{
                store.ExecuteIndex(new TestDocumentByName());
                using (var session = store.OpenSession())
                \{
                    session.Store(new TestDocument \{ Name = "Hello world!" \});
                    session.Store(new TestDocument \{ Name = "Goodbye..." \});
                    session.SaveChanges();
                \}
                // If we want to query documents, sometimes we need to wait for the indexes to catch up  
                // to prevent using stale indexes.
                WaitForIndexing(store);

                // Sometimes we want to debug the test itself. This method redirects us to the studio
                // so that we can see if the code worked as expected (in this case, created two documents).
                WaitForUserToContinueTheTest(store);

                // Queries are defined in the session scope.
                // If there is no relevant index to quickly answer the query, RavenDB creates an auto-index
                // based on the query parameters.
                // This query will use the static index defined in lines 63-70 and filter the results by name.
                using (var session = store.OpenSession())
                \{
                    var query = session.Query<TestDocument, TestDocumentByName>()
                        .Where(x => x.Name == "hello").ToList();
                    Assert.Single(query);
                \}
            \}
        \}
    \}
    // AbstractIndexCreationTask allows you to create and manually define a static index. 
    public class TestDocumentByName : AbstractIndexCreationTask<TestDocument>
    \{
        public TestDocumentByName()
        \{
            Map = docs => from doc in docs select new \{ doc.Name \};
            Indexes.Add(x => x.Name, FieldIndexing.Search);
        \}
    \}

    public class TestDocument
    \{
        public string Name \{ get; set; \}
    \}
\}
`}
</CodeBlock>
</TabItem>



## Continuous Integration (CI) Servers

Best practice is to use a CI/CD server to help automate the testing and deployment of your new code. 
Popular CI/CD products are [AppVeyor](https://www.appveyor.com/) or [Visual Studio Team Services (aka. VSTS)](https://visualstudio.microsoft.com/team-services/).



## Licensing

The embedded server that TestDriver uses while running your tests can only apply the 
features and access the resources defined by its [license](https://ravendb.net/buy).  
An unlicensed server, for example, will be able to use no more than 3 CPU cores, while 
a server licensed using a [free developers license](https://ravendb.net/buy#developer) 
will be able to use up to 9 cores and run way faster.  

* When the server is started, its license is validated.  
   * If the validation succeeds, the server will run, applying the capabilities defined 
     by its license.  
   * If the validation fails, the server may still run - but its capabilities will be 
     limited to those defined by the basic [AGPL](https://ravendb.net/legal/ravendb/commercial-license-eula) 
     license (e.g., using up to 3 CPU cores).  
     <Admonition type="note" title="">
     If the validation fails because the license expired, and the expiration date precedes 
     the server build date, the server will not run.  
     </Admonition>

* A `TestServerOptions.Licensing.ThrowOnInvalidOrMissingLicense` configuration option 
  is available since RavenDB `5.4`, determining whether to throw a `LicenseExpiredException` 
  exception if TestDriver uses an unlicensed embedded server.  
   * If `ThrowOnInvalidOrMissingLicense` is set to **`true`** and the validation fails, 
     a `LicenseExpiredException` exception will be thrown to **warn TestDriver users** 
     that in lack of a valid license, their server's capabilities are limited and they 
     may therefore miss out on much of their system's potential.  
   * If the configuration option is set to **`false`**, **no exception will be thrown** 
     even if a license cannot be validated.  
   * Up until RavenDB version `6.0`, we set `TestServerOptions.Licensing.ThrowOnInvalidOrMissingLicense` 
     to **`false`** by default, so no exception would be thrown even if license validation fails.  
     For an exception to be thrown, change the flag to **`true`**.  
     <Admonition type="note" title="">
      This default setting changes to **`true`** from RavenDB version `6.2` on, so 
      a `LicenseExpiredException` exception **would** be thrown if the embedded server 
      used by TestDriver fails to validate a license.  
     </Admonition>

* Additional `TestServerOptions.Licensing` configuration options are available as well, 
  you can read about them [here](../server/embedded.mdx#licensing-options).  







