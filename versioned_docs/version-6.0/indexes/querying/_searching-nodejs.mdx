import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).
* In this article:
  * [Indexing single field for FTS](../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../indexes/querying/searching.mdx#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../indexes/querying/searching.mdx#boosting-search-results)
  * [Searching with wildcards](../../indexes/querying/searching.mdx#searching-with-wildcards)
      * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../indexes/querying/searching.mdx#when-usingoror)
      * [When using a custom analyzer](../../indexes/querying/searching.mdx#when-using-a-custom-analyzer)
      * [When using the Exact analyzer](../../indexes/querying/searching.mdx#when-using-the-exact-analyzer)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="js">
{`class Employees_ByNotes extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            employeeNotes: e.Notes
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");
        
        // Optionally: Set your choice of analyzer for the index-field.
        // Here the text from index-field 'employeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        this.analyze("employeeNotes", "WhitespaceAnalyzer");

        // Note:
        // If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Using the `search` method has the advantage of using any of its functionalities,  
  such as using wildcards, searching for multiple terms, etc.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const employees = await session
     // Query the index
    .query({ indexName: "Employees/ByNotes" })
     // Call 'search':
     // pass the index field name that was configured for FTS and the term to search for.
    .search("employeeNotes", "French")
    .all();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(employeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="js">
{`class Employees_ByEmployeeData extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            // Multiple document-fields can be indexed
            // into the single index-field 'employeeData' 
            employeeData: [e.FirstName, e.LastName, e.Title, e.Notes]
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");

        // Note:
        // Since no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const employees = await session
     // Query the static-index
    .query({ indexName: "Employees/ByEmployeeData" })
    .openSubclause()
     // A logical OR is applied between the following two Search calls:
    .search("employeeData", "Manager")
     // A logical AND is applied between the following two terms: 
    .search("employeeData", "French Spanish", "AND")
    .closeSubclause()
    .all();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(employeeData, "Manager") or search(employeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly, use the `AsJson` method, 
  which is available when using **a C# LINQ string** that is assigned to the `map` property in the Node.js index class,
  as shown in the example below.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`,
  the index automatically includes values from ALL existing and newly added properties
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="index_6" label="index_6">
<CodeBlock language="js">
{`// Extend the index class from 'AbstractCsharpIndexCreationTask':
class Products_ByAllValues extends AbstractCsharpIndexCreationTask \{
    constructor () \{
        super();

        // Using a C# LINQ string:  
        this.map = \`docs.Products.Select(product => new \{
                        AllValues = this.AsJson(product).Select(x => x.Value)
                    \})\`;

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'AllValues'
        this.index("AllValues", "Search");

        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.

        // Set the search engine type to Lucene:
        this.searchEngineType = "Lucene";
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const products = await session
    .query({ indexName: "Products/ByAllValues" })
    .search("AllValues", "tofu")
    .all();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(AllValues, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../indexes/boosting.mdx).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../client-api/session/querying/text-search/boost-search-results.mdx).



## Searching with wildcards

* When making a full-text search with wildcards in the search terms,
  the presence of wildcards (`*`) in the terms sent to the search engine is determined by the transformations applied by the
  [analyzer](../../indexes/using-analyzers.mdx) used in the index.

* Note the different behavior in the following cases, as described below:
  * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../indexes/querying/searching.mdx#when-usingoror)
  * [When using a custom analyzer](../../indexes/querying/searching.mdx#when-using-a-custom-analyzer)
  * [When using the Exact analyzer](../../indexes/querying/searching.mdx#when-using-the-exact-analyzer)

* When using [Corax](../../indexes/search-engine/corax.mdx) as the search engine,  
  this behavior will only apply to indexes that are newly created or have been reset.
<Admonition type="note" title="">

##### When using&nbsp;`RavenStandardAnalyzer`&nbsp;or`StandardAnalyzer`&nbsp;or&nbsp;`NGramAnalyzer`:
Usually, the same analyzer used to tokenize field content at **indexing time** is also used to process the terms provided in the **full-text search query**
before they are sent to the search engine to retrieve matching documents.

**However, in the following cases**:

* When making a [dynamic search query](../../client-api/session/querying/text-search/full-text-search.mdx)
* or when querying a static index that uses the default [RavenStandardAnalyzer](../../indexes/using-analyzers.mdx#using-the-default-search-analyzer)
* or when querying a static index that uses the [StandardAnalyzer](../../indexes/using-analyzers.mdx#analyzers-that-remove-common-stop-words)
* or when querying a static index that uses the [NGramAnalyzer](../../indexes/using-analyzers.mdx#analyzers-that-tokenize-according-to-the-defined-number-of-characters)

the queried terms in the _search_ method are processed with the [LowerCaseKeywordAnalyzer](../../indexes/using-analyzers.mdx#using-the-default-analyzer)  
before being sent to the search engine.

This analyzer does Not remove the `*`, so the terms are sent with `*`, as provided in the search terms.  
For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByNotes_usingDefaultAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        // Define the index-fields 
        this.map("Employees", e => ({
            employeeNotes: e.Notes
        }));

        // Configure the index-field for FTS:
        this.index("employeeNotes", "Search");

        // Since no analyzer is explicitly set
        // then the default 'RavenStandardAnalyzer' will be used at indexing time.

        // However, when making a search query with wildcards,
        // the 'LowerCaseKeywordAnalyzer' will be used to process the search terms
        // prior to sending them to the search engine.
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByNotes/usingDefaultAnalyzer" })
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .includeExplanations(e => explanations = e)
     // Provide a term with a wildcard to the search method:
    .search("employeeNotes", "*rench")
    .all();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
const explanation = explanations.explanations[employees[0].id][0];
const expectedVal = "employeeNotes:*rench";

assert.ok(explanation.includes(expectedVal), 
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/usingDefaultAnalyzer"
where search(EmployeeNotes, "*rench")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="">

##### When using a custom analyzer:
* When setting a [custom analyzer](../../indexes/using-analyzers.mdx#creating-custom-analyzers) in your index to tokenize field content,
  then when querying the index, the search terms in the query will be processed according to the custom analyzer's logic.

* The `*` will remain in the terms if the custom analyzer allows it.
  It is the user’s responsibility to ensure that wildcards are not removed by the custom analyzer if they should be included in the query.

* Note:  
  An exception to the above is when the wildcard is used as a suffix in the search term (e.g. `Fren*`).  
  In this case the wildcard will be included in the query regardless of the analyzer's logic.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByNotes_usingCustomAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        this.map("Employees", e => ({
            employeeNotes: e.Notes
        }));

        // Configure the index-field for FTS:
        this.index("employeeNotes", "Search");

        // Set a custom analyzer for the index-field:
        this.analyze("employeeNotes", "RemoveWildcardsAnalyzer");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Custom_analyzer" label="Custom_analyzer">
<CodeBlock language="js">
{`// The custom analyzer:
// ====================

const removeWildcardsanalyzer = \`
    using System.IO;
    using Lucene.Net.Analysis; 
    using Lucene.Net.Analysis.Standard;
    namespace CustomAnalyzers
    {
        public class RemoveWildcardsAnalyzer : StandardAnalyzer
        {
            public RemoveWildcardsAnalyzer() : base(Lucene.Net.Util.Version.LUCENE_30)
            {
            }
    
            public override TokenStream TokenStream(string fieldName, System.IO.TextReader reader)
            {
                // Read input stream and remove wildcards (*)
                string text = reader.ReadToEnd();
                string processedText = RemoveWildcards(text);
                StringReader newReader = new StringReader(processedText);
                
                return base.TokenStream(fieldName, newReader);
            }
    
            private string RemoveWildcards(string input)
            {
                // Replace wildcard characters with an empty string
                return input.Replace("*", "");
            }
        }
    }\`;

// Deploying the custom analyzer:
// ==============================

const analyzerDefinition = {
    name: "RemoveWildcardsAnalyzer",
    code: RemoveWildcardsAnalyzer
};

await documentStore.maintenance.send(new PutAnalyzersOperation(analyzerDefinition));
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByNotes/usingCustomAnalyzer" })
    .includeExplanations(e => explanations = e)
     // Provide a term with wildcards to the Search method:
    .search("employeeNotes", "*French*")
    .all();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
const explanation = explanations.explanations[employees[0].id][0];

const expectedVal = "employeeNotes:french";
assert.ok(explanation.includes(expectedVal),
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);

const notExpectedVal = "employeeNotes:*french";
assert.ok(!explanation.includes(notExpectedVal),
    \`'$\{explanation\}' does not contain '$\{notExpectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/UsingCustomAnalyzer"
where search(EmployeeNotes, "*French*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="">

##### When using the Exact analyzer:
When using the default Exact analyzer in your index (which is [KeywordAnalyzer](../../indexes/using-analyzers.mdx#using-the-default-exact-analyzer)),  
then when querying the index, the wildcards in your search terms remain untouched.  
The terms are sent to the search engine exactly as produced by the analyzer.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstName_usingExactAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        this.map("Employees", e => ({
            firstName: e.FirstName
        }));

        // Set the Exact analyzer for the index-field:
        // (The field will not be tokenized)
        this.index("firstName", "Exact");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByFirstName/usingExactAnalyzer" })
    .includeExplanations(e => explanations = e)
     // Provide a term with a wildcard to the Search method:
    .search("firstName", "Mich*")
    .all();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

const explanation = explanations.explanations[employees[0].id][0];
const expectedVal = "firstName:Mich*";

assert.ok(explanation.includes(expectedVal),
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByFirstName/usingExactAnalyzer"
where search(FirstName, "Mich*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



