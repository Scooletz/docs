---
title: "Stream Query Results"
sidebar_label: Stream Query Results
sidebar_position: 3
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/language-switcher";
import LanguageContent from "@site/src/components/language-content";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Stream Query Results
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* RavenDB supports __streaming data__ from the server to the client.  
  Streaming is useful when processing a large number of results.

* The data streamed can be a result of a dynamic query, a static index query, or just filtered by a prefix.  

* To stream results, use the `Stream` method from the `Advanced` session operations.

* In this page:

    * [Streaming overview](../../../client-api/session/querying/how-to-stream-query-results#streaming-overview)
     
    * [Stream by query](../../../client-api/session/querying/how-to-stream-query-results#stream-by-query)
        * [Stream a dynamic query](../../../client-api/session/querying/how-to-stream-query-results#stream-a-dynamic-query)
        * [Stream a dynamic raw query](../../../client-api/session/querying/how-to-stream-query-results#stream-a-dynamic-raw-query)
        * [Stream a projected query](../../../client-api/session/querying/how-to-stream-query-results#stream-a-projected-query)
        * [Stream an index query](../../../client-api/session/querying/how-to-stream-query-results#stream-an-index-query)
        * [Stream related documents](../../../client-api/session/querying/how-to-stream-query-results#stream-related-documents)
        * [By query syntax](../../../client-api/session/querying/how-to-stream-query-results#by-query-syntax)
      
    * [Stream by prefix](../../../client-api/session/querying/how-to-stream-query-results#stream-by-prefix)
        * [Stream results by prefix](../../../client-api/session/querying/how-to-stream-query-results#stream-results-by-prefix)
        * [By prefix syntax](../../../client-api/session/querying/how-to-stream-query-results#by-prefix-syntax)

</Admonition>
## Streaming overview

* __Immediate processing__:  
  Neither the client nor the server holds the full response in memory.   
  Instead, as soon as the server has a single result, it sends it to the client.  
  Thus, your application can start processing results before the server sends them all.

* __No tracking__:  
  The stream results are Not tracked by the session.  
  Changes made to the resulting entities will not be sent to the server when _SaveChanges_ is called.

* __A snapshot of the data__:  
  The stream results are a snapshot of the data at the time when the query is computed by the server.  
  Results that match the query after it was already processed are Not streamed to the client.

* __Query limitations:__:  

  * A streaming query does not wait for indexing by design.  
    So calling [WaitForNonStaleResults](../../../client-api/session/querying/how-to-customize-query#waitfornonstaleresults) is Not supported and will result in an exception.   
  
  * Using [Include](../../../client-api/how-to/handle-document-relationships#includes) to load a related document to the session in a streaming query is Not supported.  
    Learn how to __stream related documents__ here [below](../../../client-api/session/querying/how-to-stream-query-results#stream-related-documents).



## Stream by query

<Admonition type="note" title="Note">
#### Stream a dynamic query

<Tabs groupId='languageSyntax'>
<TabItem value="Query-Sync" label="Query-Sync">
<CodeBlock language="csharp">
{`// Define a query on a collection
IRavenQueryable<Employee> query = session
    .Query<Employee>()
    .Where(x => x.FirstName == "Robert");

// Call 'Stream' to execute the query
// Optionally, pass an 'out param' for getting the query stats
IEnumerator<StreamResult<Employee>> streamResults = 
    session.Advanced.Stream(query, out StreamQueryStatistics streamQueryStats);

// Read from the stream
while (streamResults.MoveNext())
{
    // Process the received result
    StreamResult<Employee> currentResult = streamResults.Current;
    
    // Get the document from the result
    // This entity will Not be tracked by the session
    Employee employee = currentResult.Document;
    
    // The currentResult item also provides the following:
    var employeeId  = currentResult.Id;
    var documentMetadata = currentResult.Metadata;
    var documentChangeVector = currentResult.ChangeVector;

    // Can get info from the stats, i.e. get number of total results
    int totalResults = streamQueryStats.TotalResults;
    // Get the Auto-Index that was used/created with this dynamic query
    string indexUsed = streamQueryStats.IndexName;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query-Async" label="Query-Async">
<CodeBlock language="csharp">
{`// Define a query on a collection
IRavenQueryable<Employee> query = asyncSession
    .Query<Employee>()
    .Where(x => x.FirstName == "Robert");

// Call 'StreamAsync' to execute the query
// Optionally, pass an 'out param' for getting the query stats
await using (IAsyncEnumerator<StreamResult<Employee>> streamResults = 
             await asyncSession.Advanced.StreamAsync(query, out StreamQueryStatistics streamQueryStats))
{
    // Read from the stream
    while (await streamResults.MoveNextAsync())
    {
        // Process the received result
        StreamResult<Employee> currentResult = streamResults.Current;
        
        // Get the document from the result
        // This entity will Not be tracked by the session
        Employee employee = currentResult.Document;
        
        // The currentResult item also provides the following:
        var employeeId  = currentResult.Id;
        var documentMetadata = currentResult.Metadata;
        var documentChangeVector = currentResult.ChangeVector;
        
        // Can get info from the stats, i.e. get number of total results
        int totalResults = streamQueryStats.TotalResults;
        // Get the Auto-Index that was used/created with this dynamic query
        string indexUsed = streamQueryStats.IndexName;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery-Sync" label="DocumentQuery-Sync">
<CodeBlock language="csharp">
{`// Define a document query on a collection
IDocumentQuery<Employee> query = session
    .Advanced
    .DocumentQuery<Employee>()
    .WhereEquals(x => x.FirstName, "Robert");

// Call 'Stream' to execute the query
// Optionally, add an out param for getting the query stats
IEnumerator<StreamResult<Employee>> streamResults = 
    session.Advanced.Stream(query, out StreamQueryStatistics streamQueryStats);

// Read from the stream
while (streamResults.MoveNext())
{
    // Process the received result
    StreamResult<Employee> currentResult = streamResults.Current;
    
    // Get the document from the result
    // This entity will Not be tracked by the session
    Employee employee = currentResult.Document;
        
    // The currentResult item also provides the following:
    var employeeId  = currentResult.Id;
    var documentMetadata = currentResult.Metadata;
    var documentChangeVector = currentResult.ChangeVector;
    
    // Can get info from the stats, i.e. get number of total results
    int totalResults = streamQueryStats.TotalResults;
    // Get the Auto-Index that was used/created with this dynamic query
    string indexUsed = streamQueryStats.IndexName;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery-Async" label="DocumentQuery-Async">
<CodeBlock language="csharp">
{`// Define a document query on a collection
IAsyncDocumentQuery<Employee> query = asyncSession
    .Advanced
    .AsyncDocumentQuery<Employee>()
    .WhereEquals(x => x.FirstName, "Robert");

// Call 'StreamAsync' to execute the query
// Optionally, add an out param for getting the query stats
await using (IAsyncEnumerator<StreamResult<Employee>> streamResults =
             await asyncSession.Advanced.StreamAsync(query, out StreamQueryStatistics streamQueryStats))
{
    // Read from the stream
    while (await streamResults.MoveNextAsync())
    {
        // Process the received result
        StreamResult<Employee> currentResult = streamResults.Current;
        
        // Get the document from the result
        // This entity will Not be tracked by the session
        Employee employee = currentResult.Document;
        
        // The currentResult item also provides the following:
        var employeeId  = currentResult.Id;
        var documentMetadata = currentResult.Metadata;
        var documentChangeVector = currentResult.ChangeVector;
        
        // Can get info from the stats, i.e. get number of total results
        int totalResults = streamQueryStats.TotalResults;
        // Get the Auto-Index that was used/created with this dynamic query
        string indexUsed = streamQueryStats.IndexName;
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">
#### Stream a dynamic raw query

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// Define a raw query using RQL
IRawDocumentQuery<Employee> query = session
    .Advanced
    .RawQuery<Employee>("from Employees where FirstName = 'Robert'");

// Call 'Stream' to execute the query
IEnumerator<StreamResult<Employee>> streamResults = session.Advanced.Stream(query);

while (streamResults.MoveNext())
{
    StreamResult<Employee> currentResult = streamResults.Current;
    Employee employee = streamResults.Current.Document;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// Define a raw query using RQL
IAsyncRawDocumentQuery<Employee> query = asyncSession
    .Advanced
    .AsyncRawQuery<Employee>("from Employees where FirstName = 'Robert'");

// Call 'StreamAsync' to execute the query
await using (IAsyncEnumerator<StreamResult<Employee>> streamResults =
             await asyncSession.Advanced.StreamAsync(query))
{
    while (await streamResults.MoveNextAsync())
    {
        StreamResult<Employee> currentResult = streamResults.Current;
        Employee employee = streamResults.Current.Document;
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">
#### Stream a projected query

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// Define a query with projected results
// Each query result is not an Emplyee document but an entity of type 'NameProjection'.
IRavenQueryable<NameProjection> query = session
    .Query<Employee>()
    .ProjectInto<NameProjection>();

// Call 'Stream' to execute the query
IEnumerator<StreamResult<NameProjection>> streamResults = session.Advanced.Stream(query);

while (streamResults.MoveNext())
{
    StreamResult<NameProjection> currentResult = streamResults.Current;
    NameProjection employeeName = streamResults.Current.Document;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// Define a query with projected results
// Each query result is not an Employee document but an entity of type 'NameProjection'.
IRavenQueryable<NameProjection> query = asyncSession
    .Query<Employee>()
    .ProjectInto<NameProjection>();

// Call 'StreamAsync' to execute the query
await using (IAsyncEnumerator<StreamResult<NameProjection>> streamResults =
             await asyncSession.Advanced.StreamAsync(query))
{
    while (await streamResults.MoveNextAsync())
    {
        StreamResult<NameProjection> currentResult = streamResults.Current;
        NameProjection employeeName = streamResults.Current.Document;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="ProjectedClass" label="ProjectedClass">
<CodeBlock language="csharp">
{`// Each query result will be of this class type
public class NameProjection
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">
#### Stream an index query

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// Define a query on an index
IQueryable<Employee> query = session.Query<Employee, Employees_ByFirstName>()
    .Where(employee => employee.FirstName == "Robert");

// Call 'Stream' to execute the query
IEnumerator<StreamResult<Employee>> streamResults = session.Advanced.Stream(query);

while (streamResults.MoveNext())
{
    StreamResult<Employee> currentResult = streamResults.Current;
    Employee employee = streamResults.Current.Document;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// Define a query on an index
IQueryable<Employee> query = asyncSession.Query<Employee, Employees_ByFirstName>()
    .Where(employee => employee.FirstName == "Robert");

// Call 'StreamAsync' to execute the query
await using (IAsyncEnumerator<StreamResult<Employee>> streamResults =
             await asyncSession.Advanced.StreamAsync(query))
{
    while (await streamResults.MoveNextAsync())
    {
        StreamResult<Employee> currentResult = streamResults.Current;
        Employee employee = streamResults.Current.Document;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`// The index:
public class Employees_ByFirstName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstName()
    {
        Map = employees => from employee in employees
            select new
            {
                FirstName = employee.FirstName
            };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">
#### Stream related documents
__Why streaming query results does not support 'include'__:

* A document can reference [related documents](../../../indexes/indexing-related-documents#what-are-related-documents).
* An [Include](../../../client-api/how-to/handle-document-relationships#includes) clause in a non-streamed query loads these related documents to the session  
  so that they can be accessed without an additional query to the server.
* Those included documents are sent to the client at the end of the query results.  
  This does not mesh well with streaming, which is designed to allow transferring massive amounts of data,  
  possibly over a significant amount of time.

__How to stream related documents__:

* Instead of using _include_, define the query so that it will return a [projection](../../../indexes/querying/projections).
* The projected query results will not be just the documents from the queried collection.  
  Instead, each result will be an entity containing the related document entities in addition to the original queried document.
* On the client side, you need to define a class that matches the projected query result.

__Example__:

* The below example uses RawQuery.  
  However, the same logic can be applied to a Query, DocumentQuery, or when querying an index.
* Note:  
  The projected class in the example contains the full related documents.  
  However, you can project just the needed properties from the related documents.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// Define a query with a 'select' clause to project the results.

// The related Company & Employee documents are 'loaded',
// and returned in the projection together with the Order document itself.

// Each query result is not an Order document but an entity of type 'AllDocsProjection'.

IRawDocumentQuery<AllDocsProjection> query = session
    .Advanced
    .RawQuery<AllDocsProjection>(@"from Orders as o 
                                   where o.ShipTo.City = 'London'
                                   load o.Company as c, o.Employee as e
                                   select {
                                       Order: o,
                                       Company: c,
                                       Employee: e
                                   }");

// Call 'Stream' to execute the query
IEnumerator<StreamResult<AllDocsProjection>> streamResults = session.Advanced.Stream(query);

while (streamResults.MoveNext())
{
    StreamResult<AllDocsProjection> currentResult = streamResults.Current;
    AllDocsProjection projection = streamResults.Current.Document;
    
    Order theOrderDoc = projection.Order;
    Company theRelatedCompanyDoc = projection.Company;
    Employee theRelatedEmployeeDoc = projection.Employee;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// Define a query with a 'select' clause to project the results.

// The related Company & Employee documents are 'loaded',
// and returned in the projection together with the Order document itself.

// Each query result is not an Order document but an entity of type 'AllDocsProjection'.

IAsyncRawDocumentQuery<AllDocsProjection> query = asyncSession
    .Advanced
    .AsyncRawQuery<AllDocsProjection>(@"from Orders as o 
                                   where o.ShipTo.City = 'London'
                                   load o.Company as c, o.Employee as e
                                   select {
                                       Order: o,
                                       Company: c,
                                       Employee: e
                                   }");

// Call 'StreamAsync' to execute the query
await using (IAsyncEnumerator<StreamResult<AllDocsProjection>> streamResults =
             await asyncSession.Advanced.StreamAsync(query))
{
    while (await streamResults.MoveNextAsync())
    {
        StreamResult<AllDocsProjection> currentResult = streamResults.Current;
        AllDocsProjection projection = streamResults.Current.Document;
        
        Order theOrderDoc = projection.Order;
        Company theRelatedCompanyDoc = projection.Company;
        Employee theRelatedEmployeeDoc = projection.Employee;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="ProjectedClass" label="ProjectedClass">
<CodeBlock language="csharp">
{`// Each query result will be of this class type
public class AllDocsProjection
{
    public Order Order { get; set; }
    public Employee Employee { get; set; }
    public Company Company { get; set; }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



<Admonition type="note" title="Note">
#### By query syntax

<TabItem value="something" label="syntax">
<CodeBlock language="csharp">
{`// Stream by query:
IEnumerator<StreamResult<T>> Stream<T>(IQueryable<T> query);
IEnumerator<StreamResult<T>> Stream<T>(IQueryable<T> query, out StreamQueryStatistics streamQueryStats);

IEnumerator<StreamResult<T>> Stream<T>(IDocumentQuery<T> query);
IEnumerator<StreamResult<T>> Stream<T>(IDocumentQuery<T> query, out StreamQueryStatistics streamQueryStats);

IEnumerator<StreamResult<T>> Stream<T>(IRawDocumentQuery<T> query);
IEnumerator<StreamResult<T>> Stream<T>(IRawDocumentQuery<T> query, out StreamQueryStatistics streamQueryStats);
`}
</CodeBlock>
</TabItem>

| Parameters | type | description |
| - | - | - |
| **query** | [IQueryable](../../../client-api/session/querying/how-to-query#session.query), [IDocumentQuery](../../../client-api/session/querying/how-to-query#session.advanced.documentquery) or [IRawDocumentQuery](../../../client-api/session/querying/how-to-query#session.advanced.rawquery) | The query for which to stream results |
| `out` **streamQueryStats** | [StreamQueryStatistics](../../../glossary/stream-query-statistics) | Information about performed query |

| Return Value | |
| - | - |
| IEnumerator&lt;[StreamResult&lt;T&gt;](../../../glossary/stream-result)&gt; | Enumerator with resulting entities |

</Admonition>

## Stream by prefix

<Admonition type="note" title="Note">
####  Stream results by prefix
* Streamed data can also be filtered by an __ID prefix__ and by other __filtering options__, see syntax below.
* Note: No auto-index is created when streaming results by a prefix.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`string idPrefix = "Orders/";
string matches = "*25-A|77?-A";

// Filter streamed results by the passing 'prefix' and an optional 'matches' string
IEnumerator<StreamResult<Order>> streamResults = session.Advanced.Stream<Order>(idPrefix, matches);

while (streamResults.MoveNext())
{
    // Documents that will be returned are only those matching the following:
    // * Document ID starts with "Orders/"
    // * The rest of the ID (after prefix) must match the 'matches' string
    // e.g. "Orders/325-A" or Orders/772-A", etc.
    
    StreamResult<Order> currentResult = streamResults.Current;
    Order order = currentResult.Document;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`string idPrefix = "Orders/";
string matches = "*25-A|77?-A";

// Filter streamed results by the passing 'prefix' and an optional 'matches' string
await using (IAsyncEnumerator<StreamResult<Order>> streamResults =
             await asyncSession.Advanced.StreamAsync<Order>(idPrefix, matches))
{
    while (await streamResults.MoveNextAsync())
    {
        // Documents that will be returned are only those matching the following:
        // * Document ID starts with "Orders/"
        // * The rest of the ID (after prefix) must match the 'matches' string
        // e.g. "Orders/325-A" or Orders/772-A", etc.

        StreamResult<Order> currentResult = streamResults.Current;
        Order order = currentResult.Document;
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">
#### By prefix syntax

<TabItem value="something" label="syntax_2">
<CodeBlock language="csharp">
{`// Stream by prefix:
IEnumerator<StreamResult<T>> Stream<T>(string startsWith, string matches = null,
    int start = 0, int pageSize = int.MaxValue, string startAfter = null);
`}
</CodeBlock>
</TabItem>

| Parameters | type | description |
| - | - | - |
| **startsWith** | `string` | Stream documents with this ID prefix |
| **matches** | `string` | Filter the ID part that comes after the specified prefix.<br/>Use '?' for any character, '*' any characters.<br/>Use '&#124;' to separate rules. |
| **start** | `int` | Number of documents to skip |
| **pageSize** | `int` | Maximum number of documents to retrieve |
| **startAfter** | `string` | Skip fetching documents until this ID is found.<br/>Only return documents after this ID (default: null). |

| Return Value | |
| - | - |
| IEnumerator&lt;[StreamResult&lt;T&gt;](../../../glossary/stream-result)&gt; | Enumerator with resulting entities |

</Admonition>



</LanguageContent>
<LanguageContent language="java">


RavenDB supports __streaming data__ from the server to the client.  
Streaming is useful when processing a large number of results.

The data streamed can be a result of a dynamic query, a static index query, or just filtered by a prefix.

To stream results, use the `stream` method from the `advanced` session operations.
## Streaming overview

* __Immediate processing__:  
  Neither the client nor the server holds the full response in memory.   
  Instead, as soon as the server has a single result, it sends it to the client.  
  Thus, your application can start processing results before the server sends them all.

* __No tracking__:  
  The stream results are Not tracked by the session.  
  Changes made to the resulting entities will not be sent to the server when _saveChanges_ is called.

* __A snapshot of the data__:  
  The stream results are a snapshot of the data at the time when the query is computed by the server.  
  Results that match the query after it was already processed are Not streamed to the client.

* __Query limitations:__:

    * A streaming query does not wait for indexing by design.  
      So calling [waitForNonStaleResults](../../../client-api/session/querying/how-to-customize-query#waitfornonstaleresults) is Not supported and will result in an exception.

    * Using [include](../../../client-api/session/loading-entities#load-with-includes) to load a related document to the session in a streaming query is Not supported.  



## Syntax

<TabItem value="something-something" label="stream_1">
<CodeBlock language="java">
{`<T> CloseableIterator<StreamResult<T>> stream(IDocumentQuery<T> query);

<T> CloseableIterator<StreamResult<T>> stream(IDocumentQuery<T> query, Reference<StreamQueryStatistics> streamQueryStats);

<T> CloseableIterator<StreamResult<T>> stream(IRawDocumentQuery<T> query);

<T> CloseableIterator<StreamResult<T>> stream(IRawDocumentQuery<T> query, Reference<StreamQueryStatistics> streamQueryStats);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **query** | [IDocumentQuery](../../../client-api/session/querying/how-to-query#session.advanced.documentquery) or [IRawDocumentQuery](../../../client-api/session/querying/how-to-query#session.advanced.rawquery) | Query to stream results for. |
| `Reference` **streamQueryStats** | StreamQueryStatistics | Information about performed query. |

| Return Value | |
| ------------- | ----- |
| CloseableIterator&lt;StreamResult&gt; | Iterator with entities. |

## Example I - Using Static Index

<TabItem value="something-something" label="stream_2">
<CodeBlock language="java">
{`IDocumentQuery<Employee> query = session
    .query(Employee.class, Employees_ByFirstName.class)
    .whereEquals("FirstName", "Robert");

CloseableIterator<StreamResult<Employee>> results = session.advanced().stream(query);

while (results.hasNext()) \{
    StreamResult<Employee> employee = results.next();
\}
`}
</CodeBlock>
</TabItem>

## Example II - Dynamic Document Query

<TabItem value="something-something" label="stream_3">
<CodeBlock language="java">
{`IDocumentQuery<Employee> query = session
    .advanced()
    .documentQuery(Employee.class)
    .whereEquals("FirstName", "Robert");

Reference<StreamQueryStatistics> streamQueryStatsRef = new Reference<>();
CloseableIterator<StreamResult<Employee>> results = session.advanced().stream(query, streamQueryStatsRef);

while (results.hasNext()) \{
    StreamResult<Employee> employee = results.next();
\}
`}
</CodeBlock>
</TabItem>

## Example III - Dynamic Raw Query

<TabItem value="something-something" label="stream_4">
<CodeBlock language="java">
{`IRawDocumentQuery<Employee> query = session.advanced()
    .rawQuery(Employee.class, "from Employees where FirstName = 'Robert'");

CloseableIterator<StreamResult<Employee>> results = session.advanced().stream(query);

while (results.hasNext()) \{
    StreamResult<Employee> employee = results.next();
\}
`}
</CodeBlock>
</TabItem>


</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* RavenDB supports __streaming data__ from the server to the client.  
  Streaming is useful when processing a large number of results.

* The data streamed can be a result of a dynamic query, a static index query, or just filtered by a prefix.

* To stream results, use the `stream` method from the `advanced` session operations.

* In this page:

    * [Streaming overview](../../../client-api/session/querying/how-to-stream-query-results#streaming-overview)

    * [Stream by query](../../../client-api/session/querying/how-to-stream-query-results#stream-by-query)
        * [Stream a dynamic query](../../../client-api/session/querying/how-to-stream-query-results#stream-a-dynamic-query)
        * [Stream a dynamic raw query](../../../client-api/session/querying/how-to-stream-query-results#stream-a-dynamic-raw-query)
        * [Stream a projected query](../../../client-api/session/querying/how-to-stream-query-results#stream-a-projected-query)
        * [Stream an index query](../../../client-api/session/querying/how-to-stream-query-results#stream-an-index-query)
        * [Stream related documents](../../../client-api/session/querying/how-to-stream-query-results#stream-related-documents)
        * [By query syntax](../../../client-api/session/querying/how-to-stream-query-results#by-query-syntax)

    * [Stream by prefix](../../../client-api/session/querying/how-to-stream-query-results#stream-by-prefix)
        * [Stream results by prefix](../../../client-api/session/querying/how-to-stream-query-results#stream-results-by-prefix)
        * [By prefix syntax](../../../client-api/session/querying/how-to-stream-query-results#by-prefix-syntax)

</Admonition>
## Streaming overview

* __Immediate processing__:  
  Neither the client nor the server holds the full response in memory.   
  Instead, as soon as the server has a single result, it sends it to the client.  
  Thus, your application can start processing results before the server sends them all.

* __No tracking__:  
  The stream results are Not tracked by the session.  
  Changes made to the resulting entities will not be sent to the server when _saveChanges_ is called.

* __A snapshot of the data__:  
  The stream results are a snapshot of the data at the time when the query is computed by the server.  
  Results that match the query after it was already processed are Not streamed to the client.

* __Query limitations:__:

    * A streaming query does not wait for indexing by design.  
      So calling [waitForNonStaleResults](../../../client-api/session/querying/how-to-customize-query#waitfornonstaleresults) is Not supported and will result in an exception.

    * Using [include](../../../client-api/session/loading-entities#load-with-includes) to load a related document to the session in a streaming query is Not supported.  
      Learn how to __stream related documents__ here [below](../../../client-api/session/querying/how-to-stream-query-results#stream-related-documents).



## Stream by query

<Admonition type="note" title="Note">
#### Stream a dynamic query

<TabItem value="something-something" label="stream_1">
<CodeBlock language="nodejs">
{`// Define a query on a collection
const query = session.query(\{ collection: "employees" \})
    .whereEquals('FirstName', 'Robert');

// Call stream() to execute the query, it returns a Node.js ReadableStream.
// Parms: pass the query and an optional callback for getting the query stats.
let streamQueryStats;
const queryStream = await session.advanced.stream(query, s => streamQueryStats = s);

// Two options to get query stats:
// * Pass a callback to stream() with an 'out param' that will be filled with query stats.
//   This param can then be accessed in the 'end' event.
// * Or: Use an event listener, listen to the 'stats' event, as described below.

// Handle stream events with callback functions:        

// Process the item received:
queryStream.on("data", resultItem => \{
    // Get the employee entity from the result item.
    // Note: This entity will Not be tracked by the session.
    const employee = resultItem.document;

    // The resultItem also provides the following:
    const employeeId = resultItem.id;
    const documentMetadata = resultItem.metadata;
    const documentChangeVector = resultItem.changeVector;
\});

// Can get query stats by using an event listener:
queryStream.once("stats", queryStats => \{
    // Get number of total results
    const totalResults = queryStats.totalResults;
    // Get the Auto-Index that was used/created with this dynamic query
    const indexUsed = queryStats.indexName;
\});

// Stream emits an 'end' event when there is no more data to read:
queryStream.on("end", () => \{            
    // Get info from 'streamQueryStats', the stats object
    const totalResults = streamQueryStats.totalResults;
    const indexUsed = streamQueryStats.indexName;
\});

queryStream.on("error", err => \{
    // Handle errors
\});
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">
#### Stream a dynamic raw query

<TabItem value="something-something" label="stream_2">
<CodeBlock language="nodejs">
{`// Define a raw query using RQL
const rawQuery = session.advanced
    .rawQuery("from Employees where FirstName = 'Robert'");

// Call stream() to execute the query
const queryStream = await session.advanced.stream(rawQuery);

// Handle stats & stream events as described in the dynamic query example above.
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">
#### Stream a projected query

<TabItem value="something-something" label="stream_3">
<CodeBlock language="nodejs">
{`// Define a query with projected results
// Each query result is not an Employee document but an entity containing selected fields only.
const projectedQuery = session.query(\{collection: 'employees'\})
    .selectFields(['FirstName', 'LastName']);
       
// Call stream() to execute the query
const queryStream = await session.advanced.stream(projectedQuery);

queryStream.on("data", resultItem => \{
    // entity contains only the projected fields
    const employeeName = resultItem.document;
\});

// Handle stats & stream events as described in the dynamic query example above.
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">
#### Stream an index query

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`// Define a query on an index
const query = session.query({ indexName: "Employees/ByFirstName" })
    .whereEquals("FirstName", "Robert");

// Call stream() to execute the query
const queryStream = await session.advanced.stream(query);

// Can get info about the index used from the stats
queryStream.once("stats", queryStats => {
    const indexUsed = queryStats.indexName;
    const isIndexStale = queryStats.stale;
    const lastTimeIndexWasUpdated = queryStats.indexTimestamp;
});

// Handle stats & stream events as described in the dynamic query example above.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="nodejs">
{`// The index:
class Employees_ByFirstName extends AbstractJavaScriptIndexCreationTask {

    constructor () {
        super();

        this.map("Employees", employee => {
            return {
                firstName: employee.FirstName
            }
        });
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">
#### Stream related documents
__Why streaming query results does not support 'include'__:

* A document can reference [related documents](../../../indexes/indexing-related-documents#what-are-related-documents).
* An [include](../../../client-api/session/loading-entities#load-with-includes) clause in a non-streamed query loads these related documents to the session  
  so that they can be accessed without an additional query to the server.
* Those included documents are sent to the client at the end of the query results.  
  This does not mesh well with streaming, which is designed to allow transferring massive amounts of data,  
  possibly over a significant amount of time.

__How to stream related documents__:

* Instead of using _include_, define the query so that it will return a [projection](../../../indexes/querying/projections).
* The projected query results will not be just the documents from the queried collection.  
  Instead, each result will be an entity containing the related document entities in addition to the original queried document.
* On the client side, you need to define a class that matches the projected query result.

__Example__:

* The below example uses RawQuery.  
  However, the same logic can be applied to a Query, DocumentQuery, or when querying an index.
* Note:  
  The projected class in the example contains the full related documents.  
  However, you can project just the needed properties from the related documents.

<TabItem value="something-something" label="stream_5">
<CodeBlock language="nodejs">
{`// Define a query with a 'select' clause to project the results.

// The related Company & Employee documents are 'loaded',
// and returned in the projection together with the Order document itself.

// Each query result is not an Order document
// but an entity containing the document & the related documents. 
const rawQuery = session.advanced
    .rawQuery(\`from Orders as o
               where o.ShipTo.City = 'London'
               load o.Company as c, o.Employee as e
               select \{
                   order: o,
                   company: c,
                   employee: e
               \}\`);

// Call stream() to execute the query
const queryStream = await session.advanced.stream(rawQuery);

queryStream.on("data", resultItem => \{
    const theOrderDocument = resultItem.document.order;
    const theCompanyDocument = resultItem.document.company;
    const theEmployeeDocument = resultItem.document.employee;
\});

// Handle stats & stream events as described in the dynamic query example above.
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">
#### By query syntax

<TabItem value="something-something" label="syntax_1">
<CodeBlock language="nodejs">
{`await session.advanced.stream(query, [statsCallback]);
`}
</CodeBlock>
</TabItem>

| Parameters | type | description |
| - | - | - |
| **query** | `IDocumentQuery` or `IRawDocumentQuery` | The query for which to stream results |
| **statsCallback** | `(streamStats) => void` | &lt;ul&gt;&lt;li&gt;An optional callback function with an output parameter.&lt;/li&gt;&lt;li&gt;The parameter passed to the callback will be filled with the `StreamQueryStatistics` object when query returns.&lt;/li&gt;&lt;/ul&gt; |

| Return Value | |
| - | - |
| `Promise<DocumentResultStream>` | A `Promise` resolving to readable stream with query results |

| `StreamQueryStatistics` | | |
| - | - | - |
| __totalResults__ | `number` | Total number of results |
| __resultEtag__ | `number` | An Etag that is specific for the query results |
| __indexName__ | `string` | Name of index that was used for the query |
| __indexTimestamp__ | `object` | Time when index was last updated |
| __stale__ | `boolean` | `true` if index is stale |

</Admonition>



## Stream by prefix

<Admonition type="note" title="Note">
#### Stream results by prefix
* Streamed data can also be filtered by an __ID prefix__ and by some __filtering options__, see below.
* Note: No auto-index is created when streaming results by a prefix.

<TabItem value="something-something" label="stream_6">
<CodeBlock language="nodejs">
{`const idPrefix = "Order";

// Filter streamed results by passing an ID prefix
const streamResults = await session.advanced.stream(idPrefix);

queryStream.on("data", resultItem => \{
    // Only documents with ID that starts with 'Order' 
    const resultDocument = resultItem.document;
\});

queryStream.on("end", () => \{
    // Stream ended, no more data
\});

queryStream.on("error", err => \{
    // Handle errors
\});
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="stream_7">
<CodeBlock language="nodejs">
{`const idPrefix = "Orders/";
const options = \{
    matches: "*25-A|77?-A"
\}

// Filter streamed results by ID prefix and by options
const streamResults = await session.advanced.stream(idPrefix, options);

queryStream.on("data", resultItem => \{
    // Documents that will be returned are only those matching the following:
    // * Document ID starts with "Orders/"
    // * The rest of the ID (after prefix) must match the 'matches' string
    // e.g. "Orders/325-A" or Orders/772-A", etc.
    
    const resultDocument = resultItem.document;
\});

queryStream.on("end", () => \{
    // Stream ended, no more data
\});

queryStream.on("error", err => \{
    // Handle errors
\});
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">
#### By prefix syntax

<TabItem value="something-something" label="syntax_2">
<CodeBlock language="nodejs">
{`await session.advanced.stream(idPrefix);
await session.advanced.stream(idPrefix, options);
`}
</CodeBlock>
</TabItem>

| Parameters | type | description |
| - | - | - |
| **idPrefix** | `string` | Stream documents with this ID prefix |
| **options** | `StartingWithOptions` | More filtering options, see description below |

| Return Value | |
| - | - |
| `Promise<DocumentResultStream>` | A `Promise` resolving to readable stream with query results |

| `StartingWithOptions` | | |
| - | - | - |
| __matches__ | `number` | Filter the ID part that comes after the specified prefix.<br/>Use '?' for any character, '*' any characters.<br/>Use '&#124;' to separate rules. |
| __start__ | `number` | Number of documents to skip |
| __pageSize__ | `number` | Maximum number of documents to retrieve |
| __exclude__ | `strring` | Maximum number of documents to retrieve |
| __startAfter__ | `string` | Skip fetching documents until this ID is found.<br/>Only return documents after this ID (default: null). |

</Admonition>



</LanguageContent>