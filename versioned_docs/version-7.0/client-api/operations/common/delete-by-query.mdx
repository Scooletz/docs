---
title: "Delete by Query Operation"
sidebar_label: Delete by Query
sidebar_position: 0
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Delete by Query Operation
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Use `DeleteByQueryOperation` to delete a large number of documents that match the provided query in a single server call.

* **Dynamic behavior**:   
  The deletion of documents matching the specified query is performed in batches of size 1024.  
  During the deletion process, documents that are added/modified **after** the delete operation has started  
  may also be deleted if they match the query criteria.

* **Background operation**:  
  This operation is performed in the background on the server.  
  If needed, you can wait for the operation to complete. See: [Wait for completion](../../../client-api/operations/what-are-operations#wait-for-completion).

* **Operation scope**:  
  `DeleteByQueryOperation` runs as a single-node transaction, not a cluster-wide transaction. As a result,  
  if you use this operation to delete documents that were originally created using a cluster-wide transaction,  
  their associated [Atomic guards](../../../client-api/session/cluster-transaction/atomic-guards) will Not be deleted.

  * To avoid issues when recreating such documents using a cluster-wide session, 
    see [Best practice when storing a document](../../../client-api/session/cluster-transaction/atomic-guards#best-practice-when-storing-a-document-in-a-cluster-wide-transaction).
  * To learn more about the differences between transaction types,
    see [Cluster-wide transaction vs. Single-node transaction](../../../client-api/session/cluster-transaction/overview#cluster-wide-transaction-vs.-single-node-transaction).
* In this article:  
   * [Delete by dynamic query](../../../client-api/operations/common/delete-by-query#delete-by-dynamic-query)
   * [Delete by index query](../../../client-api/operations/common/delete-by-query#delete-by-index-query)
   * [Syntax](../../../client-api/operations/common/delete-by-query#syntax)

</Admonition>

## Delete by dynamic query

<Admonition type="note" title="Note">

##### Delete all documents in a collection

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation_Sync" label="DeleteByQueryOperation_Sync">
<CodeBlock language="csharp">
{`// Define the delete by query operation, pass an RQL querying a collection
var deleteByQueryOp = new DeleteByQueryOperation("from 'Orders'");

// Execute the operation by passing it to Operations.Send
var operation = store.Operations.Send(deleteByQueryOp);

// All documents in collection 'Orders' will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="DeleteByQueryOperation_Async" label="DeleteByQueryOperation_Async">
<CodeBlock language="csharp">
{`// Define the delete by query operation, pass an RQL querying a collection
var deleteByQueryOp = new DeleteByQueryOperation("from 'Orders'");

// Execute the operation by passing it to Operations.SendAsync
var result = await store.Operations.SendAsync(deleteByQueryOp);

// All documents in collection 'Orders' will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with filtering  

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation_Sync" label="DeleteByQueryOperation_Sync">
<CodeBlock language="csharp">
{`// Define the delete by query operation, pass an RQL querying a collection
var deleteByQueryOp = new DeleteByQueryOperation("from 'Orders' where Freight > 30");

// Execute the operation by passing it to Operations.Send
var operation = store.Operations.Send(deleteByQueryOp);

// * All documents matching the specified RQL will be deleted from the server.

// * Since the dynamic query was made with a filtering condition,
//   an auto-index is generated (if no other matching auto-index already exists).
`}
</CodeBlock>
</TabItem>
<TabItem value="DeleteByQueryOperation_Async" label="DeleteByQueryOperation_Async">
<CodeBlock language="csharp">
{`// Define the delete by query operation, pass an RQL querying a collection
var deleteByQueryOp = new DeleteByQueryOperation("from 'Orders' where Freight > 30");

// Execute the operation by passing it to Operations.SendAsync
var result = await store.Operations.SendAsync(deleteByQueryOp);

// * All documents matching the provided RQL will be deleted from the server.

// * Since a dynamic query was made with a filtering condition,
//   an auto-index is generated (if no other matching auto-index already exists).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" where Freight > 30
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## Delete by index query

* `DeleteByQueryOperation` can only be performed on a **Map-index**.  
  An exception is thrown when executing the operation on a Map-Reduce index.  

* A few overloads are available, see the following examples:
<Admonition type="note" title="Note">

##### A sample Map-index

<TabItem value="something" label="the_index">
<CodeBlock language="csharp">
{`// The index definition:
// =====================

public class Products_ByPrice : AbstractIndexCreationTask<Product>
\{
    public class IndexEntry
    \{
        public decimal Price \{ get; set; \}  
    \}
    
    public Products_ByPrice()
    \{
        Map = products => from product in products
            select new IndexEntry
            \{
                Price = product.PricePerUnit 
            \};
    \}
\}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

##### Delete documents via an index query

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="csharp">
{`// Define the delete by query operation, pass an RQL querying the index
var deleteByQueryOp =
    new DeleteByQueryOperation("from index 'Products/ByPrice' where Price > 10");

// Execute the operation by passing it to Operations.Send
var operation = store.Operations.Send(deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="Overload_1" label="Overload_1">
<CodeBlock language="csharp">
{`// Define the delete by query operation
var deleteByQueryOp = new DeleteByQueryOperation(new IndexQuery
{
    // Provide an RQL querying the index
    Query = "from index 'Products/ByPrice' where Price > 10"
});

// Execute the operation by passing it to Operations.Send
var operation = store.Operations.Send(deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="Overload_2" label="Overload_2">
<CodeBlock language="csharp">
{`// Define the delete by query operation
var deleteByQueryOp =
    // Pass parameters:
    // * The index name
    // * A filtering expression on the index-field
    new DeleteByQueryOperation<Products_ByPrice.IndexEntry>("Products/ByPrice",
        x => x.Price > 10);

// Execute the operation by passing it to Operations.Send
var operation = store.Operations.Send(deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="Overload_3" label="Overload_3">
<CodeBlock language="csharp">
{`// Define the delete by query operation
var deleteByQueryOp =
    // Pass param:
    // * A filtering expression on the index-field
    new DeleteByQueryOperation<Products_ByPrice.IndexEntry, Products_ByPrice>(
        x => x.Price > 10);

// Execute the operation by passing it to Operations.Send
var operation = store.Operations.Send(deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with options

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="csharp">
{`// Define the delete by query operation
var deleteByQueryOp = new DeleteByQueryOperation(
    // QUERY: Specify the query
    new IndexQuery
    {
        Query = "from index 'Products/ByPrice' where Price > 10"
    },
    // OPTIONS: Specify the options for the operation
    // (See all other available options in the Syntax section below)
    new QueryOperationOptions
    {
        // Allow the operation to operate even if index is stale
        AllowStale = true, 
        // Get info in the operation result about documents that were deleted
        RetrieveDetails = true 
    });

// Execute the operation by passing it to Operations.Send
Operation operation = store.Operations.Send(deleteByQueryOp);
    
// Wait for operation to complete
var result = operation.WaitForCompletion<BulkOperationResult>(TimeSpan.FromSeconds(15));

// * All documents with document-field PricePerUnit > 10 will be deleted from the server.

// * Details about deleted documents are available:
var details = result.Details;
var documentIdThatWasDeleted = details[0].ToJson()["Id"];
`}
</CodeBlock>
</TabItem>
<TabItem value="DeleteByQueryOperation_async" label="DeleteByQueryOperation_async">
<CodeBlock language="csharp">
{`// Define the delete by query operation
var deleteByQueryOp = new DeleteByQueryOperation(
    // QUERY: Specify the query
    new IndexQuery
    {
        Query = "from index 'Products/ByPrice' where Price > 10"
    },
    // OPTIONS: Specify the options for the operation
    // (See all other available options in the Syntax section below)
    new QueryOperationOptions
    {
        // Allow the operation to operate even if index is stale
        AllowStale = true, 
        // Get info in the operation result about documents that were deleted
        RetrieveDetails = true 
    });

// Execute the operation by passing it to Operations.Send
Operation operation = await store.Operations.SendAsync(deleteByQueryOp);

// Wait for operation to complete
BulkOperationResult result = 
    await operation.WaitForCompletionAsync<BulkOperationResult>(TimeSpan.FromSeconds(15))
        .ConfigureAwait(false);

// * All documents with document-field PricePerUnit > 10 will be deleted from the server.

// * Details about deleted documents are available:
var details = result.Details;
var documentIdThatWasDeleted = details[0].ToJson()["Id"];
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

* Specifying `QueryOperationOptions` is also supported by the other overload methods, see the Syntax section below.

</Admonition>


## Syntax

<TabItem value="something" label="syntax_1">
<CodeBlock language="csharp">
{`// Available overload:
// ===================

DeleteByQueryOperation DeleteByQueryOperation(
    string queryToDelete);

DeleteByQueryOperation DeleteByQueryOperation(
    IndexQuery queryToDelete, 
    QueryOperationOptions options = null);

DeleteByQueryOperation DeleteByQueryOperation<TEntity>(
    string indexName, 
    Expression<Func<TEntity, bool>> expression,
    QueryOperationOptions options = null);

DeleteByQueryOperation DeleteByQueryOperation<TEntity, TIndexCreator>(
    Expression<Func<TEntity, bool>> expression,
    QueryOperationOptions options = null)
    where TIndexCreator : AbstractIndexCreationTask, new();
`}
</CodeBlock>
</TabItem>

| Parameter         | Type                        | Description                                                |
|-------------------|-----------------------------|------------------------------------------------------------|
| **queryToDelete** | string                      | The RQL query to perform                                   |
| **queryToDelete** | `IndexQuery`                | Holds all the information required to query an index       |
| **indexName**     | string                      | The name of the index queried                              |
| **expression**    | `Expression<Func<T, bool>>` | The expression that defines the query criteria             |
| **options**       | `QueryOperationOptions`     | Object holding different setting options for the operation |

<TabItem value="something" label="syntax_2">
<CodeBlock language="csharp">
{`public class QueryOperationOptions
\{
    // Indicates whether operations are allowed on stale indexes.
    // DEFAULT: false
    public bool AllowStale \{ get; set; \}
    
    // If AllowStale is set to false and index is stale, 
    // then this is the maximum timeout to wait for index to become non-stale. 
    // If timeout is exceeded then exception is thrown.
    // DEFAULT: null (if index is stale then exception is thrown immediately) 
    public TimeSpan? StaleTimeout \{ get; set; \}
    
    // Limits the number of base operations per second allowed.
    // DEFAULT: no limit
    public int? MaxOpsPerSecond
    
    // Determines whether operation details about each document should be returned by server.
    // DEFAULT: false
    public bool RetrieveDetails \{ get; set; \}
    
    // Ignore the maximum number of statements a script can execute.
    // Note: this is only relevant for the PatchByQueryOperation. 
    public bool IgnoreMaxStepsForScript \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="java">


`DeleteByQueryOperation` gives you the ability to delete a large number of documents with a single query.
This operation is performed in the background on the server. 

## Syntax

<TabItem value="something-something" label="delete_by_query">
<CodeBlock language="java">
{`public DeleteByQueryOperation(IndexQuery queryToDelete)

public DeleteByQueryOperation(IndexQuery queryToDelete, QueryOperationOptions options)
`}
</CodeBlock>
</TabItem>

| Parameters | Type | Description |
| ------------- | ------------- | ----- |
| **indexName** | String | Name of an index to perform a query on |
| **queryToDelete** | IndexQuery | Holds all the information required to query an index |
| **options** | QueryOperationOptions | Holds different setting options for base operations |

## Example I

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`// remove all documents from the server where Name == Bob using Person/ByName index
store
    .operations()
    .send(new DeleteByQueryOperation(new IndexQuery("from Persons where name = 'Bob'")));
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Person/ByName' where Name = 'Bob'
`}
</CodeBlock>
</TabItem>
</Tabs>


## Example II

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`// remove all documents from the server where Age > 35 using Person/ByAge index
store
    .operations()
    .send(new DeleteByQueryOperation(new IndexQuery("from 'Person/ByAge' where age < 35")));
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Person/ByName' where Age < 35
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example III

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`// delete multiple docs with specific ids in a single run without loading them into the session
Operation operation = store
    .operations()
    .sendAsync(new DeleteByQueryOperation(new IndexQuery(
        "from People u where id(u) in ('people/1-A', 'people/3-A')"
    )));
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from People u where id(u) in ('people/1-A', 'people/3-A')
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="note" title="WaitForCompletion" id="waitforcompletion" href="#waitforcompletion">
`DeleteByQueryOperation` is performed in the background on the server.    
You have the option to **wait** for it using `waitForCompletion`.

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`// remove all document from server where Name == Bob and Age >= 29 using People collection
Operation operation = store.operations()
    .sendAsync(new DeleteByQueryOperation(new IndexQuery(
        "from People where Name = 'Bob' and Age >= 29"
    )));

operation.waitForCompletion();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from People where Name = 'Bob' and Age >= 29
`}
</CodeBlock>
</TabItem>
</Tabs>
</Admonition>

## Remarks

<Admonition type="warning" title="Map only indexes" id="map-only-indexes" href="#map-only-indexes"> 
`DeleteByQueryOperation` can only be performed on a map index. Executing it on map-reduce index will lead to an exception. 
</Admonition>

<Admonition type="warning" title="Batching and Concurrency" id="batching-and-concurrency" href="#batching-and-concurrency"> 

The deletion of documents matching a specified query is run in batches of size 1024. RavenDB doesn't do concurrency checks during the operation
so it can happen than a document has been updated or deleted meanwhile.

</Admonition>



</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* Use `DeleteByQueryOperation` to delete a large number of documents that match the provided query in a single server call.

* **Dynamic behavior**:   
  The deletion of documents matching the specified query is performed in batches of size 1024.  
  During the deletion process, documents that are added/modified **after** the delete operation has started  
  may also be deleted if they match the query criteria.

* **Background operation**:  
  This operation is performed in the background on the server.  

* **Operation scope**:  
  `DeleteByQueryOperation` runs as a single-node transaction, not a cluster-wide transaction. As a result,  
  if you use this operation to delete documents that were originally created using a cluster-wide transaction,  
  their associated [Atomic guards](../../../client-api/session/cluster-transaction/atomic-guards) will Not be deleted.

    * To avoid issues when recreating such documents using a cluster-wide session,
      see [Best practice when storing a document](../../../client-api/session/cluster-transaction/atomic-guards#best-practice-when-storing-a-document-in-a-cluster-wide-transaction).
    * To learn more about the differences between transaction types,
      see [Cluster-wide transaction vs. Single-node transaction](../../../client-api/session/cluster-transaction/overview#cluster-wide-transaction-vs.-single-node-transaction).
* In this article:  
   * [Delete by dynamic query](../../../client-api/operations/common/delete-by-query#delete-by-dynamic-query)
   * [Delete by index query](../../../client-api/operations/common/delete-by-query#delete-by-index-query)

</Admonition>

## Delete by dynamic query

<Admonition type="note" title="Note">

##### Delete all documents in a collection

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="python">
{`# Define the delete by query operation, pass an RQL querying a collection
delete_by_query_op = DeleteByQueryOperation("from 'Orders'")

# Execute the operation by passing it to Operation.send_async
operation = store.operations.send_async(delete_by_query_op)

# All documents in collection 'Orders' will be deleted from the server
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with filtering  

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="python">
{`# Define the delete by query operation, pass an RQL querying a collection
delete_by_query_op = DeleteByQueryOperation("from 'Orders' where Freight > 30")

# Execute the operation by passing it to Operation.send_async
operation = store.operations.send_async(delete_by_query_op)

# * All documents matching the specified RQL will be deleted from the server.
#
# * Since the dynamic query was made with a filtering condition,
#   an auto-index is generated (if no other matching auto-index already exists).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" where Freight > 30
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## Delete by index query

* `DeleteByQueryOperation` can only be performed on a **Map-index**.  
  An exception is thrown when executing the operation on a Map-Reduce index.  

* A few overloads are available, see the following examples:
<Admonition type="note" title="Note">

##### A sample Map-index

<TabItem value="something-something" label="the_index">
<CodeBlock language="python">
{`# The index definition:
# =====================
class ProductsByPrice(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, price: int):
            self.price = price

    def __init__(self):
        super().__init__()
        self.map = "from product in products select new \{price = product.PricePerUnit\}"
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

##### Delete documents via an index query

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`# Define the delete by query operation, pass an RQL querying the index
delete_by_query_op = DeleteByQueryOperation("from index 'Products/ByPrice' where Price > 10")

# Execute the operation by passing it to Operation.send_async
operation = store.operations.send_async(delete_by_query_op)

# All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="IndexQuery" label="IndexQuery">
<CodeBlock language="python">
{`# Define the delete by query operation
delete_by_query_op = DeleteByQueryOperation(
    IndexQuery(query="from index 'Products/ByPrice' where Price > 10")
)

# Execute the operation by passing it to Operation.send_async
operation = store.operations.send_async(delete_by_query_op)

# All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with options

<Tabs groupId='languageSyntax'>
<TabItem value="QueryOperationOptions" label="QueryOperationOptions">
<CodeBlock language="python">
{`# Define the delete by query operation
delete_by_query_op = DeleteByQueryOperation(
    # QUERY: Specify the query
    IndexQuery(query="from index 'Products/ByPrice' where Price > 10"),
    # OPTIONS: Specify the options for the operations
    # (See all other available options in the Syntax section below)
    QueryOperationOptions(
        # Allow the operation to operate even if index is stale
        allow_stale=True,
        # Get info in the operation result about documents that were deleted
        retrieve_details=True,
    ),
)

# Execute the operation by passing it to Operations.send_async
operation = store.operations.send_async(delete_by_query_op)

# * All documents with document-field PricePerUnit > 10 will be deleted from the server

# * Details about deleted documents are available:
details = result.details
document_id_that_was_deleted = details[0]["Id"]
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

* Specifying `QueryOperationOptions` is also supported by the other overload methods, see the Syntax section below.

</Admonition>



</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* Use `DeleteByQueryOperation` to delete a large number of documents that match the provided query in a single server call.

* **Dynamic behavior**:   
  The deletion of documents matching the specified query is performed in batches of size 1024.  
  During the deletion process, documents that are added/modified **after** the delete operation has started  
  may also be deleted if they match the query criteria.

* **Background operation**:  
  This operation is performed in the background on the server.  
  If needed, you can wait for the operation to complete. See: [Wait for completion](../../../client-api/operations/what-are-operations#wait-for-completion).

* **Operation scope**:  
  `DeleteByQueryOperation` runs as a single-node transaction, not a cluster-wide transaction. As a result,  
  if you use this operation to delete documents that were originally created using a cluster-wide transaction,  
  their associated [Atomic guards](../../../client-api/session/cluster-transaction/atomic-guards) will Not be deleted.

    * To avoid issues when recreating such documents using a cluster-wide session,
      see [Best practice when storing a document](../../../client-api/session/cluster-transaction/atomic-guards#best-practice-when-storing-a-document-in-a-cluster-wide-transaction).
    * To learn more about the differences between transaction types,
      see [Cluster-wide transaction vs. Single-node transaction](../../../client-api/session/cluster-transaction/overview#cluster-wide-transaction-vs.-single-node-transaction).
* In this article:  
   * [Delete by dynamic query](../../../client-api/operations/common/delete-by-query#delete-by-dynamic-query)
   * [Delete by index query](../../../client-api/operations/common/delete-by-query#delete-by-index-query)
   * [Syntax](../../../client-api/operations/common/delete-by-query#syntax)

</Admonition>

## Delete by dynamic query

<Admonition type="note" title="Note">

##### Delete all documents in a collection

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="php">
{`// Define the delete by query operation, pass an RQL querying a collection
$deleteByQueryOp = new DeleteByQueryOperation("from 'Orders'");

// Execute the operation by passing it to Operations.Send
$operation = $store->operations()->send($deleteByQueryOp);

// All documents in collection 'Orders' will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with filtering  

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="php">
{`// Define the delete by query operation, pass an RQL querying a collection
$deleteByQueryOp = new DeleteByQueryOperation("from 'Orders' where Freight > 30");

// Execute the operation by passing it to Operations.Send
$operation = $store->operations()->send($deleteByQueryOp);

// * All documents matching the specified RQL will be deleted from the server.

// * Since the dynamic query was made with a filtering condition,
//   an auto-index is generated (if no other matching auto-index already exists).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" where Freight > 30
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## Delete by index query

* `DeleteByQueryOperation` can only be performed on a **Map-index**.  
  An exception is thrown when executing the operation on a Map-Reduce index.  

* A few overloads are available, see the following examples:
<Admonition type="note" title="Note">

##### A sample Map-index

<TabItem value="something-something" label="the_index">
<CodeBlock language="php">
{`// The index definition:
// =====================

class IndexEntry
\{
    public float $price;

    public function getPrice(): float
    \{
        return $this->price;
    \}

    public function setPrice(float $price): void
    \{
        $this->price = $price;
    \}
\}

class Products_ByPrice extends AbstractIndexCreationTask
\{
    public function __construct()
    \{
        parent::__construct();

        $this->map = "from product in products select new \{price = product.PricePerUnit\}";
    \}
\}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

##### Delete documents via an index query

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`// Define the delete by query operation, pass an RQL querying the index
$deleteByQueryOp = new DeleteByQueryOperation("from index 'Products/ByPrice' where Price > 10");

// Execute the operation by passing it to Operations.Send
$operation = $store->operations()->send($deleteByQueryOp);


// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="IndexQuery" label="IndexQuery">
<CodeBlock language="php">
{`// Define the delete by query operation
$deleteByQueryOp = new DeleteByQueryOperation(
    // Provide an RQL querying the index
    new IndexQuery("from index 'Products/ByPrice' where Price > 10")
);

// Execute the operation by passing it to Operations.Send
$operation = $store->operations()->send($deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with options

<Tabs groupId='languageSyntax'>
<TabItem value="QueryOperationOptions" label="QueryOperationOptions">
<CodeBlock language="php">
{`// OPTIONS: Specify the options for the operation
// (See all other available options in the Syntax section below)
$options = new QueryOperationOptions();
// Allow the operation to operate even if index is stale
$options->setAllowStale(true);
// Get info in the operation result about documents that were deleted
$options->setRetrieveDetails(true);

// Define the delete by query operation
$deleteByQueryOp = new DeleteByQueryOperation(
    new IndexQuery("from index 'Products/ByPrice' where Price > 10"), // QUERY: Specify the query
    $options // OPTIONS:
);

// Execute the operation by passing it to Operations.Send
/** @var Operation $operation */
$operation = $store->operations()->sendAsync($deleteByQueryOp);

// Wait for operation to complete
/** @var BulkOperationResult $result */
$result = $operation->waitForCompletion(Duration::ofSeconds(15));

// * All documents with document-field PricePerUnit > 10 will be deleted from the server.

// * Details about deleted documents are available:
$details =  $result->getDetails();
$documentIdThatWasDeleted = $details[0]->getId();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## Syntax

<TabItem value="something-something" label="syntax_1">
<CodeBlock language="php">
{`class DeleteByQueryOperation implements OperationInterface
\{
    /**
     * Usage:
     *   - new DeleteByQueryOperation("from 'Orders'")
     *   - new DeleteByQueryOperation("from 'Orders'", $options)
     *
     *   - new DeleteByQueryOperation(new IndexQuery("from 'Orders'"))
     *   - new DeleteByQueryOperation(new IndexQuery("from 'Orders'"), $options)
     *
     * @param IndexQuery|string|null $queryToDelete
     * @param QueryOperationOptions|null $options
     */
    public function __construct(IndexQuery|string|null $queryToDelete, ?QueryOperationOptions $options = null) \{
        // ...
    \}

    // ...
\}
`}
</CodeBlock>
</TabItem>

| Parameter          | Type                     | Description                                                |
|--------------------|--------------------------|------------------------------------------------------------|
| **$queryToDelete** | `string`                 | The RQL query to perform                                   |
| **$queryToDelete** | `IndexQuery`             | Holds all the information required to query an index       |
| **$options**       | `?QueryOperationOptions` | Object holding different setting options for the operation |

<TabItem value="something-something" label="syntax_2">
<CodeBlock language="php">
{`class QueryOperationOptions
\{
    // Indicates whether operations are allowed on stale indexes.
    private bool $allowStale = false;

    // Limits the number of base operations per second allowed.
    // DEFAULT: no limit
    private ?int $maxOpsPerSecond = null;

    // If AllowStale is set to false and index is stale,
    // then this is the maximum timeout to wait for index to become non-stale.
    // If timeout is exceeded then exception is thrown.
    // DEFAULT: null (if index is stale then exception is thrown immediately)
    private ?Duration $staleTimeout = null;

    // Determines whether operation details about each document should be returned by server.
    private bool $retrieveDetails = false;

    // Ignore the maximum number of statements a script can execute.
    // Note: this is only relevant for the patchByQueryOperation.
    private bool $ignoreMaxStepsForScript = false;

    // getters and setters
\}
`}
</CodeBlock>
</TabItem>





</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Use `DeleteByQueryOperation` to delete a large number of documents that match the provided query in a single server call.

* **Dynamic behavior**:   
  The deletion of documents matching the specified query is performed in batches of size 1024.  
  During the deletion process, documents that are added/modified **after** the delete operation has started  
  may also be deleted if they match the query criteria.

* **Background operation**:  
  This operation is performed in the background on the server.  
  If needed, you can wait for the operation to complete. See: [Wait for completion](../../../client-api/operations/what-are-operations#wait-for-completion).

* **Operation scope**:  
  `DeleteByQueryOperation` runs as a single-node transaction, not a cluster-wide transaction. As a result,  
  if you use this operation to delete documents that were originally created using a cluster-wide transaction,  
  their associated [Atomic guards](../../../client-api/session/cluster-transaction/atomic-guards) will Not be deleted.

    * To avoid issues when recreating such documents using a cluster-wide session,
      see [Best practice when storing a document](../../../client-api/session/cluster-transaction/atomic-guards#best-practice-when-storing-a-document-in-a-cluster-wide-transaction).
    * To learn more about the differences between transaction types,
      see [Cluster-wide transaction vs. Single-node transaction](../../../client-api/session/cluster-transaction/overview#cluster-wide-transaction-vs.-single-node-transaction).
* In this article:  
   * [Delete by dynamic query](../../../client-api/operations/common/delete-by-query#delete-by-dynamic-query)
   * [Delete by index query](../../../client-api/operations/common/delete-by-query#delete-by-index-query)
   * [Syntax](../../../client-api/operations/common/delete-by-query#syntax)

</Admonition>

## Delete by dynamic query

<Admonition type="note" title="Note">

##### Delete all documents in collection

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="nodejs">
{`// Define the delete by query operation, pass an RQL querying a collection
const deleteByQueryOp = new DeleteByQueryOperation("from 'Orders'");

// Execute the operation by passing it to operations.send
const operation = await store.operations.send(deleteByQueryOp);

// All documents in collection 'Orders' will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with filtering 

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="nodejs">
{`// Define the delete by query operation, pass an RQL querying a collection
const deleteByQueryOp = new DeleteByQueryOperation("from 'Orders' where Freight > 30");

// Execute the operation by passing it to operations.send
const operation = await store.operations.send(deleteByQueryOp);

// * All documents matching the specified RQL will be deleted from the server.

// * Since the dynamic query was made with a filtering condition,
//   an auto-index is generated (if no other matching auto-index already exists).
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders" where Freight > 30
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## Delete by index query

* `DeleteByQueryOperation` can only be performed on a **Map-index**.  
  An exception is thrown when executing the operation on a Map-Reduce index.  

* A few overloads are available, see the following examples:
<Admonition type="note" title="Note">

##### A sample Map-index

<TabItem value="something-something" label="the_index">
<CodeBlock language="nodejs">
{`// The index definition:
// =====================

class Products_ByPrice extends AbstractJavaScriptIndexCreationTask \{
    constructor () \{
        super();

        this.map("products", product => \{
            return \{
                Price: product.PricePerUnit
            \};
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

##### Delete documents via an index query

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="nodejs">
{`// Define the delete by query operation, pass an RQL querying the index
const deleteByQueryOp = 
    new DeleteByQueryOperation("from index 'Products/ByPrice' where Price > 10");

// Execute the operation by passing it to operations.send
const operation = await store.operations.send(deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="DeleteByQueryOperation_overload" label="DeleteByQueryOperation_overload">
<CodeBlock language="nodejs">
{`// Define the index query, provide an RQL querying the index
const indexQuery = new IndexQuery();
indexQuery.query = "from index 'Products/ByPrice' where Price > 10";

// Define the delete by query operation
const deleteByQueryOp = new DeleteByQueryOperation(indexQuery);

// Execute the operation by passing it to operations.send
const operation = await store.operations.send(deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### Delete with options

<Tabs groupId='languageSyntax'>
<TabItem value="DeleteByQueryOperation" label="DeleteByQueryOperation">
<CodeBlock language="nodejs">
{`// QUERY: Define the index query, provide an RQL querying the index
const indexQuery = new IndexQuery();
indexQuery.query = "from index 'Products/ByPrice' where Price > 10";

// OPTIONS: Define the operations options
// (See all available options in the Syntax section below)
const options = {
    // Allow the operation to operate even if index is stale
    allowStale: true,
    // Limit the number of base operations per second allowed.
    maxOpsPerSecond: 500
}

// Define the delete by query operation
const deleteByQueryOp = new DeleteByQueryOperation(indexQuery, options);

// Execute the operation by passing it to operations.send
const operation = await store.operations.send(deleteByQueryOp);

// All documents with document-field PricePerUnit > 10 will be deleted from the server.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByPrice" where Price > 10
`}
</CodeBlock>
</TabItem>
</Tabs>

* Specifying `options` is also supported by the other overload methods, see the Syntax section below.

</Admonition>


## Syntax

<TabItem value="something-something" label="syntax_1">
<CodeBlock language="nodejs">
{`// Available overload:
// ===================
const deleteByQueryOp = new DeleteByQueryOperation(indexQuery);
const deleteByQueryOp = new DeleteByQueryOperation(indexQuery, options);
`}
</CodeBlock>
</TabItem>

| Parameter         | Type         | Description                                                |
|-------------------|--------------|------------------------------------------------------------|
| **queryToDelete** | `string`     | The RQL query to perform                                   |
| **queryToDelete** | `IndexQuery` | Holds all the information required to query an index       |
| **options**       | `object`     | Object holding different setting options for the operation |

<TabItem value="something-something" label="syntax_2">
<CodeBlock language="nodejs">
{`// options object
\{
    // Indicates whether operations are allowed on stale indexes.
    // DEFAULT: false
    allowStale, // boolean
        
    // If AllowStale is set to false and index is stale,
    // then this is the maximum timeout to wait for index to become non-stale.
    // If timeout is exceeded then exception is thrown.
    // DEFAULT: null (if index is stale then exception is thrown immediately)
    staleTimeout, // number 
        
    // Limits the number of base operations per second allowed.
    // DEFAULT: null (no limit)
    maxOpsPerSecond, // number
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>

<!---
### Operations
- [What are Operations](../../../client-api/operations/what-are-operations)

### Client API
- [How to Query](../../../client-api/session/querying/how-to-query)
- [Querying: Basics](../../../indexes/querying/query-index)

### Querying
- [What is RQL](../../../client-api/session/querying/what-is-rql)
- [Querying an index](../../../indexes/querying/query-index)


-->