---
title: "Querying Time Series Indexes"
sidebar_label: Querying Time Series Indexes
sidebar_position: 5
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/language-switcher";
import LanguageContent from "@site/src/components/language-content";

export const supportedLanguages = ["csharp", "python", "php", "nodejs"];


# Querying Time Series Indexes
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* **Time series index**:

    * STATIC-time-series-indexes can be defined from the [Client API](../../../document-extensions/timeseries/indexing) 
      or using [Studio](../../../studio/database/indexes/create-map-index).  
      Such an index can be queried in the same way as a regular index that indexes documents.  
      (See [Querying an index](../../../indexes/querying/query-index)).
    
    * AUTO-time-series-indexes are Not generated automatically by the server when making a time series query.

* **The contents of the query results**:

    * Unlike a document index, where the source data are your JSON documents,  
      the source data for a time series index are the time series entries within the documents.

    * When querying a **document index**:  
      the resulting objects are the document entities (unless results are [projected](../../../indexes/querying/projections)).
  
    * When querying a **time series index**:  
      each item in the results is of the type defined by the **index-entry** in the index definition,  
      (unless results are [projected](../../../document-extensions/timeseries/querying/using-indexes#project-results)). 
      The documents themselves are not returned.

* In this page:
    * [Sample index](../../../document-extensions/timeseries/querying/using-indexes#sample-index)
    * [Querying the index](../../../document-extensions/timeseries/querying/using-indexes#querying-the-index)
        * [Query all time series entries](../../../document-extensions/timeseries/querying/using-indexes#query-all-time-series-entries)
        * [Filter query results](../../../document-extensions/timeseries/querying/using-indexes#filter-query-results)
        * [Order query results](../../../document-extensions/timeseries/querying/using-indexes#order-query-results)
        * [Project results](../../../document-extensions/timeseries/querying/using-indexes#project-results)
    * [Syntax](../../../document-extensions/timeseries/querying/using-indexes#syntax)

</Admonition>
## Sample Index

* The following is a time series map-index that will be used in the query examples throughout this article.

* Each **index-entry** consists of:
  * Three index-fields obtained from the "HeartRates" time series entries: `BPM`, `Date`, and `Tag`.
  * One index-field obtained from the time series [segment](../../../document-extensions/timeseries/indexing#timeseriessegment-object) header: `EmployeeID`.
  * One index-field obtained from the loaded employee document: `EmployeeName`.

* When querying this time series index:  
  * The resulting items correspond to the time series entries that match the query predicate.  
  * Each item in the results will be of type `TsIndex.IndexEntry`, which is the index-entry.  
    Different result types may be returned when the query [projects the results](../../../document-extensions/timeseries/querying/using-indexes#project-results).

<TabItem value="something" label="sample_ts_index">
<CodeBlock language="csharp">
{`public class TsIndex : AbstractTimeSeriesIndexCreationTask<Employee>
\{
    // The index-entry:
    // ================
    public class IndexEntry
    \{
        // The index-fields:
        // =================
        public double BPM \{ get; set; \}
        public DateTime Date \{ get; set; \}
        public string Tag \{ get; set; \}
        public string EmployeeID \{ get; set; \}
        public string EmployeeName \{ get; set; \}
    \}

    public TsIndex()
    \{
        AddMap("HeartRates", timeSeries => 
            from segment in timeSeries
            from entry in segment.Entries
            
            let employee = LoadDocument<Employee>(segment.DocumentId)
            
            // Define the content of the index-fields:
            // =======================================
            select new IndexEntry()
            \{
                BPM = entry.Values[0],
                Date = entry.Timestamp,
                Tag = entry.Tag,
                EmployeeID = segment.DocumentId,
                EmployeeName = employee.FirstName + " " + employee.LastName 
            \});
    \}
\}
`}
</CodeBlock>
</TabItem>



## Querying the index 
 
#### Query all time series entries:

No filtering is applied in this query.  
Results will include ALL entries from time series "HeartRates".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session
         // Query the index
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Query for all entries w/o any filtering
        .ToList();
    
    // Access results:
    TsIndex.IndexEntry entryResult = results[0];
    string employeeName = entryResult.EmployeeName;
    double BPM = entryResult.BPM;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`using (var asyncSession = store.OpenAsyncSession())
{
    List<TsIndex.IndexEntry> results = await asyncSession
         // Query the index
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Query for all entries w/o any filtering
        .ToListAsync();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Query the index
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
         // Query for all entries w/o any filtering
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Query the index for all entries w/o any filtering
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
`}
</CodeBlock>
</TabItem> 
</Tabs>
#### Filter query results:

In this example, time series entries are filtered by the query.  
The query predicate is applied to the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Retrieve only time series entries with high BPM values for a specific employee
        .Where(x => x.EmployeeName == "Robert King" && x.BPM > 85)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`using (var asyncSession = store.OpenAsyncSession())
{
    List<TsIndex.IndexEntry> results = await asyncSession
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Retrieve only time series entries with high BPM values for a specific employee
        .Where(x => x.EmployeeName == "Robert King" && x.BPM > 85)
        .ToListAsync();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
         // Retrieve only time series entries with high BPM values for a specific employee
        .WhereEquals(x => x.EmployeeName, "Robert King")
        .AndAlso()
        .WhereGreaterThan(x => x.BPM, 85)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Retrieve only time series entries with high BPM values for a specific employee
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
              where EmployeeName == 'Robert King' and BPM > 85.0 
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where EmployeeName == "Robert King" and BPM > 85.0
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Order query results:

Results can be ordered by any of the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Retrieve time series entries where employees had a low BPM value
        .Where(x => x.BPM < 58)
         // Order by the 'Date' index-field (descending order)
        .OrderByDescending(x => x.Date)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`using (var asyncSession = store.OpenAsyncSession())
{
    List<TsIndex.IndexEntry> results = await asyncSession
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Retrieve time series entries where employees had a low BPM value
        .Where(x => x.BPM < 58)
         // Order by the 'Date' index-field (descending order)
        .OrderByDescending(x => x.Date)
        .ToListAsync();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
         // Retrieve time series entries where employees had a low BPM value
        .WhereLessThan(x => x.BPM, 58)
         // Order by the 'Date' index-field (descending order)
        .OrderByDescending(x => x.Date)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Retrieve entries with low BPM value and order by 'Date' descending
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
              where BPM < 58.0
              order by Date desc
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where BPM < 58.0
order by Date desc
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Project results:

* Instead of returning the entire `TsIndex.IndexEntry` object for each result item,  
  you can return only partial fields.

* Learn more about projecting query results in [Project Index Query Results](../../../indexes/querying/projections).

* In this example, we query for time series entries with a very high BPM value.  
  We retrieve entries with BPM value &gt; 100 but return only the _EmployeeID_ for each entry.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<string> results = session
        .Query<TsIndex.IndexEntry, TsIndex>()
        .Where(x => x.BPM > 100)
         // Return only the EmployeeID index-field in the results
        .Select(x => x.EmployeeID)
         // Optionally: call 'Distinct' to remove duplicates from results
        .Distinct()
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`using (var asyncSession = store.OpenAsyncSession())
{
    List<string> results = await asyncSession
        .Query<TsIndex.IndexEntry, TsIndex>()
        .Where(x => x.BPM > 100)
         // Return only the EmployeeID index-field in the results
        .Select(x => x.EmployeeID)
         // Optionally: call 'Distinct' to remove duplicates from results
        .Distinct()
        .ToListAsync();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var fieldsToProject = new string[] {
    "EmployeeID"
};

using (var session = store.OpenSession())
{
    List<EmployeeDetails> results = session.Advanced
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
        .WhereGreaterThan(x => x.BPM, 100)
         // Return only the EmployeeID index-field in the results
        .SelectFields<EmployeeDetails>(fieldsToProject)
         // Optionally: call 'Distinct' to remove duplicates from results
        .Distinct()
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Projection_class" label="Projection_class">
<CodeBlock language="csharp">
{`// This class is used when projecting index-fields via DocumentQuery
public class EmployeeDetails
{
    public string EmployeeName { get; set; }
    public string EmployeeID { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Return only the EmployeeID index-field in the results
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
              where BPM > 100.0
              select distinct EmployeeID
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where BPM > 100.0
select distinct EmployeeID
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax
   
* `session.Query`  

<TabItem value="something" label="json">
<CodeBlock language="json">
{`IRavenQueryable<T> Query<T, TIndexCreator>() where TIndexCreator 
: AbstractCommonApiForIndexes, new();
`}
</CodeBlock>
</TabItem>

* `DocumentQuery`  
    
<TabItem value="something" label="json">
<CodeBlock language="json">
{`IDocumentQuery<T> DocumentQuery<T, TIndexCreator>() where TIndexCreator 
: AbstractCommonApiForIndexes, new();
`}
</CodeBlock>
</TabItem>

| Parameter          | Description        |
|--------------------|--------------------|
| **T**              | The results class  |
| **TIndexCreator**  | Index              |




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* **Time series index**:

    * STATIC-time-series-indexes can be defined from the [Client API](../../../document-extensions/timeseries/indexing) 
      or using [Studio](../../../studio/database/indexes/create-map-index).  
      Such an index can be queried in the same way as a regular index that indexes documents.  
      (See [Querying an index](../../../indexes/querying/query-index)).
    
    * AUTO-time-series-indexes are Not generated automatically by the server when making a time series query.

* **The contents of the query results**:

    * Unlike a document index, where the source data are your JSON documents,  
      the source data for a time series index are the time series entries within the documents.

    * When querying a **document index**:  
      the resulting objects are the document entities (unless results are projected).
  
    * When querying a **time series index**:  
      each item in the results is of the type defined by the **index-entry** in the index definition,  
      (unless results are projected). 
      The documents themselves are not returned.

* In this page:
    * [Sample index](../../../document-extensions/timeseries/querying/using-indexes#sample-index)
    * [Querying the index](../../../document-extensions/timeseries/querying/using-indexes#querying-the-index)
        * [Query all time series entries](../../../document-extensions/timeseries/querying/using-indexes#query-all-time-series-entries)
        * [Filter query results](../../../document-extensions/timeseries/querying/using-indexes#filter-query-results)
        * [Order query results](../../../document-extensions/timeseries/querying/using-indexes#order-query-results)
        * [Project results](../../../document-extensions/timeseries/querying/using-indexes#project-results)
    * [Syntax](../../../document-extensions/timeseries/querying/using-indexes#syntax)

</Admonition>
## Sample Index

* The following is a time series map-index that will be used in the query examples throughout this article.

* Each **index-entry** consists of:
  * Three index-fields obtained from the "HeartRates" time series entries: `BPM`, `Date`, and `Tag`.
  * One index-field obtained from the time series [segment](../../../document-extensions/timeseries/indexing#timeseriessegment-object) header: `EmployeeID`.
  * One index-field obtained from the loaded employee document: `EmployeeName`.

* When querying this time series index:  
  * The resulting items correspond to the time series entries that match the query predicate.  
  * Each item in the results will be of type `TsIndex.IndexEntry`, which is the index-entry.  
    Different result types may be returned when the query [projects the results](../../../document-extensions/timeseries/querying/using-indexes#project-results).

<TabItem value="something-something" label="sample_ts_index">
<CodeBlock language="python">
{`class TsIndex(AbstractTimeSeriesIndexCreationTask):
    # The index-entry:
    # ===============
    class IndexEntry:
        def __init__(
            self,
            bpm: float = None,
            date: datetime = None,
            tag: str = None,
            employee_id: str = None,
            employee_name: str = None,
        ):
            # The index-fields:
            # =================
            self.bpm = bpm
            self.date = date
            self.tag = tag
            self.employee_id = employee_id
            self.employee_name = employee_name

    def __init__(self):
        super().__init__()
        self.map = """
        from ts in timeSeries.Employees.HeartRates
        from entry in ts.Entries
        let employee = LoadDocument(ts.DocumentId, "Employees")
        select new 
        \{
            bpm = entry.Values[0],
            date = entry.Timestamp.Date,
            tag = entry.Tag,
            employee_id = ts.DocumentId,
            employee_name = employee.FirstName + ' ' + employee.LastName
        \}
        """
`}
</CodeBlock>
</TabItem>



## Querying the index 
 
#### Query all time series entries:

No filtering is applied in this query.  
Results will include ALL entries from time series "HeartRates".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(session.query_index_type(self.TsIndex, self.TsIndex.IndexEntry))

    # Access results:
    entry_result = results[0]
    employee_name = entry_result.employee_name
    bmp = entry_result.bpm
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(session.advanced.raw_query("from index 'TsIndex'", self.TsIndex.IndexEntry))
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
`}
</CodeBlock>
</TabItem> 
</Tabs>
#### Filter query results:

In this example, time series entries are filtered by the query.  
The query predicate is applied to the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(
        session.query_index_type(self.TsIndex, self.TsIndex.IndexEntry)
        .where_equals("employee_name", "Robert King")
        .and_also()
        .where_greater_than("bpm", 85)
    )
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(
        session.advanced.raw_query(
            "from index 'TsIndex' where employee_name == 'Robert King' and bpm > 85.0",
            self.TsIndex.IndexEntry,
        )
    )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where EmployeeName == "Robert King" and BPM > 85.0
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Order query results:

Results can be ordered by any of the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(
        session.query_index_type(self.TsIndex, self.TsIndex.IndexEntry)
        .where_less_than("bpm", 58)
        .order_by_descending("date")
    )
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(
        session.advanced.raw_query(
            "from index 'TsIndex' where bpm < 58.0 order by date desc",
            self.TsIndex.IndexEntry,
        )
    )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where BPM < 58.0
order by Date desc
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Project results:

* Instead of returning the entire `TsIndex.IndexEntry` object for each result item,  
  you can return only partial fields.

* In this example, we query for time series entries with a very high BPM value.  
  We retrieve entries with BPM value &gt; 100 but return only the _EmployeeID_ for each entry.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(
        session.query_index_type(self.TsIndex, self.TsIndex.IndexEntry)
        .where_greater_than("bpm", 100)
        .select_fields(self.EmployeeDetails, "employee_id")
        .distinct()
    )
`}
</CodeBlock>
</TabItem>
<TabItem value="Projection_class" label="Projection_class">
<CodeBlock language="python">
{`# This class is used when projecting index-fields via DocumentQuery
class EmployeeDetails:
    def __init__(self, employee_name: str = None, employee_id: str = None):
        self.employee_name = employee_name
        self.employee_id = employee_id
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`with store.open_session() as session:
    results = list(
        session.advanced.raw_query(
            "from index 'TsIndex' where bpm > 100.0 select distinct employee_id",
            self.TsIndex.IndexEntry,
        )
    )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where BPM > 100.0
select distinct EmployeeID
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax
   
* [query](../../../client-api/session/querying/how-to-query#query-overview)  
<TabItem value="something" label="json">
<CodeBlock language="json">
{`def query(
self, source: Optional[Query] = None, object_type: Optional[Type[_T]] = None
) -> DocumentQuery[_T]:
...
`}
</CodeBlock>
</TabItem>

* [document_query](../../../client-api/session/querying/document-query/query-vs-document-query)  
<TabItem value="something" label="json">
<CodeBlock language="json">
{`def document_query(
self,
index_name: str = None,
collection_name: str = None,
object_type: Type[_T] = None,
is_map_reduce: bool = False,
) -> DocumentQuery[_T]:
...
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* **Time series index**:

    * STATIC-time-series-indexes can be defined from the [Client API](../../../document-extensions/timeseries/indexing) 
      or using [Studio](../../../studio/database/indexes/create-map-index).  
      Such an index can be queried in the same way as a regular index that indexes documents.  
      (See [Querying an index](../../../indexes/querying/query-index)).
    
    * AUTO-time-series-indexes are Not generated automatically by the server when making a time series query.

* **The contents of the query results**:

    * Unlike a document index, where the source data are your JSON documents,  
      the source data for a time series index are the time series entries within the documents.

    * When querying a **document index**:  
      the resulting objects are the document entities (unless results are [projected](../../../indexes/querying/projections)).
  
    * When querying a **time series index**:  
      each item in the results is of the type defined by the **index-entry** in the index definition,  
      (unless results are [projected](../../../document-extensions/timeseries/querying/using-indexes#project-results)). 
      The documents themselves are not returned.

* In this page:
    * [Sample index](../../../document-extensions/timeseries/querying/using-indexes#sample-index)
    * [Querying the index](../../../document-extensions/timeseries/querying/using-indexes#querying-the-index)
        * [Query all time series entries](../../../document-extensions/timeseries/querying/using-indexes#query-all-time-series-entries)
        * [Filter query results](../../../document-extensions/timeseries/querying/using-indexes#filter-query-results)
        * [Order query results](../../../document-extensions/timeseries/querying/using-indexes#order-query-results)
        * [Project results](../../../document-extensions/timeseries/querying/using-indexes#project-results)

</Admonition>
## Sample Index

* The following is a time series map-index that will be used in the query examples throughout this article.

* Each **index-entry** consists of:
  * Three index-fields obtained from the "HeartRates" time series entries: `BPM`, `Date`, and `Tag`.
  * One index-field obtained from the time series [segment](../../../document-extensions/timeseries/indexing#timeseriessegment-object) header: `EmployeeID`.
  * One index-field obtained from the loaded employee document: `EmployeeName`.

* When querying this time series index:  
  * The resulting items correspond to the time series entries that match the query predicate.  
  * Each item in the results will be of type `TsIndex.IndexEntry`, which is the index-entry.  
    Different result types may be returned when the query [projects the results](../../../document-extensions/timeseries/querying/using-indexes#project-results).

<TabItem value="something" label="sample_ts_index">
<CodeBlock language="csharp">
{`public class TsIndex : AbstractTimeSeriesIndexCreationTask<Employee>
\{
    // The index-entry:
    // ================
    public class IndexEntry
    \{
        // The index-fields:
        // =================
        public double BPM \{ get; set; \}
        public DateTime Date \{ get; set; \}
        public string Tag \{ get; set; \}
        public string EmployeeID \{ get; set; \}
        public string EmployeeName \{ get; set; \}
    \}

    public TsIndex()
    \{
        AddMap("HeartRates", timeSeries => 
            from segment in timeSeries
            from entry in segment.Entries
            
            let employee = LoadDocument<Employee>(segment.DocumentId)
            
            // Define the content of the index-fields:
            // =======================================
            select new IndexEntry()
            \{
                BPM = entry.Values[0],
                Date = entry.Timestamp,
                Tag = entry.Tag,
                EmployeeID = segment.DocumentId,
                EmployeeName = employee.FirstName + " " + employee.LastName 
            \});
    \}
\}
`}
</CodeBlock>
</TabItem>



## Querying the index 
 
#### Query all time series entries:

No filtering is applied in this query.  
Results will include ALL entries from time series "HeartRates".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session
         // Query the index
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Query for all entries w/o any filtering
        .ToList();
    
    // Access results:
    TsIndex.IndexEntry entryResult = results[0];
    string employeeName = entryResult.EmployeeName;
    double BPM = entryResult.BPM;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Query the index
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
         // Query for all entries w/o any filtering
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Query the index for all entries w/o any filtering
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
`}
</CodeBlock>
</TabItem> 
</Tabs>
#### Filter query results:

In this example, time series entries are filtered by the query.  
The query predicate is applied to the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Retrieve only time series entries with high BPM values for a specific employee
        .Where(x => x.EmployeeName == "Robert King" && x.BPM > 85)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
         // Retrieve only time series entries with high BPM values for a specific employee
        .WhereEquals(x => x.EmployeeName, "Robert King")
        .AndAlso()
        .WhereGreaterThan(x => x.BPM, 85)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Retrieve only time series entries with high BPM values for a specific employee
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
              where EmployeeName == 'Robert King' and BPM > 85.0 
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where EmployeeName == "Robert King" and BPM > 85.0
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Order query results:

Results can be ordered by any of the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session
        .Query<TsIndex.IndexEntry, TsIndex>()
         // Retrieve time series entries where employees had a low BPM value
        .Where(x => x.BPM < 58)
         // Order by the 'Date' index-field (descending order)
        .OrderByDescending(x => x.Date)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
         // Retrieve time series entries where employees had a low BPM value
        .WhereLessThan(x => x.BPM, 58)
         // Order by the 'Date' index-field (descending order)
        .OrderByDescending(x => x.Date)
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Retrieve entries with low BPM value and order by 'Date' descending
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
              where BPM < 58.0
              order by Date desc
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where BPM < 58.0
order by Date desc
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Project results:

* Instead of returning the entire `TsIndex.IndexEntry` object for each result item,  
  you can return only partial fields.

* Learn more about projecting query results in [Project Index Query Results](../../../indexes/querying/projections).

* In this example, we query for time series entries with a very high BPM value.  
  We retrieve entries with BPM value &gt; 100 but return only the _EmployeeID_ for each entry.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<string> results = session
        .Query<TsIndex.IndexEntry, TsIndex>()
        .Where(x => x.BPM > 100)
         // Return only the EmployeeID index-field in the results
        .Select(x => x.EmployeeID)
         // Optionally: call 'Distinct' to remove duplicates from results
        .Distinct()
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var fieldsToProject = new string[] {
    "EmployeeID"
};

using (var session = store.OpenSession())
{
    List<EmployeeDetails> results = session.Advanced
        .DocumentQuery<TsIndex.IndexEntry, TsIndex>()
        .WhereGreaterThan(x => x.BPM, 100)
         // Return only the EmployeeID index-field in the results
        .SelectFields<EmployeeDetails>(fieldsToProject)
         // Optionally: call 'Distinct' to remove duplicates from results
        .Distinct()
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Projection_class" label="Projection_class">
<CodeBlock language="csharp">
{`// This class is used when projecting index-fields via DocumentQuery
public class EmployeeDetails
{
    public string EmployeeName { get; set; }
    public string EmployeeID { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`using (var session = store.OpenSession())
{
    List<TsIndex.IndexEntry> results = session.Advanced
         // Return only the EmployeeID index-field in the results
        .RawQuery<TsIndex.IndexEntry>($@"
              from index 'TsIndex'
              where BPM > 100.0
              select distinct EmployeeID
         ")
        .ToList();
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where BPM > 100.0
select distinct EmployeeID
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* **Time series index**:

    * STATIC-time-series-indexes can be defined from the [Client API](../../../document-extensions/timeseries/indexing) 
      or using [Studio](../../../studio/database/indexes/create-map-index).  
      Such an index can be queried in the same way as a regular index that indexes documents.  
      (See [Querying an index](../../../indexes/querying/query-index)).
    
    * AUTO-time-series-indexes are Not generated automatically by the server when making a time series query.

* **The contents of the query results**:

    * Unlike a document index, where the source data are your JSON documents,  
      the source data for a time series index are the time series entries within the documents.

    * When querying a **document index**:  
      the resulting objects are the document entities (unless results are [projected](../../../indexes/querying/projections)).
  
    * When querying a **time series index**:  
      each item in the results is of the type defined by the **index-entry** in the index definition,  
      (unless results are [projected](../../../document-extensions/timeseries/querying/using-indexes#project-results)). 
      The documents themselves are not returned.

* In this page:
    * [Sample index](../../../document-extensions/timeseries/querying/using-indexes#sample-index)
    * [Querying the index](../../../document-extensions/timeseries/querying/using-indexes#querying-the-index)
        * [Query all time series entries](../../../document-extensions/timeseries/querying/using-indexes#query-all-time-series-entries)
        * [Filter query results](../../../document-extensions/timeseries/querying/using-indexes#filter-query-results)
        * [Order query results](../../../document-extensions/timeseries/querying/using-indexes#order-query-results)
        * [Project results](../../../document-extensions/timeseries/querying/using-indexes#project-results)

</Admonition>
## Sample Index

* The following is a time series map-index that will be used in the query examples throughout this article.

* Each **index-entry** consists of:
  * Three index-fields obtained from the "HeartRates" time series entries: `bpm`, `date`, and `tag`.
  * One index-field obtained from the time series [segment](../../../document-extensions/timeseries/indexing#timeseriessegment-object) header: `employeeID`.
  * One index-field obtained from the loaded employee document: `employeeName`.

* When querying this time series index:  
  * The resulting items correspond to the time series entries that match the query predicate.  
  * Each item in the results will in the shape of the defined index-entry.  
    Different result types may be returned when the query [projects the results](../../../document-extensions/timeseries/querying/using-indexes#project-results).

<TabItem value="something-something" label="sample_ts_index">
<CodeBlock language="nodejs">
{`class TsIndex extends AbstractRawJavaScriptTimeSeriesIndexCreationTask \{
    constructor() \{
        super();

        this.maps.add(\`
            timeSeries.map("Employees", "HeartRates", function (segment) \{
                 let employee = load(segment.DocumentId, "Employees")
                 
                 // Return the index-entry:
                 return segment.Entries.map(entry => (\{
                 
                     // Define the index-fields:
                     bpm: entry.Values[0],
                     date: new Date(entry.Timestamp),
                     tag: entry.Tag
                     employeeID: segment.DocumentId,
                     employeeName: employee.FirstName + " " + employee.LastName
                 \}));
            \})
        \`;
    \}
\}
`}
</CodeBlock>
</TabItem>



## Querying the index 
 
#### Query all time series entries:

No filtering is applied in this query.  
Results will include ALL entries from time series "HeartRates".

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
     // Query the index 
    .query({ indexName: "TsIndex" })
     // Query for all entries w/o any filtering
    .all();

// Access results:
const entryResult = results[0];
const employeeName = entryResult.employeeName;
const bpm = entryResult.bpm;
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session
     // Provide RQL to rawQuery
    .advanced.rawQuery("from index 'TsIndex'")
     // Execute the query
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
`}
</CodeBlock>
</TabItem> 
</Tabs>
#### Filter query results:

In this example, time series entries are filtered by the query.  
The query predicate is applied to the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
    .query({ indexName: "TsIndex" })
     // Retrieve only time series entries with high BPM values for a specific employee
    .whereEquals("employeeName", "Robert King")
    .whereGreaterThanOrEqual("bpm", 85)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session
     // Retrieve only time series entries with high BPM values for a specific employee
    .advanced.rawQuery(\`
         from index "TsIndex"
         where employeeName == "Robert King" and bpm > 85.0
    \`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where employeeName == "Robert King" and bpm >= 85
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Order query results:

Results can be ordered by any of the index-fields.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
    .query({ indexName: "TsIndex" })
     // Retrieve time series entries where employees had a low BPM value
    .whereLessThan("bpm", 58)
     // Order by the 'date' index-field (descending order)
    .orderByDescending("date")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session
     // Retrieve entries with low BPM value and order by 'date' descending
    .advanced.rawQuery(\`
          from index "TsIndex"
          where bpm < 58
          order by date desc
    \`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where bpm < 58
order by date desc
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Project results:

* Instead of returning the entire index entry object for each result item,  
  you can return only partial fields.

* Learn more about projecting query results in [Project Index Query Results](../../../indexes/querying/projections).

* In this example, we query for time series entries with a very high BPM value.  
  We retrieve entries with BPM value &gt; 100 but return only the _employeeID_ for each entry.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
    .query({ indexName: "TsIndex" })
    .whereGreaterThanOrEqual("bpm", 100)
     // Return only the employeeID index-field in the results
    .selectFields(["employeeID"])
     // Optionally: call 'distinct' to remove duplicates from results
    .distinct()
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session
     // Return only the employeeID index-field in the results
    .advanced.rawQuery(\`
         from index "TsIndex"
         where bpm >= 100
         select distinct employeeID
    \`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "TsIndex"
where bpm > 100
select distinct employeeID
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>