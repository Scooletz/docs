---
title: "Indexes: Indexing Basics"
hide_table_of_contents: true
sidebar_label: Indexing Basics
sidebar_position: 3
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexes: Indexing Basics
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


To achieve very fast response times, RavenDB handles **indexing in the background** whenever data is added or changed. This approach allows the server to respond quickly even when large amounts of data have changed. The only drawback of this choice is that results might be stale (more about staleness in next section). Underneath, the server is using [Lucene](http://lucene.apache.org/) to perform indexation and [Raven Query Language](../client-api/session/querying/what-is-rql.mdx) for querying.

## Stale Indexes

The notion of stale indexes comes from an observation deep in RavenDB's design, assuming that the user should never suffer from assigning the server big tasks. As far as RavenDB is concerned, it is better to be stale than offline, and as such it will return results to queries even if it knows they may not be as up-to-date as possible.

RavenDB returns quickly for every client request, even if involves re-indexing hundreds of thousands of documents. Since the previous request has returned so quickly, the next query can be made a millisecond after that. and results will be returned but they will be marked as `Stale`.

<Admonition type="info" title="">
You can read more about stale indexes [here](../indexes/stale-indexes.mdx).
</Admonition>

## Querying

RavenDB uses `Raven Query Language (RQL)`, an SQL-like querying language for querying. The easiest way for us would be to expose a method in which you could pass your RQL-flavored query as a string (we [did](../client-api/session/querying/how-to-query.mdx#sessionadvancedrawquery) that) and do not bother about anything else.

The fact is that we did not stop at this point. We went much further by exposing LINQ-based querying with strong-type support that hides all Lucene syntax complexity:

<Tabs groupId='languageSyntax'>
<TabItem value="Method-syntax" label="Method-syntax">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Query<Employee>("Employees/ByFirstName")
    .Where(x => x.FirstName == "Robert")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query-syntax" label="Query-syntax">
<CodeBlock language="csharp">
{`IQueryable<Employee> employees =
    from employee in session.Query<Employee>("Employees/ByFirstName")
    where employee.FirstName == "Robert"
    select employee;
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstName'
where FirstName = 'Robert'
`}
</CodeBlock>
</TabItem>
</Tabs>

You can also create queries manually by using  [DocumentQuery](../client-api/session/querying/document-query/what-is-document-query.mdx) or [RawQuery](../client-api/session/querying/how-to-query.mdx#sessionadvancedrawquery), both available as a part of advanced session operations:

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Advanced
    .DocumentQuery<Employee>("Employees/ByFirstName")
    .WhereEquals(x => x.FirstName, "Robert")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Advanced
    .RawQuery<Employee>("from index 'Employees/ByFirstName' where FirstName = 'Robert'")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstName'
where FirstName = 'Robert'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Types of Indexes

You probably know that indexes can be divided by their source of origin to the `static` and `auto` indexes (if not, read about it [here](../indexes/creating-and-deploying.mdx)), but a more interesting division is by functionality. For this case we have `Map` and `Map-Reduce` indexes.

`Map` indexes (sometimes referred as simple indexes) contain one (or more) mapping functions that indicate which fields from documents should be indexed. They indicate which documents can be searched by which fields.

`Map-Reduce` indexes allow complex aggregations to be performed in a two-step process. First by selecting appropriate records (using the Map function), then by applying a specified reduce function to these records to produce a smaller set of results.

<Admonition type="info" title="Map Indexes" id="map-indexes" href="#map-indexes">
You can read more about `Map` indexes [here](../indexes/map-indexes.mdx).
</Admonition>

<Admonition type="info" title="Map-Reduce Indexes" id="map-reduce-indexes" href="#map-reduce-indexes">
More detailed information about `Map-Reduce` indexes can be found [here](../indexes/map-reduce-indexes.mdx).
</Admonition>


</LanguageContent>
<LanguageContent language="java">


To achieve very fast response times, RavenDB handles **indexing in the background** whenever data is added or changed. This approach allows the server to respond quickly even when large amounts of data have changed. The only drawback of this choice is that results might be stale (more about staleness in next section). Underneath, the server is using [Lucene](http://lucene.apache.org/) to perform indexation and [Raven Query Language](../client-api/session/querying/what-is-rql.mdx) for querying.

## Stale Indexes

The notion of stale indexes comes from an observation deep in RavenDB's design, assuming that the user should never suffer from assigning the server big tasks. As far as RavenDB is concerned, it is better to be stale than offline, and as such it will return results to queries even if it knows they may not be as up-to-date as possible.

RavenDB returns quickly for every client request, even if involves re-indexing hundreds of thousands of documents. Since the previous request has returned so quickly, the next query can be made a millisecond after that. and results will be returned but they will be marked as `Stale`.

<Admonition type="info" title="">
You can read more about stale indexes [here](../indexes/stale-indexes.mdx).
</Admonition>

## Querying

RavenDB uses `Raven Query Language (RQL)`, an SQL-like querying language for querying. The easiest way for us would be to expose a method in which you could pass your RQL-flavored query as a string (we [did](../client-api/session/querying/how-to-query.mdx#sessionadvancedrawquery) that) and do not bother about anything else.

The fact is that we did not stop at this point. We went much further, by exposing querying methods that hides all Lucene syntax complexity:

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Employee> employees = session.query(Employee.class, Query.index("Employees/ByFirstName"))
    .whereEquals("FirstName", "Robert")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstName'
where FirstName = 'Robert'
`}
</CodeBlock>
</TabItem>
</Tabs>

You can also create queries by using [RawQuery](../client-api/session/querying/how-to-query.mdx#sessionadvancedrawquery). It is available as a part of advanced session operations:

<Tabs groupId='languageSyntax'>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="java">
{`List<Employee> employees = session.advanced()
    .rawQuery(Employee.class, "from index 'Employees/ByFirstName' where FirstName = 'Robert'")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstName'
where FirstName = 'Robert'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Types of Indexes

You probably know that indexes can be divided by their source of origin to the `static` and `auto` indexes (if not, read about it [here](../indexes/creating-and-deploying.mdx)), but a more interesting division is by functionality. For this case we have `Map` and `Map-Reduce` indexes.

`Map` indexes (sometimes referred as simple indexes) contain one (or more) mapping functions that indicate which fields from documents should be indexed. They indicate which documents can be searched by which fields.

`Map-Reduce` indexes allow complex aggregations to be performed in a two-step process. First by selecting appropriate records (using the Map function), then by applying a specified reduce function to these records to produce a smaller set of results.

<Admonition type="info" title="Map Indexes" id="map-indexes" href="#map-indexes">
You can read more about `Map` indexes [here](../indexes/map-indexes.mdx).
</Admonition>

<Admonition type="info" title="Map-Reduce Indexes" id="map-reduce-indexes" href="#map-reduce-indexes">
More detailed information about `Map-Reduce` indexes can be found [here](../indexes/map-reduce-indexes.mdx).
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">


To achieve very fast response times, RavenDB handles **indexing in the background** whenever data is added or changed. This approach allows the server to respond quickly even when large amounts of data have changed. The only drawback of this choice is that results might be stale (more about staleness in next section). Underneath, the server is using [Lucene](http://lucene.apache.org/) to perform indexation and [Raven Query Language](../client-api/session/querying/what-is-rql.mdx) for querying.

## Stale Indexes

The notion of stale indexes comes from an observation deep in RavenDB's design, assuming that the user should never suffer from assigning the server big tasks. As far as RavenDB is concerned, it is better to be stale than offline, and as such it will return results to queries even if it knows they may not be as up-to-date as possible.

RavenDB returns quickly for every client request, even if involves re-indexing hundreds of thousands of documents. Since the previous request has returned so quickly, the next query can be made a millisecond after that. and results will be returned but they will be marked as `Stale`.

<Admonition type="info" title="">
You can read more about stale indexes [here](../indexes/stale-indexes.mdx).
</Admonition>

## Querying

RavenDB uses `Raven Query Language (RQL)`, an SQL-like querying language for querying. The easiest way for us would be to expose a method in which you could pass your RQL-flavored query as a string (we [did](../client-api/session/querying/how-to-query.mdx#sessionadvancedrawquery) that) and do not bother about anything else.

The fact is that we did not stop at this point. We went much further, by exposing querying methods that hides all Lucene syntax complexity:

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const employees = await session.query({ indexName: "Employees/ByFirstName" })
    .whereEquals("FirstName", "Robert")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstName'
where FirstName = 'Robert'
`}
</CodeBlock>
</TabItem>
</Tabs>

You can also create queries by using [RawQuery](../client-api/session/querying/how-to-query.mdx#sessionadvancedrawquery). It is available as a part of advanced session operations:

<Tabs groupId='languageSyntax'>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="js">
{`const employees = await session.advanced
    .rawQuery("from index 'Employees/ByFirstName' where FirstName = 'Robert'")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstName'
where FirstName = 'Robert'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Types of Indexes

You probably know that indexes can be divided by their source of origin to the `static` and `auto` indexes (if not, read about it [here](../indexes/creating-and-deploying.mdx)), but a more interesting division is by functionality. For this case we have `Map` and `Map-Reduce` indexes.

`Map` indexes (sometimes referred as simple indexes) contain one (or more) mapping functions that indicate which fields from documents should be indexed. They indicate which documents can be searched by which fields.

`Map-Reduce` indexes allow complex aggregations to be performed in a two-step process. First by selecting appropriate records (using the Map function), then by applying a specified reduce function to these records to produce a smaller set of results.

<Admonition type="info" title="Map Indexes" id="map-indexes" href="#map-indexes">
You can read more about `Map` indexes [here](../indexes/map-indexes.mdx).
</Admonition>

<Admonition type="info" title="Map-Reduce Indexes" id="map-reduce-indexes" href="#map-reduce-indexes">
More detailed information about `Map-Reduce` indexes can be found [here](../indexes/map-reduce-indexes.mdx).
</Admonition>


</LanguageContent>

<!---
### Indexes
- [Map Indexes](../indexes/map-indexes)
- [Stale Indexes](../indexes/stale-indexes)
- [What are Indexes](../indexes/what-are-indexes)
- [Creating and Deploying Indexes](../indexes/creating-and-deploying)

### Querying
- [Query Overview](../client-api/session/querying/how-to-query)
- [What is RQL](../client-api/session/querying/what-is-rql)
- [Basics](../indexes/querying/query-index)

### Studio
- [Indexes: Overview](../studio/database/indexes/indexes-overview#indexes-overview)
- [Studio Index List View](../studio/database/indexes/indexes-list-view)


-->