import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Documents that contain spatial data can be queried by spatial queries that employ geographical criteria.  
  There are two options: **dynamic** spatial query, and spatial **index** query.  

  * **Dynamic spatial query**  
    A dynamic spatial query can be made on a collection (see [how to make a spatial query](../client-api/session/querying/how-to-make-a-spatial-query.mdx)).  
    An auto-index will be created by the server.  
  
  * **Spatial index query**  
    Documents' spatial data can be indexed in a static index (**described in this article**),  
    and a spatial query can then be executed over this index (see [query a spatial index](../indexes/querying/spatial.mdx)).  

* In this page:
  * [Create index with spatial field](../indexes/indexing-spatial-data.mdx#create-index-with-spatial-field)
  * [Customize coordinate system and strategy](../indexes/indexing-spatial-data.mdx#customize-coordinate-system-and-strategy)
  * [Spatial indexing strategies](../indexes/indexing-spatial-data.mdx#spatial-indexing-strategies)

</Admonition>
## Create index with spatial field

* Use `CreateSpatialField` to index spatial data in a static-index.

* You can then retrieve documents based on geographical criteria when making a spatial query on this index-field.

* A spatial index can also be defined from [Studio](../studio/database/indexes/create-map-index.mdx#spatial-field-options). 

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Indexing_coordinates" label="Indexing_coordinates">
<CodeBlock language="python">
{`# Define an index with a spatial field
class Events_ByNameAndCoordinates(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        # Call 'CreateSpatialField' to create a spatial index-field
        # Field 'coordinates' will be composed of lat & lng supplied from the document
        self.map = (
            "from e in docs.Events select new {"
            "    name = e.name,"
            "    coordinates = CreateSpatialField(e.latitude, e.longitude)"
            "}"
        )
        # Documents can be retrieved
        # by making a spatial query on the 'coordinates' index-field


class Event:
    def __init__(self, Id: str = None, name: str = None, latitude: float = None, longitude: float = None):
        self.Id = Id
        self.name = name
        self.latitude = latitude
        self.longitude = longitude
`}
</CodeBlock>
</TabItem>
<TabItem value="Indexing_WKT" label="Indexing_WKT">
<CodeBlock language="python">
{`# Define an index with a spatial field
class EventsWithWKT_ByNameAndWKT(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from e in docs.Events select new {" "    name = e.name," "    WKT = CreateSpatialField(e.WKT)" "}"


class EventWithWKT:
    def __init__(self, Id: str = None, name: str = None, WKT: str = None):
        self.Id = Id
        self.name = name
        self.WKT = WKT
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="python">
{`class Events_ByNameAndCoordinates_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            """
            map('events', function (e) {
                    return { 
                        name: e.name,
                        coordinates: createSpatialField(e.latitude, e.longitude)
                    };
            })
            """
        }
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="spatial_syntax_1" label="spatial_syntax_1">
<CodeBlock language="python">
{`class DynamicSpatialField(ABC):
    def __init__(self, round_factor: float = 0): ...
class PointField(DynamicSpatialField):  # Latitude/Longitude coordinates
    def __init__(self, latitude: str, longitude: str): ...


class WktField(DynamicSpatialField):  # Shape in WKT string format
    def __init__(self, wkt: str): ...
`}
</CodeBlock>
</TabItem>



## Customize coordinate system and strategy

* For each spatial index-field, you can specify the **coordinate system** and **strategy** to be used  
  during indexing and when processing the data at query time.

* RavenDB supports both the **Geography** and **Cartesian** systems with the following strategies:

  * Geography system:
      * `bounding_box_index`
      * `geohash_prefix_tree_index`
      * `quad_prefix_tree_index`

  * Cartesian system:
      * `bounding_box_index`
      * `quad_prefix_tree_index`

* **By default**, the `geohash_prefix_tree_index` strategy is used with `geohash_level` set to **9**.  

* The performance cost of spatial indexing is directly related to the tree level chosen.  
  Learn more about each strategy [below](../indexes/indexing-spatial-data.mdx#spatial-indexing-strategies).

* Note: Modifying the strategy after the index has been created & deployed will trigger the re-indexing.

#### Exmaple:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Events_ByNameAndCoordinates_Custom(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from e in docs.Events select new { name = e.name, coordinates = CreateSpatialField(e.latitude, e.longitude)}"

        # Set the spatial indexing strategy for the spatial field 'coordinates'
        self._spatial("coordinates", lambda factory: factory.cartesian.bounding_box_index())
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript_index" label="JavaScript_index">
<CodeBlock language="python">
{`class Event_ByNameAndCoordinates_Custom_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = """
        map('events', function (e) {
                return { 
                    Name: e.Name,
                    Coordinates: createSpatialField(e.Latitude, e.Longitude)
                };
        })
        """

        # Customize index fields
        self.fields = {
            "coordinates": IndexFieldOptions(
                spatial=SpatialOptions(
                    field_type=SpatialFieldType.CARTESIAN, strategy=SpatialSearchStrategy.BOUNDING_BOX
                )
            )
        }
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Syntax:

<TabItem value="spatial_syntax_2" label="spatial_syntax_2">
<CodeBlock language="python">
{`class SpatialOptionsFactory:
    def geography(self) -> GeographySpatialOptionsFactory:
        return SpatialOptionsFactory.GeographySpatialOptionsFactory()

    def cartesian(self) -> CartesianSpatialOptionsFactory:
        return SpatialOptionsFactory.CartesianSpatialOptionsFactory()
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="GeographySpatialOptionsFactory" label="GeographySpatialOptionsFactory">
<CodeBlock language="python">
{`# Default is GeohashPrefixTree strategy with max_tree_level set to 9
def default_option(self, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS) -> SpatialOptions: ...

def bounding_box_index(self, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS) -> SpatialOptions: ...
def geohash_prefix_tree_index(
    self, max_tree_level: int, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS
) -> SpatialOptions: ...
def quad_prefix_tree_index(
    self, max_tree_level: int, circle_radius_units: SpatialUnits = SpatialUnits.KILOMETERS
) -> SpatialOptions: ...
`}
</CodeBlock>
</TabItem>
<TabItem value="CartesianSpatialOptionsFactory" label="CartesianSpatialOptionsFactory">
<CodeBlock language="python">
{`def bounding_box_index(self) -> SpatialOptions: ...
def quad_prefix_tree_index(
    self, max_tree_level: int, bounds: SpatialOptionsFactory.SpatialBounds
) -> SpatialOptions: ...

class SpatialBounds:
    def __init__(self, min_x: float, min_y: float, max_x: float, max_y: float): ...
`}
</CodeBlock>
</TabItem>
</Tabs>



## Spatial indexing strategies

#### BoundingBox strategy

* The bounding box strategy is the simplest.  
  Given a spatial shape, such as a point, circle, or polygon, the shape's bounding box is computed  
  and the spatial coordinates (minX, minY, maxX, maxY) that enclose the shape are indexed.

* When making a query,  
  RavenDB translates the query criteria to the same bounding box system used for indexing. 

* Bounding box strategy is cheaper at indexing time and can produce quick queries,  
  but that's at the expense of the level of accuracy you can get.  

* Read more about bounding box [here](https://en.wikipedia.org/wiki/Minimum_bounding_rectangle).
#### GeoHashPrefixTree strategy

* Geohash is a latitude/longitude representation system that describes Earth as a grid with 32 cells, assigning an alphanumeric character to each grid cell. 
  Each grid cell is further divided into 32 smaller chunks, and each chunk has an alphanumeric character assigned as well, and so on.

* E.g. The location of 'New York' in the United States is represented by the following geohash: [DR5REGY6R](http://geohash.org/dr5regy6r) 
  and it represents the `40.7144 -74.0060` coordinates. 
  Removing characters from the end of the geohash will decrease the precision level.

* The `max_tree_level` determines the length of the geohash used for the indexing, which in turn affects accuracy.  
  By default, it is set to **9**, providing a resolution of approximately 2.5 meters.

* More information about geohash uses, decoding algorithm, and limitations can be found [here](https://en.wikipedia.org/wiki/Geohash).

<Admonition type="note" title="Geohash precision values:" id="geohash-precision-values" href="#geohash-precision-values">

| Level | E-W Distance at Equator | N-S Distance at Equator |
|:----- |:------------------------|:------------------------|
| 12    | ~3.7cm                  | ~1.8cm                  |
| 11    | ~14.9cm                 | ~14.9cm                 |
| 10    | ~1.19m                  | ~0.60m                  |
| **9** | **~4.78m**              | **~4.78m**              |
| 8     | ~38.2m                  | ~19.1m                  |
| 7     | ~152.8m                 | ~152.8m                 |
| 6     | ~1.2km                  | ~0.61km                 |
| 5     | ~4.9km                  | ~4.9km                  |
| 4     | ~39km                   | ~19.6km                 |
| 3     | ~157km                  | ~157km                  |
| 2     | ~1252km                 | ~626km                  |
| 1     | ~5018km                 | ~5018km                 |

</Admonition>
#### QuadPrefixTree strategy

* The QuadTree represents Earth as a grid consisting of four cells (also known as buckets).
  Similar to GeoHash, each cell is assigned a letter, and is recursively divided into four more cells, creating a hierarchical structure. 

* By default, the precision level (`max_tree_level`) for QuadPrefixTree is **23**.

* More information about QuadTree can be found [here](https://en.wikipedia.org/wiki/Quadtree).

<Admonition type="note" title="Quadtree precision values:" id="quadtree-precision-values" href="#quadtree-precision-values">

| Level | Distance at Equator |
|:-------|:-------------------|
| 30     | ~4cm               |
| 29     | ~7cm               |
| 28     | ~15cm              |
| 27     | ~30cm              |
| 26     | ~60cm              |
| 25     | ~1.19m             |
| 24     | ~2.39m             |
| **23** | **~4.78m**         |
| 22     | ~9.56m             |
| 21     | ~19.11m            |
| 20     | ~38.23m            |
| 19     | ~76.23m            |
| 18     | ~152.92m           |
| 17     | ~305.84m           |
| 16     | ~611.67m           |
| 15     | ~1.22km            |
| 14     | ~2.45km            |
| 13     | ~4.89km            |
| 12     | ~9.79km            |
| 11     | ~19.57km           |
| 10     | ~39.15km           |
| 9      | ~78.29km           |
| 8      | ~156.58km          |
| 7      | ~313.12km          |
| 6      | ~625.85km          |
| 5      | ~1249km            |
| 4      | ~2473km            |
| 3      | ~4755km            |
| 2      | ~7996km            |
| 1      | ~15992km           |

</Admonition>



## Remarks

<Admonition type="info" title="">

Distance is measured by default in `KILOMETERS`.

</Admonition>


