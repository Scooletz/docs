---
title: "Querying: MoreLikeThis"
sidebar_label: MoreLikeThis
sidebar_position: 13
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/language-switcher";
import LanguageContent from "@site/src/components/language-content";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Querying: MoreLikeThis
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* `MoreLikeThis` returns a list of documents that are related to a given document.  
* This feature can be used, for example, to show a list of related articles at the 
  bottom of the currently-read article page, as done in many news sites.  
* To accomplish this, RavenDB uses the Lucene contrib project `MoreLikeThis` feature.  

* In this page:

    * [Setup](../../indexes/querying/morelikethis#setup)
    * [Basic Usage](../../indexes/querying/morelikethis#basic-usage)
    * [Options](../../indexes/querying/morelikethis#options)
    * [Stop Words](../../indexes/querying/morelikethis#stop-words)
    * [Remarks](../../indexes/querying/morelikethis#remarks)

</Admonition>
## Setup

To be able to work, `MoreLikeThis` requires access to the index text.  
The queried index needs, therefore, to [store](../../indexes/storing-data-in-index) 
the fields or the [term vectors](../../indexes/using-term-vectors) for these fields.

<TabItem value="something" label="more_like_this_4">
<CodeBlock language="csharp">
{`public class Article
\{
    public string Id \{ get; set; \}
    public string Name \{ get; set; \}
    public string ArticleBody \{ get; set; \}
\}

public class Articles_ByArticleBody : AbstractIndexCreationTask<Article>
\{
    public Articles_ByArticleBody()
    \{
        Map = docs => from doc in docs
                      select new
                      \{
                          doc.ArticleBody
                      \};

        Stores.Add(x => x.ArticleBody, FieldStorage.Yes);
        Analyzers.Add(x => x.ArticleBody, "StandardAnalyzer");
    \}
\}
`}
</CodeBlock>
</TabItem>



## Basic Usage

Many `MoreLikeThis` options are set by default.  
The simplest mode will satisfy most usage scenarios.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Article> articles = session
    .Query<Article, Articles_ByArticleBody>()
    .MoreLikeThis(builder => builder
        .UsingDocument(x => x.Id == "articles/1"))
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Article> articles = session.Advanced
    .DocumentQuery<Article, Articles_ByArticleBody>()
    .MoreLikeThis(builder => builder
        .UsingDocument(x => x.WhereEquals(y => y.Id, "articles/1")))
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1')
`}
</CodeBlock>
</TabItem>
</Tabs>

`MoreLikeThis` will use **all** the fields defined in an index.  
To use only specific fields, pass these fields in the `MoreLikeThisOptions.Fields` property.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Article> articles = session
    .Query<Article, Articles_ByArticleBody>()
    .MoreLikeThis(builder => builder
        .UsingDocument(x => x.Id == "articles/1")
        .WithOptions(new MoreLikeThisOptions
        {
            Fields = new[] { nameof(Article.ArticleBody) }
        }))
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Article> articles = session.Advanced
    .DocumentQuery<Article, Articles_ByArticleBody>()
    .MoreLikeThis(builder => builder
        .UsingDocument(x => x.WhereEquals(y => y.Id, "articles/1"))
        .WithOptions(new MoreLikeThisOptions
        {
            Fields = new[] { nameof(Article.ArticleBody) }
        }))
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1', '{ "Fields" : [ "ArticleBody" ] }')
`}
</CodeBlock>
</TabItem>
</Tabs>



## Options

Default parameters can be changed by manipulating `MoreLikeThisOptions` properties and passing them 
to `MoreLikeThis`.

| Option | Type | Description |
| ------------- | ------------- | ----- |
| **MinimumTermFrequency** | `int?` | Ignores terms with less than this frequency in the source doc |
| **MaximumQueryTerms** | `int?` | Returns a query with no more than this many terms |
| **MaximumNumberOfTokensParsed** | `int?` | The maximum number of tokens to parse in each example doc field that is not stored with TermVector support |
| **MinimumWordLength** | `int?` | Ignores words less than this length or, if 0, then this has no effect |
| **MaximumWordLength** | `int?` | Ignores words greater than this length or if 0 then this has no effect |
| **MinimumDocumentFrequency** | `int?` | Ignores words which do not occur in at least this many documents |
| **MaximumDocumentFrequency** | `int?` | Ignores words which occur in more than this many documents |
| **MaximumDocumentFrequencyPercentage** | `int?` | Ignores words which occur in more than this percentage of documents |
| **Boost** | `bool?` | Boost terms in query based on score |
| **BoostFactor** | `float?` |  Boost factor when boosting based on score |
| **StopWordsDocumentId** | `string` | Document ID containing custom stop words |
| **Fields** | `string[]` | Fields to compare |



## Stop Words

Some Lucene analyzers have a built-in list of common English words that are usually not useful 
for searching, like "a", "as", "the", etc.  
These words, called *stop words*, are considered uninteresting and are ignored.  
If a used analyzer does not support *stop words*, or you need to overload these terms, you can 
specify your own set of stop words.  
A document with a list of stop words can be stored in RavenDB by storing the `MoreLikeThisStopWords` document:

<TabItem value="something" label="more_like_this_3">
<CodeBlock language="csharp">
{`session.Store(new MoreLikeThisStopWords
\{
    Id = "Config/Stopwords",
    StopWords = new List<string> \{ "I", "A", "Be" \}
\});
`}
</CodeBlock>
</TabItem>

The document ID will then be set in the `MoreLikeThisOptions`.



## Remarks

<Admonition type="info" title="Info">
Please note that default values for settings, like `MinimumDocumentFrequency`, `MinimumTermFrequency`, 
and `MinimumWordLength`, may result in filtering out related articles, especially with a small data set 
(e.g. during development). 
</Admonition>




</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="Note">

* `MoreLikeThis` returns a list of documents that are related to a given document.  
* This feature can be used, for example, to show a list of related articles at the 
  bottom of the currently-read article page, as done in many news sites.  
* To accomplish this, RavenDB uses the Lucene contrib project `MoreLikeThis` feature.  

* In this page:

    * [Setup](../../indexes/querying/morelikethis#setup)
    * [Basic Usage](../../indexes/querying/morelikethis#basic-usage)
    * [Options](../../indexes/querying/morelikethis#options)
    * [Stop Words](../../indexes/querying/morelikethis#stop-words)
    * [Remarks](../../indexes/querying/morelikethis#remarks)

</Admonition>
## Setup

To be able to work, `MoreLikeThis` requires access to the index text.  
The queried index needs, therefore, to [store](../../indexes/storing-data-in-index) 
the fields or the [term vectors](../../indexes/using-term-vectors) for these fields.

<TabItem value="something-something" label="more_like_this_4">
<CodeBlock language="java">
{`public class Article \{
    private String id;
    private String name;
    private String articleBody;

    public String getId() \{
        return id;
    \}

    public void setId(String id) \{
        this.id = id;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}

    public String getArticleBody() \{
        return articleBody;
    \}

    public void setArticleBody(String articleBody) \{
        this.articleBody = articleBody;
    \}
\}

public class Articles_ByArticleBody extends AbstractIndexCreationTask \{
    public Articles_ByArticleBody() \{
        map = "from doc in docs.articles " +
            "select new \{" +
            "   doc.articleBody " +
            "\}";

        store("articleBody", FieldStorage.YES);
        analyze("articleBody", "StandardAnalyzer");
    \}
\}
`}
</CodeBlock>
</TabItem>



## Basic Usage

Many `MoreLikeThis` options are set by default.  
The simplest mode will satisfy most usage scenarios.  

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Article> articles = session
    .query(Article.class, Articles_ByArticleBody.class)
    .moreLikeThis(builder -> builder.usingDocument(x -> x.whereEquals("id()", "articles/1")))
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1')
`}
</CodeBlock>
</TabItem>
</Tabs>

`MoreLikeThis` will use **all** the fields defined in an index.  
To use only specific fields, pass these fields in the `MoreLikeThisOptions.Fields` property.

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`MoreLikeThisOptions options = new MoreLikeThisOptions();
options.setFields(new String[]{ "articleBody" });
List<Article> articles = session
    .query(Article.class, Articles_ByArticleBody.class)
    .moreLikeThis(builder -> builder
        .usingDocument(x -> x.whereEquals("id()", "articles/1"))
        .withOptions(options))
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1', '{ "Fields" : [ "articleBody" ] }')
`}
</CodeBlock>
</TabItem>
</Tabs>



## Options

Default parameters can be changed by manipulating `MoreLikeThisOptions` properties and passing them 
to `MoreLikeThis`.

| Options | | |
| ------------- | ------------- | ----- |
| **MinimumTermFrequency** | `Integer` | Ignores terms with less than this frequency in the source doc |
| **MaximumQueryTerms** | `Integer` | Returns a query with no more than this many terms |
| **MaximumNumberOfTokensParsed** | `Integer` | The maximum number of tokens to parse in each example doc field that is not stored with TermVector support |
| **MinimumWordLength** | `Integer` | Ignores words less than this length or, if 0, then this has no effect |
| **MaximumWordLength** | `Integer` | Ignores words greater than this length or if 0 then this has no effect |
| **MinimumDocumentFrequency** | `Integer` | Ignores words which do not occur in at least this many documents |
| **MaximumDocumentFrequency** | `Integer` | Ignores words which occur in more than this many documents |
| **MaximumDocumentFrequencyPercentage** | `Integer` | Ignores words which occur in more than this percentage of documents |
| **Boost** | `Boolean` | Boost terms in query based on score |
| **BoostFactor** | `Float` |  Boost factor when boosting based on score |
| **StopWordsDocumentId** | `String` | Document ID containing custom stop words |
| **Fields** | `String[]` | Fields to compare |



## Stop Words

Some Lucene analyzers have a built-in list of common English words that are usually not useful 
for searching, like "a", "as", "the", etc.  
These words, called *stop words*, are considered uninteresting and are ignored.  
If a used analyzer does not support *stop words*, or you need to overload these terms, you can 
specify your own set of stop words.  
A document with a list of stop words can be stored in RavenDB by storing the `MoreLikeThisStopWords` document:

<TabItem value="something-something" label="more_like_this_3">
<CodeBlock language="java">
{`MoreLikeThisStopWords stopWords = new MoreLikeThisStopWords();
stopWords.setStopWords(Arrays.asList("I", "A", "Be"));
session.store(stopWords, "Config/Stopwords");
`}
</CodeBlock>
</TabItem>

The document ID will then be set in the `MoreLikeThisOptions`.



## Remarks

<Admonition type="info" title="Info">
Please note that default values for settings, like `MinimumDocumentFrequency`, `MinimumTermFrequency`, 
and `MinimumWordLength`, may result in filtering out related articles, especially with a small data set 
(e.g. during development). 
</Admonition>




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* `more_like_this` returns a list of documents that are related to a given document.  
* This feature can be used, for example, to show a list of related articles at the 
  bottom of the currently-read article page, as done in many news sites.  
* To accomplish this, RavenDB uses the Lucene contrib project `MoreLikeThis` feature.  

* In this page:

    * [Setup](../../indexes/querying/morelikethis#setup)
    * [Basic Usage](../../indexes/querying/morelikethis#basic-usage)
    * [Options](../../indexes/querying/morelikethis#options)
    * [Stop Words](../../indexes/querying/morelikethis#stop-words)
    * [Remarks](../../indexes/querying/morelikethis#remarks)

</Admonition>
## Setup

To be able to work, `more_like_this` requires access to the index text.  
The queried index needs, therefore, to [store](../../indexes/storing-data-in-index) 
the fields or the [term vectors](../../indexes/using-term-vectors) for these fields.

<TabItem value="something-something" label="more_like_this_4">
<CodeBlock language="python">
{`from ravendb import AbstractIndexCreationTask, MoreLikeThisOptions
from ravendb.documents.indexes.definitions import FieldStorage
from ravendb.documents.queries.more_like_this import MoreLikeThisStopWords

from examples_base import ExampleBase


class Article:
    def __init__(self, Id: str = None, name: str = None, article_type: str = None):
        self.Id = Id
        self.name = name
        self.article_type = article_type


class Articles_ByArticleBody(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from doc in docs.Articles select \{ doc.article_body \}"
        self._store("article_body", FieldStorage.YES)
        self._analyze("article_body", "StandardAnalyzer")
`}
</CodeBlock>
</TabItem>



## Basic Usage

Many `more_like_this` options are set by default.  
The simplest mode will satisfy most usage scenarios.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`articles = list(
    session.query_index_type(Articles_ByArticleBody, Article).more_like_this(
        lambda builder: builder.using_document(lambda x: x.where_equals("id()", "articles/1"))
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1')
`}
</CodeBlock>
</TabItem>
</Tabs>

`more_like_this` will use **all** the fields defined in an index.  
To use only specific fields, pass these fields in the `MoreLikeThisOptions` fields property.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`options = MoreLikeThisOptions(fields=["article_body"])
articles = list(
    session.query_index_type(Articles_ByArticleBody, Article).more_like_this(
        lambda builder: builder.using_document(
            lambda x: x.where_equals("id()", "articles/1")
        ).with_options(options)
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1', '{ "Fields" : [ "ArticleBody" ] }')
`}
</CodeBlock>
</TabItem>
</Tabs>



## Options

Default parameters can be changed by manipulating `MoreLikeThisOptions` properties and passing them 
to `more_like_this`.

| Option | Type | Description |
| ------------- | ------------- | ----- |
| **minimum_term_frequency** | `int` | Ignores terms with less than this frequency in the source doc |
| **maximum_query_terms** | `int` | Returns a query with no more than this many terms |
| **maximum_number_of_tokens_parsed** | `int` | The maximum number of tokens to parse in each example doc field that is not stored with TermVector support |
| **minimum_word_length** | `int` | Ignores words less than this length or, if 0, then this has no effect |
| **maximum_word_length** | `int` | Ignores words greater than this length or if 0 then this has no effect |
| **minimum_document_frequency** | `int` | Ignores words which do not occur in at least this many documents |
| **maximum_document_frequency** | `int` | Ignores words which occur in more than this many documents |
| **maximum_document_frequency_percentage** | `int` | Ignores words which occur in more than this percentage of documents |
| **boost** | `bool` | Boost terms in query based on score |
| **boost_factor** | `float` |  Boost factor when boosting based on score |
| **stop_words_document_id** | `str` | Document ID containing custom stop words |
| **fields** | `List[str]` | Fields to compare |



## Stop Words

Some Lucene analyzers have a built-in list of common English words that are usually not useful 
for searching, like "a", "as", "the", etc.  
These words, called *stop words*, are considered uninteresting and are ignored.  
If a used analyzer does not support *stop words*, or you need to overload these terms, you can 
specify your own set of stop words.  
A document with a list of stop words can be stored in RavenDB by storing the `MoreLikeThisStopWords` document:

<TabItem value="something-something" label="more_like_this_3">
<CodeBlock language="python">
{`stop_words = MoreLikeThisStopWords(stop_words=["I", "A", "Be"])
session.store(stop_words, "Config/Stopwords")
`}
</CodeBlock>
</TabItem>

The document ID will then be set in the `MoreLikeThisOptions`.



## Remarks

<Admonition type="info" title="Info">
Please note that default values for settings, like `MinimumDocumentFrequency`, `MinimumTermFrequency`, 
and `MinimumWordLength`, may result in filtering out related articles, especially with a small data set 
(e.g. during development). 
</Admonition>




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* `moreLikeThis` returns a list of documents that are related to a given document.  
* This feature can be used, for example, to show a list of related articles at the 
  bottom of the currently-read article page, as done in many news sites.  
* To accomplish this, RavenDB uses the Lucene contrib project `MoreLikeThis` feature.  

* In this page:

    * [Setup](../../indexes/querying/morelikethis#setup)
    * [Basic Usage](../../indexes/querying/morelikethis#basic-usage)
    * [Options](../../indexes/querying/morelikethis#options)
    * [Stop Words](../../indexes/querying/morelikethis#stop-words)
    * [Remarks](../../indexes/querying/morelikethis#remarks)

</Admonition>
## Setup

To be able to work, `moreLikeThis` requires access to the index text.  
The queried index needs, therefore, to [store](../../indexes/storing-data-in-index) 
the fields or the [term vectors](../../indexes/using-term-vectors) for these fields.

<TabItem value="something-something" label="more_like_this_4">
<CodeBlock language="php">
{`class Article
\{
    public ?string $id = null;
    public ?string $name = null;
    public ?string $articleBody = null;

    public function getId(): ?string
    \{
        return $this->id;
    \}

    public function setId(?string $id): void
    \{
        $this->id = $id;
    \}

    public function getName(): ?string
    \{
        return $this->name;
    \}

    public function setName(?string $name): void
    \{
        $this->name = $name;
    \}

    public function getArticleBody(): ?string
    \{
        return $this->articleBody;
    \}

    public function setArticleBody(?string $articleBody): void
    \{
        $this->articleBody = $articleBody;
    \}
\}

class Articles_ByArticleBody extends AbstractIndexCreationTask
\{
    public function __construct()
    \{
        parent::__construct();

        $this->map = "from doc in docs.Articles select \{ doc.ArticleBody \}";

        $this->store("ArticleBody", FieldStorage::yes());
        $this->analyze("ArticleBody", "StandardAnalyzer");
    \}
\}
`}
</CodeBlock>
</TabItem>



## Basic Usage

Many `moreLikeThis` options are set by default.  
The simplest mode will satisfy most usage scenarios.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Article> $articles */
$articles = $session
    ->query(Article::class, Articles_ByArticleBody::class)
    ->moreLikeThis(function($builder) {
        return $builder
            ->usingDocument(function($x) {
                return $x->whereEquals("id()", "articles/1");
            });
    })
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`/** @var array<Article> $articles */
$articles = $session->advanced()
    ->documentQuery(Article::class, Articles_ByArticleBody::class)
    ->moreLikeThis(function($builder) {
        return $builder
            ->usingDocument(function($x) {
                return $x->whereEquals("id()", "articles/1");
            });
    })
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1')
`}
</CodeBlock>
</TabItem>
</Tabs>

`moreLikeThis` will use **all** the fields defined in an index.  
To use only specific fields, pass these fields in the `MoreLikeThisOptions` fields property.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Article> $articles */
$articles = $session
    ->query(Article::class, Articles_ByArticleBody::class)
    ->moreLikeThis(function($builder) {
        $mlt = new MoreLikeThisOptions();
        $mlt->setFields(["ArticleBody"]);

        return $builder
            ->usingDocument(function($x) {
                return $x->whereEquals("id()", "articles/1");
            })
            ->withOptions($mlt);
    })
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`/** @var array<Article> $articles */
$articles = $session->advanced()
    ->documentQuery(Article::class, Articles_ByArticleBody::class)
    ->moreLikeThis(function($builder) {
        $mlt = new MoreLikeThisOptions();
        $mlt->setFields(["ArticleBody"]);

        return $builder
            ->usingDocument(function($x) {
                return $x->whereEquals("id()", "articles/1");
            })
            ->withOptions($mlt);
    })
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1', '{ "Fields" : [ "ArticleBody" ] }')
`}
</CodeBlock>
</TabItem>
</Tabs>



## Options

Default parameters can be changed by manipulating `MoreLikeThisOptions` properties and passing them 
to `moreLikeThis`.

| Option | Type | Description |
| ------------- | ------------- | ----- |
| **MinimumTermFrequency** | `int?` | Ignores terms with less than this frequency in the source doc |
| **MaximumQueryTerms** | `int?` | Returns a query with no more than this many terms |
| **MaximumNumberOfTokensParsed** | `int?` | The maximum number of tokens to parse in each example doc field that is not stored with TermVector support |
| **MinimumWordLength** | `int?` | Ignores words less than this length or, if 0, then this has no effect |
| **MaximumWordLength** | `int?` | Ignores words greater than this length or if 0 then this has no effect |
| **MinimumDocumentFrequency** | `int?` | Ignores words which do not occur in at least this many documents |
| **MaximumDocumentFrequency** | `int?` | Ignores words which occur in more than this many documents |
| **MaximumDocumentFrequencyPercentage** | `int?` | Ignores words which occur in more than this percentage of documents |
| **Boost** | `bool?` | Boost terms in query based on score |
| **BoostFactor** | `float?` |  Boost factor when boosting based on score |
| **StopWordsDocumentId** | `string` | Document ID containing custom stop words |
| **Fields** | `string[]` | Fields to compare |






## Stop Words

Some Lucene analyzers have a built-in list of common English words that are usually not useful 
for searching, like "a", "as", "the", etc.  
These words, called *stop words*, are considered uninteresting and are ignored.  
If a used analyzer does not support *stop words*, or you need to overload these terms, you can 
specify your own set of stop words.  
A document with a list of stop words can be stored in RavenDB by storing the `MoreLikeThisStopWords` document:

<TabItem value="something-something" label="more_like_this_3">
<CodeBlock language="php">
{`$mlt = new MoreLikeThisStopWords();
$mlt->setId("Config/Stopwords");
$mlt->setStopWords(["I", "A", "Be"]);
$session->store($mlt);
`}
</CodeBlock>
</TabItem>

The document ID will then be set in the `MoreLikeThisOptions`.



## Remarks

<Admonition type="info" title="Info">
Please note that default values for settings, like `MinimumDocumentFrequency`, `MinimumTermFrequency`, 
and `MinimumWordLength`, may result in filtering out related articles, especially with a small data set 
(e.g. during development). 
</Admonition>




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* `moreLikeThis` returns a list of documents that are related to a given document.  
* This feature can be used, for example, to show a list of related articles at the 
  bottom of the currently-read article page, as done in many news sites.  
* To accomplish this, RavenDB uses the Lucene contrib project `moreLikeThis` feature.  

* In this page:

    * [Setup](../../indexes/querying/morelikethis#setup)
    * [Basic Usage](../../indexes/querying/morelikethis#basic-usage)
    * [Options](../../indexes/querying/morelikethis#options)
    * [Stop Words](../../indexes/querying/morelikethis#stop-words)
    * [Remarks](../../indexes/querying/morelikethis#remarks)

</Admonition>
## Setup

To be able to work, `MoreLikeThis` requires access to the index text.  
The queried index needs, therefore, to [store](../../indexes/storing-data-in-index) 
the fields or the [term vectors](../../indexes/using-term-vectors) for these fields.

<TabItem value="something-something" label="more_like_this_4">
<CodeBlock language="nodejs">
{`class Article \{
    constructor(id, name, articleBody) \{
        this.id = id;
        this.name = name;
        this.articleBody = articleBody;
    \}
\}

class Articles_ByArticleBody extends AbstractIndexCreationTask \{
    constructor() \{
        super();

        this.map = \`from doc in docs.Articles select new \{ 
            doc.articleBody 
        \}\`;

        this.store("articleBody", "Yes");
        this.analyze("articleBody", "StandardAnalyzer");
    \}
\}
`}
</CodeBlock>
</TabItem>



## Basic Usage

Many `MoreLikeThis` options are set by default.  
The simplest mode will satisfy most usage scenarios.  

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="nodejs">
{`const articles = await session
    .query({ indexName: "Articles/ByArticleBody" })
    .moreLikeThis(builder => 
        builder.usingDocument(x => 
            x.whereEquals("id()", "articles/1")))
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1')
`}
</CodeBlock>
</TabItem>
</Tabs>

`MoreLikeThis` will use **all** the fields defined in an index.  
To use only specific fields, pass these fields in the `MoreLikeThisOptions.fields` property.

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="nodejs">
{`const options = {
    fields: [ "articleBody" ]
};
const articles = await session
    .query({ indexName: "Articles/ByArticleBody" })
    .moreLikeThis(builder => builder
        .usingDocument(x => x.whereEquals("id()", "articles/1"))
        .withOptions(options))
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Articles/ByArticleBody' 
where morelikethis(id() = 'articles/1', '{ "Fields" : [ "articleBody" ] }')
`}
</CodeBlock>
</TabItem>
</Tabs>



## Options

Default parameters can be changed by manipulating `MoreLikeThisOptions` properties and passing them 
to `MoreLikeThis`.

| Options | | |
| ------------- | ------------- | ----- |
| **minimumTermFrequency** | `number` | Ignores terms with less than this frequency in the source doc |
| **maximumQueryTerms** | `number` | Returns a query with no more than this many terms |
| **maximumNumberOfTokensParsed** | `number` | The maximum number of tokens to parse in each example doc field that is not stored with TermVector support |
| **minimumWordLength** | `number` | Ignores words less than this length or, if 0, then this has no effect |
| **maximumWordLength** | `number` | Ignores words greater than this length or if 0 then this has no effect |
| **minimumDocumentFrequency** | `number` | Ignores words which do not occur in at least this many documents |
| **maximumDocumentFrequency** | `number` | Ignores words which occur in more than this many documents |
| **maximumDocumentFrequencyPercentage** | `number` | Ignores words which occur in more than this percentage of documents |
| **boost** | `boolean` | Boost terms in query based on score |
| **boostFactor** | `number` |  Boost factor when boosting based on score |
| **stopWordsDocumentId** | `string` | Document ID containing custom stop words |
| **fields** | `string[]` | Fields to compare |



## Stop Words

Some Lucene analyzers have a built-in list of common English words that are usually not useful 
for searching, like "a", "as", "the", etc.  
These words, called *stop words*, are considered uninteresting and are ignored.  
If a used analyzer does not support *stop words*, or you need to overload these terms, you can 
specify your own set of stop words.  
A document with a list of stop words can be stored in RavenDB by storing the `MoreLikeThisStopWords` document:

<TabItem value="something-something" label="more_like_this_3">
<CodeBlock language="nodejs">
{`const stopWords = new MoreLikeThisStopWords();
stopWords.stopWords = [ "I", "A", "Be" ];
await session.store(stopWords, "Config/Stopwords");
`}
</CodeBlock>
</TabItem>

The document ID will then be set in the `MoreLikeThisOptions`.

## Remarks

<Admonition type="info" title="Info">
Please note that default values for settings, like `minimumDocumentFrequency`, `minimumTermFrequency`, 
and `minimumWordLength`, may result in filtering out related articles, especially with a small data set 
(e.g. during development). 
</Admonition>





</LanguageContent>