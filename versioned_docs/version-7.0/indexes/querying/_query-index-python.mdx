import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Prior to this article, it is recommended that you first read this [Query Overview](../../client-api/session/querying/how-to-query.mdx).

* For a basic indexes overview, see the [Indexes Overview](../../studio/database/indexes/indexes-overview.mdx).
* Indexing the content of your documents allows for **fast document retrieval** when querying the index.  

* This article is a basic overview of how to query a **static index** using **code**.  
   * For dynamic query examples see [Query Overview](../../client-api/session/querying/how-to-query.mdx).  
   * An index can also be queried from [Studio](../../studio/database/queries/query-view.mdx) 
     using [RQL](../../client-api/session/querying/what-is-rql.mdx).

* In this page:  
   * [Query an index by `query_index_type` and `query_index`](../../indexes/querying/query-index.mdx#query-an-index-by-query_index_type-and-query_index)
   * [Query an index by `raw_query`](../../indexes/querying/query-index.mdx#query-an-index-by-raw_query) (using RQL)

</Admonition>
## Query an index by `query_index_type` and `query_index`

* In the following examples we **query an index** using the session `query_index_type` and `query_index` methods.  

* Querying can be enhanced using these [extension methods](../../client-api/session/querying/how-to-query.mdx#custom-methods).
#### Query index - no filtering:

<Tabs groupId='languageSyntax'>
<TabItem value="query_index_type" label="query_index_type">
<CodeBlock language="python">
{`# Query the 'Employees' collection using the index - without filtering
# (Open the 'Index' tab to view the index class definition)
employees = list(
    session
    # Pass the queried collection as the first generic parameter
    # Pass the index class as the second generic parameter
    .query_index_type(Employees_ByName, Employee)
)

# All 'Employee' documents that contain DOCUMENT-fields 'FirstName' and\\or 'LastName' will be returned
`}
</CodeBlock>
</TabItem>
<TabItem value="query_index" label="query_index">
<CodeBlock language="python">
{`# Query the 'Employees' collection using the index - without filtering
employees = list(
    session
    # Pass the index name as a parameter
    # Use slash '/' in the index name, replacing the underscore '_' from the index class definition
    .query_index("Employees/ByName")
)
# All 'Employee' documents that contain DOCUMENT-fields 'FirstName' and\\or 'LastName' will be returned
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`# The index definition:
class Employees_ByName(AbstractIndexCreationTask):
    # The IndexEntry class defines the index-fields
    class IndexEntry:
        def __init__(self, first_name: str = None, last_name: str = None):
            self.first_name = first_name
            self.last_name = last_name

        # The from_json method to handle different casing on the server
        @classmethod
        def from_json(cls, json_dict: Dict[str, Any]) -> "Employees_ByName.IndexEntry":
            return cls(json_dict["FirstName"], json_dict["LastName"])

    def __init__(self):
        super().__init__()
        # The 'map' function defines the content of the INDEX-fields
        # * The content of INDEX-fields 'FirstName' & 'LastName'
        #   is composed of the relevant DOCUMENT-fields.
        self.map = """from e in docs.Employees select new {FirstName = e.FirstName, LastName = e.LastName}"""
        # * The index-fields can be queried on to fetch matching documents.
        #   You can query and filter Employee documents based on their first or last names.

        # * Employee documents that do Not contain both 'FirstName' and 'LastName' fields
        #   will Not be indexed.

        # * Note: the INDEX-field name does Not have to be exactly the same
        #   as the DOCUMENT-field name.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Note:
// Use slash \`/\` in the index name, replacing the underscore \`_\` from the index class definition

from index "Employees/ByName"

// All 'Employee' documents that contain DOCUMENT-fields 'FirstName' and\\or 'LastName' will be returned
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query index - with filtering:

<Tabs groupId='languageSyntax'>
<TabItem value="query_index_type" label="query_index_type">
<CodeBlock language="python">
{`# Query the 'Employees' collection using the index - filter by INDEX-field

employees = list(
    session
    # Pass the index class as the first parameter
    # Pass the IndexEntry class as the second parameter
    .query_index_type(Employees_ByName, Employees_ByName.IndexEntry)
    # Filter the retrieved documents by some predicate on an INDEX-field
    .where_equals("LastName", "King")
    # Specify the type of the returned document entities
    .of_type(Employee)
)

# Results will include all documents from 'Employees' collection whose 'LastName' equals to 'King'
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`# The index definition:
class Employees_ByName(AbstractIndexCreationTask):
    # The IndexEntry class defines the index-fields
    class IndexEntry:
        def __init__(self, first_name: str = None, last_name: str = None):
            self.first_name = first_name
            self.last_name = last_name

        # The from_json method to handle different casing on the server
        @classmethod
        def from_json(cls, json_dict: Dict[str, Any]) -> "Employees_ByName.IndexEntry":
            return cls(json_dict["FirstName"], json_dict["LastName"])

    def __init__(self):
        super().__init__()
        # The 'map' function defines the content of the INDEX-fields
        # * The content of INDEX-fields 'FirstName' & 'LastName'
        #   is composed of the relevant DOCUMENT-fields.
        self.map = """from e in docs.Employees select new {FirstName = e.FirstName, LastName = e.LastName}"""
        # * The index-fields can be queried on to fetch matching documents.
        #   You can query and filter Employee documents based on their first or last names.

        # * Employee documents that do Not contain both 'FirstName' and 'LastName' fields
        #   will Not be indexed.

        # * Note: the INDEX-field name does Not have to be exactly the same
        #   as the DOCUMENT-field name.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Note:
// Use slash \`/\` in the index name, replacing the underscore \`_\` from the index class definition

from index "Employees/ByName"
where LastName == "King"

// Results will include all documents from 'Employees' collection whose 'LastName' equals to 'King'.
`}
</CodeBlock>
</TabItem>
</Tabs>

* `of_type` is used to convert the type being used in the where clause (`IndexEntry`)   
  to the collection type (`Employee`).  
  The reason for this is that while the `IndexEntry` type allows for a strongly typed query,  
  the server returns the actual documents entities objects.

* An exception will be thrown when filtering by fields that are Not defined in the index.

* Read more about filtering [here](../../indexes/querying/filtering.mdx).
#### Query index - with paging:

<Tabs groupId='languageSyntax'>
<TabItem value="query_index_type" label="query_index_type">
<CodeBlock language="python">
{`# Query the 'Employees' collection using the index - page results

# This example is based on the previous filtering example
employees = list(
    session.query_index_type(Employees_ByName, Employees_ByName.IndexEntry)
    .where_equals("LastName", "King")
    .skip(5)  # Skip first 5 results
    .take(10)  # Retrieve up to 10 documents
    .of_type(Employee)
)

# Results will include up to 10 matching documents
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`# The index definition:
class Employees_ByName(AbstractIndexCreationTask):
    # The IndexEntry class defines the index-fields
    class IndexEntry:
        def __init__(self, first_name: str = None, last_name: str = None):
            self.first_name = first_name
            self.last_name = last_name

        # The from_json method to handle different casing on the server
        @classmethod
        def from_json(cls, json_dict: Dict[str, Any]) -> "Employees_ByName.IndexEntry":
            return cls(json_dict["FirstName"], json_dict["LastName"])

    def __init__(self):
        super().__init__()
        # The 'map' function defines the content of the INDEX-fields
        # * The content of INDEX-fields 'FirstName' & 'LastName'
        #   is composed of the relevant DOCUMENT-fields.
        self.map = """from e in docs.Employees select new {FirstName = e.FirstName, LastName = e.LastName}"""
        # * The index-fields can be queried on to fetch matching documents.
        #   You can query and filter Employee documents based on their first or last names.

        # * Employee documents that do Not contain both 'FirstName' and 'LastName' fields
        #   will Not be indexed.

        # * Note: the INDEX-field name does Not have to be exactly the same
        #   as the DOCUMENT-field name.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Note:
// Use slash \`/\` in the index name, replacing the underscore \`_\` from the index class definition

from index "Employees/ByName"
where LastName == "King"
limit 5, 10 // skip 5, take 10
`}
</CodeBlock>
</TabItem>
</Tabs>

* Read more about paging [here](../../indexes/querying/paging.mdx).



## Query an index by `raw_query`

* Queries defined with [Query](../../indexes/querying/query-index.mdx#sessionquery) 
  or [DocumentQuery](../../indexes/querying/query-index.mdx#sessionadvanceddocumentquery) 
  are translated by the RavenDB client to [RQL](../../client-api/session/querying/what-is-rql.mdx)  
  when sent to the server.

* The session also gives you a way to express the query directly in RQL using the 
  `session.advanced.raw_query` method.

**Example**:

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
<CodeBlock language="python">
{`# Query with RawQuery - filter by INDEX-field

employees = list(
    session.advanced
    # Provide RQL to raw_query
    .raw_query("from index 'Employees/ByName' where LastName == 'King'", Employee)
)
# Results will include all documents from 'Employees' collection whose 'LastName' equals to 'King'.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`# The index definition:
class Employees_ByName(AbstractIndexCreationTask):
    # The IndexEntry class defines the index-fields
    class IndexEntry:
        def __init__(self, first_name: str = None, last_name: str = None):
            self.first_name = first_name
            self.last_name = last_name

        # The from_json method to handle different casing on the server
        @classmethod
        def from_json(cls, json_dict: Dict[str, Any]) -> "Employees_ByName.IndexEntry":
            return cls(json_dict["FirstName"], json_dict["LastName"])

    def __init__(self):
        super().__init__()
        # The 'map' function defines the content of the INDEX-fields
        # * The content of INDEX-fields 'FirstName' & 'LastName'
        #   is composed of the relevant DOCUMENT-fields.
        self.map = """from e in docs.Employees select new {FirstName = e.FirstName, LastName = e.LastName}"""
        # * The index-fields can be queried on to fetch matching documents.
        #   You can query and filter Employee documents based on their first or last names.

        # * Employee documents that do Not contain both 'FirstName' and 'LastName' fields
        #   will Not be indexed.

        # * Note: the INDEX-field name does Not have to be exactly the same
        #   as the DOCUMENT-field name.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Note:
// Use slash \`/\` in the index name, replacing the underscore \`_\` from the index class definition

from index "Employees/ByName"
where LastName == "King"
`}
</CodeBlock>
</TabItem>
</Tabs>




