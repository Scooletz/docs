---
title: "Indexes: Storing Data in Index"
sidebar_label: Storing Data in Index
sidebar_position: 26
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Indexes: Storing Data in Index
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

Once the [tokenization and analysis](../indexes/using-analyzers) process is completed, 
the resulting tokens created by the used analyzer are stored in the index.  
By default, tokens saved in the index are available for searching, but their original 
field values are not stored.  

Lucene allows you to store the original field text (before it is analyzed) as well.  

* In this page:
  * [Storing Data in Index](../indexes/storing-data-in-index#storing-data-in-index)

</Admonition>

## Storing Data in Index

Lucene's original field text storage feature is exposed in the index definition object as 
the `Storage` property of the `IndexFieldOptions`.  

When the original values are stored in the index, they become available for retrieval via 
[projections](../indexes/querying/projections).  

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastName()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               employee.FirstName,
                               employee.LastName
                           };

        Stores.Add(x => x.FirstName, FieldStorage.Yes);
        Stores.Add(x => x.LastName, FieldStorage.Yes);
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="csharp">
{`store
    .Maintenance
    .Send(new PutIndexesOperation(
        new IndexDefinition
        {
            Name = "Employees_ByFirstAndLastName",
            Maps =
            {
                @"from employee in docs.Employees
                  select new
                  {
                      employee.FirstName,
                      employee.LastName
                  }"
            },
            Fields = new Dictionary<string, IndexFieldOptions>
            {
                {"FirstName", new IndexFieldOptions
                              {
                                  Storage = FieldStorage.Yes
                              }
                },
                {"LastName", new IndexFieldOptions
                             {
                                Storage = FieldStorage.Yes
                             }
                }
            }
        }));
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">
The default `Storage` value for each field is `FieldStorage.No`.  
Keep in mind that storing fields will increase disk space usage.  
</Admonition>

<Admonition type="info" title="Info">
If **the projection requires only the fields that are stored**, the document will 
not be loaded from the storage and the query results will be retrieved directly from the index.  
This can increase query performance at the cost of disk space used.  
</Admonition>




</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="Note">

Once the [tokenization and analysis](../indexes/using-analyzers) process is completed, 
the resulting tokens created by the used analyzer are stored in the index.  
By default, tokens saved in the index are available for searching, but their original 
field values are not stored.  

Lucene allows you to store the original field text (before it is analyzed) as well.  

* In this page:
  * [Storing Data in Index](../indexes/storing-data-in-index#storing-data-in-index)

</Admonition>

## Storing Data in Index

Lucene's original field text storage feature is exposed in the index definition object as 
the `Storage` property of the `IndexFieldOptions`.  

When the original values are stored in the index, they become available for retrieval via 
[projections](../indexes/querying/projections).  

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="java">
{`public static class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastName() {
        map =  "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";

        store("FirstName", FieldStorage.YES);
        store("LastName", FieldStorage.YES);
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="java">
{`IndexDefinition indexDefinition = new IndexDefinition();
indexDefinition.setName("Employees_ByFirstAndLastName");
indexDefinition.setMaps(Collections.singleton("docs.Employees.Select(employee => new {" +
    "    FirstName = employee.FirstName," +
    "    LastName = employee.LastName" +
    "})"));

java.util.Map<String, IndexFieldOptions> fields = new HashMap<>();
indexDefinition.setFields(fields);

IndexFieldOptions firstNameOptions = new IndexFieldOptions();
firstNameOptions.setStorage(FieldStorage.YES);
fields.put("FirstName", firstNameOptions);

IndexFieldOptions lastNameOptions = new IndexFieldOptions();
lastNameOptions.setStorage(FieldStorage.YES);
fields.put("LastName", lastNameOptions);

store
    .maintenance()
    .send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">
The default `Storage` value for each field is `FieldStorage.NO`.  
Keep in mind that storing fields will increase disk space usage.  
</Admonition>

<Admonition type="info" title="Info">
If **the projection requires only the fields that are stored**, the document will 
not be loaded from the storage and the query results will be retrieved directly from the index.  
This can increase query performance at the cost of disk space used.  
</Admonition>




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

Once the [tokenization and analysis](../indexes/using-analyzers) process is completed, 
the resulting tokens created by the used analyzer are stored in the index.  
By default, tokens saved in the index are available for searching, but their original 
field values are not stored.  

Lucene allows you to store the original field text (before it is analyzed) as well.  

* In this page:
  * [Storing Data in Index](../indexes/storing-data-in-index#storing-data-in-index)

</Admonition>

## Storing Data in Index

Lucene's original field text storage feature is exposed in the index definition object as 
the `storage` property of the `IndexFieldOptions`.  

When the original values are stored in the index, they become available for retrieval via 
[projections](../indexes/querying/projections).  

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="python">
{`class Employees_ByFirstAndLastName(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from employee in docs.Employees select new { employee.FirstName, employee.LastName }"
        self._store("FirstName", FieldStorage.YES)
        self._store("LastName", FieldStorage.YES)
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="python">
{`store.maintenance.send(
    PutIndexesOperation(
        IndexDefinition(
            name="Employees_ByFirstAndLastName",
            maps={
                """
    from employee in docs.Employees
    select new
    {
        employee.FirstName,
        employee.LastName
    }
    """
            },
            fields={
                "FirstName": IndexFieldOptions(storage=FieldStorage.YES),
                "LastName": IndexFieldOptions(storage=FieldStorage.YES),
            },
        )
    )
)
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">
The default `storage` value for each field is `FieldStorage.NO`.  
Keep in mind that storing fields will increase disk space usage.  
</Admonition>

<Admonition type="info" title="Info">
If **the projection requires only the fields that are stored**, the document will 
not be loaded from the storage and the query results will be retrieved directly from the index.  
This can increase query performance at the cost of disk space used.  
</Admonition>




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

Once the [tokenization and analysis](../indexes/using-analyzers) process is completed, 
the resulting tokens created by the used analyzer are stored in the index.  
By default, tokens saved in the index are available for searching, but their original 
field values are not stored.  

Lucene allows you to store the original field text (before it is analyzed) as well.  

* In this page:
  * [Storing Data in Index](../indexes/storing-data-in-index#storing-data-in-index)

</Admonition>

## Storing Data in Index

Lucene's original field text storage feature is exposed in the index definition object as 
the `storage` property of the `IndexFieldOptions`.  

When the original values are stored in the index, they become available for retrieval via 
[projections](../indexes/querying/projections).  

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="php">
{`class Employees_ByFirstAndLastName extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =  "docs.Employees.Select(employee => new {" .
            "    FirstName = employee.FirstName," .
            "    LastName = employee.LastName" .
            "})";

        $this->store('FirstName', FieldStorage::yes());
        $this->store('LastName', FieldStorage::yes());
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="php">
{`$indexDefinition = new IndexDefinition();
$indexDefinition->setName("Employees_ByFirstAndLastName");
$indexDefinition->setMaps([
    "docs.Employees.Select(employee => new {" .
    "    FirstName = employee.FirstName," .
    "    LastName = employee.LastName" .
    "})"
]);

$fields = [];

$firstNameOptions = new IndexFieldOptions();
$firstNameOptions->setStorage(FieldStorage::yes());
$fields['FirstName'] = $firstNameOptions;

$lastNameOptions = new IndexFieldOptions();
$lastNameOptions->setStorage(FieldStorage::yes());
$fields['LastName'] = $lastNameOptions;

$indexDefinition->setFields($fields);

$store->maintenance()->send(new PutIndexesOperation($indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">
The default `storage` value for each field is `FieldStorage.NO`.  
Keep in mind that storing fields will increase disk space usage.  
</Admonition>

<Admonition type="info" title="Info">
If **the projection requires only the fields that are stored**, the document will 
not be loaded from the storage and the query results will be retrieved directly from the index.  
This can increase query performance at the cost of disk space used.  
</Admonition>




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

Once the [tokenization and analysis](../indexes/using-analyzers) process is completed, 
the resulting tokens created by the used analyzer are stored in the index.  
By default, tokens saved in the index are available for searching, but their original 
field values are not stored.  

Lucene allows you to store the original field text (before it is analyzed) as well.  

* In this page:
  * [Storing Data in Index](../indexes/storing-data-in-index#storing-data-in-index)

</Admonition>

## Storing Data in Index

Lucene's original field text storage feature is exposed in the index definition object as 
the `Storage` property of the `IndexFieldOptions`.  

When the original values are stored in the index, they become available for retrieval via 
[projections](../indexes/querying/projections).  

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="nodejs">
{`class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    constructor() {
        super();
        
        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            LastName = employee.LastName
        })\`;

        this.store("FirstName", "Yes");
        this.store("LastName", "Yes");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="nodejs">
{`const indexDefinition = new IndexDefinition();
indexDefinition.name = "Employees_ByFirstAndLastName";
indexDefinition.maps = new Set([
    "docs.Employees.Select(employee => new {" +
    "    FirstName = employee.FirstName," +
    "    LastName = employee.LastName" +
    "})"
]);
indexDefinition.fields = {
    "FirstName": { storage: "Yes" },
    "LastName": { storage: "Yes" }
};

await store.maintenance.send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Info">
The default `Storage` value for each field is `"No"`.  
Keep in mind that storing fields will increase disk space usage.  
</Admonition>

<Admonition type="info" title="Info">
If **the projection requires only the fields that are stored**, the document will 
not be loaded from the storage and the query results will be retrieved directly from the index.  
This can increase query performance at the cost of disk space used.  
</Admonition>




</LanguageContent>

<!---
### Indexes
- [Boosting](../indexes/boosting)
- [Analyzers](../indexes/using-analyzers)
- [Term Vectors](../indexes/using-term-vectors)
- [Dynamic Fields](../indexes/using-dynamic-fields)

### Querying
- [Projections and Stored Fields](../indexes/querying/projections#projections-and-stored-fields)


-->