---
title: "Session: Querying: How to Project Query Results"
hide_table_of_contents: true
sidebar_label: Project Query Results
sidebar_position: 6
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Session: Querying: How to Project Query Results
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Instead of pulling full documents in query results you can just grab some pieces of data from documents. You can also transform the projected
results. The projections are defined in LINQ with the usage of:

- [Select](../../../client-api/session/querying/how-to-project-query-results.mdx#select)  
- [SelectFields](../../../client-api/session/querying/how-to-project-query-results.mdx#selectfields)  
- [ProjectInto](../../../client-api/session/querying/how-to-project-query-results.mdx#projectinto)  
- [OfType (As)](../../../client-api/session/querying/how-to-project-query-results.mdx#oftype-(as)---simple-projection)  

## Select

The most common way to perform a query with projection is to use the `Select` method. You can specify what fields from a document you want to retrieve and even provide complex expression.

### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// request Name, City and Country for all entities from 'Companies' collection
var results = session
    .Query<Company>()
    .Select(x => new
    {
        Name = x.Name,
        City = x.Address.City,
        Country = x.Address.Country
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// request Name, City and Country for all entities from 'Companies' collection
var results = await asyncSession
    .Query<Company>()
    .Select(x => new
    {
        Name = x.Name,
        City = x.Address.City,
        Country = x.Address.Country
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Companies
select Name, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = session
    .Query<Order>()
    .Select(x => new
    {
        ShipTo = x.ShipTo,
        Products = x.Lines.Select(y => y.ProductName),
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await asyncSession
    .Query<Order>()
    .Select(x => new
    {
        ShipTo = x.ShipTo,
        Products = x.Lines.Select(y => y.ProductName),
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders
select ShipTo, Lines[].ProductName as Products
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = (from e in session.Query<Employee>()
               select new
               {
                   FullName = e.FirstName + " " + e.LastName,
               }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await (from e in asyncSession.Query<Employee>()
                     select new
                     {
                         FullName = e.FirstName + " " + e.LastName,
                     }).ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e
select {
    FullName : e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IV - Projection with `let`

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = (from e in session.Query<Employee>()
               let format = (Func<Employee, string>)(p => p.FirstName + " " + p.LastName)
               select new
               {
                   FullName = format(e)
               }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await (from e in asyncSession.Query<Employee>()
                     let format = (Func<Employee, string>)(p => p.FirstName + " " + p.LastName)
                     select new
                     {
                         FullName = format(e)
                     }).ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from Employees as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example V - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = session
    .Query<Order>()
    .Select(x => new
    {
        Total = x.Lines.Sum(l => l.PricePerUnit * l.Quantity),
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await asyncSession
    .Query<Order>()
    .Select(x => new
    {
        Total = x.Lines.Sum(l => l.PricePerUnit * l.Quantity),
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VI - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = (from o in session.Query<Order>()
               let c = RavenQuery.Load<Company>(o.Company)
               select new
               {
                   CompanyName = c.Name,
                   ShippedAt = o.ShippedAt
               }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = (from o in asyncSession.Query<Order>()
               let c = RavenQuery.Load<Company>(o.Company)
               select new
               {
                   CompanyName = c.Name,
                   ShippedAt = o.ShippedAt
               }).ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VII - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = session
    .Query<Employee>()
    .Select(e => new
    {
        DayOfBirth = e.Birthday.Day,
        MonthOfBirth = e.Birthday.Month,
        Age = DateTime.Today.Year - e.Birthday.Year
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await asyncSession
    .Query<Employee>()
    .Select(e => new
    {
        DayOfBirth = e.Birthday.Day,
        MonthOfBirth = e.Birthday.Month,
        Age = DateTime.Today.Year - e.Birthday.Year
    })
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VIII - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = from e in session.Query<Employee>()
              select new
              {
                  Date = RavenQuery.Raw<DateTime>("new Date(Date.parse(e.Birthday))"),
                  Name = RavenQuery.Raw(e.FirstName, "substr(0,3)"),
              };
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await (from e in asyncSession.Query<Employee>()
                     select new
                     {
                         Date = RavenQuery.Raw<DateTime>("new Date(Date.parse(e.Birthday))"),
                         Name = RavenQuery.Raw(e.FirstName, "substr(0,3)"),
                     }).ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IX - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = (from e in session.Query<Employee>()
               select new
               {
                   Name = e.FirstName,
                   Metadata = RavenQuery.Metadata(e),
               }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await (from e in asyncSession.Query<Employee>()
                     select new
                     {
                         Name = e.FirstName,
                         Metadata = RavenQuery.Metadata(e),
                     }).ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## SelectFields

The `SelectFields` method can only be used with the [Document Query](../../../client-api/session/querying/document-query/what-is-document-query.mdx). 
It has two overloads:

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`// 1) By array of fields
IDocumentQuery<TProjection> SelectFields<TProjection>(params string[] fields);
// 2) By projection type
IDocumentQuery<TProjection> SelectFields<TProjection>();
`}
</CodeBlock>
</TabItem>

1) The fields of the projection are specified as a `string` array of field names. It also takes the type of the projection as 
a generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var fields = new string[]{
    "Name",
    "Phone"
};

var results = session
    .Advanced
    .DocumentQuery<Company, Companies_ByContact>()
    .SelectFields<ContactDetails>(fields)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var fields = new string[]{
    "Name",
    "Phone"
};

var results = await asyncSession
    .Advanced
    .AsyncDocumentQuery<Company, Companies_ByContact>()
    .SelectFields<ContactDetails>(fields)
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Companies_ByContact : AbstractIndexCreationTask<Company>
{
    public Companies_ByContact()
    {
        Map = companies => companies
            .Select(x => new
            {
                Name = x.Contact.Name,
                x.Phone
            });

        StoreAllFields(FieldStorage.Yes); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class ContactDetails
{
    public string Name { get; set; }

    public string Phone { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>

2) The projection is defined by simply passing the projection type as the generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = session
    .Advanced
    .DocumentQuery<Company, Companies_ByContact>()
    .SelectFields<ContactDetails>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await asyncSession
    .Advanced
    .AsyncDocumentQuery<Company, Companies_ByContact>()
    .SelectFields<ContactDetails>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Companies_ByContact : AbstractIndexCreationTask<Company>
{
    public Companies_ByContact()
    {
        Map = companies => companies
            .Select(x => new
            {
                Name = x.Contact.Name,
                x.Phone
            });

        StoreAllFields(FieldStorage.Yes); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class ContactDetails
{
    public string Name { get; set; }

    public string Phone { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>



## ProjectInto

This extension method retrieves all public fields and properties of the type given in generic and uses them to perform projection to the requested type.
You can use this method instead of using `Select` together with all fields of the projection class.

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`var results = session.Query<Company, Companies_ByContact>()
    .ProjectInto<ContactDetails>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`var results = await asyncSession.Query<Company, Companies_ByContact>()
    .ProjectInto<ContactDetails>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_2" label="RQL_2">
<CodeBlock language="csharp">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Companies_ByContact : AbstractIndexCreationTask<Company>
{
    public Companies_ByContact()
    {
        Map = companies => companies
            .Select(x => new
            {
                Name = x.Contact.Name,
                x.Phone
            });

        StoreAllFields(FieldStorage.Yes); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>

</Tabs>



## OfType (As) - simple projection

`OfType` or `As` is a client-side projection. The easiest explanation of how it works is to take the results that the server returns and map them to given type. This may become useful when querying an index that contains fields that are not available in mapped type.

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// query index 'Products_BySupplierName' 
// return documents from collection 'Products' that have a supplier 'Norske Meierier'
// project them to 'Products'
List<Product> results = session
    .Query<Products_BySupplierName.Result, Products_BySupplierName>()
    .Where(x => x.Name == "Norske Meierier")
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// query index 'Products_BySupplierName' 
// return documents from collection 'Products' that have a supplier 'Norske Meierier'
// project them to 'Products'
List<Product> results = await asyncSession
    .Query<Products_BySupplierName.Result, Products_BySupplierName>()
    .Where(x => x.Name == "Norske Meierier")
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Products_BySupplierName : AbstractIndexCreationTask<Product>
{
    public class Result
    {
        public string Name { get; set; }
    }

    public Products_BySupplierName()
    {
        Map =
            products =>
                from product in products
                let supplier = LoadDocument<Supplier>(product.Supplier)
                select new
                {
                    Name = supplier.Name
                };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>



<Admonition type="note" title="">
Projected entities (even named types) are not tracked by the session.
</Admonition>

<Admonition type="note" title="">
If the projected fields are stored inside the index itself (`FieldStorage.Yes` in the index definition), then the query results will be created directly from there instead of retrieving documents in order to project.
</Admonition>


</LanguageContent>
<LanguageContent language="java">


Instead of pulling full documents in query results you can just grab some pieces of data from documents. You can also transform the projected
results. The projections are defined with the usage of:

- [SelectFields](../../../client-api/session/querying/how-to-project-query-results.mdx#selectfields)
- [OfType](../../../client-api/session/querying/how-to-project-query-results.mdx#oftype---simple-projection)

## SelectFields

The most common way to perform a query with projection is to use the `selectFields` method. You can specify what fields from a document you want to retrieve.

### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`// request name, city and country for all entities from 'Companies' collection
QueryData queryData = new QueryData(
    new String[] { "Name", "Address.city", "Address.country"},
    new String[] { "Name", "City", "Country"});
List<NameCityAndCountry> results = session
    .query(Company.class)
    .selectFields(NameCityAndCountry.class, queryData)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Companies
select Name, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`QueryData queryData = new QueryData(new String[]{ "ShipTo", "Lines[].ProductName" },
    new String[]{"ShipTo", "Products"});

List<ShipToAndProducts> results = session.query(Order.class)
    .selectFields(ShipToAndProducts.class, queryData)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders
select ShipTo, Lines[].ProductName as Products
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<FullName> results = session.advanced().rawQuery(FullName.class, "from Employees as e " +
    "select {" +
    "    FullName : e.FirstName + \\" \\" + e.LastName " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e
select {
    FullName : e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IV - Projection with `declared function`

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Employee> results = session.advanced().rawQuery(Employee.class, "declare function output(e) { " +
    "    var format = function(p){ return p.FirstName + \\" \\" + p.LastName; }; " +
    "    return { FullName : format(e) }; " +
    "} " +
    "from Employees as e select output(e)").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from Employees as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example V - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Total> results = session.advanced().rawQuery(Total.class, "from Orders as o " +
    "select { " +
    "    Total : o.Lines.reduce( " +
    "        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0) " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VI - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<OrderProjection> results = session.advanced().rawQuery(OrderProjection.class, "from Orders as o " +
    "load o.Company as c " +
    "select { " +
    "    CompanyName: c.Name," +
    "    ShippedAt: o.ShippedAt" +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VII - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<EmployeeProjection> results = session.advanced().rawQuery(EmployeeProjection.class, "from Employees as e " +
    "select { " +
    "    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), " +
    "    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1, " +
    "    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VIII - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<EmployeeProjection> results = session.advanced().rawQuery(EmployeeProjection.class, "from Employees as e " +
    "select { " +
    "    Date : new Date(Date.parse(e.Birthday)), " +
    "    Name : e.FirstName.substr(0,3) " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IX - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<Employee> results = session.advanced().rawQuery(Employee.class, "from Employees as e " +
    "select {" +
    "     Name : e.FirstName, " +
    "     Metadata : getMetadata(e)" +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

This method overload retrieves all public fields of the class given in generic and uses them to perform projection to the requested type.
You can use this method instead of using `selectFields` together with all fields of the projection class.

### Example X

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`List<ContactDetails> results = session.query(Company.class, Companies_ByContact.class)
    .selectFields(ContactDetails.class)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="java">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`private class Companies_ByContact extends AbstractIndexCreationTask {
    public Companies_ByContact() {

        map = "from c in docs.Companies select new  { Name = c.Contact.Name, Phone = c.Phone } ";

        storeAllFields(FieldStorage.YES); // name and phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>

</Tabs>



## OfType - simple projection

`ofType` is a client-side projection. The easiest explanation of how it works is to take the results that the server returns and map them to given type. This may become useful when querying an index that contains fields that are not available in mapped type.

### Example

<TabItem value="projections_10" label="projections_10">
<CodeBlock language="java">
{`// query index 'Products_BySupplierName'
// return documents from collection 'Products' that have a supplier 'Norske Meierier'
// project them to 'Products'
List<Product> results = session.query(Products_BySupplierName.Result.class, Products_BySupplierName.class)
    .whereEquals("Name", "Norske Meierier")
    .ofType(Product.class)
    .toList();
`}
</CodeBlock>
</TabItem>



<Admonition type="note" title="">
Projected entities (even named types) are not tracked by the session.
</Admonition>

<Admonition type="note" title="">
If the projected fields are stored inside the index itself (`FieldStorage.YES` in the index definition), then the query results will be created directly from there instead of retrieving documents in order to project.
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">


Instead of pulling full documents in query results you can just grab some pieces of data from documents. You can also transform the projected
results. The projections are defined with the usage of:

- [selectFields()](../../../client-api/session/querying/how-to-project-query-results.mdx#selectfields)
- [ofType()](../../../client-api/session/querying/how-to-project-query-results.mdx#oftype)

## SelectFields()

The most common way to perform a query with projection is to use the `selectFields()` method, which let's you specify what fields from a document you want to retrieve.

### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`// request name, city and country for all entities from 'Companies' collection
const queryData = new QueryData(
    [ "Name", "Address.City", "Address.Country"],
    [ "Name", "City", "Country"]);
const results = await session
    .query({ collection: "Companies" })
    .selectFields(queryData)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Companies
select Name, Address.City as City, Address.Country as Country
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const queryData = new QueryData(
    [ "ShipTo", "Lines[].ProductName" ],
    [ "ShipTo", "Products" ]);

const results = await session.query({ collection: "Orders" })
    .selectFields(queryData)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders
select ShipTo, Lines[].ProductName as Products
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(
    \`from Employees as e select {
        FullName: e.FirstName + " " + e.LastName 
    }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e
select {
    fullName : e.FirstName + " " + e.LastName
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IV - Projection with `declared function`

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(
        \`declare function output(e) { 
            var format = function(p){ return p.FirstName + " " + p.LastName; }; 
            return { FullName : format(e) }; 
        } 
        from Employees as e select output(e)\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from Employees as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example V - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(\`from Orders as o select { 
        Total : o.Lines.reduce( 
            (acc , l) => 
                acc += l.PricePerUnit * l.Quantity, 0) 
    }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VI - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(\`from Orders as o 
    load o.Company as c 
    select { 
        CompanyName: c.Name,
        ShippedAt: o.ShippedAt
    }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VII - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(
        \`from Employees as e 
        select { 
            DayOfBirth: new Date(Date.parse(e.Birthday)).getDate(), 
            MonthOfBirth: new Date(Date.parse(e.Birthday)).getMonth() + 1, 
            Age: new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
        }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VIII - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = session.advanced
    .rawQuery(
        \`from Employees as e 
        select { 
            Date : new Date(Date.parse(e.Birthday)), 
            Name : e.FirstName.substr(0,3) 
        }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IX - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(
        \`from Employees as e 
        select {
             Name : e.FirstName, 
             Metadata : getMetadata(e)
        }\`)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Employees as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example X

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const results = await session.query({ indexName: "Companies/ByContact" })
    .selectFields([ "Name", "Phone" ])
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="js">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>

</Tabs>



## OfType

`ofType()` is a client-side projection - in JS it only sets the type of the result entries. The easiest explanation of how it works is to take the results that the server returns and assign them to instance of the type indicated by the parameter.

### Example

<TabItem value="projections_10" label="projections_10">
<CodeBlock language="js">
{`// For example - Create a document with nested objects: 
// ====================================================

class User \{
    constructor(firstName, lastName, jobDetails, lastLogin) \{
        this.firstName = firstName;
        this.lastName = lastName;
        this.jobDetails = jobDetails
        this.lastLogin = lastLogin;
    \}
\}

class Job \{
    constructor(company, title) \{
        this.company = company;
        this.title = title;
    \}
\}

const job = new Job("RavenDB", "CEO");
const user = new User("Ayende", "Rahien", job, new Date(2023, 11, 12));

await session.store(user, "users/1");
await session.saveChanges();

// Query the users collecions:
// ===========================

class Projection \{
    constructor(jobDetails, lastLogin) \{
        this.jobDetails = jobDetails;
        this.lastLogin = lastLogin;
    \}
\}

const projectedResults = await session.query(\{ collection: "users" \})
     // Project selected fields:
    .selectFields(["jobDetails", "lastLogin"], Projection)
    .all();
`}
</CodeBlock>
</TabItem>



<Admonition type="note" title="">
Projected entities (even named types) are not tracked by the session.
</Admonition>

<Admonition type="note" title="">
If the projected fields are stored inside the index itself (`"Yes"` in the index definition), then the query results will be created directly from there instead of retrieving documents in order to project.
</Admonition>


</LanguageContent>

<!---
### Session
- [How to Query](../../../client-api/session/querying/how-to-query)
- [How to Stream Query Results](../../../client-api/session/querying/how-to-stream-query-results)

### Querying
- [Basics](../../../indexes/querying/basics)
- [Projections](../../../indexes/querying/projections)

### Server
- [JavaScript Engine](../../../server/kb/javascript-engine)


-->