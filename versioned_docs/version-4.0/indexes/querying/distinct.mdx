---
title: "Query for distinct results"
hide_table_of_contents: true
sidebar_label: Distinct
sidebar_position: 6
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Query for distinct results
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

* The `Distinct` method allows you to remove duplicates from query results.  
  Items are compared based on the fields listed in the `select` section of the query. 

* In this page:
   * [Sample query with Distinct](../../indexes/querying/distinct.mdx#sample-query-with-distinct)
   * [Paging with Distinct](../../indexes/querying/distinct.mdx#paging-with-distinct)
   * [Count with Distinct](../../indexes/querying/distinct.mdx#count-with-distinct)
      * [Performance cost and alternative approaches](../../indexes/querying/distinct.mdx#performance-cost-and-alternative-approaches)

</Admonition>
## Sample query with Distinct

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Get a sorted list without duplicates:
// =====================================

List<string> countries = session
    .Query<Order>()
    .OrderBy(x => x.ShipTo.Country)
    .Select(x => x.ShipTo.Country)
     // Call 'Distinct' to remove duplicates from results
     // Items wil be compared based on field 'Country' that is specified in the above 'Select' 
    .Distinct()
    .ToList();

// Running this on the Northwind sample data
// will result in a sorted list of 21 countries w/o duplicates.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Get a sorted list without duplicates:
// =====================================

List<string> countries = await asyncSession
    .Query<Order>()
    .OrderBy(x => x.ShipTo.Country)
    .Select(x => x.ShipTo.Country)
     // Call 'Distinct' to remove duplicates from results
     // Items wil be compared based on field 'Country' that is specified in the above 'Select' 
    .Distinct()
    .ToListAsync();

// Running this on the Northwind sample data
// will result in a sorted list of 21 countries w/o duplicates.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Get a sorted list without duplicates:
// =====================================

IList<string> countries = session
    .Advanced
    .DocumentQuery<Order>()
    .OrderBy(x => x.ShipTo.Country)
    .SelectFields<string>("ShipTo.Country")
     // Call 'Distinct' to remove duplicates from results
     // Items wil be compared based on field 'Country' that is specified in the above 'SelectFields' 
    .Distinct()
    .ToList();

// Running this on the Northwind sample data
// will result in a sorted list of 21 countries w/o duplicates.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
order by ShipTo.Country
select distinct ShipTo.Country
`}
</CodeBlock>
</TabItem>
</Tabs>

 

## Paging with Distinct

A special approach must be used when calling `Distinct()` while paging.  
Please read the dedicated article about [paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results).  



## Count with Distinct

Use `Count()` in combination with `Distinct()` to get the number of unique items.  
Similar to _ToList()_, _Count()_ triggers query execution on the server-side.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Count the number of unique countries:
// =====================================

var numberOfCountries = session
    .Query<Order>()
    .Select(x => x.ShipTo.Country)
    .Distinct()
    .Count();

// Running this on the Northwind sample data,
// will result in 21, which is the number of unique countries.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Count the number of unique countries:
// =====================================

var numberOfCountries = await asyncSession
    .Query<Order>()
    .Select(x => x.ShipTo.Country)
    .Distinct()
    .CountAsync();

// Running this on the Northwind sample data,
// will result in 21, which is the number of unique countries.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Count the number of unique countries:
// =====================================

var numberOfCountries = session
    .Advanced
    .DocumentQuery<Order>()
    .SelectFields<string>("ShipTo.Country")
    .Distinct()
    .Count();

// Running this on the Northwind sample data,
// will result in 21, which is the number of unique countries.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// This RQL is intended for use when issuing a Raw Query from the client API.
// Running directly from the Studio will not display the number of results.
// ========================================================================

from "Orders"
select distinct ShipTo.Country
limit 0, 0
`}
</CodeBlock>
</TabItem>
</Tabs>

### Performance cost and alternative approaches

* Please keep in mind that using `Count()` with `Distinct()` might not be efficient for large sets of data  
  as it requires scanning all index results to find unique values.

* Getting the distinct items' count can also be achieved by creating a [Map-Reduce](../../indexes/map-reduce-indexes.mdx) index 
  that will aggregate data by the field for which distinct count results are needed.

* Using a Map-Reduce index is more efficient since computations are done during indexing time and not at query time. 
  The entire dataset is [indexed](../../indexes/creating-and-deploying.mdx) once, 
  whereafter the aggregated value is always kept up to date as indexing will occur only for new/modified data.  

#### Map-Reduce index example:

Index definition:

<TabItem value="index" label="index">
<CodeBlock language="csharp">
{`public class Orders_ByShipToCountry : AbstractIndexCreationTask<Order, Orders_ByShipToCountry.IndexEntry>
\{
    public class IndexEntry
    \{
        public string Country \{ get; set; \}
        public int CountryCount \{ get; set; \}
    \}

    public Orders_ByShipToCountry()
    \{
        // The Map phase indexes the country listed in each order document
        // CountryCount is assigned with 1, which will be aggregated in the Reduce phase
        Map = orders => from order in orders
            select new IndexEntry
            \{
                Country = order.ShipTo.Country,
                CountryCount = 1
            \};

        // The Reduce phase will group the country results and aggregate the CountryCount
        Reduce = results => from result in results
            group result by result.Country
            into g
            select new IndexEntry
            \{
                Country = g.Key,
                CountryCount = g.Sum(x => x.CountryCount)
            \};
    \}
\}
`}
</CodeBlock>
</TabItem>

Query the index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Query the map-reduce index defined above
var queryResult = session
    .Query<Orders_ByShipToCountry.IndexEntry, Orders_ByShipToCountry>()
    .ToList();

// The resulting list contains all index-entry items where each entry represents a country. 
// The size of the list corresponds to the number of unique countries.
var numberOfUniqueCountries = queryResult.Count;
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Query the map-reduce index defined above
var queryResult = await asyncSession
    .Query<Orders_ByShipToCountry.IndexEntry, Orders_ByShipToCountry>()
    .ToListAsync();

// The resulting list contains all index-entry items where each entry represents a country. 
// The size of the list corresponds to the number of unique countries.
var numberOfUniqueCountries = queryResult.Count;
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Query the map-reduce index defined above
var queryResult = session.Advanced
    .DocumentQuery<Orders_ByShipToCountry.IndexEntry, Orders_ByShipToCountry>()
    .ToList();

// The resulting list contains all index-entry items where each entry represents a country. 
// The size of the list corresponds to the number of unique countries.
var numberOfUniqueCountries = queryResult.Count;
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByShipToCountry"
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Combining faceted queries with Map-Reduce:

Faceted queries can be used together with a map-reduce index as another alternative approach.  
See the article "[Implementing a count(distinct) query in RavenDB](https://ravendb.net/articles/implementing-a-countdistinct-query-in-ravendb)" for an example.

 


</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="">

* The `distinct` method allows you to remove duplicates from query results.  
  Items are compared based on the fields listed in the `select` section of the query. 

* In this page:
   * [Sample query with distinct](../../indexes/querying/distinct.mdx#sample-query-with-distinct)
   * [Paging with distinct](../../indexes/querying/distinct.mdx#paging-with-distinct)
   * [Count with distinct](../../indexes/querying/distinct.mdx#count-with-distinct)
      * [Performance cost and an alternative approach](../../indexes/querying/distinct.mdx#performance-cost-and-an-alternative-approach)

</Admonition>
## Sample query with Distinct

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`// Get a sorted list without duplicates:
// =====================================

List<String> countries = session
    .query(Order.class)
    .orderBy("ShipTo.Country")
    .selectFields(String.class, "ShipTo.Country")
     // Call 'distinct' to remove duplicates from results
     // Items wil be compared based on field 'Country' that is specified in the above 'selectFields' 
    .distinct()
    .toList();
    
// Running this on the Northwind sample data
// will result in a sorted list of 21 countries w/o duplicates.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
order by ShipTo.Country
select distinct ShipTo.Country
`}
</CodeBlock>
</TabItem>
</Tabs>

 

## Paging with distinct

A special approach must be used when calling `distinct()` while paging.  
Please read the dedicated article about [paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results).  



## Count with distinct

Use `count()` in combination with `distinct()` to get the number of unique items.  
Similar to _toList()_, _count()_ triggers query execution on the server-side.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`// Count the number of unique countries:
// =====================================

int numberOfCountries = session
    .query(Order.class)
    .selectFields(String.class, "ShipTo.Country")
    .distinct()
    .count();
    
// Running this on the Northwind sample data,
// will result in 21, which is the number of unique countries.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// This RQL is intended for use when issuing a Raw Query from the client API.
// Running directly from the Studio will not display the number of results.
// ========================================================================

from "Orders"
select distinct ShipTo.Country
limit 0, 0
`}
</CodeBlock>
</TabItem>
</Tabs>

### Performance cost and an alternative approach

* Please keep in mind that using `count()` with `distinct()` might not be efficient for large sets of data  
  as it requires scanning all index results to find unique values.

* Getting the distinct items' count can also be achieved by creating a [Map-Reduce](../../indexes/map-reduce-indexes.mdx) index 
  that will aggregate data by the field for which distinct count results are needed.

* Using a Map-Reduce index is more efficient since computations are done during indexing time and not at query time. 
  The entire dataset is [indexed](../../indexes/creating-and-deploying.mdx) once,
  whereafter the aggregated value is always kept up to date as indexing will occur only for new/modified data.

#### Map-Reduce index example:

Index definition:

<TabItem value="distinct_3_1" label="distinct_3_1">
<CodeBlock language="java">
{`public static class Orders_ByShipToCountry extends AbstractIndexCreationTask \{

public Orders_ByShipToCountry() \{

    // The map phase indexes the country listed in each order document
    // CountryCount is assigned with 1, which will be aggregated in the reduce phase
    map = "docs.Orders.Select(order => new \{ " +
          "    Country = order.ShipTo.Country, " +
          "    CountryCount = 1 " +
          "\})";

    // The reduce phase will group the Country results and aggregate the CountryCount
    reduce = "results.GroupBy(result => result.Country).Select(g => new \{ " +
             "    Country = g.Key, " +
             "    CountryCount = Enumerable.Sum(g, x => x.CountryCount) " +
             "\})";
\}

public static class Result \{
    private String country;
    private int countryCount;

    public String getCountry() \{
        return country;
    \}

    public void setCountry(String country) \{
        this.country = country;
    \}

    public int getCountryCount() \{
        return countryCount;
    \}

    public void setCountryCount(int countryCount) \{
        this.countryCount = countryCount;
    \}
\}
\}
`}
</CodeBlock>
</TabItem>

Query the index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`// Query the map-reduce index defined above
try (IDocumentSession session = DocumentStoreHolder.store.openSession()) {
    Orders_ByShipToCountry.Result queryResult = session
        .query(Orders_ByShipToCountry.Result.class, Orders_ByShipToCountry.class)
        .toList();

    // The resulting list contains all index-entry items where each entry represents a country. 
    // The size of the list corresponds to the number of unique countries.
    int numberOfUniqueCountries = queryResult.length;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByShipToCountry"
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Combining faceted queries with Map-Reduce:

Faceted queries can be used together with a map-reduce index as another alternative approach.  
See a C# example for [Implementing a count(distinct) query in RavenDB](https://ravendb.net/articles/implementing-a-countdistinct-query-in-ravendb).

 


</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">

* The `distinct` method allows you to remove duplicates from query results.  
  Items are compared based on the fields listed in the `select` section of the query. 

* In this page:
   * [Sample query with distinct](../../indexes/querying/distinct.mdx#sample-query-with-distinct)
   * [Paging with distinct](../../indexes/querying/distinct.mdx#paging-with-distinct)
   * [Count with distinct](../../indexes/querying/distinct.mdx#count-with-distinct)
      * [Performance cost and an alternative approach](../../indexes/querying/distinct.mdx#performance-cost-and-an-alternative-approach)

</Admonition>
## Sample query with distinct

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Get a sorted list without duplicates:
// =====================================

const countries = await session
    .query(Order)
    .orderBy("ShipTo.Country")
    .selectFields("ShipTo.Country")
     // Call 'distinct' to remove duplicates from results
     // Items wil be compared based on field 'Country' that is specified in the above 'selectFields' 
    .distinct()
    .all();

// Running this on the Northwind sample data
// will result in a sorted list of 21 countries w/o duplicates.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Orders"
order by ShipTo.Country
select distinct ShipTo.Country
`}
</CodeBlock>
</TabItem>
</Tabs>

 

## Paging with distinct

A special approach must be used when calling `distinct()` while paging.  
Please read the dedicated article about [paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results).  



## Count with distinct

Use `count()` in combination with `distinct()` to get the number of unique items.  
Similar to _toList()_, _count()_ triggers query execution on the server-side.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Count the number of unique countries:
// =====================================

const numberOfCountries = await session
    .query(Order)
    .selectFields("ShipTo.Country")
    .distinct()
    .count();

// Running this on the Northwind sample data,
// will result in 21, which is the number of unique countries.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// This RQL is intended for use when issuing a Raw Query from the client API.
// Running directly from the Studio will not display the number of results.
// ========================================================================

from "Orders"
select distinct ShipTo.Country
limit 0, 0
`}
</CodeBlock>
</TabItem>
</Tabs>

### Performance cost and an alternative approach

* Please keep in mind that using `count()` with `distinct()` might not be efficient for large sets of data  
  as it requires scanning all index results to find unique values.

* Getting the distinct items' count can also be achieved by creating a [Map-Reduce](../../indexes/map-reduce-indexes.mdx) index 
  that will aggregate data by the field for which distinct count results are needed.

* Using a Map-Reduce index is more efficient since computations are done during indexing time and not at query time. 
  The entire dataset is [indexed](../../indexes/creating-and-deploying.mdx) once,
  whereafter the aggregated value is always kept up to date as indexing will occur only for new/modified data.

#### Map-Reduce index example:#

Index definition:

<TabItem value="index" label="index">
<CodeBlock language="js">
{`class Orders_ByShipToCountry extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // The map phase indexes the country listed in each order document
        // countryCount is assigned with 1, which will be aggregated in the reduce phase
        this.map("Orders", order => \{
            return \{
                country: order.ShipTo.Country,
                countryCount: 1
            \}
        \});

        // The reduce phase will group the country results and aggregate the countryCount
        this.reduce(results => results.groupBy(x => x.country).aggregate(g => \{
            return \{
                country: g.key,
                countryCount: g.values.reduce((p, c) => p + c.countryCount, 0)
            \}
        \}));
    \}
\}
`}
</CodeBlock>
</TabItem>

Query the index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Query the map - reduce index defined above
const session = documentStore.openSession();
const queryResult = await session
    .query({ indexName: "Orders/ByShipToCountry" })
    .all();

// The resulting list contains all index-entry items where each entry represents a country. 
// The size of the list corresponds to the number of unique countries.
const numberOfUniqueCountries = queryResult.length;
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByShipToCountry"
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Combining faceted queries with Map-Reduce:

Faceted queries can be used together with a map-reduce index as another alternative approach.  
See a C# example for [Implementing a count(distinct) query in RavenDB](https://ravendb.net/articles/implementing-a-countdistinct-query-in-ravendb).

 


</LanguageContent>

<!---
### Querying
- [Paging](../../indexes/querying/paging)

### Indexing
- [Map-Reduce Indexes](../../indexes/map-reduce-indexes)

### Code Walkthrough
- [Map-Reduce Index](https://demo.ravendb.net/demos/csharp/static-indexes/map-reduce-index)
- [Paging Query Results](https://demo.ravendb.net/demos/csharp/queries/paging-query-results)


-->