---
title: "Indexes: Dynamic Fields"
hide_table_of_contents: true
sidebar_label: Dynamic Fields
sidebar_position: 28
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexes: Dynamic Fields
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


While strongly typed entities are well processed by LINQ expressions, some scenarios demand the use of dynamic properties. 

To support searching in object graphs they cannot have the entire structure declared upfront. 

RavenDB exposes an indexing API for creating fields dynamically.

With this feature, you can search for documents using fields which are created on the fly. For example, consider a `Product` object that is declared as follows:

<TabItem value="dynamic_fields_1" label="dynamic_fields_1">
<CodeBlock language="csharp">
{`public class Product
\{
    public string Id \{ get; set; \}
    
    // The KEYS under the Attributes object will be dynamically indexed 
    // Fields added to this object after index creation time will also get indexed
    public Dictionary<string, object> Attributes \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

Properties such as color or size are added only to some products, while other ones can have the weight and volume defined. Since `Attribute` has string fields, they can specify very different properties of products.
In order to query on fields which aren't known at index creation time, we introduced the ability to create them dynamically during indexing.

The following index can be created in order to index each attribute value under its name as a separate field:

<TabItem value="dynamic_fields_2" label="dynamic_fields_2">
<CodeBlock language="csharp">
{`public class Products_ByAttributeKey : AbstractIndexCreationTask<Product>
\{
    public Products_ByAttributeKey()
    \{
        Map = products => from p in products
            select new
            \{
                // Call 'CreateField' to generate dynamic-index-fields from the Attributes object keys
                // Using '_' is just a convention. Any other string can be used instead of '_'
                
                // The actual field name will be item.Key
                // The actual field terms will be derived from item.Value
                _ = p.Attributes.Select(item => CreateField(item.Key, item.Value))
            \};
    \}
\}
`}
</CodeBlock>
</TabItem>

The `_` character used as the field name in the mapping definition is just a convention. You can use any name, it won't be used by the index anyway. The actual field name
that you want to query by is defined in `CreateField(...)`. It will generate an index field based on the properties of indexed documents and passed parameters 

The index can have more fields defined, just like in any other ordinary index.

<Admonition type="info" title="Options" id="options" href="#options">
Field options like `FieldStorage` and `FieldIndexing` are configurable by arguments of the `CreateField` method:   

  * stored   
    * false (default) - `FieldStorage.No`   
    * true - `FieldStorage.Yes`   
  * analyzed   
    * null (default) - `FieldIndexing.Default`   
    * true - `FieldIndexing.Search`   
    * false - `FieldIndexing.Exact`  
</Admonition>

Looking for products by attributes with the usage of such a defined index is supported as if it were real object properties:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Product> results = session
    .Query<Products_ByAttribute.Result, Products_ByAttribute>()
    .Where(x => x.Color == "Red")
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Product> results = session
    .Advanced
    .DocumentQuery<Product, Products_ByAttribute>()
    .WhereEquals("Color", "Red")
    .ToList();
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="">
All types of values are supported by dynamically created fields. They can be numbers, dates, etc.
</Admonition>


</LanguageContent>
<LanguageContent language="java">


To support searching in object graphs they cannot have the entire structure declared upfront. 

RavenDB exposes an indexing API for creating fields dynamically.

With this feature, you can search for documents using fields which are created on the fly. For example, consider a `Product` object that is declared as follows:

<TabItem value="dynamic_fields_1" label="dynamic_fields_1">
<CodeBlock language="java">
{`public class Product \{
    private String id;

    // The KEYS under the attributes object will be dynamically indexed
    // Fields added to this object after index creation time will also get indexed
    private Dictionary<String, Object> attributes;

    // get + set implementation ...
\}
`}
</CodeBlock>
</TabItem>

Properties such as color or size are added only to some products, while other ones can have the weight and volume defined. Since `Attribute` has string fields, they can specify very different properties of products.
In order to query on fields which aren't known at index creation time, we introduced the ability to create them dynamically during indexing.

The following index can be created in order to index each attribute value under its name as a separate field:

<TabItem value="dynamic_fields_2" label="dynamic_fields_2">
<CodeBlock language="java">
{`_JS
        public class Products_ByAttributeKey_JS extends AbstractJavaScriptIndexCreationTask \{
            public Products_ByAttributeKey_JS() \{
                // Call 'createField' to generate dynamic-index-fields from the attributes object keys
                // Using '_' is just a convention. Any other string can be used instead of '_'

                // The actual field name will be the key
                // The actual field terms will be derived from p.attributes[key]
                setMaps(Sets.newHashSet(
                    "map('Products', function (p) \{ " +
                    "    return \{ " +
                    "        _: Object.keys(p.attributes).map(key => createField(key, p.attributes[key], " +
                    "            \{ indexing: 'Search', storage: false, termVector: null \})) " +
                    "    \}; " +
                    "\}) "
                ));
            \}
        \}
`}
</CodeBlock>
</TabItem>

The `_` character used as the field name in the mapping definition is just a convention. You can use any name, it won't be used by the index anyway. The actual field name
that you want to query by is defined in `CreateField(...)`. It will generate an index field based on the properties of indexed documents and passed parameters 

The index can have more fields defined, just like in any other ordinary index.

<Admonition type="info" title="Options" id="options" href="#options">
Field options like `FieldStorage` and `FieldIndexing` are configurable by arguments of the `CreateField` method:   

  * stored   
    * false (default) - `FieldStorage.No`   
    * true - `FieldStorage.Yes`   
  * analyzed   
    * null (default) - `FieldIndexing.Default`   
    * true - `FieldIndexing.Search`   
    * false - `FieldIndexing.Exact`  
</Admonition>

Looking for products by attributes with the usage of such a defined index is supported as if it were real object properties:

<TabItem value="dynamic_fields_4" label="dynamic_fields_4">
<CodeBlock language="java">
{`public class Product \{
    private String id;

    // All KEYS in the document will be dynamically indexed
    // Fields added to the document after index creation time will also get indexed
    private String firstName;
    private String lastName;
    private String title;
    // ...

    // get + set implementation ...
\}
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="">
All types of values are supported by dynamically created fields. They can be numbers, dates, etc.
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">


To support searching in object graphs they cannot have the entire structure declared upfront. 

RavenDB exposes an indexing API for creating fields dynamically.

With this feature, you can search for documents using fields which are created on the fly. For example, consider a `Product` object that is declared as follows:

<TabItem value="dynamic_fields_1" label="dynamic_fields_1">
<CodeBlock language="js">
{`class Product \{
    constructor(id, attributes) \{
        this.id = id;

        // The KEYS under the attributes object will be dynamically indexed 
        // Fields added to this object after index creation time will also get indexed
        this.attributes = attributes;
    \}
\}
`}
</CodeBlock>
</TabItem>

Properties such as color or size are added only to some products, while other ones can have the weight and volume defined. Since `Attribute` has string fields, they can specify very different properties of products.
In order to query on fields which aren't known at index creation time, we introduced the ability to create them dynamically during indexing.

The following index can be created in order to index each attribute value under its name as a separate field:

<TabItem value="dynamic_fields_2" label="dynamic_fields_2">
<CodeBlock language="js">
{`_JS
    class Products_ByAttributeKey_JS extends AbstractJavaScriptIndexCreationTask \{
        constructor() \{
            super();

            const \{ createField \} = this.mapUtils();

            this.map("Products", p => \{
                return \{
                    // Call 'createField' to generate dynamic-index-fields from the attributes object keys
                    // Using '_' is just a convention. Any other string can be used instead of '_'

                    // The actual field name will be the key
                    // The actual field terms will be derived from p.attributes[key]
                    _: Object.keys(p.attributes).map(key => createField(key, p.attributes[key], \{
                        indexing: "Search",
                        storage: false,
                        termVector: null
                    \}))
                \};
            \});
        \}
    \}
`}
</CodeBlock>
</TabItem>

The `_` character used as the field name in the mapping definition is just a convention. You can use any name, it won't be used by the index anyway. The actual field name
that you want to query by is defined in `CreateField(...)`. It will generate an index field based on the properties of indexed documents and passed parameters 

The index can have more fields defined, just like in any other ordinary index.

<Admonition type="info" title="Options" id="options" href="#options">
Field options like `FieldStorage` and `FieldIndexing` are configurable by arguments of the `CreateField` method:   

  * stored   
    * false (default) - `FieldStorage.No`   
    * true - `FieldStorage.Yes`   
  * analyzed   
    * null (default) - `FieldIndexing.Default`   
    * true - `FieldIndexing.Search`   
    * false - `FieldIndexing.Exact`  
</Admonition>

Looking for products by attributes with the usage of such a defined index is supported as if it were real object properties:

<TabItem value="dynamic_fields_4" label="dynamic_fields_4">
<CodeBlock language="js">
{`class Product \{
    constructor(id, firstName, lastName, title) \{
        this.id = id;

        // All KEYS in the document will be dynamically indexed 
        // Fields added to the document after index creation time will also get indexed
        this.firstName = firstName;
        this.lastName = lastName;
        this.title = title;
        // ...
    \}
\}
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="">
All types of values are supported by dynamically created fields. They can be numbers, dates, etc.
</Admonition>


</LanguageContent>

<!---
### Indexes
- [Boosting](../indexes/boosting)
- [Analyzers](../indexes/using-analyzers)
- [Storing Data in Index](../indexes/storing-data-in-index)
- [Term Vectors](../indexes/using-term-vectors)


-->