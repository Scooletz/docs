---
title: "Indexes: Multi-Map Indexes"
hide_table_of_contents: true
sidebar_label: Multi-Map Indexes
sidebar_position: 6
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexes: Multi-Map Indexes
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Multi-Map indexes allow you to index data from multiple collections e.g. polymorphic data (check the [example](../indexes/indexing-polymorphic-data.mdx)) or any common data between types.

## AddMap & AddMapForAll

`AddMap` method is used to map fields from a single collection e.g. `Dogs`. `AddMapForAll` gives you the ability to specify what fields will be indexed from a base class. 

Let's assume that we have `Dog` and `Cat` classes, and both of them inherit from the class `Animal`:

<Tabs groupId='languageSyntax'>
<TabItem value="Dog" label="Dog">
<CodeBlock language="csharp">
{`public class Dog : Animal
{

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Cat" label="Cat">
<CodeBlock language="csharp">
{`public class Cat : Animal
{

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Animal" label="Animal">
<CodeBlock language="csharp">
{`public abstract class Animal : IAnimal
{
    public string Name { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IAnimal" label="IAnimal">
<CodeBlock language="csharp">
{`public interface IAnimal
{
    string Name { get; set; }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we can define our index using `AddMap` or `AddMapForAll` in the following way:

<Tabs groupId='languageSyntax'>
<TabItem value="AddMap" label="AddMap">
<CodeBlock language="csharp">
{`public class Animals_ByName : AbstractMultiMapIndexCreationTask
{
    public Animals_ByName()
    {
        AddMap<Cat>(cats => from c in cats select new { c.Name });

        AddMap<Dog>(dogs => from d in dogs select new { d.Name });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="AddMapForAll" label="AddMapForAll">
<CodeBlock language="csharp">
{`public class Animals_ByName_ForAll : AbstractMultiMapIndexCreationTask
{
    public Animals_ByName_ForAll()
    {
        AddMapForAll<Animal>(parents => from p in parents select new { p.Name });
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<IAnimal> results = session
    .Query<IAnimal, Animals_ByName>()
    .Where(x => x.Name == "Mitzy")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<IAnimal> results = session
    .Advanced
    .DocumentQuery<IAnimal, Animals_ByName>()
    .WhereEquals(x => x.Name, "Mitzy")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Animals/ByName'
where Name = 'Mitzy'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Indexing Polymorphic Data

Please read more in our dedicated article on indexing polymorphic data. This article can be found [here](../indexes/indexing-polymorphic-data.mdx).

## Searching Across Multiple Collections

Another great application of Multi-Map indexes is smart-search. To search for products, companies, or employees by their name, you need to define the following index:

<TabItem value="multi_map_1_0" label="multi_map_1_0">
<CodeBlock language="csharp">
{`public class Smart_Search : AbstractMultiMapIndexCreationTask<Smart_Search.Result>
\{
    public class Result
    \{
        public string Id \{ get; set; \}

        public string DisplayName \{ get; set; \}

        public object Collection \{ get; set; \}

        public string[] Content \{ get; set; \}
    \}

    public class Projection
    \{
        public string Id \{ get; set; \}

        public string DisplayName \{ get; set; \}

        public string Collection \{ get; set; \}
    \}

    public Smart_Search()
    \{
        AddMap<Company>(companies => from c in companies
            select new Result
            \{
                Id = c.Id,
                Content = new[]
                \{
                    c.Name
                \},
                DisplayName = c.Name,
                Collection = MetadataFor(c)["@collection"]
            \});

        AddMap<Product>(products => from p in products
            select new Result
            \{
                Id = p.Id,
                Content = new[]
                \{
                    p.Name
                \},
                DisplayName = p.Name,
                Collection = MetadataFor(p)["@collection"]
            \});

        AddMap<Employee>(employees => from e in employees
            select new Result
            \{
                Id = e.Id,
                Content = new[]
                \{
                    e.FirstName,
                    e.LastName
                \},
                DisplayName = e.FirstName + " " + e.LastName,
                Collection = MetadataFor(e)["@collection"]
            \});

        // mark 'Content' field as analyzed which enables full text search operations
        Index(x => x.Content, FieldIndexing.Search);

        // storing fields so when projection (e.g. ProjectInto)
        // requests only those fields
        // then data will come from index only, not from storage
        Store(x => x.Id, FieldStorage.Yes);
        Store(x => x.DisplayName, FieldStorage.Yes);
        Store(x => x.Collection, FieldStorage.Yes);
    \}
\}
`}
</CodeBlock>
</TabItem>

and query it using:

<TabItem value="multi_map_1_1" label="multi_map_1_1">
<CodeBlock language="csharp">
{`IList<Smart_Search.Projection> results = session
    .Query<Smart_Search.Result, Smart_Search>()
    .Search(x => x.Content, "Lau*")
    .ProjectInto<Smart_Search.Projection>()
    .ToList();

foreach (Smart_Search.Projection result in results)
\{
    Console.WriteLine(result.Collection + ": " + result.DisplayName);
    // Companies: Laughing Bacchus Wine Cellars
    // Products: Laughing Lumberjack Lager
    // Employees: Laura Callahan
\}
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="">
Remember that all map functions **must** output objects with **identical** shape (field names have to match).
</Admonition>


</LanguageContent>
<LanguageContent language="java">


Multi-Map indexes allow you to index data from multiple collections e.g. polymorphic data (check the [example](../indexes/indexing-polymorphic-data.mdx)) or any common data between types.

## AddMap

`AddMap` method is used to map fields from a single collection e.g. `Dogs`.

Let's assume that we have `Dog` and `Cat` classes, and both of them inherit from the class `Animal`:

<Tabs groupId='languageSyntax'>
<TabItem value="Dog" label="Dog">
<CodeBlock language="java">
{`public static class Dog extends Animal {

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Cat" label="Cat">
<CodeBlock language="java">
{`public static class Cate extends Animal {

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Animal" label="Animal">
<CodeBlock language="java">
{`public abstract static class Animal implements IAnimal {
    private String name;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IAnimal" label="IAnimal">
<CodeBlock language="java">
{`public interface IAnimal {
    String getName();
    void setName(String name);
}
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we can define our index using `addMap` in the following way:

<TabItem value="multi_map_4" label="multi_map_4">
<CodeBlock language="java">
{`public static class Animals_ByName extends AbstractMultiMapIndexCreationTask \{
    public Animals_ByName() \{
        addMap( "docs.Cats.Select(c => new \{ " +
            "    Name = c.Name " +
            "\})");

        addMap( "docs.Dogs.Select(d => new \{ " +
            "    Name = d.Name " +
            "\})");
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<IAnimal> results = session
    .query(IAnimal.class, Animals_ByName.class)
    .whereEquals("Name", "Mitzy")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Animals/ByName'
where Name = 'Mitzy'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Indexing Polymorphic Data

Please read more in our dedicated article on indexing polymorphic data. This article can be found [here](../indexes/indexing-polymorphic-data.mdx).

## Searching Across Multiple Collections

Another great application of Multi-Map indexes is smart-search. To search for products, companies, or employees by their name, you need to define the following index:

<TabItem value="multi_map_1_0" label="multi_map_1_0">
<CodeBlock language="java">
{`public static class Smart_Search extends AbstractMultiMapIndexCreationTask \{
    public static class Result \{
        private String id;
        private String displayName;
        private String collection;
        private String content;

        public String getId() \{
            return id;
        \}

        public void setId(String id) \{
            this.id = id;
        \}

        public String getDisplayName() \{
            return displayName;
        \}

        public void setDisplayName(String displayName) \{
            this.displayName = displayName;
        \}

        public String getCollection() \{
            return collection;
        \}

        public void setCollection(String collection) \{
            this.collection = collection;
        \}

        public String getContent() \{
            return content;
        \}

        public void setContent(String content) \{
            this.content = content;
        \}
    \}

    public static class Projection \{
        private String id;
        private String displayName;
        private String collection;

        public String getId() \{
            return id;
        \}

        public void setId(String id) \{
            this.id = id;
        \}

        public String getDisplayName() \{
            return displayName;
        \}

        public void setDisplayName(String displayName) \{
            this.displayName = displayName;
        \}

        public String getCollection() \{
            return collection;
        \}

        public void setCollection(String collection) \{
            this.collection = collection;
        \}
    \}

    public Smart_Search() \{

        addMap("docs.Companies.Select(c => new \{ " +
            "    Id = Id(c), " +
            "    Content = new string[] \{ " +
            "        c.Name " +
            "    \}, " +
            "    DisplayName = c.Name, " +
            "    Collection = this.MetadataFor(c)[\\"@collection\\"] " +
            "\})");

        addMap("docs.Products.Select(p => new \{ " +
            "    Id = Id(p), " +
            "    Content = new string[] \{ " +
            "        p.Name " +
            "    \}, " +
            "    DisplayName = p.Name, " +
            "    Collection = this.MetadataFor(p)[\\"@collection\\"] " +
            "\})");

        addMap("docs.Employees.Select(e => new \{ " +
            "    Id = Id(e), " +
            "    Content = new string[] \{ " +
            "        e.FirstName, " +
            "        e.LastName " +
            "    \}, " +
            "    DisplayName = (e.FirstName + \\" \\") + e.LastName, " +
            "    Collection = this.MetadataFor(e)[\\"@collection\\"] " +
            "\})");

        // mark 'content' field as analyzed which enables full text search operations
        index("Content", FieldIndexing.SEARCH);

        // storing fields so when projection (e.g. ProjectInto)
        // requests only those fields
        // then data will come from index only, not from storage
        store("Id", FieldStorage.YES);
        store("DisplayName", FieldStorage.YES);
        store("Collection", FieldStorage.YES);
    \}
\}
`}
</CodeBlock>
</TabItem>

and query it using:

<TabItem value="multi_map_1_1" label="multi_map_1_1">
<CodeBlock language="java">
{`List<Smart_Search.Projection> results = session
    .query(Smart_Search.Result.class, Smart_Search.class)
    .search("Content", "Lau*")
    .selectFields(Smart_Search.Projection.class)
    .toList();

for (Smart_Search.Projection result : results) \{
    System.out.println(result.getCollection() + ": " + result.getDisplayName());
    // Companies: Laughing Bacchus Wine Cellars
    // Products: Laughing Lumberjack Lager
    // Employees: Laura Callahan
\}
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="">
Remember that all map functions **must** output objects with **identical** shape (field names have to match).
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">


Multi-Map indexes allow you to index data from multiple collections e.g. polymorphic data (check the [example](../indexes/indexing-polymorphic-data.mdx)) or any common data between types.

## AddMap

`addMap()` method is used to map fields from a single collection e.g. `Dogs`.

Let's assume that we have `Dog` and `Cat` classes, and both of them inherit from the class `Animal`:

<Tabs groupId='languageSyntax'>
<TabItem value="Dog" label="Dog">
<CodeBlock language="js">
{`class Dog extends Animal { }
`}
</CodeBlock>
</TabItem>
<TabItem value="Cat" label="Cat">
<CodeBlock language="js">
{`class Cat extends Animal { }
`}
</CodeBlock>
</TabItem>
<TabItem value="Animal" label="Animal">
<CodeBlock language="js">
{`class Animal {
    constructor(name) {
        this.name = name;
    } 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we can define our index using `addMap` in the following way:

<TabItem value="multi_map_4" label="multi_map_4">
<CodeBlock language="js">
{`class Animals_ByName extends AbstractMultiMapIndexCreationTask \{
    constructor() \{
        super();

        this.addMap(\`docs.Cats.Select(c => new \{     
            name = c.name 
        \})\`);

        this.addMap(\`docs.Dogs.Select(d => new \{     
            name = d.name 
        \})\`);
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    .query({ indexName: "Animals/ByName" })
    .whereEquals("name", "Mitzy")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Animals/ByName'
where Name = 'Mitzy'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Indexing Polymorphic Data

Please read more in our dedicated article on indexing polymorphic data. This article can be found [here](../indexes/indexing-polymorphic-data.mdx).

## Searching Across Multiple Collections

Another great application of Multi-Map indexes is smart-search. To search for products, companies, or employees by their name, you need to define the following index:

<TabItem value="multi_map_1_0" label="multi_map_1_0">
<CodeBlock language="js">
{`class Smart_Search extends AbstractMultiMapIndexCreationTask \{

    constructor() \{
        super();

        this.addMap(\`docs.Companies.Select(c => new \{     
            id = Id(c),     
            content = new string[] \{         
                c.name     
            \},     
            displayName = c.name,     
            collection = this.MetadataFor(c)["@collection"] 
        \})\`);


        this.addMap(\`docs.Products.Select(p => new \{     
            id = Id(p),     
            content = new string[] \{         
                p.name     
            \},     
            displayName = p.name,     
            collection = this.MetadataFor(p)["@collection"] 
        \})\`);

        this.addMap(\`docs.Employees.Select(e => new \{     
            id = Id(e),     
            content = new string[] \{         
                e.firstName,         
                e.lastName     
            \},     
            displayName = (e.firstName + " ") + e.lastName,     
            collection = this.MetadataFor(e)["@collection"] 
        \})\`);

        // mark 'content' field as analyzed which enables full text search operations
        this.index("content", "Search");

        // storing fields so when projection (e.g. ProjectInto)
        // requests only those fields
        // then data will come from index only, not from storage
        this.store("id", "Yes");
        this.store("displayName", "Yes");
        this.store("collection", "Yes");
    \}
\}
`}
</CodeBlock>
</TabItem>

and query it using:

<TabItem value="multi_map_1_1" label="multi_map_1_1">
<CodeBlock language="js">
{`const results = await session
    .query(\{ indexName: "Smart/Search" \})
    .search("Content", "Lau*")
    .selectFields([ "id", "displayName", "collection" ])
    .all();

for (const result of results) \{
    console.log(result.collection + ": " + result.displayName);
    // Companies: Laughing Bacchus Wine Cellars
    // Products: Laughing Lumberjack Lager
    // Employees: Laura Callahan
\}
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="">
Remember that all map functions **must** output objects with **identical** shape (field names have to match).
</Admonition>


</LanguageContent>

<!---
### Indexes
- [Map Indexes](../indexes/map-indexes)
- [Map-Reduce Indexes](../indexes/map-reduce-indexes)
- [Indexing Polymorphic Data](../indexes/indexing-polymorphic-data)

### Studio
- [Create Multi-Map Index](../studio/database/indexes/create-multi-map-index)


-->