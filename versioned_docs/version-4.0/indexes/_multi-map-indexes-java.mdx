import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

Multi-Map indexes allow you to index data from multiple collections e.g. polymorphic data (check the [example](../indexes/indexing-polymorphic-data.mdx)) or any common data between types.

## AddMap

`AddMap` method is used to map fields from a single collection e.g. `Dogs`.

Let's assume that we have `Dog` and `Cat` classes, and both of them inherit from the class `Animal`:

<Tabs groupId='languageSyntax'>
<TabItem value="Dog" label="Dog">
<CodeBlock language="java">
{`public static class Dog extends Animal {

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Cat" label="Cat">
<CodeBlock language="java">
{`public static class Cate extends Animal {

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Animal" label="Animal">
<CodeBlock language="java">
{`public abstract static class Animal implements IAnimal {
    private String name;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IAnimal" label="IAnimal">
<CodeBlock language="java">
{`public interface IAnimal {
    String getName();
    void setName(String name);
}
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we can define our index using `addMap` in the following way:

<TabItem value="multi_map_4" label="multi_map_4">
<CodeBlock language="java">
{`public static class Animals_ByName extends AbstractMultiMapIndexCreationTask \{
    public Animals_ByName() \{
        addMap( "docs.Cats.Select(c => new \{ " +
            "    Name = c.Name " +
            "\})");

        addMap( "docs.Dogs.Select(d => new \{ " +
            "    Name = d.Name " +
            "\})");
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<IAnimal> results = session
    .query(IAnimal.class, Animals_ByName.class)
    .whereEquals("Name", "Mitzy")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Animals/ByName'
where Name = 'Mitzy'
`}
</CodeBlock>
</TabItem>
</Tabs>

## Indexing Polymorphic Data

Please read more in our dedicated article on indexing polymorphic data. This article can be found [here](../indexes/indexing-polymorphic-data.mdx).

## Searching Across Multiple Collections

Another great application of Multi-Map indexes is smart-search. To search for products, companies, or employees by their name, you need to define the following index:

<TabItem value="multi_map_1_0" label="multi_map_1_0">
<CodeBlock language="java">
{`public static class Smart_Search extends AbstractMultiMapIndexCreationTask \{
    public static class Result \{
        private String id;
        private String displayName;
        private String collection;
        private String content;

        public String getId() \{
            return id;
        \}

        public void setId(String id) \{
            this.id = id;
        \}

        public String getDisplayName() \{
            return displayName;
        \}

        public void setDisplayName(String displayName) \{
            this.displayName = displayName;
        \}

        public String getCollection() \{
            return collection;
        \}

        public void setCollection(String collection) \{
            this.collection = collection;
        \}

        public String getContent() \{
            return content;
        \}

        public void setContent(String content) \{
            this.content = content;
        \}
    \}

    public static class Projection \{
        private String id;
        private String displayName;
        private String collection;

        public String getId() \{
            return id;
        \}

        public void setId(String id) \{
            this.id = id;
        \}

        public String getDisplayName() \{
            return displayName;
        \}

        public void setDisplayName(String displayName) \{
            this.displayName = displayName;
        \}

        public String getCollection() \{
            return collection;
        \}

        public void setCollection(String collection) \{
            this.collection = collection;
        \}
    \}

    public Smart_Search() \{

        addMap("docs.Companies.Select(c => new \{ " +
            "    Id = Id(c), " +
            "    Content = new string[] \{ " +
            "        c.Name " +
            "    \}, " +
            "    DisplayName = c.Name, " +
            "    Collection = this.MetadataFor(c)[\\"@collection\\"] " +
            "\})");

        addMap("docs.Products.Select(p => new \{ " +
            "    Id = Id(p), " +
            "    Content = new string[] \{ " +
            "        p.Name " +
            "    \}, " +
            "    DisplayName = p.Name, " +
            "    Collection = this.MetadataFor(p)[\\"@collection\\"] " +
            "\})");

        addMap("docs.Employees.Select(e => new \{ " +
            "    Id = Id(e), " +
            "    Content = new string[] \{ " +
            "        e.FirstName, " +
            "        e.LastName " +
            "    \}, " +
            "    DisplayName = (e.FirstName + \\" \\") + e.LastName, " +
            "    Collection = this.MetadataFor(e)[\\"@collection\\"] " +
            "\})");

        // mark 'content' field as analyzed which enables full text search operations
        index("Content", FieldIndexing.SEARCH);

        // storing fields so when projection (e.g. ProjectInto)
        // requests only those fields
        // then data will come from index only, not from storage
        store("Id", FieldStorage.YES);
        store("DisplayName", FieldStorage.YES);
        store("Collection", FieldStorage.YES);
    \}
\}
`}
</CodeBlock>
</TabItem>

and query it using:

<TabItem value="multi_map_1_1" label="multi_map_1_1">
<CodeBlock language="java">
{`List<Smart_Search.Projection> results = session
    .query(Smart_Search.Result.class, Smart_Search.class)
    .search("Content", "Lau*")
    .selectFields(Smart_Search.Projection.class)
    .toList();

for (Smart_Search.Projection result : results) \{
    System.out.println(result.getCollection() + ": " + result.getDisplayName());
    // Companies: Laughing Bacchus Wine Cellars
    // Products: Laughing Lumberjack Lager
    // Employees: Laura Callahan
\}
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="">
Remember that all map functions **must** output objects with **identical** shape (field names have to match).
</Admonition>


