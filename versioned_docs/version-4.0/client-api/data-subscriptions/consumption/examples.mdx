---
title: "Data Subscriptions: Subscription Consumption Examples"
hide_table_of_contents: true
sidebar_label: Examples
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Data Subscriptions: Subscription Consumption Examples
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

In this page:  

[Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-with-a-specified-batch-size)  
[Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples.mdx#client-with-full-exception-handling-and-processing-retries)  
[Subscription that ends when no documents left](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-ends-when-no-documents-left)  
[Worker that processes dynamic objects](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-that-processes-dynamic-objects)  
[Subscription that works with lowest level API](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-works-with-lowest-level-api)  
[Two subscription workers that are waiting for each other](../../../client-api/data-subscriptions/consumption/examples.mdx#two-subscription-workers-that-are-waiting-for-each-other)  

</Admonition>
## Worker with a specified batch size

Here we create a worker, specifying the maximum batch size we want to receive.

<TabItem value="subscription_worker_with_batch_size" label="subscription_worker_with_batch_size">
<CodeBlock language="csharp">
{`var workerWBatch = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
    \{
        MaxDocsPerBatch = 20
    \});

_ = workerWBatch.Run(x =>
\{
    // your custom logic 
\});
`}
</CodeBlock>
</TabItem>



## Client with full exception handling and processing retries

Here we implement a client that treats exceptions thrown by worker, and retries creating the worker if an exception is recoverable.

<TabItem value="reconnecting_client" label="reconnecting_client">
<CodeBlock language="csharp">
{`while (true)
\{
    // Create the worker:
    // ==================
    var options = new SubscriptionWorkerOptions(subscriptionName);

    // Configure the worker:
    // Allow a downtime of up to 2 hours,
    // and wait 2 minutes before reconnecting
    options.MaxErroneousPeriod = TimeSpan.FromHours(2);
    options.TimeToWaitBeforeConnectionRetry = TimeSpan.FromMinutes(2);

    subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(options);

    try
    \{
        // Subscribe to connection retry events
        // and log any exceptions that occur during processing
        subscriptionWorker.OnSubscriptionConnectionRetry += exception =>
        \{
            Logger.Error("Error during subscription processing: " + subscriptionName,
                exception);
        \};

        // Run the worker:
        // ===============
        await subscriptionWorker.Run(batch =>
        \{
            foreach (var item in batch.Items)
            \{
                // Forcefully stop subscription processing if the ID is "companies/2-A"
                // and throw an exception to let external logic handle the specific case
                if (item.Result.Company == "companies/2-A")
                \{
                    // The custom exception thrown from here
                    // will be wrapped by \`SubscriberErrorException\`
                    throw new UnsupportedCompanyException(
                        "Company ID can't be 'companies/2-A', pleases fix");
                \}

                // Process the order document - provide your own logic
                ProcessOrder(item.Result);
            \}
        \}, cancellationToken);

        // The Run method will stop if the subscription worker is disposed,
        // exiting the while loop
        return;
    \}
    catch (Exception e)
    \{
        Logger.Error("Failure in subscription: " + subscriptionName, e);

        // The following exceptions are Not recoverable
        if (e is DatabaseDoesNotExistException ||
            e is SubscriptionDoesNotExistException ||
            e is SubscriptionInvalidStateException ||
            e is AuthorizationException)
            throw;


        if (e is SubscriptionClosedException)
            // Subscription probably closed explicitly by admin
            return;

        if (e is SubscriberErrorException se)
        \{
            // For UnsupportedCompanyException we want to throw an exception,
            // otherwise, continue processing
            if (se.InnerException != null && se.InnerException is UnsupportedCompanyException)
            \{
                throw;
            \}

            // Call continue to skip the current while(true) iteration and try reconnecting
            // in the next one, allowing the worker to process future batches.
            continue;
        \}

        // Handle this depending on the subscription opening strategy
        if (e is SubscriptionInUseException)
            continue;

        // Call return to exit the while(true) loop,
        // dispose the worker (via finally), and stop the subscription.
        return;
    \}
    finally
    \{
        subscriptionWorker.Dispose();
    \}
\}
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents left

Here we create a subscription client that runs only up to the point there are no more new documents left to process.  

This is useful for an ad-hoc single use processing that the user wants to be sure is performed completely. 

<TabItem value="single_run" label="single_run">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================
var subscriptionName = store.Subscriptions.Create<Order>(
    new SubscriptionCreationOptions<Order>
    \{
        Filter = order => order.Lines.Sum(line => line.PricePerUnit * line.Quantity) > 10000,
        Projection = order => new OrderAndCompany
        \{
            OrderId = order.Id,
            Company = RavenQuery.Load<Company>(order.Company)
        \}
    \});

// Create the subscription worker that will consume the documents:
// ===============================================================
var highValueOrdersWorker = store.Subscriptions.GetSubscriptionWorker<OrderAndCompany>(
    new SubscriptionWorkerOptions(subscriptionName)
    \{
        // Here we set the worker to stop when there are no more documents left to send 
        // Will throw SubscriptionClosedException when it finishes it's job
        CloseWhenNoDocsLeft = true
    \});

try
\{
    await highValueOrdersWorker.Run(batch =>
    \{
        foreach (var item in batch.Items)
        \{
            SendThankYouNoteToEmployee(item.Result); // call your custom method 
        \}
    \});
\}
catch (SubscriptionClosedException)
\{
    // That's expected, no more documents to process
\}
`}
</CodeBlock>
</TabItem>




## Worker that processes dynamic objects

Here we create a worker that processes received data as dynamic objects.

<TabItem value="dynamic_worker" label="dynamic_worker">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = "My dynamic subscription";
store.Subscriptions.Create(new SubscriptionCreationOptions<Order>()
\{
    Name = subscriptionName,
    Projection = order => 
        new \{ DynanamicField_1 = "Company: " + order.Company + " Employee: " + order.Employee \}
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    foreach (var item in batch.Items)
    \{
        // Access the dynamic field in the document
        dynamic field = item.Result.DynanamicField_1;
        
        // Call your custom method
        ProcessItem(field); 
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that works with lowest level API

Here we create a subscription that works with blittable document representation that can be useful in very high performance scenarios, 
but it may be dangerous due to the direct usage of unmanaged memory.

<TabItem value="blittable_worker" label="blittable_worker">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions<Order>
\{
    Projection = x => new
    \{
        x.Employee
    \}
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = 
    // Specify \`BlittableJsonReaderObject\` as the generic type parameter
    store.Subscriptions.GetSubscriptionWorker<BlittableJsonReaderObject>(subscriptionName);

_ = subscriptionWorker.Run(batch =>
\{
    foreach (var item in batch.Items)
    \{
        // Access the Employee field within the blittable object
        var employeeField = item.Result["Employee"].ToString();
        
        ProcessItem(employeeField); // call your custom method 
    \}
\});
`}
</CodeBlock>
</TabItem>



## Two subscription workers that are waiting for each other

Here we create two workers:  
* The main worker with the `TakeOver` strategy that will take over the other one and will take the lead  
* The secondary worker that will wait for the first one fail (due to machine failure etc.)

The main worker:

<TabItem value="waiting_subscription_1" label="waiting_subscription_1">
<CodeBlock language="csharp">
{`var primaryWorker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.TakeOver
\});

while (true)
\{
    try
    \{
        await primaryWorker.Run(x =>
        \{
            // your logic
        \});
    \}
    catch (Exception)
    \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>

The secondary worker:

<TabItem value="waiting_subscription_2" label="waiting_subscription_2">
<CodeBlock language="csharp">
{`var secondaryWorker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.WaitForFree
\});

while (true)
\{
    try
    \{
        await secondaryWorker.Run(x =>
        \{
            // your logic
        \});
    \}
    catch (Exception)
    \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="">

In this page:  

[Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-with-a-specified-batch-size)  
[Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples.mdx#client-with-full-exception-handling-and-processing-retries)  
[Subscription that ends when no documents left](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-ends-when-no-documents-left)  
[Worker that processes dynamic objects](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-that-processes-dynamic-objects)  
[Subscription that works with lowest level API](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-works-with-lowest-level-api)  
[Two subscription workers that are waiting for each other](../../../client-api/data-subscriptions/consumption/examples.mdx#two-subscription-workers-that-are-waiting-for-each-other)  

</Admonition>
## Worker with a specified batch size

Here we create a worker, specifying the maximum batch size we want to receive.

<TabItem value="subscription_worker_with_batch_size" label="subscription_worker_with_batch_size">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subscriptionName);
options.setMaxDocsPerBatch(20);
SubscriptionWorker<Order> workerWBatch = store.subscriptions().getSubscriptionWorker(Order.class, options);
workerWBatch.run(x -> \{ /* custom logic */\});
`}
</CodeBlock>
</TabItem>



## Client with full exception handling and processing retries

Here we implement a client that treats exceptions thrown by worker, and retries creating the worker if an exception is recoverable.

<TabItem value="reconnecting_client" label="reconnecting_client">
<CodeBlock language="java">
{`while (true) \{
    SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subscriptionName);
    // here we configure that we allow a down time of up to 2 hours,
    // and will wait for 2 minutes for reconnecting

    options.setMaxErroneousPeriod(Duration.ofHours(2));
    options.setTimeToWaitBeforeConnectionRetry(Duration.ofMinutes(2));

    subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, options);

    try \{
        // here we are able to be informed of any exception that happens during processing
        subscriptionWorker.addOnSubscriptionConnectionRetry(exception -> \{
            logger.error("Error during subscription processing: " + subscriptionName, exception);
        \});

        subscriptionWorker.run(batch -> \{
            for (SubscriptionBatch.Item<Order> item : batch.getItems()) \{
                // we want to force close the subscription processing in that case
                // and let the external code decide what to do with that
                if ("Europe".equalsIgnoreCase(item.getResult().getShipVia())) \{
                    throw new IllegalStateException("We cannot ship via Europe");
                \}
                processOrder(item.getResult());
            \}
        \}).get();


        // Run will complete normally if you have disposed the subscription
        return;
    \} catch (Exception e) \{
        logger.error("Failure in subscription: " + subscriptionName, e);

        e = ExceptionsUtils.unwrapException(e);
        if (e instanceof DatabaseDoesNotExistException ||
            e instanceof SubscriptionDoesNotExistException ||
            e instanceof SubscriptionInvalidStateException ||
            e instanceof AuthorizationException) \{
            throw e; // not recoverable
        \}

        if (e instanceof SubscriptionClosedException) \{
            // closed explicitly by admin, probably
            return;
        \}

        if (e instanceof SubscriberErrorException) \{
            SubscriberErrorException se = (SubscriberErrorException) e;
            // for IllegalStateException type, we want to throw an exception, otherwise
            // we continue processing
            if (se.getCause() != null && se.getCause() instanceof IllegalStateException) \{
                throw e;
            \}

            continue;
        \}

        // handle this depending on subscription
        // open strategy (discussed later)
        if (e instanceof SubscriptionInUseException) \{
            continue;
        \}

        return;
    \} finally \{
        subscriptionWorker.close();
    \}
\}
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents left

Here we create a subscription client that runs only up to the point there are no more new documents left to process.  

This is useful for an ad-hoc single use processing that the user wants to be sure is performed completely. 

<TabItem value="single_run" label="single_run">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subsId);

// Here we ask the worker to stop when there are no documents left to send.
// Will throw SubscriptionClosedException when it finishes it's job
options.setCloseWhenNoDocsLeft(true);
SubscriptionWorker<OrderAndCompany> highValueOrdersWorker = store
    .subscriptions().getSubscriptionWorker(OrderAndCompany.class, options);

try \{
    highValueOrdersWorker.run(batch -> \{
        for (SubscriptionBatch.Item<OrderAndCompany> item : batch.getItems()) \{
            sendThankYouNoteToEmployee(item.getResult());
        \}
    \});
\} catch (SubscriptionClosedException e) \{
    //that's expected
\}
`}
</CodeBlock>
</TabItem>



## Worker that processes raw objects

Here we create a worker that processes received data as ObjectNode objects.

<TabItem value="dynamic_worker" label="dynamic_worker">
<CodeBlock language="java">
{`String subscriptionName = "My dynamic subscription";

SubscriptionCreationOptions subscriptionCreationOptions = new SubscriptionCreationOptions();
subscriptionCreationOptions.setName("My dynamic subscription");
subscriptionCreationOptions.setQuery("from Orders as o \\n" +
    "select \{ \\n" +
    "   DynamicField_1: 'Company:' + o.Company + ' Employee: ' + o.Employee \\n" +
    "\}");

SubscriptionWorker<ObjectNode> worker = store.subscriptions().getSubscriptionWorker(subscriptionName);
worker.run(x -> \{
    for (SubscriptionBatch.Item<ObjectNode> item : x.getItems()) \{
        ObjectNode result = item.getResult();
        raiseNotification(result.get("DynamicField_1"));
    \}
\});
`}
</CodeBlock>
</TabItem>




## Two subscription workers that are waiting for each other

Here we create two workers:  
* The main worker with the `TAKE_OVER` strategy that will take over the other one and will take the lead  
* The secondary worker that will wait for the first one fail (due to machine failure etc.)

The main worker:

<TabItem value="waiting_subscription_1" label="waiting_subscription_1">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options1 = new SubscriptionWorkerOptions(subscriptionName);
options1.setStrategy(SubscriptionOpeningStrategy.TAKE_OVER);
SubscriptionWorker<Order> worker1 = store.subscriptions().getSubscriptionWorker(Order.class, options1);


while (true) \{
    try \{
        worker1
            .run(x -> \{
                // your logic
            \});
    \} catch (Exception e) \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>

The secondary worker:

<TabItem value="waiting_subscription_2" label="waiting_subscription_2">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options2 = new SubscriptionWorkerOptions(subscriptionName);
options2.setStrategy(SubscriptionOpeningStrategy.WAIT_FOR_FREE);
SubscriptionWorker<Order> worker2 = store.subscriptions().getSubscriptionWorker(Order.class, options2);

while (true) \{
    try \{
        worker2
            .run(x -> \{
                // your logic
            \});
    \} catch (Exception e) \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">

In this page:  

[Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-with-a-specified-batch-size)  
[Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples.mdx#client-with-full-exception-handling-and-processing-retries)  
[Subscription that ends when no documents left](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-ends-when-no-documents-left)  
[Worker that processes dynamic objects](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-that-processes-dynamic-objects)  
[Subscription that works with lowest level API](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-works-with-lowest-level-api)  
[Two subscription workers that are waiting for each other](../../../client-api/data-subscriptions/consumption/examples.mdx#two-subscription-workers-that-are-waiting-for-each-other)  

</Admonition>
## Worker with a specified batch size

Here we create a worker, specifying the maximum batch size we want to receive.

<TabItem value="subscription_worker_with_batch_size" label="subscription_worker_with_batch_size">
<CodeBlock language="js">
{`const options = \{ 
    subscriptionName,
    maxDocsPerBatch: 20
\};

const workerWBatch = store.subscriptions.getSubscriptionWorker(options);
workerWBatch.on("batch", (batch, callback) => \{ /* custom logic */\});
`}
</CodeBlock>
</TabItem>



## Client with full exception handling and processing retries

Here we implement a client that treats exceptions thrown by worker, and retries creating the worker if an exception is recoverable.

<TabItem value="reconnecting_client" label="reconnecting_client">
<CodeBlock language="js">
{`// here we configure that we allow a down time of up to 2 hours,
// and will wait for 2 minutes for reconnecting
const options = \{
    subscriptionName,
    maxErroneousPeriod: 2 * 3600 * 1000,
    timeToWaitBeforeConnectionRetry: 2 * 60 * 1000
\};

setupReconnectingSubscription(options);

function setupReconnectingSubscription(subscriptionWorkerOptions) \{
    let subscriptionWorker;

    reconnect();

    function closeWorker(worker) \{
        worker.removeAllListeners();
        worker.on("error", () => \{\}); // ignore errors from old connection
        worker.dispose();
    \}

    function reconnect() \{
        if (subscriptionWorker) \{
            closeWorker();
        \}

        subscriptionWorker = store.subscriptions.getSubscriptionWorker(subscriptionWorkerOptions);

        // here we are able to be informed of any exception that happens during processing
        subscriptionWorker.on("connectionRetry", error => \{
            console.error(
                "Error during subscription processing: " + subscriptionName, error);
        \});

        subscriptionWorker.on("batch", (batch, callback) => \{
            for (const item of batch.items) \{
                // we want to force close the subscription processing in that case
                // and let the external code decide what to do with that
                if (item.result.shipVia 
                    && "Europe" === item.result.shipVia) \{
                    callback(new InvalidOperationException("We cannot ship via Europe."));
                    return;
                \}

                processOrder(item.result);
            \}
        \});

        subscriptionWorker.on("error", error => \{
            console.error("Failure in subscription: " + subscriptionName, error);

            if (error.name === "DatabaseDoesNotExistException" ||
                error.name === "SubscriptionDoesNotExistException" ||
                error.name === "SubscriptionInvalidStateException" ||
                error.name === "AuthorizationException") \{
                throw error; 
            \}

            if (error.name === "SubscriptionClosedException") \{
                // closed explicitly by admin, probably
                return closeWorker(subscriptionWorker);
            \}

            if (error.name === "SubscriberErrorException") \{
                // for InvalidOperationException type, we want to throw an exception, otherwise
                // we continue processing
                // RavenDB client uses VError - it can nest errors and keep track of inner errors
                // under cause property
                if (error.cause && error.cause.name === "InvalidOperationException") \{
                    throw error;
                \}

                return reconnect();
            \}

            // handle this depending on subscription
            // open strategy (discussed later)
            if (error.name === "SubscriptionInUseException") \{
                return reconnect();
            \}

            return reconnect();
        \});

        subscriptionWorker.on("end", () => \{
            closeWorker(subscriptionWorker);
        \});
    \}
\}
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents left

Here we create a subscription client that runs only up to the point there are no more new documents left to process.  

This is useful for an ad-hoc single use processing that the user wants to be sure is performed completely. 

<TabItem value="single_run" label="single_run">
<CodeBlock language="js">
{`const options = \{ 
    subscriptionName: subsId,
    // Here we ask the worker to stop when there are no documents left to send.
    // Will throw SubscriptionClosedException when it finishes it's job
    closeWhenNoDocsLeft: true
\};

const highValueOrdersWorker = store
    .subscriptions.getSubscriptionWorker(options);

highValueOrdersWorker.on("batch", async (batch, callback) => \{
    for (const item of batch.items) \{
        await sendThankYouNoteToEmployee(item.result);
    \}

    callback();
\});

highValueOrdersWorker.on("error", err => \{
    if (err.name === "SubscriptionClosedException")\{
        //that's expected
    \}
\});
`}
</CodeBlock>
</TabItem>




## Two subscription workers that are waiting for each other

Here we create two workers:

* The main worker with the `TakeOver` strategy that will take over the other one and will take the lead  

* The secondary worker that will wait for the first one fail (due to machine failure etc.)

The main worker:

<TabItem value="waiting_subscription_1" label="waiting_subscription_1">
<CodeBlock language="js">
{`const options1 = \{
    subscriptionName,
    strategy: "TakeOver",
    documentType: Order
\};

const worker1 = store.subscriptions.getSubscriptionWorker(options1);

worker1.on("batch", (batch, callback) => \{
    // your logic
    callback();
\});

worker1.on("error", err => \{
    // retry
\});
`}
</CodeBlock>
</TabItem>

The secondary worker:

<TabItem value="waiting_subscription_2" label="waiting_subscription_2">
<CodeBlock language="js">
{`const options2 = \{
    subscriptionName,
    strategy: "WaitForFree",
    documentType: Order
\};

const worker2 = store.subscriptions.getSubscriptionWorker(options2);

worker2.on("batch", (batch, callback) => \{
    // your logic
    callback();
\});

worker2.on("error", err => \{
    // retry
\});
`}
</CodeBlock>
</TabItem>




</LanguageContent>

<!---
### Data Subscriptions:
- [What are Data Subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions)
- [How to Create a Data Subscription](../../../client-api/data-subscriptions/creation/how-to-create-data-subscription)
- [How to Consume a Data Subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription)


-->