---
title: "Data Subscriptions: Creation API Overview"
hide_table_of_contents: true
sidebar_label: API Overview
sidebar_position: 2
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Data Subscriptions: Creation API Overview
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">


In this page:  
[Subscription creation overloads summary](../../../client-api/data-subscriptions/creation/api-overview.mdx#create-and-createasync-overloads-summary)  
[Subscription Creation Options](../../../client-api/data-subscriptions/creation/api-overview.mdx#subscriptioncreationoptions)  
[SubscriptionCreationOptions&lt;T&gt;](../../../client-api/data-subscriptions/creation/api-overview.mdx#subscriptioncreationoptionst)  
[Subscription query](../../../client-api/data-subscriptions/creation/api-overview.mdx#subscription-query)  

</Admonition>
## Create and CreateAsync overloads summary

Subscription creation is accessible through `DocumentStore`'s `Subscriptions` Property, of type `DocumentSubscriptions`:
<TabItem value="subscriptionCreationOverloads" label="subscriptionCreationOverloads">
<CodeBlock language="csharp">
{`string Create(SubscriptionCreationOptions options,
              string database = null);

string Create<T>(SubscriptionCreationOptions options = null,
                 string database = null);

string Create<T>(SubscriptionCreationOptions<T> options,
                 string database = null);

string Create<T>(Expression<Func<T, bool>> predicate = null,
                 PredicateSubscriptionCreationOptions options = null,
                 string database = null);

Task<string> CreateAsync(SubscriptionCreationOptions options,
                         string database = null,
                         CancellationToken token = default);

public Task<string> CreateAsync<T>(SubscriptionCreationOptions options = null,
                                   string database = null,
                                   CancellationToken token = default);

Task<string> CreateAsync<T>(SubscriptionCreationOptions<T> options,
                            string database = null,
                            CancellationToken token = default);

Task<string> CreateAsync<T>(Expression<Func<T, bool>> predicate = null,
                            PredicateSubscriptionCreationOptions options = null,
                            string database = null,
                            CancellationToken token = default);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **predicate** | `Expression<Func<T, bool>>` | Predicate that returns a boolean, describing filter of the subscription documents |
| **options** | `SubscriptionCreationOptions<T>` | Contains subscription creation options |
| **database** | `string` | Name of database to create a data subscription. If `null`, default database configured in DocumentStore will be used. |

| Return value | |
| ------------- | ----- |
| `string` | Created data subscription name. If Name was provided in SubscriptionCreationOptions, it will be returned, otherwise, a unique name will be generated by server. |



## SubscriptionCreationOptions

Non generic version of the class, relies on user's full knowledge of the RQL query structure

| Member | Type | Description |
|--------|:-----|-------------| 
| **Name** | `string` | User defined name of the subscription: allows to have a human readable identification of a subscription. The name must be unique in the database. |
| **Query** | `string` | **Required.** RQL query that describes the subscription. That RQL comes with additional support to javascript clause inside the 'Where' statement and special semantics for subscriptions on documents revisions. |
| **ChangeVector** | `string` | Allows to define a change vector, from which the subscription will start processing. It might be useful for ad-hoc processes that need to process only recent changes in data, for that specific use, the field may receive a special value: "LastDocument", that will take the latest change vector in the machine. |
| **MentorNode** | `string` | Allows to define a specific node in the cluster that we want to treat the subscription. That's useful in cases when one server is preffered over other, either because of stronger hardware or closer geographic proximity to clients etc. |



## SubscriptionCreationOptions&lt;T&gt;

An RQL statement will be built based on the fields.

| Member | Type | Description |
|--------|:-----|-------------| 
| **&lt;T&gt;** | type | Type of the object, from which the collection will be derived. |
| **Name** | `string` | User defined name of the subscription: allows to have a human readable identification of a subscription. The name must be unique in the database. |
| **Filter** | `Expression<Func<T, bool>>` | Lambda describing filter logic for the subscription. Will be translated to a javascript function. |
| **Projection** | `Expression<Func<T, object>>` | Lambda describing the projection of returned documents. Will be translated to a javascript function. |
| **ChangeVector** | `string` | Allows to define a change vector, from which the subscription will start processing. It might be useful for ad-hoc processes that need to process only recent changes in data, for that specific use, the field may receive a special value: "LastDocument", that will take the latest change vector in the machine. |
| **MentorNode** | `string` | Allows to define a specific node in the cluster that we want to treat the subscription. That's useful in cases when one server is preffered over other, either because of stronger hardware or closer geographic proximity to clients etc. |



## Subscription query 
All subscriptions, are eventually translated to an RQL-like statement. These statements has four parts:

* Functions definition part, like in ordinary RQL. Those functions can contain any javascript code,
  and also supports `load` operations.

* From statement, defining the documents source, ex: `from Orders`. The from statement can only address collections, therefore, indexes are not supported.    

* Where statement describing the criteria according to which it will be decided to either 
send the documents to the worker or not. Those statements supports either RQL like `equality` operations (`=`, `==`) ,  
plain JavaScript expressions or declared function calls, allowing to perform complex filtering logic.  
The subscriptions RQL does not support any of the known RQL searching keywords.

* Select statement, that defines the projection to be performed. 
The select statements can contain function calls, allowing complex transformations.

* Include statement allowing to define include path in document.  

<Admonition type="info" title="Keywords" id="keywords" href="#keywords">
Although subscription's query syntax has an RQL-like structure, it supports only the `declare`, `select` and `where` keywords, usage of all other RQL keywords is not supported.  
Usage of JavaScript ES5 syntax is supported.
</Admonition>

<Admonition type="info" title="Paths" id="paths" href="#paths">
Paths in subscriptions RQL statements are treated as JavaScript indirections and not like regular RQL paths.  
It means that a query that in RQL would look like:  

```
from Orders as o
where o.Lines[].Product = "products/1-A"
```

Will look like that in subscriptions RQL:

```
declare function filterLines(doc, productId)
{
    if (!!doc.Lines){
        return doc.Lines.filter(x=>x.Product == productId).length >0;
    }
    return false;
}

from Orders as o
where filterLines(o, "products/1-A")
```
</Admonition>  

<Admonition type="info" title="Revisions" id="revisions" href="#revisions">
In order to define a data subscription that uses documents revisions, there first has to be revisions configured for the specific collection.  
The subscription should be defined in a special way:  
* In case of the generic API, the `SubscriptionCreationOptions<>` generic parameter should be of the generic type `Revision<>`, while it's generic parameter correlates to the collection to be processed.  Ex: `new SubscriptionCreationOptions<Revision<Order>>()`  
* For RQL syntax, the `(Revisions = true)` statement should be concatenated to the collection to be queries.  Ex: `From orders(Revisions = true) as o`

</Admonition>
  



</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="">


In this page:  
[Subscription creation overloads summary](../../../client-api/data-subscriptions/creation/api-overview.mdx#create-and-createasync-overloads-summary)  
[Subscription Creation Options](../../../client-api/data-subscriptions/creation/api-overview.mdx#subscriptioncreationoptions)  
[Subscription query](../../../client-api/data-subscriptions/creation/api-overview.mdx#subscription-query)  

</Admonition>
## Create and CreateForRevisions overloads summary

Subscription creation is accessible through `DocumentStore`'s `subscriptions()` method, of type `DocumentSubscriptions`:
<TabItem value="subscriptionCreationOverloads" label="subscriptionCreationOverloads">
<CodeBlock language="java">
{`String create(SubscriptionCreationOptions options);

String create(SubscriptionCreationOptions options, String database);

<T> String create(Class<T> clazz);

<T> String create(Class<T> clazz, SubscriptionCreationOptions options);

<T> String create(Class<T> clazz, SubscriptionCreationOptions options, String database);

<T> String createForRevisions(Class<T> clazz);

<T> String createForRevisions(Class<T> clazz, SubscriptionCreationOptions options);

<T> String createForRevisions(Class<T> clazz, SubscriptionCreationOptions options, String database);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **clazz** | `Class` | Subscription item class |
| **options** | `SubscriptionCreationOptions` | Contains subscription creation options |
| **database** | `String` | Name of database to create a data subscription. If `null`, default database configured in DocumentStore will be used. |

| Return value | |
| ------------- | ----- |
| `String` | Created data subscription name. If Name was provided in SubscriptionCreationOptions, it will be returned, otherwise, a unique name will be generated by server. |



## SubscriptionCreationOptions

Non generic version of the class, relies on user's full knowledge of the RQL query structure

| Member | Type | Description |
|--------|:-----|-------------| 
| **name** | `String` | User defined name of the subscription: allows to have a human readable identification of a subscription. The name must be unique in the database. |
| **query** | `String` | **Required.** RQL query that describes the subscription. That RQL comes with additional support to javascript clause inside the 'Where' statement and special semantics for subscriptions on documents revisions. |
| **changeVector** | `String` | Allows to define a change vector, from which the subscription will start processing. It might be useful for ad-hoc processes that need to process only recent changes in data, for that specific use, the field may receive a special value: "LastDocument", that will take the latest change vector in the machine. |
| **mentorNode** | `String` | Allows to define a specific node in the cluster that we want to treat the subscription. That's useful in cases when one server is preffered over other, either because of stronger hardware or closer geographic proximity to clients etc. |



## Subscription query 


All subscriptions, are eventually translated to an RQL-like statement. These statements has four parts:

* Functions definition part, like in ordinary RQL. Those functions can contain any javascript code,
  and also supports `load` operations.

* From statement, defining the documents source, ex: `from Orders`. The from statement can only address collections, therefore, indexes are not supported.    

* Where statement describing the criteria according to which it will be decided to either 
send the documents to the worker or not. Those statements supports either RQL like `equality` operations (`=`, `==`) ,  
plain JavaScript expressions or declared function calls, allowing to perform complex filtering logic.  
The subscriptions RQL does not support any of the known RQL searching keywords.

* Select statement, that defines the projection to be performed. 
The select statements can contain function calls, allowing complex transformations.

* Include statement allowing to define include path in document.  

<Admonition type="info" title="Keywords" id="keywords" href="#keywords">
Although subscription's query syntax has an RQL-like structure, it supports only the `declare`, `select` and `where` keywords, usage of all other RQL keywords is not supported.  
Usage of JavaScript ES5 syntax is supported.
</Admonition>

<Admonition type="info" title="Paths" id="paths" href="#paths">
Paths in subscriptions RQL statements are treated as Javascript indirections and not like regular RQL paths.  
It means that a query that in RQL would look like:  

```
from Orders as o
where o.Lines[].Product = "products/1-A"
```

Will look like that in subscriptions RQL:

```
declare function filterLines(doc, productId)
{
    if (!!doc.Lines){
        return doc.Lines.filter(x=>x.Product == productId).length >0;
    }
    return false;
}

from Orders as o
where filterLines(o, "products/1-A")
```
</Admonition>  

<Admonition type="info" title="Revisions" id="revisions" href="#revisions">
In order to define a data subscription that uses documents revisions, there first has to be revisions configured for the specific collection.  
The subscription should be defined in a special way:  
* In case of the generic API, use method 'createForRevisions' instead of 'create'  
* For RQL syntax, the `(Revisions = true)` statement should be concatenated to the collection to be queries.  Ex: `From orders(Revisions = true) as o`

</Admonition>
  



</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">


In this page:  
[Subscription creation overloads summary](../../../client-api/data-subscriptions/creation/api-overview.mdx#create-and-createasync-overloads-summary)  
[Subscription Creation Options](../../../client-api/data-subscriptions/creation/api-overview.mdx#subscriptioncreationoptions)  
[Subscription query](../../../client-api/data-subscriptions/creation/api-overview.mdx#subscription-query)  

</Admonition>
## Create and CreateForRevisions overloads summary

Subscription creation is accessible through `DocumentStore`'s `subscriptions` property, of type `DocumentSubscriptions`:
<TabItem value="subscriptionCreationOverloads" label="subscriptionCreationOverloads">
<CodeBlock language="js">
{`store.subscriptions.create(clazz, [database]);
store.subscriptions.create(options, [database]);

store.subscriptions.createForRevisions(clazz, [database]);
store.subscriptions.createForRevisions(options, [database]);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **documentType** | class | Subscription item class |
| **options** | object | Contains subscription creation options |
| &nbsp;&nbsp;*id* | string | User defined name of the subscription: allows to have a human readable identification of a subscription. The name must be unique in the database. |
| &nbsp;&nbsp;*query* | string | **Required.** RQL query that describes the subscription. That RQL comes with additional support to javascript clause inside the 'Where' statement and special semantics for subscriptions on documents revisions. |
| &nbsp;&nbsp;*changeVector* | string | Allows to define a change vector, from which the subscription will start processing. It might be useful for ad-hoc processes that need to process only recent changes in data, for that specific use, the field may receive a special value: "LastDocument", that will take the latest change vector in the machine. |
| &nbsp;&nbsp;*mentorNode* | string | Allows to define a specific node in the cluster that we want to treat the subscription. That's useful in cases when one server is preffered over other, either because of stronger hardware or closer geographic proximity to clients etc. |
| &nbsp;&nbsp;*documentType* | class | Subscription item class |
| **database** | string | Name of database to create a data subscription. If `null`, default database configured in DocumentStore will be used. |

| Return value | |
| ------------- | ----- |
| `string` | Created data subscription name. If Name was provided in SubscriptionCreationOptions, it will be returned, otherwise, a unique name will be generated by server. |



## Subscription query 

* Functions definition part, like in ordinary RQL. Those functions can contain any javascript code,
  and also supports `load` operations.

* From statement, defining the documents source, ex: `from Orders`. The from statement can only address collections, therefore, indexes are not supported.    

* Where statement describing the criteria according to which it will be decided to either 
send the documents to the worker or not. Those statements supports either RQL like `equality` operations (`=`, `==`) ,  
plain JavaScript expressions or declared function calls, allowing to perform complex filtering logic.  
The subscriptions RQL does not support any of the known RQL searching keywords.

* Select statement, that defines the projection to be performed. 
The select statements can contain function calls, allowing complex transformations.

* Include statement allowing to define include path in document.  

<Admonition type="info" title="Keywords" id="keywords" href="#keywords">
Although subscription's query syntax has an RQL-like structure, it supports only the `declare`, `select` and `where` keywords, usage of all other RQL keywords is not supported.  
Usage of JavaScript ES5 syntax is supported.
</Admonition>

<Admonition type="info" title="Paths" id="paths" href="#paths">
Paths in subscriptions RQL statements are treated as Javascript indirections and not like regular RQL paths.  
It means that a query that in RQL would look like:  

```
from Orders as o
where o.Lines[].Product = "products/1-A"
```

Will look like that in subscriptions RQL:

```
declare function filterLines(doc, productId)
{
    if (!!doc.Lines){
        return doc.Lines.filter(x=>x.Product == productId).length >0;
    }
    return false;
}

from Orders as o
where filterLines(o, "products/1-A")
```
</Admonition>  

<Admonition type="info" title="Revisions" id="revisions" href="#revisions">
In order to define a data subscription that uses documents revisions, there first has to be revisions configured for the specific collection.  
The subscription should be defined in a special way:

* In case of the generic API, use method `createForRevisions()` instead of `create()`

* For RQL syntax, the `(Revisions = true)` statement should be concatenated to the collection to be queries.  Ex: `From orders(Revisions = true) as o`

</Admonition>
  



</LanguageContent>

<!---
### Data Subscriptions:
- [What are Data Subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions)
- [How to Create a Data Subscription](../../../client-api/data-subscriptions/creation/how-to-create-data-subscription)
- [How to Consume a Data Subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription)

### Knowledge Base:
- [JavaScript Engine](../../../server/kb/javascript-engine)


-->