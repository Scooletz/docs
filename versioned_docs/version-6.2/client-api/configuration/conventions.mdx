---
title: "Conventions"
sidebar_label: Conventions
sidebar_position: 0
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "nodejs"];


# Conventions
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


<Admonition type="note" title="Note">

* **Conventions** in RavenDB are customizable settings that users can configure to tailor client behaviors according to their preferences.

* In this page:
    * [How to set conventions](../../client-api/configuration/conventions.mdx#how-to-set-conventions)
    * [Conventions:](../../client-api/configuration/conventions.mdx#conventions:)  
      [AddIdFieldToDynamicObjects](../../client-api/configuration/conventions.mdx#addidfieldtodynamicobjects)  
      [AggressiveCache.Duration](../../client-api/configuration/conventions.mdx#aggressivecacheduration)  
      [AggressiveCache.Mode](../../client-api/configuration/conventions.mdx#aggressivecachemode)  
      [AsyncDocumentIdGenerator](../../client-api/configuration/conventions.mdx#asyncdocumentidgenerator)  
      [CreateHttpClient](../../client-api/configuration/conventions.mdx#createhttpclient)  
      [DisableAtomicDocumentWritesInClusterWideTransaction](../../client-api/configuration/conventions.mdx#disableatomicdocumentwritesinclusterwidetransaction)  
      [DisableTcpCompression](../../client-api/configuration/conventions.mdx#disabletcpcompression)  
      [DisableTopologyCache](../../client-api/configuration/conventions.mdx#disabletopologycache)  
      [DisableTopologyUpdates](../../client-api/configuration/conventions.mdx#disabletopologyupdates)  
      [DisposeCertificate](../../client-api/configuration/conventions.mdx#disposecertificate)  
      [FindClrType](../../client-api/configuration/conventions.mdx#findclrtype)  
      [FindClrTypeName](../../client-api/configuration/conventions.mdx#findclrtypename)  
      [FindClrTypeNameForDynamic](../../client-api/configuration/conventions.mdx#findclrtypenamefordynamic)  
      [FindCollectionName](../../client-api/configuration/conventions.mdx#findcollectionname)  
      [FindCollectionNameForDynamic](../../client-api/configuration/conventions.mdx#findcollectionnamefordynamic)  
      [FindIdentityProperty](../../client-api/configuration/conventions.mdx#findidentityproperty)  
      [FindIdentityPropertyNameFromCollectionName](../../client-api/configuration/conventions.mdx#findidentitypropertynamefromcollectionname)  
      [FindProjectedPropertyNameForIndex](../../client-api/configuration/conventions.mdx#findprojectedpropertynameforindex)  
      [FindPropertyNameForDynamicIndex](../../client-api/configuration/conventions.mdx#findpropertynamefordynamicindex)  
      [FindPropertyNameForIndex](../../client-api/configuration/conventions.mdx#findpropertynameforindex)  
      [FirstBroadcastAttemptTimeout](../../client-api/configuration/conventions.mdx#firstbroadcastattempttimeout)  
      [HttpClientType](../../client-api/configuration/conventions.mdx#httpclienttype)  
      [HttpVersion](../../client-api/configuration/conventions.mdx#httpversion)  
      [IdentityPartsSeparator](../../client-api/configuration/conventions.mdx#identitypartsseparator)  
      [LoadBalanceBehavior](../../client-api/configuration/conventions.mdx#loadbalancebehavior)  
      [LoadBalancerContextSeed](../../client-api/configuration/conventions.mdx#loadbalancebehavior)  
      [LoadBalancerPerSessionContextSelector](../../client-api/configuration/conventions.mdx#loadbalancebehavior)  
      [MaxHttpCacheSize](../../client-api/configuration/conventions.mdx#maxhttpcachesize)  
      [MaxNumberOfRequestsPerSession](../../client-api/configuration/conventions.mdx#maxnumberofrequestspersession)  
      [Modify serialization of property name](../../client-api/configuration/conventions.mdx#modify-serialization-of-property-name)  
      [OperationStatusFetchMode](../../client-api/configuration/conventions.mdx#operationstatusfetchmode)  
      [PreserveDocumentPropertiesNotFoundOnModel](../../client-api/configuration/conventions.mdx#preservedocumentpropertiesnotfoundonmodel)  
      [ReadBalanceBehavior](../../client-api/configuration/conventions.mdx#readbalancebehavior)  
      [RequestTimeout](../../client-api/configuration/conventions.mdx#requesttimeout)  
      [ResolveTypeFromClrTypeName](../../client-api/configuration/conventions.mdx#resolvetypefromclrtypename)  
      [SaveEnumsAsIntegers](../../client-api/configuration/conventions.mdx#saveenumsasintegers)  
      [SecondBroadcastAttemptTimeout](../../client-api/configuration/conventions.mdx#secondbroadcastattempttimeout)  
      [SendApplicationIdentifier](../../client-api/configuration/conventions.mdx#sendapplicationidentifier)  
      [ShouldIgnoreEntityChanges](../../client-api/configuration/conventions.mdx#shouldignoreentitychanges)  
      [TopologyCacheLocation](../../client-api/configuration/conventions.mdx#topologycachelocation)  
      [TransformTypeCollectionNameToDocumentIdPrefix](../../client-api/configuration/conventions.mdx#transformtypecollectionnametodocumentidprefix)  
      [UseHttpCompression](../../client-api/configuration/conventions.mdx#usehttpcompression)  
      [UseHttpDecompression](../../client-api/configuration/conventions.mdx#usehttpdecompression)  
      [UseOptimisticConcurrency](../../client-api/configuration/conventions.mdx#useoptimisticconcurrency)  
      [WaitForIndexesAfterSaveChangesTimeout](../../client-api/configuration/conventions.mdx#waitforindexesaftersavechangestimeout)  
      [WaitForNonStaleResultsTimeout](../../client-api/configuration/conventions.mdx#waitfornonstaleresultstimeout)  
      [WaitForReplicationAfterSaveChangesTimeout](../../client-api/configuration/conventions.mdx#waitforreplicationaftersavechangestimeout)

</Admonition>
## How to set conventions

* Access the conventions via the `Conventions` property of the `DocumentStore` object.

* The conventions set on a Document Store will apply to ALL [sessions](../../client-api/session/what-is-a-session-and-how-does-it-work.mdx) and [operations](../../client-api/operations/what-are-operations.mdx) associated with that store.

* Customizing the conventions can only be set **before** calling `DocumentStore.Initialize()`.  
  Trying to do so after calling _Initialize()_ will throw an exception.

<TabItem value="conventions_1" label="conventions_1">
<CodeBlock language="csharp">
{`using (var store = new DocumentStore()
\{
    Conventions =
    \{
        // Set conventions HERE, e.g.:
        MaxNumberOfRequestsPerSession = 50,
        AddIdFieldToDynamicObjects = false
        // ...
    \}
\}.Initialize())
\{
    // * Here you can interact with the RavenDB store:
    //   open sessions, create or query for documents, perform operations, etc.
    
    // * Conventions CANNOT be set here after calling Initialize()
\}
`}
</CodeBlock>
</TabItem>



## Conventions:

<Admonition type="note" title="Note">

#### AddIdFieldToDynamicObjects
* Use the `AddIdFieldToDynamicObjects` convention to determine whether an `Id` field is automatically added  
  to [dynamic objects](https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/interop/using-type-dynamic) when [storing new entities](../../client-api/session/storing-entities.mdx) via the session.

* DEFAULT: `true`

<TabItem value="AddIdFieldToDynamicObjectsSyntax" label="AddIdFieldToDynamicObjectsSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool AddIdFieldToDynamicObjects \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### AggressiveCache.Duration
* Use the `AggressiveCache.Duration` convention to define the [aggressive cache](../../client-api/how-to/setup-aggressive-caching.mdx) duration period.

* DEFAULT: `1 day`

<TabItem value="AggressiveCacheDurationSyntax" label="AggressiveCacheDurationSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public TimeSpan Duration \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### AggressiveCache.Mode
* Use the `AggressiveCache.Mode` convention to define the [aggressive cache](../../client-api/how-to/setup-aggressive-caching.mdx) mode.  
  (`AggressiveCacheMode.TrackChanges` or `AggressiveCacheMode.DoNotTrackChanges`)

* DEFAULT: `AggressiveCacheMode.TrackChanges`

<TabItem value="AggressiveCacheModeSyntax" label="AggressiveCacheModeSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public AggressiveCacheMode Mode \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### AsyncDocumentIdGenerator
* Use the `AsyncDocumentIdGenerator` convention to define the document ID generator method that will be used when storing a document without explicitly specifying its `Id`.

* You can override this global ID generator for specific object types using the [RegisterAsyncIdConvention](../../client-api/configuration/identifier-generation/type-specific.mdx) convention.

* DEFAULT:  
  The default document ID generator is the `GenerateDocumentIdAsync` method, which is part of the `HiLoIdGenerator` object within the _DocumentStore_.
  This method implements the [HiLo algorithm](../../client-api/document-identifiers/hilo-algorithm.mdx) to ensure efficient ID generation when storing a document without explicitly specifying its `Id`.

<TabItem value="AsyncDocumentIdGenerator" label="AsyncDocumentIdGenerator">
<CodeBlock language="csharp">
{`// Customize ID generation for all collections
AsyncDocumentIdGenerator = (database, obj) =>
\{
    var objectType = obj.GetType().Name;  // e.g., Person, Order, etc.
    var timestamp = DateTime.UtcNow.Ticks; // Get the current timestamp

    // Format the ID as \{ObjectType\}/\{Ticks\}
    var id = $"\{objectType\}/\{timestamp\}";

    return Task.FromResult(id);
\}
`}
</CodeBlock>
</TabItem>
<TabItem value="AsyncDocumentIdGeneratorSyntax" label="AsyncDocumentIdGeneratorSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<string, object, Task<string>> AsyncDocumentIdGenerator \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### CreateHttpClient
* Use the `CreateHttpClient` convention to modify the HTTP client your client application uses.

* For example, implementing your own HTTP client can be useful when you'd like your clients to provide the server with tracing info.

* If you override the default `CreateHttpClient` convention we advise that you also set the HTTP client type
  correctly using the [HttpClientType](../../client-api/configuration/conventions.mdx#httpclienttype) convention.

<TabItem value="CreateHttpClient" label="CreateHttpClient">
<CodeBlock language="csharp">
{`CreateHttpClient = handler =>
\{
    // Your HTTP client code here, e.g.:
    var httpClient = new MyHttpClient(new HttpClientXRayTracingHandler(new HttpClientHandler()));
    return httpClient;
\}
`}
</CodeBlock>
</TabItem>
<TabItem value="CreateHttpClientSyntax" label="CreateHttpClientSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<HttpClientHandler, HttpClient> CreateHttpClient \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### DisableAtomicDocumentWritesInClusterWideTransaction
* EXPERT ONLY:   
  Use the `DisableAtomicDocumentWritesInClusterWideTransaction` convention to disable automatic  
  atomic writes with cluster write transactions.

* When set to `true`, will only consider explicitly added compare exchange values to validate cluster wide transactions.

* DEFAULT: `false`

<TabItem value="DisableAtomicDocumentWritesInClusterWideTransactionSyntax" label="DisableAtomicDocumentWritesInClusterWideTransactionSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool? DisableAtomicDocumentWritesInClusterWideTransaction \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### DisableTcpCompression
* When setting the `DisableTcpCompression` convention to `true`, TCP data will not be compressed.

* DEFAULT: `false`

<TabItem value="DisableTcpCompressionSyntax" label="DisableTcpCompressionSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool DisableTcpCompression \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### DisableTopologyCache
* By default, the client caches the cluster's topology in `*.raven-cluster-topology` files on disk.  
  When all servers provided in the `DocumentStore.Urls` property are down or unavailable,
  the client will load the topology from the latest file and try to connect to nodes that are not listed in the URL property.

* This behavior can be disabled when setting the `DisableTopologyCache` convention to `true`.  
  In such a case:

    * The client will not load the topology from the cache upon failing to connect to a server.
    * Even if the client is configured to [receive topology updates](../../client-api/configuration/conventions.mdx#disabletopologyupdates) from the server,
      no topology files will be saved on disk, thus preventing the accumulation of these files.

* DEFAULT: `false`

<TabItem value="DisableTopologyCacheSyntax" label="DisableTopologyCacheSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool DisableTopologyCache \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### DisableTopologyUpdates
* When setting the `DisableTopologyUpdates` convention to `true`,  
  no database topology updates will be sent from the server to the client (e.g. adding or removing a node).

* DEFAULT: `false`

<TabItem value="DisableTopologyUpdatesSyntax" label="DisableTopologyUpdatesSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool DisableTopologyUpdates \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### DisposeCertificate
* When setting the `DisposeCertificate` convention to `true`,  
  the `DocumentStore.Certificate` will be disposed of during DocumentStore disposal. 

* DEFAULT: `true`

<TabItem value="DisposeCertificateSyntax" label="DisposeCertificateSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool DisposeCertificate \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindClrType
* Use the `FindClrType` convention to define a function that finds the CLR type of a document.

* DEFAULT:  
  The CLR type is retrieved from the `Raven-Clr-Type` property under the `@metadata` key in the document.

<TabItem value="FindClrType" label="FindClrType">
<CodeBlock language="csharp">
{`// The default implementation is:
FindClrType = (_, doc) =>
\{
    if (doc.TryGet(Constants.Documents.Metadata.Key, out BlittableJsonReaderObject metadata) &&
        metadata.TryGet(Constants.Documents.Metadata.RavenClrType, out string clrType))
        return clrType;

    return null;
\}
`}
</CodeBlock>
</TabItem>
<TabItem value="FindClrTypeSyntax" label="FindClrTypeSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<string, BlittableJsonReaderObject, string> FindClrType \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindClrTypeName
* Use the `FindClrTypeName` convention to define a function that returns the CLR type name from a given type.

* DEFAULT: The entity's full name with the assembly name is returned.

<TabItem value="FindClrTypeNameSyntax" label="FindClrTypeNameSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<Type, string> FindClrTypeName \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindClrTypeNameForDynamic
* Use the `FindClrTypeNameForDynamic` convention to define a function that returns the CLR type name  
  from a dynamic entity.

* DEFAULT: The dynamic entity type is returned.

<TabItem value="FindClrTypeNameForDynamic" label="FindClrTypeNameForDynamic">
<CodeBlock language="csharp">
{`// The dynamic entity's type is returned by default
FindClrTypeNameForDynamic = dynamicEntity => dynamicEntity.GetType()
`}
</CodeBlock>
</TabItem>
<TabItem value="FindClrTypeNameForDynamicSyntax" label="FindClrTypeNameForDynamicSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<dynamic, string> FindClrTypeNameForDynamic \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindCollectionName
* Use the `FindCollectionName` convention to define a function that will customize the collection name  
  from given type.

* DEFAULT: The collection name will be the plural form of the type name.

<TabItem value="FindCollectionName" label="FindCollectionName">
<CodeBlock language="csharp">
{`// Here the collection name will be the type name separated by dashes
FindCollectionName = type => String.Join("-", type.Name.ToCharArray())
`}
</CodeBlock>
</TabItem>
<TabItem value="FindCollectionNameSyntax" label="FindCollectionNameSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<Type, string> FindCollectionName \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindCollectionNameForDynamic
* Use the `FindCollectionNameForDynamic` convention to define a function that will customize the  
  collection name from a dynamic type.

* DEFAULT: The collection name will be the entity's type.

<TabItem value="FindCollectionNameForDynamic" label="FindCollectionNameForDynamic">
<CodeBlock language="csharp">
{`// Here the collection name will be some property of the dynamic entity
FindCollectionNameForDynamic = dynamicEntity => dynamicEntity.SomeProperty
`}
</CodeBlock>
</TabItem>
<TabItem value="FindCollectionNameForDynamicSyntax" label="FindCollectionNameForDynamicSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<dynamic, string> FindCollectionNameForDynamic \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindIdentityProperty
* Use the `FindIdentityProperty` convention to define a function that finds the specified ID property  
  in the entity.

* DEFAULT: The entity's `Id` property serves as the ID property.

<TabItem value="FindIdentityProperty" label="FindIdentityProperty">
<CodeBlock language="csharp">
{`// If there exists a property with name "CustomizedId" then it will be the entity's ID property 
FindIdentityProperty = memberInfo => memberInfo.Name == "CustomizedId"
`}
</CodeBlock>
</TabItem>
<TabItem value="FindIdentityPropertySyntax" label="FindIdentityPropertySyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<MemberInfo, bool> FindIdentityProperty \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindIdentityPropertyNameFromCollectionName
* Use the `FindIdentityPropertyNameFromCollectionName` convention to define a function that customizes
  the entity's ID property from the collection name.

* DEFAULT: Will use the `Id` property.

<TabItem value="FindIdentityPropertyNameFromCollectionName" label="FindIdentityPropertyNameFromCollectionName">
<CodeBlock language="csharp">
{`// Will use property "CustomizedId" as the ID property
FindIdentityPropertyNameFromCollectionName = collectionName => "CustomizedId"
`}
</CodeBlock>
</TabItem>
<TabItem value="FindIdentityPropertyNameFromCollectionNameSyntax" label="FindIdentityPropertyNameFromCollectionNameSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<string, string> FindIdentityPropertyNameFromCollectionName \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindProjectedPropertyNameForIndex
* Use the `FindProjectedPropertyNameForIndex` convention to define a function that customizes the  
  projected fields names that will be used in the RQL sent to the server when querying an index.

* Given input: The indexed document type, the index name, the current path, and the property path  
  that is used in a query.

* DEFAULT: `null`

<TabItem value="FindProjectedPropertyNameForIndexSyntax" label="FindProjectedPropertyNameForIndexSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<Type, string, string, string, string> FindProjectedPropertyNameForIndex \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindPropertyNameForDynamicIndex
* Use the `FindPropertyNameForDynamicIndex` convention to define a function that customizes the  
  property name that will be used in the RQL sent to the server when making a dynamic query.

* Given input: The indexed document type, the index name, the current path, and the property path  
  that is used in a query predicate.

<TabItem value="FindPropertyNameForDynamicIndex" label="FindPropertyNameForDynamicIndex">
<CodeBlock language="csharp">
{`// The DEFAULT function:
FindPropertyNameForDynamicIndex = (Type indexedType, string indexedName, string path, string prop) =>
    path + prop
`}
</CodeBlock>
</TabItem>
<TabItem value="FindPropertyNameForDynamicIndexSyntax" label="FindPropertyNameForDynamicIndexSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<Type, string, string, string, string> FindPropertyNameForDynamicIndex \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FindPropertyNameForIndex
* Use the `FindPropertyNameForIndex` convention to define a function that customizes the name of the  
  index-field property that will be used in the RQL sent to the server when querying an index.

* Given input: The indexed document type, the index name, the current path, and the property path  
  that is used in a query predicate.

* DEFAULT: `[].` & `.` are replaced by `_`

<TabItem value="FindPropertyNameForIndex" label="FindPropertyNameForIndex">
<CodeBlock language="csharp">
{`// The default function:
FindPropertyNameForIndex = (Type indexedType, string indexedName, string path, string prop) => 
    (path + prop).Replace("[].", "_").Replace(".", "_")
`}
</CodeBlock>
</TabItem>
<TabItem value="FindPropertyNameForIndexSyntax" label="FindPropertyNameForIndexSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<Type, string, string, string, string> FindPropertyNameForIndex \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### FirstBroadcastAttemptTimeout
* Use the `FirstBroadcastAttemptTimeout` convention to set the timeout for the first broadcast attempt.

* In the first attempt, the request executor will send a single request to the selected node.  
  Learn about the "selected node" in: [Client logic for choosing a node](../../client-api/configuration/load-balance/overview.mdx#client-logic-for-choosing-a-node).

* A [second attempt](../../client-api/configuration/conventions.mdx#secondbroadcastattempttimeout) will be held upon failure.

* DEFAULT: `5 seconds`

<TabItem value="FirstBroadcastAttemptTimeout" label="FirstBroadcastAttemptTimeout">
<CodeBlock language="csharp">
{`FirstBroadcastAttemptTimeout = TimeSpan.FromSeconds(10)
`}
</CodeBlock>
</TabItem>
<TabItem value="FirstBroadcastAttemptTimeoutSyntax" label="FirstBroadcastAttemptTimeoutSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public TimeSpan FirstBroadcastAttemptTimeout \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### HttpClientType
* Use the `HttpClientType` convention to set the type of HTTP client you're using.

* RavenDB uses the HTTP type internally to manage its cache.

* If you override the [CreateHttpClient](../../client-api/configuration/conventions.mdx#createhttpclient) convention to use a non-default HTTP client,  
  we advise that you also set `HttpClientType` so it returns the client type you are actually using.

<TabItem value="HttpClientType" label="HttpClientType">
<CodeBlock language="csharp">
{`// The type of HTTP client you are using
HttpClientType = typeof(MyHttpClient)
`}
</CodeBlock>
</TabItem>
<TabItem value="HttpClientTypeSyntax" label="HttpClientTypeSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Type HttpClientType \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### HttpVersion
* Use the `HttpVersion` convention to set the Http version the client will use when communicating  
  with the server.

* DEFAULT:
    * When this convention is explicitly set to `null`, the default HTTP version provided by your .NET framework is used.
    * Otherwise, the default HTTP version is set to `System.Net.HttpVersion.Version20` (HTTP 2.0).

<TabItem value="HttpVersionSyntax" label="HttpVersionSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Version HttpVersion \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### IdentityPartsSeparator
* Use the `IdentityPartsSeparator` convention to set the default **ID separator** for automatically-generated document IDs.

* DEFAULT: `/` (forward slash)

* The value can be any `char` except `|` (pipe).

* Changing the separator affects these ID generation strategies:
    * [Server-Side ID](../../server/kb/document-identifier-generation.mdx#strategy--2)
    * [Identity](../../server/kb/document-identifier-generation.mdx#strategy--3)
    * [HiLo Algorithm](../../server/kb/document-identifier-generation.mdx#strategy--4)

<TabItem value="IdentityPartsSeparatorSyntax" label="IdentityPartsSeparatorSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public char IdentityPartsSeparator \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### LoadBalanceBehavior
#### LoadBalancerPerSessionContextSelector
#### LoadBalancerContextSeed
* Configure the **load balance behavior** by setting the following conventions:
    * `LoadBalanceBehavior`
    * `LoadBalancerPerSessionContextSelector`
    * `LoadBalancerContextSeed`

* Learn more in the dedicated [Load balance behavior](../../client-api/configuration/load-balance/load-balance-behavior.mdx) article.

</Admonition>
<Admonition type="note" title="Note">

#### MaxHttpCacheSize
* Use the `MaxHttpCacheSize` convention to set the maximum HTTP cache size.  
  This setting will affect all the databases accessed by the Document Store.

* DEFAULT:

  | System   | Usable Memory                                                                                         | Default Value              |
  |----------|-------------------------------------------------------------------------------------------------------|----------------------------|
  | 64-bit   | Lower than or equal to 3GB <br/> Greater than 3GB and Lower than or equal to 6GB <br/> Greater than 6GB | 64MB <br/> 128MB <br/> 512MB |
  | 32-bit   |                                                                                                       | 32MB                       |

* **Disabling Caching**:

    * To disable caching globally, set `MaxHttpCacheSize` to zero.
    * To disable caching per session, see: [Disable caching per session](../../client-api/session/configuration/how-to-disable-caching.mdx).

* Note: RavenDB also supports Aggressive Caching.  
  Learn more about that in article [Setup aggressive caching](../../client-api/how-to/setup-aggressive-caching.mdx).

<TabItem value="MaxHttpCacheSize" label="MaxHttpCacheSize">
<CodeBlock language="csharp">
{`MaxHttpCacheSize = new Size(256, SizeUnit.Megabytes) // Set max cache size
`}
</CodeBlock>
</TabItem>
<TabItem value="disable_cache" label="disable_cache">
<CodeBlock language="csharp">
{`MaxHttpCacheSize = new Size(0, SizeUnit.Megabytes) // Disable caching
`}
</CodeBlock>
</TabItem>
<TabItem value="MaxHttpCacheSizeSyntax" label="MaxHttpCacheSizeSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Size MaxHttpCacheSize \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### MaxNumberOfRequestsPerSession
* Use the `MaxNumberOfRequestsPerSession` convention to set the maximum number of requests per session.

* DEFAULT: `30`

<TabItem value="MaxNumberOfRequestsPerSessionSyntax" label="MaxNumberOfRequestsPerSessionSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public int MaxNumberOfRequestsPerSession \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### Modify serialization of property name
* Different clients use different casing conventions for entity field names. For example:

  | Language   | Default casing  | Example    |
  |------------|-----------------|------------|
  | C#         | PascalCase      | OrderLines |
  | Java       | camelCase       | orderLines |
  | JavaScript | camelCase       | orderLines |

* By default, when saving an entity, the naming convention used by the client is reflected in the JSON document properties on the server-side.  
  This default serialization behavior can be customized to facilitate language interoperability.

* **Example**:

  Set `CustomizeJsonSerializer` and `PropertyNameConverter` to serialize an entity's properties as camelCase from a C# client:

<TabItem value="PropertyCasing" label="PropertyCasing">
<CodeBlock language="csharp">
{`Serialization = new NewtonsoftJsonSerializationConventions
\{
    // .Net properties will be serialized as camelCase in the JSON document when storing an entity
    // and deserialized back to PascalCase
    CustomizeJsonSerializer = s => s.ContractResolver = new CamelCasePropertyNamesContractResolver()
\},

// In addition, the following convention is required when
// making a query that filters by a field name and when indexing. 
PropertyNameConverter = memberInfo => FirstCharToLower(memberInfo.Name)
`}
</CodeBlock>
</TabItem>
<TabItem value="FirstChar" label="FirstChar">
<CodeBlock language="csharp">
{`private string FirstCharToLower(string str) => $"\{Char.ToLower(str[0])\}\{str.Substring(1)\}";
`}
</CodeBlock>
</TabItem>
<TabItem value="SerializationSyntax" label="SerializationSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public ISerializationConventions Serialization \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### OperationStatusFetchMode
* Use the `OperationStatusFetchMode` convention to set the way an [operation](../../client-api/operations/what-are-operations.mdx) is getting its status when [waiting for completion](../../client-api/operations/what-are-operations.mdx#wait-for-completion).

* DEFAULT:  
  By default, the value is set to `ChangesApi` which uses the WebSocket protocol underneath when a connection is established with the server.

* On some older systems like Windows 7 the WebSocket protocol might not be available due to the OS and .NET Framework limitations.
  To bypass this issue, the value can be changed to `Polling`.

<TabItem value="OperationStatusFetchMode" label="OperationStatusFetchMode">
<CodeBlock language="csharp">
{`OperationStatusFetchMode = OperationStatusFetchMode.ChangesApi // ChangesApi | Polling
`}
</CodeBlock>
</TabItem>
<TabItem value="OperationStatusFetchModeSyntax" label="OperationStatusFetchModeSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public OperationStatusFetchMode OperationStatusFetchMode \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### PreserveDocumentPropertiesNotFoundOnModel
* Loading a document using a different model will result in the removal of the missing model properties  
  from the loaded entity, and no exception is thrown.

* Setting the `PreserveDocumentPropertiesNotFoundOnModel` convention to `true`  
  allows the client to check (via [whatChanged](../../client-api/session/how-to/check-if-there-are-any-changes-on-a-session.mdx#get-session-changes)
  or via [WhatChangedFor](../../client-api/session/how-to/check-if-entity-has-changed.mdx#get-entity-changes) methods)
  for the missing properties on the entity after loading the document.

* DEFAULT: `true`

<TabItem value="PreserveDocumentPropertiesNotFoundOnModelSyntax" label="PreserveDocumentPropertiesNotFoundOnModelSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool PreserveDocumentPropertiesNotFoundOnModel \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### ReadBalanceBehavior
* Configure the **read request behavior** by setting the `ReadBalanceBehavior` convention.

* Learn more in the dedicated [Read balance behavior](../../client-api/configuration/load-balance/read-balance-behavior.mdx) article.

</Admonition>
<Admonition type="note" title="Note">

#### RequestTimeout
* Use the `RequestTimeout` convention to define the global request timeout value for all `RequestExecutors` created per database.

* DEFAULT: `null` (the default HTTP client timout will be applied - 12h)

<TabItem value="RequestTimeout" label="RequestTimeout">
<CodeBlock language="csharp">
{`RequestTimeout = TimeSpan.FromSeconds(90)
`}
</CodeBlock>
</TabItem>
<TabItem value="RequestTimeoutSyntax" label="RequestTimeoutSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public TimeSpan? RequestTimeout \{ get; set; \} 
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### ResolveTypeFromClrTypeName
* Use the `ResolveTypeFromClrTypeName` convention to define a function that resolves the CLR type  
  from the CLR type name.

* DEFAULT: The type is returned.

<TabItem value="ResolveTypeFromClrTypeName" label="ResolveTypeFromClrTypeName">
<CodeBlock language="csharp">
{`// The type itself is returned by default
ResolveTypeFromClrTypeName = clrType => clrType.GetType()
`}
</CodeBlock>
</TabItem>
<TabItem value="ResolveTypeFromClrTypeNameSyntax" label="ResolveTypeFromClrTypeNameSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<string, Type> ResolveTypeFromClrTypeName \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### SaveEnumsAsIntegers
* When setting the `SaveEnumsAsIntegers` convention to `true`,  
  C# `enum` types will be stored and queried as integers, rather than their string representations.

* DEFAULT: `false` (save as strings)

<TabItem value="SaveEnumsAsIntegersSyntax" label="SaveEnumsAsIntegersSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool SaveEnumsAsIntegers \{ get; set; \} 
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### SecondBroadcastAttemptTimeout
* Use the `SecondBroadcastAttemptTimeout` convention to set the timeout for the second broadcast attempt.

* Upon failure of the [first attempt](../../client-api/configuration/conventions.mdx#firstbroadcastattempttimeout) the request executor will resend the command to all nodes simultaneously.

* DEFAULT: `30 seconds`

<TabItem value="SecondBroadcastAttemptTimeout" label="SecondBroadcastAttemptTimeout">
<CodeBlock language="csharp">
{`SecondBroadcastAttemptTimeout = TimeSpan.FromSeconds(20)
`}
</CodeBlock>
</TabItem>
<TabItem value="SecondBroadcastAttemptTimeoutSyntax" label="SecondBroadcastAttemptTimeoutSyntax">
<CodeBlock language="csharp">
{`public TimeSpan SecondBroadcastAttemptTimeout \{ get; set; \} 
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### SendApplicationIdentifier
* Use the `SendApplicationIdentifier` convention to `true` to enable sending a unique application identifier to the RavenDB Server.

* Setting to _true_ allows the server to issue performance hint notifications to the client,
  e.g. during robust topology update requests which could indicate a Client API misuse impacting the overall performance.

* DEFAULT: `true`

<TabItem value="SendApplicationIdentifierSyntax" label="SendApplicationIdentifierSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool SendApplicationIdentifier \{ get; set; \} 
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### ShouldIgnoreEntityChanges
* Set the `ShouldIgnoreEntityChanges` convention to disable entity tracking for certain entities.

* Learn more in [Customize tracking in conventions](../../client-api/session/configuration/how-to-disable-tracking.mdx#customize-tracking-in-conventions).

</Admonition>
<Admonition type="note" title="Note">

#### TopologyCacheLocation
* Use the `TopologyCacheLocation` convention to change the location of the topology cache files   
  (`*.raven-database-topology` & `*.raven-cluster-topology`).

* Directory existence and writing permissions will be checked when setting this value.

* DEFAULT: `AppContext.BaseDirectory` (The application's base directory)

<TabItem value="TopologyCacheLocation" label="TopologyCacheLocation">
<CodeBlock language="csharp">
{`TopologyCacheLocation = @"C:\\RavenDB\\TopologyCache"
`}
</CodeBlock>
</TabItem>
<TabItem value="TopologyCacheLocationSyntax" label="TopologyCacheLocationSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public string TopologyCacheLocation \{ get; set; \} 
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### TransformTypeCollectionNameToDocumentIdPrefix
* Use the `TransformTypeCollectionNameToDocumentIdPrefix` convention to define a function that will  
  customize the document ID prefix from the the collection name.

* DEFAULT:  
  By default, the document id prefix is determined as follows:

| Number of uppercase letters in collection name   | Document ID prefix                                          |
|--------------------------------------------------|-------------------------------------------------------------|
| `<= 1`                                           | Use the collection name with all lowercase letters          |
| `> 1`                                            | Use the collection name as is, preserving the original case |

<TabItem value="TransformTypeCollectionNameToDocumentIdPrefixSyntax" label="TransformTypeCollectionNameToDocumentIdPrefixSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public Func<string, string> TransformTypeCollectionNameToDocumentIdPrefix \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### UseHttpCompression
* When setting the `UseHttpCompression` convention to `true`,  
  then `Gzip` compression will be used when sending content of HTTP request.

* When the convention is set to `false`, content will not be compressed.

* DEFAULT: `true`

<TabItem value="UseHttpCompressionSyntax" label="UseHttpCompressionSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool UseHttpCompression \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### UseHttpDecompression
* When setting the `UseHttpDecompression` convention to `true`,  
  the client can accept compressed HTTP response content and will use zstd/gzip/deflate decompression methods.

* DEFAULT: `true`

<TabItem value="UseHttpDecompressionSyntax" label="UseHttpDecompressionSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool UseHttpDecompression \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### UseOptimisticConcurrency
* When setting the `UseOptimisticConcurrency` convention to `true`,  
  Optimistic Concurrency checks will be applied for all sessions opened from the Document Store.

* Learn more about Optimistic Concurrency and the various ways to enable it in article  
  [how to enable optimistic concurrency](../../client-api/session/configuration/how-to-enable-optimistic-concurrency.mdx).

* DEFAULT: `false`

<TabItem value="UseOptimisticConcurrencySyntax" label="UseOptimisticConcurrencySyntax">
<CodeBlock language="csharp">
{`// Syntax:
public bool UseOptimisticConcurrency \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### WaitForIndexesAfterSaveChangesTimeout
* Use the `WaitForIndexesAfterSaveChangesTimeout` convention to set the default timeout for the
  `DocumentSession.Advanced.WaitForIndexesAfterSaveChanges` method.

* DEFAULT: 15 Seconds

<TabItem value="WaitForIndexesAfterSaveChangesTimeout" label="WaitForIndexesAfterSaveChangesTimeout">
<CodeBlock language="csharp">
{`WaitForIndexesAfterSaveChangesTimeout = TimeSpan.FromSeconds(10)
`}
</CodeBlock>
</TabItem>
<TabItem value="WaitForIndexesAfterSaveChangesTimeoutSyntax" label="WaitForIndexesAfterSaveChangesTimeoutSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public TimeSpan WaitForIndexesAfterSaveChangesTimeout \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### WaitForNonStaleResultsTimeout
* Use the `WaitForNonStaleResultsTimeout` convention to set the default timeout used by the  
  `WaitForNonStaleResults` method when querying.

* DEFAULT: 15 Seconds

<TabItem value="WaitForNonStaleResultsTimeout" label="WaitForNonStaleResultsTimeout">
<CodeBlock language="csharp">
{`WaitForNonStaleResultsTimeout = TimeSpan.FromSeconds(10)
`}
</CodeBlock>
</TabItem>
<TabItem value="WaitForNonStaleResultsTimeoutSyntax" label="WaitForNonStaleResultsTimeoutSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public TimeSpan WaitForNonStaleResultsTimeout \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### WaitForReplicationAfterSaveChangesTimeout
* Use the `WaitForReplicationAfterSaveChangesTimeout` convention to set the default timeout for the  
  `DocumentSession.Advanced.WaitForReplicationAfterSaveChanges`method.

* DEFAULT: 15 Seconds

<TabItem value="WaitForReplicationAfterSaveChangesTimeout" label="WaitForReplicationAfterSaveChangesTimeout">
<CodeBlock language="csharp">
{`WaitForReplicationAfterSaveChangesTimeout = TimeSpan.FromSeconds(10)
`}
</CodeBlock>
</TabItem>
<TabItem value="WaitForReplicationAfterSaveChangesTimeoutSyntax" label="WaitForReplicationAfterSaveChangesTimeoutSyntax">
<CodeBlock language="csharp">
{`// Syntax:
public TimeSpan WaitForReplicationAfterSaveChangesTimeout \{ get; set; \}
`}
</CodeBlock>
</TabItem>

</Admonition>



</LanguageContent>
<LanguageContent language="nodejs">


<Admonition type="note" title="Note">

* **Conventions** in RavenDB are customizable settings that users can configure to tailor client behaviors according to their preferences.
 
* In this page:  
  * [How to set conventions](../../client-api/configuration/conventions.mdx#how-to-set-conventions)  
  * [Conventions:](../../client-api/configuration/conventions.mdx#conventions:)  
      [customFetch](../../client-api/configuration/conventions.mdx#customfetch)  
      [disableAtomicDocumentWritesInClusterWideTransaction](../../client-api/configuration/conventions.mdx#disableatomicdocumentwritesinclusterwidetransaction)  
      [disableTopologyUpdates](../../client-api/configuration/conventions.mdx#disabletopologyupdates)  
      [findCollectionName](../../client-api/configuration/conventions.mdx#findcollectionname)  
      [findJsType](../../client-api/configuration/conventions.mdx#_findjstype)  
      [findJsTypeName](../../client-api/configuration/conventions.mdx#_findjstypename)  
      [firstBroadcastAttemptTimeout](../../client-api/configuration/conventions.mdx#firstbroadcastattempttimeout)  
      [identityPartsSeparator](../../client-api/configuration/conventions.mdx#identitypartsseparator)  
      [loadBalanceBehavior](../../client-api/configuration/conventions.mdx#loadbalancebehavior)  
      [loadBalancerContextSeed](../../client-api/configuration/conventions.mdx#loadbalancebehavior)  
      [loadBalancerPerSessionContextSelector](../../client-api/configuration/conventions.mdx#loadbalancebehavior)  
      [maxHttpCacheSize](../../client-api/configuration/conventions.mdx#maxhttpcachesize)  
      [maxNumberOfRequestsPerSession](../../client-api/configuration/conventions.mdx#maxnumberofrequestspersession)  
      [readBalanceBehavior](../../client-api/configuration/conventions.mdx#readbalancebehavior)  
      [requestTimeout](../../client-api/configuration/conventions.mdx#requesttimeout)  
      [secondBroadcastAttemptTimeout](../../client-api/configuration/conventions.mdx#secondbroadcastattempttimeout)  
      [sendApplicationIdentifier](../../client-api/configuration/conventions.mdx#sendapplicationidentifier)  
      [shouldIgnoreEntityChanges](../../client-api/configuration/conventions.mdx#shouldignoreentitychanges)  
      [storeDatesInUtc](../../client-api/configuration/conventions.mdx#storedatesinutc)  
      [storeDatesWithTimezoneInfo](../../client-api/configuration/conventions.mdx#storedateswithtimezoneinfo)  
      [syncJsonParseLimit](../../client-api/configuration/conventions.mdx#syncjsonparselimit)  
      [throwIfQueryPageSizeIsNotSet](../../client-api/configuration/conventions.mdx#throwifquerypagesizeisnotset)  
      [transformClassCollectionNameToDocumentIdPrefix](../../client-api/configuration/conventions.mdx#transformclasscollectionnametodocumentidprefix)  
      [useCompression](../../client-api/configuration/conventions.mdx#usecompression)  
      [useJsonlStreaming](../../client-api/configuration/conventions.mdx#usejsonlstreaming)  
      [useOptimisticConcurrency](../../client-api/configuration/conventions.mdx#useoptimisticconcurrency)  
      [waitForIndexesAfterSaveChangesTimeout](../../client-api/configuration/conventions.mdx#waitforindexesaftersavechangestimeout)  
      [waitForNonStaleResultsTimeout](../../client-api/configuration/conventions.mdx#waitfornonstaleresultstimeout)  
      [waitForReplicationAfterSaveChangesTimeout](../../client-api/configuration/conventions.mdx#waitforreplicationaftersavechangestimeout)  

</Admonition>
## How to set conventions

* Access the conventions via the `conventions` property of the `DocumentStore` object.

* The conventions set on a Document Store will apply to ALL [sessions](../../client-api/session/what-is-a-session-and-how-does-it-work.mdx) and [operations](../../client-api/operations/what-are-operations.mdx) associated with that store.
 
* Customizing the conventions can only be set **before** calling `documentStore.initialize()`.  
  Trying to do so after calling _initialize()_ will throw an exception.

<TabItem value="conventions_1" label="conventions_1">
<CodeBlock language="js">
{`const documentStore = new DocumentStore(["serverUrl_1", "serverUrl_2", "..."], "DefaultDB");

// Set conventions HERE, e.g.:
documentStore.conventions.maxNumberOfRequestsPerSession = 50;
documentStore.conventions.disableTopologyUpdates = true;

documentStore.initialize();

// * Here you can interact with the RavenDB store:
//   open sessions, create or query for documents, perform operations, etc.

// * Conventions CANNOT be set here after calling initialize()
`}
</CodeBlock>
</TabItem>



## Conventions:

<Admonition type="note" title="Note">

#### customFetch
* Use the `customFetch` convention to override the default _fetch_ method.  
  This method is useful to enable RavenDB Node.js client on CloudFlare Workers.

* DEFAULT: undefined

<TabItem value="customFetchSyntax" label="customFetchSyntax">
<CodeBlock language="js">
{`// Returns an object
get customFetch();
// Set an object bound to worker with type: mtls_certificate
set customFetch(customFetch);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### disableAtomicDocumentWritesInClusterWideTransaction
* EXPERT ONLY:   
  Use the `disableAtomicDocumentWritesInClusterWideTransaction` convention to disable automatic  
  atomic writes with cluster write transactions.

* When set to `true`, will only consider explicitly added compare exchange values to validate cluster wide transactions.

* DEFAULT: `false`

<TabItem value="disableAtomicDocumentWritesInClusterWideTransactionSyntax" label="disableAtomicDocumentWritesInClusterWideTransactionSyntax">
<CodeBlock language="js">
{`// Returns a boolean value
get disableAtomicDocumentWritesInClusterWideTransaction();
// Set a boolean value
set disableAtomicDocumentWritesInClusterWideTransaction(
    disableAtomicDocumentWritesInClusterWideTransaction
);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### disableTopologyUpdates
* When setting the `disableTopologyUpdates` convention to `true`,  
  no database topology updates will be sent from the server to the client (e.g. adding or removing a node).
 
* DEFAULT: `false`

<TabItem value="disableTopologyUpdatesSyntax" label="disableTopologyUpdatesSyntax">
<CodeBlock language="js">
{`// Returns a boolean value
get disableTopologyUpdates();
// Set a boolean value
set disableTopologyUpdates(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### findCollectionName
* Use the `findCollectionName` convention to define a function that will customize the collection name  
  from given type.

* DEFAULT: The collection name will be the plural form of the type name.

<TabItem value="findCollectionNameSyntax" label="findCollectionNameSyntax">
<CodeBlock language="js">
{`// Returns a method
get findCollectionName();
// Set a method
set findCollectionName(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### findJsType
* Use the `findJsType` convention to define a function that finds the class of a document (if exists).

* The type is retrieved from the `Raven-Node-Type` property under the `@metadata` key in the document.

* DEFAULT: `null`

<TabItem value="findJsTypeSyntax" label="findJsTypeSyntax">
<CodeBlock language="js">
{`// Returns a method
get findJsType();
// Set a method
set findJsType(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### findJsTypeName
* Use the `findJsTypeName` convention to define a function that returns the class type name from a given type.

* The class name will be stored in the entity metadata.

* DEFAULT: `null`

<TabItem value="findJsTypeNameSyntax" label="findJsTypeNameSyntax">
<CodeBlock language="js">
{`// Returns a method
get findJsTypeName();
// Set a method
set findJsTypeName(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### firstBroadcastAttemptTimeout
* Use the `firstBroadcastAttemptTimeout` convention to set the timeout for the first broadcast attempt.  
 
* In the first attempt, the request executor will send a single request to the selected node.  
  Learn about the "selected node" in: [Client logic for choosing a node](../../client-api/configuration/load-balance/overview.mdx#client-logic-for-choosing-a-node).
 
* A [second attempt](../../client-api/configuration/conventions.mdx#secondbroadcastattempttimeout) will be held upon failure.
 
* DEFAULT: `5 seconds`

<TabItem value="firstBroadcastAttemptTimeoutSyntax" label="firstBroadcastAttemptTimeoutSyntax">
<CodeBlock language="js">
{`// Returns a number
get firstBroadcastAttemptTimeout();
// Set a number
set firstBroadcastAttemptTimeout(firstBroadcastAttemptTimeout);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### identityPartsSeparator
* Use the `identityPartsSeparator` convention to set the default **ID separator** for automatically-generated document IDs.
 
* DEFAULT: `/` (forward slash)  
 
* The value can be any `char` except `|` (pipe).
 
* Changing the separator affects these ID generation strategies:  
  * [Server-Side ID](../../server/kb/document-identifier-generation.mdx#strategy--2)
  * [Identity](../../server/kb/document-identifier-generation.mdx#strategy--3)
  * [HiLo Algorithm](../../server/kb/document-identifier-generation.mdx#strategy--4)

<TabItem value="identityPartsSeparatorSyntax" label="identityPartsSeparatorSyntax">
<CodeBlock language="js">
{`// Returns a string
get identityPartsSeparator();
// Set a string
set identityPartsSeparator(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### loadBalanceBehavior
#### loadBalancerPerSessionContextSelector
#### loadBalancerContextSeed
* Configure the **load balance behavior** by setting the following conventions:
  * `loadBalanceBehavior`
  * `loadBalancerPerSessionContextSelector`
  * `loadBalancerContextSeed`

* Learn more in the dedicated [Load balance behavior](../../client-api/configuration/load-balance/load-balance-behavior.mdx) article.

</Admonition>
<Admonition type="note" title="Note">

#### maxHttpCacheSize
* Use the `MaxHttpCacheSize` convention to set the maximum HTTP cache size.  
  This setting will affect all the databases accessed by the Document Store.
 
* DEFAULT: `128 MB`

* **Disabling Caching**:

    * To disable caching globally, set `MaxHttpCacheSize` to zero.
    * To disable caching per session, see: [Disable caching per session](../../client-api/session/configuration/how-to-disable-caching.mdx).

* Note: RavenDB also supports Aggressive Caching.  
  Learn more about that in article [Setup aggressive caching](../../client-api/how-to/setup-aggressive-caching.mdx).

<TabItem value="maxHttpCacheSizeSyntax" label="maxHttpCacheSizeSyntax">
<CodeBlock language="js">
{`// Returns a number
get maxHttpCacheSize();
// Set a number
set maxHttpCacheSize(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### maxNumberOfRequestsPerSession
* Use the `maxNumberOfRequestsPerSession` convention to set the maximum number of requests per session.
 
* DEFAULT: `30`
 
<TabItem value="maxNumberOfRequestsPerSessionSyntax" label="maxNumberOfRequestsPerSessionSyntax">
<CodeBlock language="js">
{`// Returns a number
get maxNumberOfRequestsPerSession();
// Set a number
set maxNumberOfRequestsPerSession(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### readBalanceBehavior
* Configure the **read request behavior** by setting the `readBalanceBehavior` convention.

* Learn more in the dedicated [Read balance behavior](../../client-api/configuration/load-balance/read-balance-behavior.mdx) article.

</Admonition>
<Admonition type="note" title="Note">

#### requestTimeout
* Use the `requestTimeout` convention to define the global request timeout value for all `RequestExecutors` created per database.
 
* DEFAULT: `null` (the default HTTP client timout will be applied - 12h)

<TabItem value="requestTimeoutSyntax" label="requestTimeoutSyntax">
<CodeBlock language="js">
{`// Returns a number
get requestTimeout();
// Set a number
set requestTimeout(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### secondBroadcastAttemptTimeout
* Use the `secondBroadcastAttemptTimeout` convention to set the timeout for the second broadcast attempt.
 
* Upon failure of the [first attempt](../../client-api/configuration/conventions.mdx#firstbroadcastattempttimeout) the request executor will resend the command to all nodes simultaneously.
 
* DEFAULT: `30 seconds`

<TabItem value="secondBroadcastAttemptTimeoutSyntax" label="secondBroadcastAttemptTimeoutSyntax">
<CodeBlock language="js">
{`// Returns a number
get secondBroadcastAttemptTimeout();
// Set a number
set secondBroadcastAttemptTimeout(timeout);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### sendApplicationIdentifier
* Use the `sendApplicationIdentifier` convention to `true` to enable sending a unique application identifier to the RavenDB Server.

* Setting to _true_ allows the server to issue performance hint notifications to the client, 
  e.g. during robust topology update requests which could indicate a Client API misuse impacting the overall performance.

* DEFAULT: `true`

<TabItem value="sendApplicationIdentifierSyntax" label="sendApplicationIdentifierSyntax">
<CodeBlock language="js">
{`// Returns a boolean
get sendApplicationIdentifier();
// Set a boolean
set sendApplicationIdentifier(sendApplicationIdentifier)
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### shouldIgnoreEntityChanges
* Set the `shouldIgnoreEntityChanges` convention to disable entity tracking for certain entities.  
 
* Learn more in [Customize tracking in conventions](../../client-api/session/configuration/how-to-disable-tracking.mdx#customize-tracking-in-conventions).

</Admonition>
<Admonition type="note" title="Note">

#### storeDatesInUtc
* When setting the `storeDatesInUtc` convention to `true`,  
  DateTime values will be stored in the database in UTC format.

* DEFAULT: `false`

<TabItem value="storeDatesInUtcSyntax" label="storeDatesInUtcSyntax">
<CodeBlock language="js">
{`// Returns a boolean
get storeDatesInUtc();
// Set a boolean
set storeDatesInUtc(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### storeDatesWithTimezoneInfo
* When setting the `storeDatesWithTimezoneInfo` to `true`,  
  DateTime values will be stored in the database with their time zone information included.

* DEFAULT: `false`

<TabItem value="storeDatesWithTimezoneInfoSyntax" label="storeDatesWithTimezoneInfoSyntax">
<CodeBlock language="js">
{`// Returns a boolean
get storeDatesWithTimezoneInfo();
// Set a boolean
set storeDatesWithTimezoneInfo(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### syncJsonParseLimit
* Use the `syncJsonParseLimit` convention to define the maximum size for the _sync_ parsing of the JSON data responses received from the server.  
  For data exceeding this size, the client switches to _async_ parsing.

* DEFAULT: `2 * 1_024 * 1_024`

<TabItem value="syncJsonParseLimitSyntax" label="syncJsonParseLimitSyntax">
<CodeBlock language="js">
{`// Returns a number
get syncJsonParseLimit();
// Set a number
set syncJsonParseLimit(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### throwIfQueryPageSizeIsNotSet
* When setting the `throwIfQueryPageSizeIsNotSet` convention to `true`,  
  an exception will be thrown if a query is performed without explicitly setting a page size.

* This can be useful during development to identify potential performance bottlenecks
  since there is no limitation on the number of results returned from the server.

* DEFAULT: `false`

<TabItem value="throwIfQueryPageSizeIsNotSetSyntax" label="throwIfQueryPageSizeIsNotSetSyntax">
<CodeBlock language="js">
{`// Returns a boolean
get throwIfQueryPageSizeIsNotSet();
// Set a boolean
set throwIfQueryPageSizeIsNotSet(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### transformClassCollectionNameToDocumentIdPrefix
* Use the `transformTypeCollectionNameToDocumentIdPrefix` convention to define a function that will  
  customize the document ID prefix from the the collection name.

* DEFAULT:  
  By default, the document id prefix is determined as follows:

| Number of uppercase letters in collection name   | Document ID prefix                                          |
|--------------------------------------------------|-------------------------------------------------------------|
| `<= 1`                                           | Use the collection name with all lowercase letters          |
| `> 1`                                            | Use the collection name as is, preserving the original case |

<TabItem value="transformClassCollectionNameToDocumentIdPrefixSyntax" label="transformClassCollectionNameToDocumentIdPrefixSyntax">
<CodeBlock language="js">
{`// Returns a method
get transformClassCollectionNameToDocumentIdPrefix();
// Set a method
set transformClassCollectionNameToDocumentIdPrefix(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### useCompression
* Set the `useCompression` convention to true in order to accept the **response** in compressed format and the automatic decompression of the HTTP response content.

* A `Gzip` compression is always applied when sending content in an HTTP request.
 
* DEFAULT: `true`  

<TabItem value="useCompressionSyntax" label="useCompressionSyntax">
<CodeBlock language="js">
{`// Returns a boolean
get useCompression();
// Set a boolean
set useCompression(value);
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

#### useJsonlStreaming
* Set the `useJsonlStreaming` convention to `true` when streaming query results as JSON Lines (JSONL) format.

* DEFAULT: `true`

<TabItem value="useJsonlStreamingSyntax" label="useJsonlStreamingSyntax">
<CodeBlock language="js">
{`// Returns a boolean
get useJsonlStreaming();
// Set a boolean
set useJsonlStreaming(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### useOptimisticConcurrency
* When setting the `useOptimisticConcurrency` convention to `true`,  
  Optimistic Concurrency checks will be applied for all sessions opened from the Document Store. 

* Learn more about Optimistic Concurrency and the various ways to enable it in article  
  [how to enable optimistic concurrency](../../client-api/session/configuration/how-to-enable-optimistic-concurrency.mdx).

* DEFAULT: `false`  

<TabItem value="useOptimisticConcurrencySyntax" label="useOptimisticConcurrencySyntax">
<CodeBlock language="js">
{`// Returns a boolean
get useOptimisticConcurrency();
// Set a boolean
set useOptimisticConcurrency(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### waitForIndexesAfterSaveChangesTimeout
* Use the `waitForIndexesAfterSaveChangesTimeout` convention to set the default timeout for the 
  `documentSession.advanced.waitForIndexesAfterSaveChanges` method.  
 
* DEFAULT: 15 Seconds

<TabItem value="waitForIndexesAfterSaveChangesTimeoutSyntax" label="waitForIndexesAfterSaveChangesTimeoutSyntax">
<CodeBlock language="js">
{`// Returns a number
get waitForIndexesAfterSaveChangesTimeout();
// Set a number
set waitForIndexesAfterSaveChangesTimeout(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### waitForNonStaleResultsTimeout
* Use the `waitForNonStaleResultsTimeout` convention to set the default timeout used by the  
  `waitForNonStaleResults` method when querying.  
 
* DEFAULT: 15 Seconds  

<TabItem value="waitForNonStaleResultsTimeoutSyntax" label="waitForNonStaleResultsTimeoutSyntax">
<CodeBlock language="js">
{`// Returns a number
get waitForNonStaleResultsTimeout();
// Set a number
set waitForNonStaleResultsTimeout(value);
`}
</CodeBlock>
</TabItem>

</Admonition>
<Admonition type="note" title="Note">

#### waitForReplicationAfterSaveChangesTimeout
* Use the `waitForReplicationAfterSaveChangesTimeout` convention to set the default timeout for the  
  `documentSession.advanced.waitForReplicationAfterSaveChanges`method.  
 
* DEFAULT: 15 Seconds  

<TabItem value="waitForReplicationAfterSaveChangesTimeoutSyntax" label="waitForReplicationAfterSaveChangesTimeoutSyntax">
<CodeBlock language="js">
{`// Returns a number
get waitForReplicationAfterSaveChangesTimeout();
// Set a number
set waitForReplicationAfterSaveChangesTimeout(value);
`}
</CodeBlock>
</TabItem>

</Admonition>



</LanguageContent>

<!---
### Conventions
- [Querying](../../client-api/configuration/querying)
- [Serialization](../../client-api/configuration/serialization)
- [Load Balancing Client Requests](../../client-api/configuration/load-balance/overview)

### Document Identifiers
- [Working with Document Identifiers](../../client-api/document-identifiers/working-with-document-identifiers)
- [Global ID Generation Conventions](../../client-api/configuration/identifier-generation/global)
- [Type-specific ID Generation Conventions](../../client-api/configuration/identifier-generation/type-specific)

### Document Store
- [What is a Document Store](../../client-api/what-is-a-document-store)


-->