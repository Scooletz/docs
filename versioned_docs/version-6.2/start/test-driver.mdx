---
title: "Getting Started: Writing your Unit Test using TestDriver"
sidebar_label: Unit Tests
sidebar_position: 4
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];


# Getting Started: Writing your Unit Test using TestDriver
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* In this section, we explain how to use [RavenDB.TestDriver](https://www.nuget.org/packages/RavenDB.TestDriver/) 
  to write RavenDB unit tests.  

* TestDriver uses an [Embedded Server](../server/embedded.mdx) package with the same set of 
  [prerequisites](../server/embedded.mdx#prerequisite) as embedded servers to run the tests.  

* In this page: 
   - [`RavenTestDriver`](../start/test-driver.mdx#raventestdriver)
   - [Pre-initializing the store: `PreInitialize`](../start/test-driver.mdx#pre-initializing-the-store:-preinitialize)
   - [Configure the server: `ConfigureServer`](../start/test-driver.mdx#configure-the-server:-configureserver)
   - [Unit test](../start/test-driver.mdx#unit-test)
   - [Complete example](../start/test-driver.mdx#complete-example)
   - [Continuous Integration (CI) Servers](../start/test-driver.mdx#continuous-integration-(ci)-servers)
   - [Licensing](../start/test-driver.mdx#licensing)

</Admonition>

## `RavenTestDriver`

Start by creating a class that derives from `RavenTestDriver`.  
Find below a list of test driver methods, followed by [samples](../start/test-driver.mdx#complete-example).  

### TestDriver Methods

#### `DatabaseDumpFilePath`
Override the path to the database dump file that is loaded when calling ImportDatabase.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual string DatabaseDumpFilePath => null;
`}
</CodeBlock>
</TabItem>  

#### `DatabaseDumpFileStream`
Allow overriding the stream containing the database dump loaded when calling ImportDatabase.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual Stream DatabaseDumpFileStream => null;
`}
</CodeBlock>
</TabItem>  

#### `GetDocumentStore`
Get an IDocumentStore instance for the requested database.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public IDocumentStore GetDocumentStore([CallerMemberName] string database = null, 
                                                TimeSpan? waitForIndexingTimeout = null)
`}
</CodeBlock>
</TabItem>  
  
#### `PreInitialize`
Pre-initialize IDocumentStore.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void PreInitialize(IDocumentStore documentStore)
`}
</CodeBlock>
</TabItem>  

#### `PreConfigureDatabase`
Pre configure the database record before creating it.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void PreConfigureDatabase(DatabaseRecord databaseRecord)
`}
</CodeBlock>
</TabItem>  

#### `SetupDatabase`
Initialize the database  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void SetupDatabase(IDocumentStore documentStore)
`}
</CodeBlock>
</TabItem>  

#### `DriverDisposed`  
An event raised when the test driver is disposed of  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected event EventHandler DriverDisposed;
`}
</CodeBlock>
</TabItem>  

#### `ConfigureServer`  
Configure the server before running it
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public static void ConfigureServer(TestServerOptions options)
`}
</CodeBlock>
</TabItem>  

#### `WaitForIndexing`
Wait for indexes to become non-stale  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public void WaitForIndexing(IDocumentStore store, string database = null, 
                                                    TimeSpan? timeout = null)
`}
</CodeBlock>
</TabItem>  

#### `WaitForUserToContinueTheTest`  
Pause the test and launch Studio to examine database state  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public void WaitForUserToContinueTheTest(IDocumentStore store)
`}
</CodeBlock>
</TabItem>  

#### `OpenBrowser`  
Open browser  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void OpenBrowser(string url)
`}
</CodeBlock>
</TabItem>  

#### `Dispose`  
Dispose of the server  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public virtual void Dispose()
`}
</CodeBlock>
</TabItem>  



## Pre-initializing the store: `PreInitialize`

Pre-Initializing the IDocumentStore allows you to mutate the conventions used by the document store.

### Example

<TabItem value="test_driver_PreInitialize" label="test_driver_PreInitialize">
<CodeBlock language="csharp">
{`//This allows us to modify the conventions of the store we get from 'GetDocumentStore'
protected override void PreInitialize(IDocumentStore documentStore)
\{
    documentStore.Conventions.MaxNumberOfRequestsPerSession = 50;
\}
`}
</CodeBlock>
</TabItem>



## Configure the server: `ConfigureServer`

The `ConfigureServer` method allows you to be more in control of your server.  
You can use it with `TestServerOptions` to change the path to the Raven server binaries, specify data storage path, adjust .NET framework versions, etc.

* `ConfigureServer` can only be set once per test run.  
  It needs to be set before `GetDocumentStore` is called.  
  See an [example](../start/test-driver.mdx#complete-example) below.  

* If it is called twice, or within the `DocumentStore` scope, you will get the following error message:
  `System.InvalidOperationException : Cannot configure server after it was started. Please call 'ConfigureServer' method before any 'GetDocumentStore' is called.`  

<Admonition type="info" title="TestServerOptions" id="testserveroptions" href="#testserveroptions">

Defining TestServerOptions allows you to be more in control of 
how the embedded server is going to run with just a minor [definition change](../start/test-driver.mdx#example-2).

* To see the complete list of `TestServerOptions`, which inherits from embedded servers, go to embedded [ServerOptions](../server/embedded.mdx#serveroptions).  
* It's important to be sure that the correct [.NET FrameworkVersion](../server/embedded.mdx#net-frameworkversion) is set.

</Admonition>

#### Example

<TabItem value="test_driver_ConfigureServer" label="test_driver_ConfigureServer">
<CodeBlock language="csharp">
{`var testServerOptions = new TestServerOptions
\{
    // Looks for the newest version on your machine including 3.1.15 and any newer patches
    // but not major new releases (default is .NET version at time of server release).
    FrameworkVersion = "3.1.15+",

    // Specifies where ravendb server binaries are located (Optional)
    ServerDirectory = "PATH_TO_RAVENDB_SERVER",

    // Specifies where ravendb data will be placed/located (Optional)
    DataDirectory = "PATH_TO_RAVENDB_DATADIR", 
\};

ConfigureServer(testServerOptions);
`}
</CodeBlock>
</TabItem>



## Unit test

We use [xunit](https://www.nuget.org/packages/xunit/) for the test framework in the below example.  

<Admonition type="note" title="Note">
Note that the test itself is meant to show different capabilities of the test driver and is not meant to be the most efficient.  
</Admonition>

The example below depends on the `TestDocumentByName` index and `TestDocument` class that can be seen in the [full example](../start/test-driver.mdx#complete-example)

#### Example

In the example, we get an `IDocumentStore` object to our test database, deploy an index, and insert two documents into the document store.  

We then use `WaitForUserToContinueTheTest(store)` which launches the Studio so we can verify that the documents 
and index are deployed (we can remove this line after the test succeeds).  

Finally, we use `session.Query` to query for "TestDocument" where the name contains the word 'hello', 
and we assert that we have only one such document.

<TabItem value="test_driver_MyFirstTest" label="test_driver_MyFirstTest">
<CodeBlock language="csharp">
{`[Fact]
public void MyFirstTest()
\{
    using (var store = GetDocumentStore())
    \{
        store.ExecuteIndex(new TestDocumentByName());
        using (var session = store.OpenSession())
        \{
            session.Store(new TestDocument \{ Name = "Hello world!" \});
            session.Store(new TestDocument \{ Name = "Goodbye..." \});
            session.SaveChanges();
        \}
        // If we want to query documents, sometimes we need to wait for the indexes to catch up  
        // to prevent using stale indexes.
        WaitForIndexing(store);

        // Sometimes we want to debug the test itself. This method redirects us to the studio
        // so that we can see if the code worked as expected (in this case, created two documents).
        WaitForUserToContinueTheTest(store);

        using (var session = store.OpenSession())
        \{
            var query = session.Query<TestDocument, TestDocumentByName>().Where(x => x.Name == "hello").ToList();
            Assert.Single(query);
        \}
    \}
\}
`}
</CodeBlock>
</TabItem>



## Complete example

This is a full unit test using [Xunit](https://www.nuget.org/packages/xunit/).

In the test, we get an `IDocumentStore` object to our test database, deploy an index, and insert two documents into the document store.  

We then use `WaitForUserToContinueTheTest(store)` which launches the Studio so we can verify that the documents 
and index are deployed (we can remove this line after the test succeeds).  

Finally, we use `session.Query` to query for "TestDocument" where the name contains the word 'hello', 
and we assert that we have only one such document.

<TabItem value="test_full_example" label="test_full_example">
<CodeBlock language="csharp">
{`using Raven.Client.Documents;
using Raven.TestDriver;
using Xunit;
using System.Linq;
using Raven.Client.Documents.Indexes;

namespace RavenDBTestDriverFullExample
\{

    public class RavenDBTestDriver : RavenTestDriver
    \{
        static RavenDBTestDriver()
        \{
            // ConfigureServer() must be set before calling GetDocumentStore()
            // and can only be set once per test run.
            ConfigureServer(new TestServerOptions
            \{
                DataDirectory = "C:\\\\RavenDBTestDir"
            \});
        \}
        // This allows us to modify the conventions of the store we get from 'GetDocumentStore'
        protected override void PreInitialize(IDocumentStore documentStore)
        \{
            documentStore.Conventions.MaxNumberOfRequestsPerSession = 50;
        \}

        [Fact]
        public void MyFirstTest()
        \{
            // GetDocumentStore() evokes the Document Store, which establishes and manages communication
            // between your client application and a RavenDB cluster via HTTP requests.
            using (var store = GetDocumentStore())
            \{
                store.ExecuteIndex(new TestDocumentByName());
                using (var session = store.OpenSession())
                \{
                    session.Store(new TestDocument \{ Name = "Hello world!" \});
                    session.Store(new TestDocument \{ Name = "Goodbye..." \});
                    session.SaveChanges();
                \}
                // If we want to query documents, sometimes we need to wait for the indexes to catch up  
                // to prevent using stale indexes.
                WaitForIndexing(store);

                // Sometimes we want to debug the test itself. This method redirects us to the studio
                // so that we can see if the code worked as expected (in this case, created two documents).
                WaitForUserToContinueTheTest(store);

                // Queries are defined in the session scope.
                // If there is no relevant index to quickly answer the query, RavenDB creates an auto-index
                // based on the query parameters.
                // This query will use the static index defined in lines 63-70 and filter the results by name.
                using (var session = store.OpenSession())
                \{
                    var query = session.Query<TestDocument, TestDocumentByName>()
                        .Where(x => x.Name == "hello").ToList();
                    Assert.Single(query);
                \}
            \}
        \}
    \}
    // AbstractIndexCreationTask allows you to create and manually define a static index. 
    public class TestDocumentByName : AbstractIndexCreationTask<TestDocument>
    \{
        public TestDocumentByName()
        \{
            Map = docs => from doc in docs select new \{ doc.Name \};
            Indexes.Add(x => x.Name, FieldIndexing.Search);
        \}
    \}

    public class TestDocument
    \{
        public string Name \{ get; set; \}
    \}
\}
`}
</CodeBlock>
</TabItem>



## Continuous Integration (CI) Servers

Best practice is to use a CI/CD server to help automate the testing and deployment of your new code. 
Popular CI/CD products are [AppVeyor](https://www.appveyor.com/) or [Visual Studio Team Services (aka. VSTS)](https://visualstudio.microsoft.com/team-services/).



## Licensing

The embedded server that TestDriver uses while running your tests can only apply the 
features and access the resources defined by its [license](https://ravendb.net/buy).  
An unlicensed server, for example, will be able to use no more than 3 CPU cores, while 
a server licensed using a [free developers license](https://ravendb.net/buy#developer) 
will be able to use up to 9 cores and run way faster.  

* When the server is started, its license is validated.  
   * If the validation succeeds, the server will run, applying the capabilities defined 
     by its license.  
   * If the validation fails, the server may still run - but its capabilities will be 
     limited to those defined by the basic [AGPL](https://ravendb.net/legal/ravendb/commercial-license-eula) 
     license (e.g., using up to 3 CPU cores).  
     <Admonition type="note" title="Note">
     If the validation fails because the license expired, and the expiration date precedes 
     the server build date, the server will not run.  
     </Admonition>

* A `TestServerOptions.Licensing.ThrowOnInvalidOrMissingLicense` configuration option 
  is available since RavenDB `5.4`, determining whether to throw a `LicenseExpiredException` 
  exception if TestDriver uses an unlicensed embedded server.  
   * If `ThrowOnInvalidOrMissingLicense` is set to **`true`** and the validation fails, 
     a `LicenseExpiredException` exception will be thrown to **warn TestDriver users** 
     that in lack of a valid license, their server's capabilities are limited and they 
     may therefore miss out on much of their system's potential.  
   * If the configuration option is set to **`false`**, **no exception will be thrown** 
     even if a license cannot be validated.  
   * Since RavenDB version `6.2`, `TestServerOptions.Licensing.ThrowOnInvalidOrMissingLicense` 
     is set by default to `true` so a `LicenseExpiredException` exception **would** be thrown 
     if the embedded server used by TestDriver fails to validate a license.  
     Users that prefer that no exception would be thrown if an unlicensed embedded server 
     is used, can explicitly set the configuration option to **`false`**.  

* Additional `TestServerOptions.Licensing` configuration options are available as well, 
  you can read about them [here](../server/embedded.mdx#licensing-options).  







</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="Note">

* In this section, we explain how to use [ravendb-test-driver](https://central.sonatype.com/search?q=g:net.ravendb%20%20a:ravendb-test-driver&core=gav&smo=true) 
  to write RavenDB unit tests.  

* TestDriver uses an [Embedded Server](../server/embedded.mdx) package with the same set of 
  [prerequisites](../server/embedded.mdx#prerequisites) as embedded servers to run the tests.  

* In this page: 
   - [RavenTestDriver](../start/test-driver.mdx#raventestdriver)
   - [Pre-initializing the store](../start/test-driver.mdx#preinitialize)
   - [ConfigureServer](../start/test-driver.mdx#configureserver)
   - [Unit test](../start/test-driver.mdx#unittest)
   - [Complete example](../start/test-driver.mdx#complete-example)

</Admonition>

## RavenTestDriver

First, please make sure that the Raven TestDriver is added to your project dependencies.  

```
<dependency>
    <groupId>net.ravendb</groupId>
    <artifactId>ravendb-test-driver</artifactId>
    <version>4.1.3</version>
    <scope>test</scope>
</dependency>
```

Then, define a class that derives from the Raven TestDriver.

We can start by reviewing TestDriver methods, and then get into implementation 
(find a complete Raven TestDriver code sample [below](../start/test-driver.mdx#complete-example)).  
### Methods

| Signature | Description |
| ----------| ----- |
| **protected String getDatabaseDumpFilePath()** | Allows you to override the path to the database dump file that will be loaded when calling importDatabase. |
| **protected InputStream getDatabaseDumpFileStream()** |  Allows you to override the stream containing the database dump that will be loaded when calling importDatabase.  |
| **public IDocumentStore getDocumentStore()** | Gets you an IDocumentStore instance. |
| **public IDocumentStore getDocumentStore(String database)** | Gets you an IDocumentStore instance for the requested database. |
| **public IDocumentStore getDocumentStore(GetDocumentStoreOptions options)** | Gets you an IDocumentStore instance. |
| **public IDocumentStore getDocumentStore(GetDocumentStoreOptions options, String database)** | Gets you an IDocumentStore instance for the requested database. |
| **protected void preInitialize(IDocumentStore documentStore)** |Allows you to pre-initialize the IDocumentStore. |
| **protected void setupDatabase(IDocumentStore documentStore)** | Allows you to initialize the database. |
| **protected Consumer&lt;RavenTestDriver&gt; onDriverClosed** | An event that is raised when the test driver has been closed. |
| **public static void configureServer(ServerOptions options)** |Allows you to configure your server before running it|
| **public static void waitForIndexing(IDocumentStore store)** | Allows you to wait for indexes to become non-stale. |
| **public static void waitForIndexing(IDocumentStore store, String database)** | Allows you to wait for indexes to become non-stale. |
| **public static void waitForIndexing(IDocumentStore store, String database, Duration timeout)** | Allows you to wait for indexes to become non-stale. |
| **protected void waitForUserToContinueTheTest(IDocumentStore store)** | Allows you to break the test and launch the Studio to examine the state of the database. |
| **protected void openBrowser(String url)** | Allows you to open the browser. |
| **public void close()** | Allows you to dispose of the server. |



## PreInitialize

Pre-Initializing the IDocumentStore allows you to mutate the conventions used by the document store.

### Example

<TabItem value="test_driver_PreInitialize" label="test_driver_PreInitialize">
<CodeBlock language="java">
{`//This allows us to modify the conventions of the store we get from 'getDocumentStore'
@Override
protected void preInitialize(IDocumentStore documentStore) \{
    documentStore.getConventions().setMaxNumberOfRequestsPerSession(50);
\}
`}
</CodeBlock>
</TabItem>



## UnitTest

We'll be using [JUnit](https://junit.org/) for my test framework in the below example.
Note that the test itself is meant to show different capabilities of the test driver and is not meant to be the most efficient.
The example below depends on the `TestDocumentByName` index and `TestDocument` class that can be seen in the [full example](../start/test-driver.mdx#complete-example)

### Example

<TabItem value="test_driver_MyFirstTest" label="test_driver_MyFirstTest">
<CodeBlock language="java">
{`@Test
public void myFirstTest() \{
    try (IDocumentStore store = getDocumentStore()) \{
        store.executeIndex(new TestDocumentByName());

        try (IDocumentSession session = store.openSession()) \{
            TestDocument testDocument1 = new TestDocument();
            testDocument1.setName("Hello world!");
            session.store(testDocument1);

            TestDocument testDocument2 = new TestDocument();
            testDocument2.setName("Goodbye...");
            session.store(testDocument2);

            session.saveChanges();
        \}

        waitForIndexing(store); //If we want to query documents sometime we need to wait for the indexes to catch up
        waitForUserToContinueTheTest(store); //Sometimes we want to debug the test itself, this redirect us to the studio

        try (IDocumentSession session = store.openSession()) \{
            List<TestDocument> query = session.query(TestDocument.class, TestDocumentByName.class)
                .whereEquals("name", "hello")
                .toList();

            Assert.assertEquals(1, query.size());
        \}
    \}
\}
`}
</CodeBlock>
</TabItem>

In the test we get an IDocumentStore to our test database, deploy an index and insert two documents into it.  
We then wait for the indexing to complete, and launch Studio so we can verify that the documents and index 
are deployed (we can remove this line once the test is working).  
Finally we query for a TestDocument whose name contains the word 'hello' and assert that we have only one 
such document.  



## ConfigureServer

Before RavenDB server can be started, TestDriver extracts binaries to `targetServerLocation` (Default: `.`). Optionally before doing this, target directory can be cleaned up (when `cleanTargetServerLocation` option is turned on (Default: false)). 

The `configureServer` method allows you to be more in control on your server. 
You can use it with `ServerOptions` to change the target path where Raven server binaries are extracted to or to specify where your RavenDB data is stored, security, etc.

<Admonition type="info" title="ServerOptions" id="serveroptions" href="#serveroptions">

`ServerOptions` gives you control of how the embedded server is going to run
with just a minor change. Here you can change your targetServerLocation.

| Name | Type | Description |
| ------------- | ------------- | ----- |
| **targetServerLocation** | string | The temporary path used by TestDriver to extract server binary files (.dll) |
| **logsPath** | string | Path to server logs files |
| **dataDirectory**  | string | Path where server stores data files |
| **cleanTargetServerLocation** | boolean | Should we remove all files from targetServerLocation before extracting server binaries? |

</Admonition>

### Example

<TabItem value="test_driver_ConfigureServer" label="test_driver_ConfigureServer">
<CodeBlock language="java">
{`ServerOptions testServerOptions = new ServerOptions();

// specify where ravendb server should be extracted (optional)
testServerOptions.setTargetServerLocation("PATH_TO_TEMPORARY_SERVER_LOCATION");

// Specify where ravendb data will be placed/located (optional)
testServerOptions.setDataDirectory("PATH_TO_RAVENDB_DATADIR");
`}
</CodeBlock>
</TabItem>



## Complete Example

<TabItem value="test_full_example" label="test_full_example">
<CodeBlock language="java">
{`public class RavenDBTestDriverFull extends RavenTestDriver \{

    //This allows us to modify the conventions of the store we get from 'getDocumentStore'
    @Override
    protected void preInitialize(IDocumentStore documentStore) \{
        documentStore.getConventions().setMaxNumberOfRequestsPerSession(50);
    \}

    @Test
    public void myFirstTest() \{
        ServerOptions serverOptions = new ServerOptions();
        serverOptions.setDataDirectory("C:\\\\RavenDBTestDir");
        configureServer(serverOptions);

        try (IDocumentStore store = getDocumentStore()) \{
            store.executeIndex(new TestDocumentByName());

            try (IDocumentSession session = store.openSession()) \{
                TestDocument testDocument1 = new TestDocument();
                testDocument1.setName("Hello world!");
                session.store(testDocument1);

                TestDocument testDocument2 = new TestDocument();
                testDocument2.setName("Goodbye...");
                session.store(testDocument2);

                session.saveChanges();
            \}

            waitForIndexing(store); //If we want to query documents sometime we need to wait for the indexes to catch up
            waitForUserToContinueTheTest(store); //Sometimes we want to debug the test itself, this redirect us to the studio

            try (IDocumentSession session = store.openSession()) \{
                List<TestDocument> query = session.query(TestDocument.class, TestDocumentByName.class)
                    .whereEquals("name", "hello")
                    .toList();

                Assert.assertEquals(1, query.size());
            \}
        \}
    \}

    public static class TestDocumentByName extends AbstractIndexCreationTask \{
        public TestDocumentByName() \{
            map = "from doc in docs select new \{ doc.name \}";
            index("name", FieldIndexing.SEARCH);
        \}
    \}

    public static class TestDocument \{
        private String name;

        public String getName() \{
            return name;
        \}

        public void setName(String name) \{
            this.name = name;
        \}
    \}

\}
`}
</CodeBlock>
</TabItem>





</LanguageContent>

<!---
### Embedded Server
- [Running an Embedded Instance](../server/embedded)
- [Embedded Server Options](../server/embedded#server-options)

### Troubleshooting
- [Collect information for support](../server/troubleshooting/collect-info)
- [Running an Embedded Instance](../server/embedded)


-->