---
title: "Query by Facets"
sidebar_label: Faceted Search
sidebar_position: 12
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Query by Facets
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* A **Faceted Search** provides an efficient way to explore and navigate through large datasets or search results.
 
* Multiple filters (facets) are applied to narrow down the search results according to different attributes or categories.

![Facets](./assets/CNET_faceted_search.jpg)
* In this page
   * [Define an index](../../indexes/querying/faceted-search#define-an-index)
   * [Facets - Basics](../../indexes/querying/faceted-search#facets---basics)
   * [Facets - Options](../../indexes/querying/faceted-search#facets---options)
   * [Facets - Aggregations](../../indexes/querying/faceted-search#facets---aggregations)
   * [Storing facets definition in a document](../../indexes/querying/faceted-search#storing-facets-definition-in-a-document)
   * [Syntax](../../indexes/querying/faceted-search#syntax)
   
</Admonition>
## Define an index

* To make a faceted search, **a static-index must be defined** for the fields you want to query and apply facets on.

* The examples in this article will be based on the following Class, Index, and Sample Data:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class Camera
{
    public string Manufacturer { get; set; }
    public double Cost { get; set; }
    public double MegaPixels { get; set; }
    public int MaxFocalLength { get; set; }
    public int UnitsInStock { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Cameras_ByFeatures : AbstractIndexCreationTask<Camera>
{
    public class IndexEntry
    {
        public string Brand { get; set; }
        public double Price { get; set; }
        public double MegaPixels { get; set; }
        public int MaxFocalLength { get; set; }
        public int UnitsInStock { get; set; }
    }
    
    public Cameras_ByFeatures()
    {
        Map = cameras => from camera in cameras
            select new
            {
                Brand = camera.Manufacturer,
                Price = camera.Cost,
                MegaPixels = camera.MegaPixels,
                MaxFocalLength = camera.MaxFocalLength,
                UnitsInStock = camera.UnitsInStock
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="csharp">
{`// Creating sample data for the examples in this article:
// ======================================================

var cameras = new[]
{
  new Camera { Manufacturer = "Sony", Cost = 100, MegaPixels = 20.1, MaxFocalLength = 200, UnitsInStock = 10 },
  new Camera { Manufacturer = "Sony", Cost = 200, MegaPixels = 29, MaxFocalLength = 250, UnitsInStock = 15 },
  new Camera { Manufacturer = "Nikon", Cost = 120, MegaPixels = 22.3, MaxFocalLength = 300, UnitsInStock = 2 },
  new Camera { Manufacturer = "Nikon", Cost = 180, MegaPixels = 32, MaxFocalLength = 300, UnitsInStock = 5 },
  new Camera { Manufacturer = "Nikon", Cost = 220, MegaPixels = 40, MaxFocalLength = 300, UnitsInStock = 20 },
  new Camera { Manufacturer = "Canon", Cost = 200, MegaPixels = 30.4, MaxFocalLength = 400, UnitsInStock = 30 },
  new Camera { Manufacturer = "Olympus", Cost = 250, MegaPixels = 32.5, MaxFocalLength = 600, UnitsInStock = 4 },
  new Camera { Manufacturer = "Olympus", Cost = 390, MegaPixels = 40, MaxFocalLength = 600, UnitsInStock = 6 },
  new Camera { Manufacturer = "Fuji", Cost = 410, MegaPixels = 45, MaxFocalLength = 700, UnitsInStock = 1 },
  new Camera { Manufacturer = "Fuji", Cost = 590, MegaPixels = 45, MaxFocalLength = 700, UnitsInStock = 5 },
  new Camera { Manufacturer = "Fuji", Cost = 650, MegaPixels = 61, MaxFocalLength = 800, UnitsInStock = 17 },
  new Camera { Manufacturer = "Fuji", Cost = 850, MegaPixels = 102, MaxFocalLength = 800, UnitsInStock = 19 }
};

using (var session = store.OpenSession())
{
    foreach (var camera in cameras)
    {
        session.Store(camera);
    }

    session.SaveChanges();
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Facets - Basics

#### Facets definition:

* Define a list of facets by which to aggregate the data.

* There are two **Facet types**:
    * `Facet` - returns a count for each unique term found in the specified index-field.
    * `RangeFacet` - returns a count per range within the specified index-field.
  
<TabItem value="something" label="facets_1">
<CodeBlock language="csharp">
{`// Define a list of facets to query by:
// ====================================
List<FacetBase> facets = new List<FacetBase>
\{
    // Define a Facet:
    // ===============
    new Facet
    \{
        // Specify the index-field for which to get count of documents per unique ITEM
        // e.g. get the number of Camera documents for each unique Brand
        FieldName = "Brand",
        // Set a display name for this field in the results (optional) 
        DisplayFieldName = "Camera Brand"
    \},

    // Define a RangeFacet:
    // ====================
    new RangeFacet<Cameras_ByFeatures.IndexEntry>
    \{
        Ranges =
        \{
            // Specify ranges within an index-field in order to get count per RANGE
            // e.g. get the number of Camera documents that cost below 200, between 200 & 400, etc...
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800
        \},
        // Set a display name for this field in the results (optional) 
        DisplayFieldName = "Camera Price"
    \}
\};
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

* Query the index to get the aggregated facets information.  

* Either:  

  * Pass the facets definition from above directly to the query  
  
  * Or - construct a facet using a builder with the Fluent API option, as shown below.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index    
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facets)
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index    
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index    
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .AggregateBy(builder => builder
         // Specify the index-field (e.g. 'Brand') for which to get count per unique ITEM
        .ByField(x => x.Brand)
         // Set a display name for the field in the results (optional) 
        .WithDisplayName("Camera Brand"))
    .AndAggregateBy(builder => builder
         // Specify ranges within an index field (e.g. 'Price') in order to get count per RANGE
        .ByRanges(
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800)
         // Set a display name for the field in the results (optional) 
        .WithDisplayName("Camera Price"))
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
      // Query the index
      // Provide the RQL string to the RawQuery method
     .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                         select 
                             facet(Brand) as 'Camera Brand',
                             facet(Price < 200.0,
                                   Price >= 200.0 and Price < 400.0,
                                   Price >= 400.0 and Price < 600.0,
                                   Price >= 600.0 and Price < 800.0,
                                   Price >= 800.0) as 'Camera Price'")
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand) as "Camera Brand",
    facet(Price < 200.0,
          Price >= 200.0 and Price < 400.0,
          Price >= 400.0 and Price < 600.0,
          Price >= 600.0 and Price < 800.0,
          Price >= 800.0) as "Camera Price"
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

* **Query results** are Not the collection documents, they are of type:  
  `Dictionary<string, FacetResult>` which is the facets results per index-field specified.  

* Using the sample data from this article, the resulting aggregations will be:

<TabItem value="something" label="facets_6">
<CodeBlock language="csharp">
{`// The resulting aggregations per display name will contain:
// =========================================================

// For the "Camera Brand" Facet:
//     "canon"   - Count: 1
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2
//     "sony"    - Count: 2

// For the "Camera Price" Ranges:
//     "Price < 200"                      - Count: 3
//     "Price >= 200.0 and Price < 400.0" - Count: 5
//     "Price >= 400.0 and Price < 600.0" - Count: 2
//     "Price >= 600.0 and Price < 800.0" - Count: 1
//     "Price >= 800.0"                   - Count: 1
`}
</CodeBlock>
</TabItem>
<TabItem value="something" label="facets_7">
<CodeBlock language="csharp">
{`// Get facets results for index-field 'Brand' using the display name specified:
// ============================================================================
var brandFacets = results["Camera Brand"];
var numberOfBrands = brandFacets.Values.Count; // 5 unique brands

// Get the aggregated facet value for a specific Brand:
var facetValue = brandFacets.Values[0];
// The brand name is available in the 'Range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index
Assert.Equal("canon", facetValue.Range);
// Number of documents for 'Canon' is available in the 'Count' property
Assert.Equal(1, facetValue.Count);

// Get facets results for index-field 'Price' using the display name specified:
// ============================================================================
var priceFacets = results["Camera Price"];
var numberOfRanges = priceFacets.Values.Count; // 5 different ranges

// Get the aggregated facet value for a specific Range:
facetValue = priceFacets.Values[0];
Assert.Equal("Price < 200", facetValue.Range); // The range string
Assert.Equal(3, facetValue.Count); // Number of documents in this range
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="Info">

**Query further**:

* Typically, after presenting users with the initial facets results which show the available options,  
  users can select specific categories to explore further.

* For example, if the user selects Fuji and Nikon,  
  then your next query can include a filter to focus only on those selected brands.

<TabItem value="something" label="facets_8">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> filteredResults = session
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Limit query results to the selected brands: 
    .Where(x => x.Brand.In("Fuji", "Nikon"))
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Options

#### Facets definition:

* **Options** are available only for the `Facet` type.  

* Available options:  

    * `Start` - The position from which to send items (how many to skip).  
    * `PageSize` - Number of items to return.  
    * `IncludeRemainingTerms` - Show summary of items that didn't make it into the requested PageSize.  
    * `TermSortMode` - Set the sort order on the resulting items. 

<TabItem value="something" label="facets_9">
<CodeBlock language="csharp">
{`// Define the list of facets to query by:
// ======================================
List<FacetBase> facetsWithOptions = new List<FacetBase>
\{
    // Define a Facet:
    new Facet
    \{
        // Specify the index-field for which to get count of documents per unique ITEM
        FieldName = "Brand",
        // Set some facets options
        Options = new FacetOptions
        \{
            // Return the top 3 brands with most items count:
            PageSize = 3,
            TermSortMode = FacetTermSortMode.CountDesc
        \}
    \}
\};
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithOptions)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithOptions)
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithOptions)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .AggregateBy(builder => builder
         // Specify an index-field (e.g. 'Brand') for which to get count per unique ITEM
        .ByField(x => x.Brand)
         // Specify the facets options
        .WithOptions(new FacetOptions
        {
            // Return the top 3 brands with most items count:
            PageSize = 3,
            TermSortMode = FacetTermSortMode.CountDesc
        }))
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
     // Provide the RQL string to the RawQuery method
    .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                        select facet(Brand, $p0)")
     // Add the facet options to the "p0" parameter
    .AddParameter("p0", new { PageSize = 3, TermSortMode = FacetTermSortMode.CountDesc })
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(Brand, $p0)
{"p0": { "TermSortMode": "CountDesc", "PageSize": 3 }}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

<TabItem value="something" label="facets_14">
<CodeBlock language="csharp">
{`// The resulting items will contain:
// =================================

// For the "Brand" Facet:
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2

// As requested, only 3 unique items are returned, ordered by documents count descending:
`}
</CodeBlock>
</TabItem>
<TabItem value="something" label="facets_15">
<CodeBlock language="csharp">
{`// Get facets results for index-field 'Brand':
// ===========================================
var brandFacets = results["Brand"];
var numberOfBrands = brandFacets.Values.Count; // 3 brands

// Get the aggregated facet value for a specific Brand:
var facetValue = brandFacets.Values[0];
// The brand name is available in the 'Range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index
Assert.Equal("fuji", facetValue.Range);
// Number of documents for 'Fuji' is available in the 'Count' property
Assert.Equal(4, facetValue.Count);
`}
</CodeBlock>
</TabItem>



## Facets - Aggregations

#### Facets definition:

* Aggregation of data is available for an index-field per unique Facet or Range item.  
  For example:  
  * Get the total number of UnitsInStock per Brand  
  * Get the highest MegaPixels value for documents that cost between 200 & 400   

* The following aggregation operations are available:  
  * Sum
  * Average
  * Min
  * Max

* Multiple operations can be added on each facet, for multiple fields.

<TabItem value="something" label="facets_16">
<CodeBlock language="csharp">
{`// Define the list of facets to query by:
// ======================================
List<FacetBase> facetsWithAggregations = new List<FacetBase>
\{
    // Define a Facet:
    // ===============
    new Facet
    \{
        FieldName = "Brand",
        Aggregations =
        \{
            \{
                // Set the aggregation operation:
                FacetAggregation.Sum,
                // Create a HasSet specifying the index-fields for which to perform the aggregation
                new HashSet<FacetAggregationField>
                \{
                    // Get total number of UnitsInStock per Brand
                    new FacetAggregationField \{Name = "UnitsInStock"\}
                \}
            \},
            \{
                FacetAggregation.Average, new HashSet<FacetAggregationField>
                \{
                    // Get average Price per Brand
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Min, new HashSet<FacetAggregationField>
                \{
                    // Get min Price per Brand
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Max, new HashSet<FacetAggregationField>
                \{
                    // Get max MegaPixels per Brand
                    new FacetAggregationField \{Name = "MegaPixels"\},
                    // Get max MaxFocalLength per Brand
                    new FacetAggregationField \{Name = "MaxFocalLength"\}
                \}
            \}
        \}
    \},

    // Define a RangeFacet:
    // ====================
    new RangeFacet<Cameras_ByFeatures.IndexEntry>
    \{
        Ranges =
        \{
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800
        \},
        Aggregations =
        \{
            \{
                FacetAggregation.Sum, new HashSet<FacetAggregationField>
                \{
                    // Get total number of UnitsInStock for each group of documents per range specified
                    new FacetAggregationField \{Name = "UnitsInStock"\}
                \}
            \},
            \{
                FacetAggregation.Average, new HashSet<FacetAggregationField>
                \{
                    // Get average Price of each group of documents per range specified
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Min, new HashSet<FacetAggregationField>
                \{
                    // Get min Price of each group of documents per range specified
                    new FacetAggregationField \{Name = "Price"\}
                \}
            \},
            \{
                FacetAggregation.Max, new HashSet<FacetAggregationField>
                \{
                    // Get max MegaPixels for each group of documents per range specified
                    new FacetAggregationField \{Name = "MegaPixels"\},
                    // Get max MaxFocalLength for each group of documents per range specified
                    new FacetAggregationField \{Name = "MaxFocalLength"\}
                \}
            \}
        \}
    \}
\};
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithAggregations)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithAggregations)
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .AggregateBy(facetsWithAggregations)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .AggregateBy(builder => builder
         // Specify an index-field (e.g. 'Brand') for which to get count per unique ITEM
        .ByField(x => x.Brand)
         // Specify the aggregations per the Brand facet:
        .SumOn(x => x.UnitsInStock)
        .AverageOn(x => x.Price)
        .MinOn(x => x.Price)
        .MaxOn(x => x.MegaPixels)
        .MaxOn(x => x.MaxFocalLength))
    .AndAggregateBy(builder => builder
         // Specify ranges within an index field (e.g. 'Price') in order to get count per RANGE
        .ByRanges(
            x => x.Price < 200,
            x => x.Price >= 200 && x.Price < 400,
            x => x.Price >= 400 && x.Price < 600,
            x => x.Price >= 600 && x.Price < 800,
            x => x.Price >= 800)
         // Specify the aggregations per the Price range:
        .SumOn(x => x.UnitsInStock)
        .AverageOn(x => x.Price)
        .MinOn(x => x.Price)
        .MaxOn(x => x.MegaPixels)
        .MaxOn(x => x.MaxFocalLength))
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
     // Provide the RQL string to the RawQuery method
    .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                        select
                            facet(Brand,
                                  sum(UnitsInStock),
                                  avg(Price),
                                  min(Price),
                                  max(MegaPixels),
                                  max(MaxFocalLength)),
                            facet(Price < $p0,
                                  Price >= $p1 and Price < $p2,
                                  Price >= $p3 and Price < $p4,
                                  Price >= $p5 and Price < $p6,
                                  Price >= $p7,
                                  sum(UnitsInStock),
                                  avg(Price),
                                  min(Price),
                                  max(MegaPixels),
                                  max(MaxFocalLength))")
     // Add the parameters' values
    .AddParameter("p0", 200.0)
    .AddParameter("p1", 200.0)
    .AddParameter("p2", 400.0)
    .AddParameter("p3", 400.0)
    .AddParameter("p4", 600.0)
    .AddParameter("p5", 600.0)
    .AddParameter("p6", 800.0)
    .AddParameter("p7", 800.0)
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength)),
    facet(Price < $p0,
          Price >= $p1 and Price < $p2,
          Price >= $p3 and Price < $p4,
          Price >= $p5 and Price < $p6,
          Price >= $p7,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength))
{"p0":200.0,"p1":200.0,"p2":400.0,"p3":400.0,"p4":600.0,"p5":600.0,"p6":800.0,"p7":800.0}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

<TabItem value="something" label="facets_21">
<CodeBlock language="csharp">
{`// The resulting items will contain (Showing partial results):
// ===========================================================

// For the "Brand" Facet:
//     "canon" Count:1, Sum: 30, Name: UnitsInStock
//     "canon" Count:1, Min: 200, Average: 200, Name: Price
//     "canon" Count:1, Max: 30.4, Name: MegaPixels
//     "canon" Count:1, Max: 400, Name: MaxFocalLength
//
//     "fuji" Count:4, Sum: 42, Name: UnitsInStock
//     "fuji" Count:4, Min: 410, Name: Price
//     "fuji" Count:4, Max: 102, Name: MegaPixels
//     "fuji" Count:4, Max: 800, Name: MaxFocalLength
//     
//     etc.....

// For the "Price" Ranges:
//     "Price < 200.0" Count:3, Sum: 17, Name: UnitsInStock
//     "Price < 200.0" Count:3, Min: 100, Average: 133.33, Name: Price
//     "Price < 200.0" Count:3, Max: 32, Name: MegaPixels
//     "Price < 200.0" Count:3, Max: 300, Name: MaxFocalLength
//
//     "Price < 200.0 and Price > 400.0" Count:5, Sum: 75, Name: UnitsInStock
//     "Price < 200.0 and Price > 400.0" Count:5, Min: 200, Average: 252, Name: Price
//     "Price < 200.0 and Price > 400.0" Count:5, Max: 40, Name: MegaPixels
//     "Price < 200.0 and Price > 400.0" Count:5, Max: 600, Name: MaxFocalLength
//     
//     etc.....
`}
</CodeBlock>
</TabItem>
<TabItem value="something" label="facets_22">
<CodeBlock language="csharp">
{`// Get results for the 'Brand' Facets:
// ==========================================
var brandFacets = results["Brand"];

// Get the aggregated facet value for a specific Brand:
var facetValue = brandFacets.Values[0];
// The brand name is available in the 'Range' property:
Assert.Equal("canon", facetValue.Range);
// The index-field on which aggregation was done is in the 'Name' property:
Assert.Equal("UnitsInStock", facetValue.Name);
// The requested aggregation result:
Assert.Equal(30, facetValue.Sum);

// Get results for the 'Price' RangeFacets:
// =======================================
var priceRangeFacets = results["Price"];

// Get the aggregated facet value for a specific Brand:
facetValue = priceRangeFacets.Values[0];
// The range string is available in the 'Range' property:
Assert.Equal("Price < 200.0", facetValue.Range);
// The index-field on which aggregation was done is in the 'Name' property:
Assert.Equal("UnitsInStock", facetValue.Name);
// The requested aggregation result:
Assert.Equal(17, facetValue.Sum);
`}
</CodeBlock>
</TabItem>



## Storing facets definition in a document

#### Define and store facets in a document:

* The facets definitions can be stored in a document.

* That document can then be used by a faceted search query.

<TabItem value="something" label="facets_23">
<CodeBlock language="csharp">
{`// Create a FacetSetup object:
// ===========================
FacetSetup facetSetup = new FacetSetup
\{
    // Provide the ID of the document in which the facet setup will be stored.
    // This is optional -
    // if not provided then the session will assign an ID for the stored document.
    Id = "customDocumentID",

    // Define Facets and RangeFacets to query by:
    Facets = new List<Facet> \{
        new Facet()
        \{
            FieldName = "Brand"
        \}\},
    
    RangeFacets = new List<RangeFacet>
    \{
        new RangeFacet<Cameras_ByFeatures.IndexEntry>
        \{
            Ranges =
            \{
                x => x.MegaPixels < 20,
                x => x.MegaPixels >= 20 && x.MegaPixels < 30,
                x => x.MegaPixels >= 30 && x.MegaPixels < 50,
                x => x.MegaPixels >= 50
            \}
        \}
    \}
\};

// Store the facet setup document and save changes:
// ================================================
session.Store(facetSetup);
session.SaveChanges();

// The document will be stored under the 'FacetSetups' collection
`}
</CodeBlock>
</TabItem>
#### Query using facets from document:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateUsing'
     // Pass the ID of the document that contains your facets setup
    .AggregateUsing("customDocumentID")
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = await asyncSession
     // Query the index
    .Query<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateUsing'
     // Pass the ID of the document that contains your facets setup
    .AggregateUsing("customDocumentID")
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
    .DocumentQuery<Cameras_ByFeatures.IndexEntry, Cameras_ByFeatures>()
     // Call 'AggregateUsing'
     // Pass the ID of the document that contains your facets setup
    .AggregateUsing("customDocumentID")
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> results = session.Advanced
     // Query the index
     // Provide the RQL string to the RawQuery method
    .RawQuery<Camera>(@"from index 'Cameras/ByFeatures'
                        select facet(id('customDocumentID'))")
     // Execute the query
    .ExecuteAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(id("customDocumentID"))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax

<TabItem value="something" label="syntax_1">
<CodeBlock language="csharp">
{`IAggregationQuery<T> AggregateBy<T>(FacetBase facet);
IAggregationQuery<T> AggregateBy<T>(IEnumerable<FacetBase> facets);
IAggregationQuery<T> AggregateBy<T>(Action<IFacetBuilder<T>> builder);
IAggregationQuery<T> AggregateUsing<T>(string facetSetupDocumentKey);
`}
</CodeBlock>
</TabItem>

| Parameter                | Type                       | Description                                                                                       |
|--------------------------|----------------------------|---------------------------------------------------------------------------------------------------|
| **facet**                | `FacetBase`                | `FacetBase` implementation defining the facet and its options.<br/>Either `Facet` or `RangeFacet`. |
| **facets**               | `IEnumerable<FacetBase>`   | Enumerable containing `FacetBase` implementations.                                                |
| **builder**              | `Action<IFacetFactory<T>>` | Builder with a fluent API that constructs a `FacetBase` instance.                                 |
| **facetSetupDocumentId** | `string`                   | ID of a document containing `FacetSetup`.                                                         |

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="csharp">
{`public class Facet
{
    public string FieldName { get; set; }
    public FacetOptions Options { get; set; }
}

public class Facet<T>
{
    public Expression<Func<T, object>> FieldName { get; set; }
    public FacetOptions Options { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="csharp">
{`public class RangeFacet
{
    public List<string> Ranges { get; set; }
}

public class RangeFacet<T>
{
    public List<Expression<Func<T, bool>>> Ranges { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetBase" label="FacetBase">
<CodeBlock language="csharp">
{`public class FacetBase
{
    public Dictionary<FacetAggregation, HashSet<FacetAggregationField>> Aggregations { get; set; }
    public string DisplayFieldName { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetAggregation" label="FacetAggregation">
<CodeBlock language="csharp">
{`public enum FacetAggregation
{
    None,
    Max,
    Min,
    Average,
    Sum
}
`}
</CodeBlock>
</TabItem>
</Tabs>

**Fluent API builder methods**:

<TabItem value="something" label="syntax_6">
<CodeBlock language="csharp">
{`IFacetOperations<T> ByField(string fieldName);
IFacetOperations<T> ByField(Expression<Func<T, object>> path);
IFacetOperations<T> ByRanges(Expression<Func<T, bool>> path, params Expression<Func<T, bool>>[] paths);
IFacetOperations<T> WithDisplayName(string displayName);
IFacetOperations<T> WithOptions(FacetOptions options);
IFacetOperations<T> SumOn(Expression<Func<T, object>> path);
IFacetOperations<T> MinOn(Expression<Func<T, object>> path);
IFacetOperations<T> MaxOn(Expression<Func<T, object>> path);
IFacetOperations<T> AverageOn(Expression<Func<T, object>> path);
`}
</CodeBlock>
</TabItem>

| Parameter       | Type                        | Description                                                                                                                            |
|-----------------|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| **fieldName**   | `string`                    | The index-field to use for the facet                                                                                                   |
| **path**        | `Expression<Func<T, bool>>` | Points to the index-field to use for the facet (`ByRanges`, `ByField`) or for the aggregation (`SumOn`, `MinOn`, `MaxOn`, `AverageOn`) |
| **displayName** | `string`                    | If set, results of a facet will be returned under this name                                                                            |
| **options**     | `FacetOptions`              | Non-default options to use in the facet definition                                                                                     |

**Options**:

<TabItem value="something" label="syntax_7">
<CodeBlock language="csharp">
{`public class FacetOptions
\{
    public FacetTermSortMode TermSortMode \{ get; set; \} = FacetTermSortMode.ValueAsc;
    public bool IncludeRemainingTerms \{ get; set; \}
    public int Start \{ get; set; \}
    public int PageSize \{ get; set; \} = int.MaxValue;
\}
`}
</CodeBlock>
</TabItem>

| Option                    | Type                | Description                                                                                                 |
|---------------------------|---------------------|-------------------------------------------------------------------------------------------------------------|
| **TermSortMode**          | `FacetTermSortMode` | Set the sort order on the resulting items<br/>(`ValueAsc` (Default), `ValueDesc`, `CountAsc`, `CountDesc`)   |
| **Start**                 | `int`               | The position from which to send items (how many to skip)                                                    |
| **PageSize**              | `int`               | Number of items to return                                                                                   |
| **IncludeRemainingTerms** | `bool`              | Indicates if remaining terms that didn't make it into the requested PageSize should be included in results  |




</LanguageContent>
<LanguageContent language="java">


When displaying a large amount of data, paging is often used to make viewing the data manageable. 
It's also useful to give some context of the entire data-set and a easy way to drill-down into 
particular categories. The common approach to doing this is a "faceted search", as shown in the 
image below. **Note** how the count of each category within the current search is across the top.

![Facets](./assets/CNET_faceted_search.jpg)

&lt;br /&gt;
Let's start with defining a document like this:

<TabItem value="something-something" label="camera">
<CodeBlock language="java">
{`public class Camera \{
    private Date dateOfListing;
    private String model;
    private double cost;
    private int zoom;
    private double megapixels;
    private boolean imageStabilizer;
    private String manufacturer;

    public Date getDateOfListing() \{
        return dateOfListing;
    \}

    public void setDateOfListing(Date dateOfListing) \{
        this.dateOfListing = dateOfListing;
    \}

    public String getModel() \{
        return model;
    \}

    public void setModel(String model) \{
        this.model = model;
    \}

    public double getCost() \{
        return cost;
    \}

    public void setCost(double cost) \{
        this.cost = cost;
    \}

    public int getZoom() \{
        return zoom;
    \}

    public void setZoom(int zoom) \{
        this.zoom = zoom;
    \}

    public double getMegapixels() \{
        return megapixels;
    \}

    public void setMegapixels(double megapixels) \{
        this.megapixels = megapixels;
    \}

    public boolean isImageStabilizer() \{
        return imageStabilizer;
    \}

    public void setImageStabilizer(boolean imageStabilizer) \{
        this.imageStabilizer = imageStabilizer;
    \}

    public String getManufacturer() \{
        return manufacturer;
    \}

    public void setManufacturer(String manufacturer) \{
        this.manufacturer = manufacturer;
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 1

Create an index to work against. 

<TabItem value="something-something" label="step_2">
<CodeBlock language="java">
{`public class Cameras_ByManufacturerModelCostDateOfListingAndMegapixels extends AbstractIndexCreationTask \{
    public Cameras_ByManufacturerModelCostDateOfListingAndMegapixels() \{
        map = "from camera in docs.Cameras " +
            "select new \{" +
            "   camera.manufacturer," +
            "   camera.model," +
            "   camera.cost," +
            "   camera.dateOfListing," +
            "   camera.megapixels" +
            "\} ";
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 2

Setup your facet definitions:

<TabItem value="something-something" label="step_1">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>

This tells RavenDB that you would like to get the following facets:

* For the **manufacturer** field, look at the documents and return a count for each unique Term found.

* For the **cost** field, return the count of the following ranges:

 * cost &lt; 200.0
 * 200.0 &lt;= cost &lt; 400.0
 * 400.0 &lt;= cost &lt; 600.0
 * 600.0 &lt;= cost &lt; 800.0
 * cost &gt;= 800.0
* For the **megapixels** field, return the count of the following ranges:
 * megapixels &lt;= 3.0
 * 3.0 &lt;= megapixels &lt; 7.0
 * 7.0 &lt;= megapixels &lt; 10.0
 * megapixels &gt;= 10.0

## Step 3

You can write the following code to get back the data below:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`Map<String, FacetResult> facetResults = session
    .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
    .whereBetween("cost", 100, 300)
    .aggregateBy(facets)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(manufacturer), facet(cost <= 200, cost between 200 and 400, cost between 400 and 600, cost between 600 and 800, cost >= 800), facet(megapixels <= 3, megapixels between 3 and 7, megapixels between 7 and 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

This data represents the sample faceted data that satisfies the above query:

<TabItem value="something" label="json">
<CodeBlock language="json">
{`[
    \{
        "Name": "manufacturer",
        "Values": [
            \{
                "Count": 1,
                "Range": "canon"
            \},
            \{
                "Count": 2,
                "Range": "jessops"
            \},
            \{
                "Count": 1,
                "Range": "nikon"
            \},
            \{
                "Count": 1,
                "Range": "phillips"
            \},
            \{
                "Count": 3,
                "Range": "sony"
            \}
        ]
    \},
    \{
        "Name": "cost",
        "Values": [
            \{
                "Count": 6,
                "Range": "cost <= 200"
            \},
            \{
                "Count": 2,
                "Range": "cost between 200 and 400"
            \},
            \{
                "Count": 0,
                "Range": "cost between 400 and 600"
            \},
            \{
                "Count": 0,
                "Range": "cost between 600 and 800"
            \},
            \{
                "Count": 0,
                "Range": "cost >= 800"
            \}
        ]
    \},
    \{
        "Name": "megapixels",
        "Values": [
            \{
                "Count": 0,
                "Range": "megapixels <= 3"
            \},
            \{
                "Count": 6,
                "Range": "megapixels between 3 and 7"
            \},
            \{
                "Count": 1,
                "Range": "megapixels between 7 and 10"
            \},
            \{
                "Count": 1,
                "Range": "megapixels >= 10"
            \}
        ]
    \}
]
`}
</CodeBlock>
</TabItem>

### Storing Facets

If you do not have to change your facets dynamically, you can store your facets as a `FacetSetup` document and pass the document ID instead of the list each time:

<TabItem value="something-something" label="step_4_0">
<CodeBlock language="java">
{`FacetSetup facetSetup = new FacetSetup();
facetSetup.setFacets(facets);
facetSetup.setRangeFacets(rangeFacets);

session.store(facetSetup, "facets/CameraFacets");
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`Map<String, FacetResult> facetResults = session
    .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
    .whereBetween("cost", 100, 300)
    .aggregateUsing("facets/CameraFacets")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

### Stale Results

The faceted search does not take into account a staleness of an index. You can wait for non stale results by customizing your query with the `waitForNonStaleResults` method.

### Fluent API

As an alternative for creating a list of facets and passing it to the `aggregateBy` method, RavenDB also exposes a dynamic API where you can create your facets using a builder. You can read more about those methods in our dedicated Client API article [here](../../client-api/session/querying/how-to-perform-a-faceted-search).


</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* A **Faceted Search** provides an efficient way to explore and navigate through large datasets or search results.
 
* Multiple filters (facets) are applied to narrow down the search results according to different attributes or categories.

![Facets](./assets/CNET_faceted_search.jpg)
* In this page
   * [Define an index](../../indexes/querying/faceted-search#define-an-index)
   * [Facets - Basics](../../indexes/querying/faceted-search#facets---basics)
   * [Facets - Options](../../indexes/querying/faceted-search#facets---options)
   * [Facets - Aggregations](../../indexes/querying/faceted-search#facets---aggregations)
   * [Storing facets definition in a document](../../indexes/querying/faceted-search#storing-facets-definition-in-a-document)
   * [Syntax](../../indexes/querying/faceted-search#syntax)
   
</Admonition>
## Define an index

* To make a faceted search, **a static-index must be defined** for the fields you want to query and apply facets on.

* The examples in this article will be based on the following Class, Index, and Sample Data:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="python">
{`class Camera:
    def __init__(
        self,
        manufacturer: str = None,
        cost: float = None,
        mega_pixels: float = None,
        max_focal_length: int = None,
        units_in_stock: int = None,
    ):
        self.manufacturer = manufacturer
        self.cost = cost
        self.mega_pixels = mega_pixels
        self.max_focal_length = max_focal_length
        self.units_in_stock = units_in_stock
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Cameras_ByFeatures(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(
            self,
            brand: str = None,
            price: float = None,
            mega_pixels: float = None,
            max_focal_length: int = None,
            units_in_stock: int = None,
        ):
            self.brand = brand
            self.price = price
            self.mega_pixels = mega_pixels
            self.max_focal_length = max_focal_length
            self.units_in_stock = units_in_stock

    def __init__(self):
        super().__init__()
        self.map = (
            "from camera in docs.Cameras "
            "select new "
            "{ "
            " brand = camera.manufacturer,"
            " price = camera.cost,"
            " mega_pixels = camera.mega_pixels,"
            " max_focal_length = camera.max_focal_length,"
            " units_in_stock = camera.units_in_stock"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="python">
{`# Creating sample data for the examples in this article:
# ======================================================

cameras = [
    Camera(manufacturer="Sony", cost=100, mega_pixels=20.1, max_focal_length=200, units_in_stock=10),
    Camera(manufacturer="Sony", cost=200, mega_pixels=29, max_focal_length=250, units_in_stock=15),
    Camera(manufacturer="Nikon", cost=120, mega_pixels=22.3, max_focal_length=300, units_in_stock=2),
    Camera(manufacturer="Nikon", cost=180, mega_pixels=32, max_focal_length=300, units_in_stock=5),
    Camera(manufacturer="Nikon", cost=220, mega_pixels=40, max_focal_length=300, units_in_stock=20),
    Camera(manufacturer="Canon", cost=200, mega_pixels=30.4, max_focal_length=400, units_in_stock=30),
    Camera(manufacturer="Olympus", cost=250, mega_pixels=32.5, max_focal_length=600, units_in_stock=4),
    Camera(manufacturer="Olympus", cost=390, mega_pixels=40, max_focal_length=600, units_in_stock=6),
    Camera(manufacturer="Fuji", cost=410, mega_pixels=45, max_focal_length=700, units_in_stock=1),
    Camera(manufacturer="Fuji", cost=590, mega_pixels=45, max_focal_length=700, units_in_stock=5),
    Camera(manufacturer="Fuji", cost=650, mega_pixels=61, max_focal_length=800, units_in_stock=17),
    Camera(manufacturer="Fuji", cost=850, mega_pixels=102, max_focal_length=800, units_in_stock=19),
]

with store.open_session() as session:
    for camera in cameras:
        session.store(camera)
    session.save_changes()
`}
</CodeBlock>
</TabItem>
</Tabs>



## Facets - Basics

#### Facets definition:

* Define a list of facets by which to aggregate the data.

* There are two **Facet types**:
    * `Facet` - returns a count for each unique term found in the specified index-field.
    * `RangeFacet` - returns a count per range within the specified index-field.
  
<TabItem value="something-something" label="facets_1">
<CodeBlock language="python">
{`# Define a Facet:
# ===============
facet = Facet(
    # Specify the index-field for which to get count of documents per unique ITEM
    # e.g. get the number of Camera documents for each unique brand
    field_name="brand",
)

# Set a display name for this field in the results (optional)
facet.display_field_name = "Camera Brand"

# Define a RangeFacet:
# ====================
range_facet = RangeFacet()
# Specify ranges within an index-field in order to get count per RANGE
# e.g. get the number of Camera documents that cost below 200, between 200 & 400, etc...
range_facet.ranges = [
    "price < 200",
    "price between 200 and 400",
    "price between 400 and 600",
    "price between 600 and 800",
    "price >= 800",
]

# Set a display name for this field in the results (optional)
range_facet.display_field_name = "Camera Price"

# Define a list of facets to query by:
# ====================================
facets = [facet, range_facet]
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

* Query the index to get the aggregated facets information.  

* Either:  

  * Pass the facets definition from above directly to the query  
  
  * Or - construct a facet using a builder with the Fluent API option, as shown below.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = (
    session
    # Query the index
    .query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    # Call 'aggregate_by' to aggregate the data by facets
    # Pass the defined facets from above
    .aggregate_by_facets(facets).execute()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="python">
{`# Query the index
results = (
    session.query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    # Call 'aggregate_by' to aggregate the data by facets
    # Use a builder as follows:
    .aggregate_by(
        lambda builder: builder
        # Specify the index-field (e.g. 'brand') for which to get count per unique ITEM
        .by_field("brand")
        # Set a display name for the field in the results (optional)
        .with_display_name("Camera Brand")
    )
    .and_aggregate_by(
        lambda builder: builder
        # Specify ranges within an index field (e.g. 'Price') in order to get count per RANGE
        .by_ranges(
            RangeBuilder("price").is_less_than(200),
            RangeBuilder("price").is_greater_than_or_equal_to(200).is_less_than(400),
            RangeBuilder("price").is_greater_than_or_equal_to(400).is_less_than(600),
            RangeBuilder("price").is_greater_than_or_equal_to(600).is_less_than(800),
            RangeBuilder("price").is_greater_than_or_equal_to(800),
        )
        # Set a display name for the field in the results (optional)
        .with_display_name("Camera Price")
    )
    .execute()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`results = (
    session.advanced
    # Query the index
    # Provide the RQL string to the raw_query method
    .raw_query(
        """from index 'Cameras/ByFeatures'
       select
           facet(brand) as 'Camera Brand',
           facet(price < 200.0,
                 price >= 200.0 and price < 400.0,
                 price >= 400.0 and price < 600.0,
                 price >= 600.0 and price < 800.0,
                 price >= 800.0) as 'Camera Price'""",
        object_type=Camera,
    )
    # Execute the query
    .execute_aggregation()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand) as "Camera Brand",
    facet(Price < 200.0,
          Price >= 200.0 and Price < 400.0,
          Price >= 400.0 and Price < 600.0,
          Price >= 600.0 and Price < 800.0,
          Price >= 800.0) as "Camera Price"
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

* **Query results** are Not the collection documents, they are of type:  
  `Dict[str, FacetResult]` which is the facets results per index-field specified.  

* Using the sample data from this article, the resulting aggregations will be:

<TabItem value="something-something" label="facets_6">
<CodeBlock language="python">
{`# The resulting aggregations per display name will contain:
# =========================================================

# For the "Camera Brand" Facet:
#     "canon"   - Count: 1
#     "fuji"    - Count: 4
#     "nikon"   - Count: 3
#     "olympus" - Count: 2
#     "sony"    - Count: 2

# For the "Camera Price" Ranges:
#     "price < 200"                      - Count: 3
#     "200 <= price < 400" - Count: 5
#     "400 <= price < 600" - Count: 2
#     "600 <= price < 800" - Count: 1
#     "price >= 800"                   - Count: 1
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_7">
<CodeBlock language="python">
{`# Get facets results for index-field 'brand' using the display name specified:
# ============================================================================
brand_facets = results["Camera Brand"]
number_of_brands = len(brand_facets.values)  # 5 unique brands

# Get the aggregated facet value for a specific brand:
facet_value = brand_facets.values[0]
# The brand name is available in the 'Range' property
# Note: value is lower-case since the default RavenDB analyzer was used by the index
self.assertEqual("canon", facet_value.range_)
# Number of documents for 'Canon' is available in the 'Count' property
self.assertEqual(1, facet_value.count_)

# Get facets results for index-field 'Price' using the display name specified:
# ============================================================================
price_facets = results["Camera Price"]
number_of_ranges = len(price_facets.values)  # 5 different ranges

# Get the aggregated facet value for a specific Range:
facet_value = price_facets.values[0]
self.assertEqual("price < 200", facet_value.range_)  # The range string
self.assertEqual(3, facet_value.count_)
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="Info">

**Query further**:

* Typically, after presenting users with the initial facets results which show the available options,  
  users can select specific categories to explore further.

* For example, if the user selects Fuji and Nikon,  
  then your next query can include a filter to focus only on those selected brands.

<TabItem value="something-something" label="facets_8">
<CodeBlock language="python">
{`filtered_results = list(
    session.query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    .where_in("brand", ["Fuji", "Nikon"])
    .aggregate_by_facets(facets)
    .execute()
)
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Options

#### Facets definition:

* **Options** are available only for the `Facet` type.  

* Available options:  

    * `start` - The position from which to send items (how many to skip).  
    * `page_size` - Number of items to return.  
    * `include_remaining_terms` - Show summary of items that didn't make it into the requested PageSize.  
    * `term_sort_mode` - Set the sort order on the resulting items. 

<TabItem value="something-something" label="facets_9">
<CodeBlock language="python">
{`# Define the list of facets to query by:
# ======================================
facets_with_options = [
    # Define a Facet:
    Facet(
        # Specify the index-field for which to get count of documents per unique ITEM
        field_name="brand",
    )
]
# Set some facets options
# Assign facet options after creating the object
facets_with_options[0].options = FacetOptions()
# Return the top 3 brands with most items count:
facets_with_options[0].options.page_size = 3
facets_with_options[0].options.term_sort_mode = FacetTermSortMode.COUNT_DESC
facets_with_options[0].options.start = 0
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = (
    session
    # Query the index
    .query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    # Call 'aggregate_by' to aggregate the data by facets
    # Pass the defined facets from above
    .aggregate_by_facets(facets_with_options).execute()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="python">
{`# Return the top 3 brands with most items count:
facet_options = FacetOptions()
facet_options.start = 0
facet_options.page_size = 3
facet_options.term_sort_mode = FacetTermSortMode.COUNT_DESC

results = (
    session
    # Query the index
    .query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    # Call 'aggregate_by' to aggregate the data by facets
    # Use a builder as follows:
    .aggregate_by(
        lambda builder: builder
        # Specify an index-field (e.g. 'brand') for which to get count per unique ITEM
        .by_field("brand")
        # Specify the facets options
        .with_options(facet_options)
    ).execute()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`results = (
    session.advanced
    # Query the index
    # Provide the RQL string to the raw_query method
    .raw_query(
        """from index 'Cameras/ByFeatures'
       select facet(brand, $p0)""",
        object_type=Camera,
    )
    # Add the facet options to the "p0" parameter
    .add_parameter("p0", {"PageSize": 3, "TermSortMode": FacetTermSortMode.COUNT_DESC})
    # Execute the query
    .execute_aggregation()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(Brand, $p0)
{"p0": { "TermSortMode": "CountDesc", "PageSize": 3 }}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

<TabItem value="something-something" label="facets_14">
<CodeBlock language="python">
{`# The resulting items will contain:
# =================================
# For the "brand" Facet:
#     "fuji"    - Count: 4
#     "nikon"   - Count: 3
#     "olympus" - Count: 2
# As requested, only 3 unique items are returned, ordered by documents count descending:
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_15">
<CodeBlock language="python">
{`# Get facets results for index-field 'brand':
# ===========================================
brand_facets = results["brand"]
number_of_brands = len(brand_facets.values)  # 3 brands

# Get the aggregated facet value for a specific brand:
facet_value = brand_facets.values[0]
# The brand name is available in the 'Range' property
# Note: value is lower-case since the default RavenDB analyzer was used by the index
self.assertEqual("fuji", facet_value.range_)
# Number of documents for 'Fuji' is available in the 'Count' property
self.assertEqual(4, facet_value.count_)
`}
</CodeBlock>
</TabItem>



## Facets - Aggregations

#### Facets definition:

* Aggregation of data is available for an index-field per unique Facet or Range item.  
  For example:  
  * Get the total number of UnitsInStock per Brand  
  * Get the highest MegaPixels value for documents that cost between 200 & 400   

* The following aggregation operations are available:  
  * Sum
  * Average
  * Min
  * Max

* Multiple operations can be added on each facet, for multiple fields.

<TabItem value="something-something" label="facets_16">
<CodeBlock language="python">
{`# Define the list of facets to query by:
# =====================================

# Define a facet:
# ===============
facet_with_aggregations = Facet()
facet_with_aggregations.field_name = "brand"
facet_with_aggregations.aggregations = \{
    # Set the aggregation operation:
    FacetAggregation.SUM:
    # Create a set specifying the index-fields for which to perform the aggregation
    \{
        # Get total number of units_in_stock per brand
        FacetAggregationField("units_in_stock")
    \},
    FacetAggregation.AVERAGE: \{
        # Get average price per brand
        FacetAggregationField("price")
    \},
    FacetAggregation.MIN: \{
        # Get min price per brand
        FacetAggregationField("price")
    \},
    FacetAggregation.MAX: \{
        # Get max mega_pixels per brand
        FacetAggregationField("mega_pixels"),
        # Get max max_focal_length per brand
        FacetAggregationField("max_focal_length"),
    \},
\}

# Define a RangeFacet:
# ===================
range_facet_with_aggregations = RangeFacet()
range_facet_with_aggregations.ranges = [
    "price < 200",
    "price between 200 and 400",
    "price between 400 and 600",
    "price between 600 and 800",
    "price >= 800",
]
range_facet_with_aggregations.aggregations = \{
    FacetAggregation.SUM: \{
        # Get total number of units_in_stock for each group of documents per range specified
        FacetAggregationField("units_in_stock")
    \},
    FacetAggregation.AVERAGE: \{
        # Get average price of each group of documents per range specified
        FacetAggregationField("price")
    \},
    FacetAggregation.MIN: \{
        # Get min price of each group of documents per range specified
        FacetAggregationField("price")
    \},
    FacetAggregation.MAX: \{
        # Get max mega_pixels for each group of documents per range specified
        FacetAggregationField("mega_pixels"),
        # Get max max_focal_length for each group of documents per range specified
        FacetAggregationField("max_focal_length"),
    \},
\}

facets_with_aggregations = [facet_with_aggregations, range_facet_with_aggregations]
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = (
    session
    # Query the index
    .query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    # Call 'aggregate_by_facets' to aggregate the data by facets
    # Pass the defined facets from above
    .aggregate_by_facets(facets_with_aggregations).execute()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="python">
{`results = (
    session
    # Query the index
    .query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    # Call 'aggregate_by' to aggregate the data by facets
    # Use a builder as follows:
    .aggregate_by(
        lambda builder: builder
        # Specify an index-field (e.g. 'brand') for which to get count per unique ITEM
        .by_field("brand")
        # Specify the aggregations per the brand facet:
        .sum_on("units_in_stock")
        .average_on("price")
        .min_on("price")
        .max_on("mega_pixels")
        .max_on("max_focal_length")
    )
    .and_aggregate_by(
        lambda builder: builder
        # Specify ranges within an index field (e.g. 'price') in order to get count per RANGE
        .by_ranges(
            RangeBuilder("price").is_less_than(200),
            RangeBuilder("price").is_greater_than_or_equal_to(200).is_less_than(400),
            RangeBuilder("price").is_greater_than_or_equal_to(400).is_less_than(600),
            RangeBuilder("price").is_greater_than_or_equal_to(600).is_less_than(800),
            RangeBuilder("price").is_greater_than_or_equal_to(800),
        )
        # Specify the aggregations per the price range:
        .sum_on("units_in_stock")
        .average_on("price")
        .min_on("price")
        .max_on("mega_pixels")
        .max_on("max_focal_length")
    )
    .execute()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`results = (
    session.advanced
    # Query the index
    # Provide the RQL string to the raw_query method
    .raw_query(
        """
           from index 'Cameras/ByFeatures'
                                select
                                    facet(brand,
                                          sum(units_in_stock),
                                          avg(price),
                                          min(price),
                                          max(mega_pixels),
                                          max(max_focal_length)),
                                    facet(price < $p0,
                                          price >= $p1 and price < $p2,
                                          price >= $p3 and price < $p4,
                                          price >= $p5 and price < $p6,
                                          price >= $p7,
                                          sum(units_in_stock),
                                          avg(price),
                                          min(price),
                                          max(mega_pixels),
                                          max(max_focal_length))
           """
    )
    .add_parameter("p0", 200.0)
    .add_parameter("p1", 200.0)
    .add_parameter("p2", 400.0)
    .add_parameter("p3", 400.0)
    .add_parameter("p4", 600.0)
    .add_parameter("p5", 600.0)
    .add_parameter("p6", 800.0)
    .add_parameter("p7", 800.0)
    # Execute the query
    .execute_aggregation()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength)),
    facet(Price < $p0,
          Price >= $p1 and Price < $p2,
          Price >= $p3 and Price < $p4,
          Price >= $p5 and Price < $p6,
          Price >= $p7,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength))
{"p0":200.0,"p1":200.0,"p2":400.0,"p3":400.0,"p4":600.0,"p5":600.0,"p6":800.0,"p7":800.0}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

<TabItem value="something-something" label="facets_21">
<CodeBlock language="python">
{`# The resulting items will contain (Showing partial results):
# ===========================================================

# For the "brand" Facet:
#     "canon" Count:1, Sum: 30, Name: UnitsInStock
#     "canon" Count:1, Min: 200, Average: 200, Name: Price
#     "canon" Count:1, Max: 30.4, Name: MegaPixels
#     "canon" Count:1, Max: 400, Name: MaxFocalLength

#     "fuji" Count:4, Sum: 42, Name: UnitsInStock
#     "fuji" Count:4, Min: 410, Name: Price
#     "fuji" Count:4, Max: 102, Name: MegaPixels
#     "fuji" Count:4, Max: 800, Name: MaxFocalLength

#     etc.....
#
# For the "Price" Ranges:
#     "Price < 200.0" Count:3, Sum: 17, Name: UnitsInStock
#     "Price < 200.0" Count:3, Min: 100, Average: 133.33, Name: Price
#     "Price < 200.0" Count:3, Max: 32, Name: MegaPixels
#     "Price < 200.0" Count:3, Max: 300, Name: MaxFocalLength

#     "Price < 200.0 and Price > 400.0" Count:5, Sum: 75, Name: UnitsInStock
#     "Price < 200.0 and Price > 400.0" Count:5, Min: 200, Average: 252, Name: Price
#     "Price < 200.0 and Price > 400.0" Count:5, Max: 40, Name: MegaPixels
#     "Price < 200.0 and Price > 400.0" Count:5, Max: 600, Name: MaxFocalLength

#     etc.....
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_22">
<CodeBlock language="python">
{`# Get results for the 'brand' facets:
# ========================================
brand_facets = results["brand"]

# Get the aggregated facet value for a specific brand:
facet_value = brand_facets.values[0]
# The brand name is available in the 'Range' property:
self.assertEqual("canon", facet_value.range_)
# The index-field on which aggregation was done is in the 'name' property:
self.assertEqual("units_in_stock", facet_value.name)
# The requested aggregation result
self.assertEqual(30, facet_value.sum_)

# Get results for the 'price' RangeFacets:
# ========================================
price_range_facets = results["price"]

# Get the aggregated facet value for a specific brand:
facet_value = price_range_facets.values[0]
# The range string is available in the 'Range' property:
self.assertEqual("price < 200", facet_value.range_)
# The index-field on which aggregation was done is in the 'Name' property:
self.assertEqual("units_in_stock", facet_value.name)
# The requested aggregation result:
self.assertEqual(17, facet_value.sum_)
`}
</CodeBlock>
</TabItem>



## Storing facets definition in a document

#### Define and store facets in a document:

* The facets definitions can be stored in a document.

* That document can then be used by a faceted search query.

<TabItem value="something-something" label="facets_23">
<CodeBlock language="python">
{`facet_setup = FacetSetup()
# Provide  the ID of the document in which the facet setup will be stored.
# This is optional -
# if not provided then the session will assign an ID for the stored document.
facet_setup.Id = "customDocumentID"

# Define Facets and RangeFacets to query by:
facet = Facet("brand")
range_facet = RangeFacet()
range_facet.ranges = [
    "mega_pixels < 20",
    "mega_pixels between 20 and 30",
    "mega_pixels between 30 and 50",
    "mega_pixels >= 50",
]

facet_setup.facets = [facet]
facet_setup.range_facets = [range_facet]

# Store the facet setup document and save changes:
# ===============================================
session.store(facet_setup)
session.save_changes()

# The document will be stored under the 'FacetSetups' collection
`}
</CodeBlock>
</TabItem>
#### Query using facets from document:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = (
    session
    # Query the index
    .query_index_type(Cameras_ByFeatures, Cameras_ByFeatures.IndexEntry)
    # Call 'aggregate_using'
    # Pass the ID of the document that contains your facets setup
    .aggregate_using("customDocumentID").execute()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="python">
{`results = (
    session.advanced
    # Query the index
    # Provide the RQL string to the raw_query method
    .raw_query("from index 'Cameras/ByFeatures' select facet(id('customDocumentID'))", Camera)
    # Execute the query
    .execute_aggregation()
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(id("customDocumentID"))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax

<TabItem value="something-something" label="syntax_1">
<CodeBlock language="python">
{`def aggregate_by(
    self, builder_or_facet: Union[Callable[[FacetBuilder], None], FacetBase]
) -> AggregationDocumentQuery[_T]: ...

def aggregate_by_facets(self, facets: List[FacetBase]) -> AggregationDocumentQuery[_T]: ...

def aggregate_using(self, facet_setup_document_id: str) -> AggregationDocumentQuery[_T]: ...
`}
</CodeBlock>
</TabItem>

| Parameter                    | Type                       | Description           |
|------------------------------|----------------------------|-----------------------|
| **builder_or_facet** (Union) | `Callable[[FacetBuilder]`<br/>**or**<br/>`FacetBase` | Builder with a fluent API that constructs a `FacetBase` implementation instance<br/>**or**<br/>`FacetBase` implementation instance |
| **facets** | `List[FacetBase]` | A list of `FacetBase` implementations instances. |
| **facet_setup_document_id**  | `str` | ID of a document containing `FacetSetup` |

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="python">
{`class Facet(FacetBase):
    def __init__(self, field_name: str = None):
        super().__init__()
        self.field_name = field_name
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="python">
{`class RangeFacet(FacetBase):
    def __init__(self, parent: Optional[FacetBase] = None):
        super().__init__()
        self.ranges: List[str] = []
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetBase" label="FacetBase">
<CodeBlock language="python">
{`class FacetBase(ABC):
    def __init__(self):
        self.display_field_name: Union[None, str] = None
        self.options: Union[None, FacetOptions] = None
        self.aggregations: Dict[FacetAggregation, Set[FacetAggregationField]] = {}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetAggregation" label="FacetAggregation">
<CodeBlock language="python">
{`class FacetAggregation(enum.Enum):
    NONE = "None"
    MAX = "Max"
    MIN = "Min"
    AVERAGE = "Average"
    SUM = "Sum"
`}
</CodeBlock>
</TabItem>
</Tabs>

**Fluent API builder methods**:

<TabItem value="something-something" label="syntax_6">
<CodeBlock language="python">
{`def by_ranges(self, range_: RangeBuilder, *ranges: RangeBuilder) -> FacetOperations[_T]: ...

def by_field(self, field_name: str) -> FacetOperations[_T]: ...

def with_display_name(self, display_name: str) -> FacetOperations[_T]: ...

def with_options(self, options: FacetOptions) -> FacetOperations[_T]: ...

def sum_on(self, path: str, display_name: Optional[str] = None) -> FacetOperations[_T]: ...

def min_on(self, path: str, display_name: Optional[str] = None) -> FacetOperations[_T]: ...

def max_on(self, path: str, display_name: Optional[str] = None) -> FacetOperations[_T]: ...

def average_on(self, path: str, display_name: Optional[str] = None) -> FacetOperations[_T]: ...
`}
</CodeBlock>
</TabItem>

| Parameter        | Type                        | Description |
|------------------|-----------------------------|-------------|
| **range_**       | `RangeBuilder` | A range of indexes |
| **\*ranges**     | `RangeBuilder` | Multiple index ranges (at least one), separated by `,` |
| **field_name**   | `str` | The index-field to use for the facet |
| **path**         | `str` | Points to the index-field to use for the facet (`ByRanges`, `ByField`) or for the aggregation (`SUM_ON`, `MIN_ON`, `MAX_ON`, `AVERAGE_ON`) |
| **display_name** | `str` | If set, results of a facet will be returned under this name |
| **options**      | `FacetOptions` | Non-default options to use in the facet definition |



**Options**:

<TabItem value="something-something" label="syntax_7">
<CodeBlock language="python">
{`class FacetOptions:
    def __init__(self):
        self.page_size: int = constants.int_max
        self.start: Union[None, int] = None
        self.term_sort_mode: FacetTermSortMode = FacetTermSortMode.VALUE_ASC
        self.include_remaining_terms: bool = False
`}
</CodeBlock>
</TabItem>

| Option                    | Type                | Description                                                                                                 |
|---------------------------|---------------------|-------------------------------------------------------------------------------------------------------------|
| **term_sort_mode**          | `FacetTermSortMode` | Set the sort order on the resulting items<br/>(`VALUE_ASC` (Default), `VALUE_DESC`, `COUNT_ASC`, `COUNT_DESC`) |
| **start**                 | `int` | The position from which to send items (how many to skip) |
| **page_size**              | `int` | Number of items to return |
| **include_remaining_terms** | `bool` | Indicates if remaining terms that didn't make it into the requested PageSize should be included in results<br/>Default value: `False` |




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* A **Faceted Search** provides an efficient way to explore and navigate through large datasets or search results.
 
* Multiple filters (facets) are applied to narrow down the search results according to different attributes or categories.

![Facets](./assets/CNET_faceted_search.jpg)
* In this page
   * [Define an index](../../indexes/querying/faceted-search#define-an-index)
   * [Facets - Basics](../../indexes/querying/faceted-search#facets---basics)
   * [Facets - Options](../../indexes/querying/faceted-search#facets---options)
   * [Facets - Aggregations](../../indexes/querying/faceted-search#facets---aggregations)
   * [Storing facets definition in a document](../../indexes/querying/faceted-search#storing-facets-definition-in-a-document)
   * [Syntax](../../indexes/querying/faceted-search#syntax)
   
</Admonition>
## Define an index

* To make a faceted search, **a static-index must be defined** for the fields you want to query and apply facets on.

* The examples in this article will be based on the following Class, Index, and Sample Data:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="php">
{`class Camera
{
    private ?string $manufacturer = null;
    private ?float $cost = null;
    private ?float $megaPixels = null;
    private ?int $maxFocalLength = null;
    private ?int $unitsInStock = null;

    public function __construct(
        ?string $manufacturer = null,
        ?float $cost = null,
        ?float $megaPixels = null,
        ?int $maxFocalLength = null,
        ?int $unitsInStock = null,
    )
    {
        $this->manufacturer = $manufacturer;
        $this->cost = $cost;
        $this->megaPixels = $megaPixels;
        $this->maxFocalLength = $maxFocalLength;
        $this->unitsInStock = $unitsInStock;
    }

    public function getManufacturer(): ?string
    {
        return $this->manufacturer;
    }

    public function setManufacturer(?string $manufacturer): void
    {
        $this->manufacturer = $manufacturer;
    }

    public function getCost(): ?float
    {
        return $this->cost;
    }

    public function setCost(?float $cost): void
    {
        $this->cost = $cost;
    }

    public function getMegaPixels(): ?float
    {
        return $this->megaPixels;
    }

    public function setMegaPixels(?float $megaPixels): void
    {
        $this->megaPixels = $megaPixels;
    }

    public function getMaxFocalLength(): ?int
    {
        return $this->maxFocalLength;
    }

    public function setMaxFocalLength(?int $maxFocalLength): void
    {
        $this->maxFocalLength = $maxFocalLength;
    }

    public function getUnitsInStock(): ?int
    {
        return $this->unitsInStock;
    }

    public function setUnitsInStock(?int $unitsInStock): void
    {
        $this->unitsInStock = $unitsInStock;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Cameras_ByFeatures_IndexEntry
{
    private ?string $brand = null;
    private ?float $price = null;
    private ?float $megaPixels = null;
    private ?int $maxFocalLength = null;
    private ?int $unitsInStock = null;

    public function getBrand(): ?string
    {
        return $this->brand;
    }

    public function setBrand(?string $brand): void
    {
        $this->brand = $brand;
    }

    public function getPrice(): ?float
    {
        return $this->price;
    }

    public function setPrice(?float $price): void
    {
        $this->price = $price;
    }

    public function getMegaPixels(): ?float
    {
        return $this->megaPixels;
    }

    public function setMegaPixels(?float $megaPixels): void
    {
        $this->megaPixels = $megaPixels;
    }

    public function getMaxFocalLength(): ?int
    {
        return $this->maxFocalLength;
    }

    public function setMaxFocalLength(?int $maxFocalLength): void
    {
        $this->maxFocalLength = $maxFocalLength;
    }

    public function getUnitsInStock(): ?int
    {
        return $this->unitsInStock;
    }

    public function setUnitsInStock(?int $unitsInStock): void
    {
        $this->unitsInStock = $unitsInStock;
    }
}

class Cameras_ByFeatures extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from camera in docs.Cameras " .
            "select new " .
            "{ " .
            " brand = camera.manufacturer," .
            " price = camera.cost," .
            " megaPixels = camera.megaPixels," .
            " maxFocalLength = camera.maxFocalLength," .
            " unitsInStock = camera.unitsInStock" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="php">
{`// Creating sample data for the examples in this article:
// ======================================================

$cameras = [];

$cameras[] = new Camera ( $manufacturer = "Sony", $cost = 100, $megaPixels = 20.1, $maxFocalLength = 200, $unitsInStock = 10 );
$cameras[] = new Camera ( $manufacturer = "Sony", $cost = 200, $megaPixels = 29, $maxFocalLength = 250, $unitsInStock = 15 );
$cameras[] = new Camera ( $manufacturer = "Nikon", $cost = 120, $megaPixels = 22.3, $maxFocalLength = 300, $unitsInStock = 2 );
$cameras[] = new Camera ( $manufacturer = "Nikon", $cost = 180, $megaPixels = 32, $maxFocalLength = 300, $unitsInStock = 5 );
$cameras[] = new Camera ( $manufacturer = "Nikon", $cost = 220, $megaPixels = 40, $maxFocalLength = 300, $unitsInStock = 20 );
$cameras[] = new Camera ( $manufacturer = "Canon", $cost = 200, $megaPixels = 30.4, $maxFocalLength = 400, $unitsInStock = 30 );
$cameras[] = new Camera ( $manufacturer = "Olympus", $cost = 250, $megaPixels = 32.5, $maxFocalLength = 600, $unitsInStock = 4 );
$cameras[] = new Camera ( $manufacturer = "Olympus", $cost = 390, $megaPixels = 40, $maxFocalLength = 600, $unitsInStock = 6 );
$cameras[] = new Camera ( $manufacturer = "Fuji", $cost = 410, $megaPixels = 45, $maxFocalLength = 700, $unitsInStock = 1 );
$cameras[] = new Camera ( $manufacturer = "Fuji", $cost = 590, $megaPixels = 45, $maxFocalLength = 700, $unitsInStock = 5 );
$cameras[] = new Camera ( $manufacturer = "Fuji", $cost = 650, $megaPixels = 61, $maxFocalLength = 800, $unitsInStock = 17 );
$cameras[] = new Camera ( $manufacturer = "Fuji", $cost = 850, $megaPixels = 102, $maxFocalLength = 800, $unitsInStock = 19 );

$session = $store->openSession();
try {
    foreach ($cameras as $camera)
    {
        $session->store($camera);
    }

    $session->saveChanges();
} finally {
    $session->close();
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Facets - Basics

#### Facets definition:

* Define a list of facets to aggregate the data by.

* There are two **Facet types**:
    * `Facet` - returns a count for each unique term found in the specified index-field.
    * `RangeFacet` - returns a count per range within the specified index-field.
  
<TabItem value="something-something" label="facets_1">
<CodeBlock language="php">
{`// Define a list of facets to query by:
// ====================================
$facets = [];

// Define a Facet:
// ===============
$facet = new Facet();
// Specify the index-field for which to get count of documents per unique ITEM
// e.g. get the number of Camera documents for each unique Brand
$facet->setFieldName("Brand");
// Set a display name for this field in the results (optional)
$facet->setDisplayFieldName("Camera Brand");

$facets[] = $facet;

// Define a RangeFacet: for Cameras_ByFeatures_IndexEntry
// ====================
$rangeFacet = new RangeFacet();

// Specify ranges within an index-field in order to get count per RANGE
// e.g. get the number of Camera documents that cost below 200, between 200 & 400, etc...
$rangeFacet->setRanges([
    "price < 200",
    "price >= 200 and price <= 400",
    "price >= 400 and price <= 600",
    "price >= 600 and price <= 800",
    "price >= 800"
]);

// Set a display name for this field in the results (optional)
$rangeFacet->setDisplayFieldName("Camera Price");

$facets[] = $rangeFacet;
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

* Query the index to get the aggregated facets information.  

* Either:  

  * Pass the facets definition from above directly to the query  
  
  * Or - construct a facet using a builder with the Fluent API option, as shown below.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
     // Query the index
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    ->aggregateBy($facets)
    ->execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="php">
{`$results = $session
     // Query the index
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    ->aggregateBy(function($builder) {
        return $builder
             // Specify the index-field (e.g. 'Brand') for which to get count per unique ITEM
            ->byField("Brand")
             // Set a display name for the field in the results (optional)
            ->withDisplayName("Camera Brand");
    })
    ->andAggregateBy(function($builder) {
        return $builder
            // Specify ranges within an index field (e.g. 'Price') in order to get count per RANGE
            ->byRanges([
                "Price < 200",
                "Price >= 200 && Price < 400",
                "Price >= 400 && Price < 600",
                "Price >= 600 && Price < 800",
                "Price >= 800"
            ])
            // Set a display name for the field in the results (optional)
            ->withDisplayName("Camera Price");
    })
    ->execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="php">
{`$results = $session->advanced()
      // Query the index
      // Provide the RQL string to the RawQuery method
     ->rawQuery(Camera::class,
          "from index 'Cameras/ByFeatures'
                 select
                     facet(Brand) as 'Camera Brand',
                     facet(Price < 200.0,
                           Price >= 200.0 and Price < 400.0,
                           Price >= 400.0 and Price < 600.0,
                           Price >= 600.0 and Price < 800.0,
                           Price >= 800.0) as 'Camera Price'"
      )
     // Execute the query
    ->executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand) as "Camera Brand",
    facet(Price < 200.0,
          Price >= 200.0 and Price < 400.0,
          Price >= 400.0 and Price < 600.0,
          Price >= 600.0 and Price < 800.0,
          Price >= 800.0) as "Camera Price"
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

* **Query results** are Not the collection documents, they are of type:  
  `Dict[str, FacetResult]` which is the facets results per index-field specified.  

* Using the sample data from this article, the resulting aggregations will be:

<TabItem value="something-something" label="facets_6">
<CodeBlock language="php">
{`// The resulting aggregations per display name will contain:
// =========================================================

// For the "Camera Brand" Facet:
//     "canon"   - Count: 1
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2
//     "sony"    - Count: 2

// For the "Camera Price" Ranges:
//     "Price < 200"                      - Count: 3
//     "Price >= 200.0 and Price < 400.0" - Count: 5
//     "Price >= 400.0 and Price < 600.0" - Count: 2
//     "Price >= 600.0 and Price < 800.0" - Count: 1
//     "Price >= 800.0"                   - Count: 1
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_7">
<CodeBlock language="php">
{`// Get facets results for index-field 'Brand' using the display name specified:
// ============================================================================
/** @var FacetResult $brandFacets */
$brandFacets = $results["Camera Brand"];
$numberOfBrands = count($brandFacets->getValues()); // 5 unique brands

// Get the aggregated facet value for a specific Brand:
/** @var FacetValue $facetValue */
$facetValue = $brandFacets->getValues()[0];
// The brand name is available in the 'Range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index

$this->assertEquals("canon", $facetValue->getRange());
// Number of documents for 'Canon' is available in the 'Count' property
$this->assertEquals(1, $facetValue->getCount());

// Get facets results for index-field 'Price' using the display name specified:
// ============================================================================
/** @var FacetResult $priceFacets */
$priceFacets = $results["Camera Price"];
$numberOfRanges = count($priceFacets->getValues()); // 5 different ranges

// Get the aggregated facet value for a specific Range:
/** @var FacetValue $facetValue */
$facetValue = $priceFacets->getValues()[0];
$this->assertEquals("Price < 200", $facetValue->getRange()); // The range string
$this->assertEquals(3, $facetValue->getCount()); // Number of documents in this range
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="Info">

**Query further**:

* Typically, after presenting users with the initial facets results which show the available options,  
  users can select specific categories to explore further.

* For example, if the user selects Fuji and Nikon,  
  then your next query can include a filter to focus only on those selected brands.

<TabItem value="something-something" label="facets_8">
<CodeBlock language="php">
{`$filteredResults = $session
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Limit query results to the selected brands:
     ->whereIn("Brand", ["Fuji", "Nikon"])
    ->aggregateBy($facets)
    ->execute();
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Options

#### Facets definition:

* **Options** are available only for the `Facet` type.  

* Available options:  
    * `Start` - The position from which to send items (how many to skip).  
    * `PageSize` - Number of items to return.  
    * `IncludeRemainingTerms` - Show summary of items that didn't make it into the requested PageSize.  
    * `TermSortMode` - Set the sort order on the resulting items. 

<TabItem value="something-something" label="facets_9">
<CodeBlock language="php">
{`// Define the list of facets to query by:
// ======================================
$facetsWithOptions = [];

    // Define a Facet:
$facet = new Facet();

// Specify the index-field for which to get count of documents per unique ITEM
$facet->setFieldName("Brand");

// Set some facets options
$options = new FacetOptions();
// Return the top 3 brands with most items count:
$options->setPageSize(3);
$options->setTermSortMode(FacetTermSortMode::countDesc());

$facet->setOptions($options);

$facetsWithOptions[] = $facet;
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
     // Query the index
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Call 'aggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    ->aggregateBy($facetsWithOptions)
    ->execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="php">
{`$results = $session
     // Query the index
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    ->aggregateBy(function($builder) {
        $options = new FacetOptions();
        // Return the top 3 brands with most items count:
        $options->setPageSize(3);
        $options->setTermSortMode(FacetTermSortMode::countDesc());

         return $builder
             // Specify an index-field (e.g. 'Brand') for which to get count per unique ITEM
             ->byField("Brand")
             // Specify the facets options
             ->withOptions($options);
     })
    ->execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="php">
{`$results = $session->advanced()
     // Query the index
     // Provide the RQL string to the RawQuery method
    ->rawQuery(Camera::class, "from index 'Cameras/ByFeatures'select facet(Brand, \\$p0)")
     // Add the facet options to the "p0" parameter
    ->addParameter("p0", [ "PageSize" => 3, "TermSortMode" => FacetTermSortMode::countDesc() ])
     // Execute the query
    ->executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(Brand, $p0)
{"p0": { "TermSortMode": "CountDesc", "PageSize": 3 }}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

<TabItem value="something-something" label="facets_14">
<CodeBlock language="php">
{`// The resulting items will contain:
// =================================

// For the "Brand" Facet:
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2

// As requested, only 3 unique items are returned, ordered by documents count descending:
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_15">
<CodeBlock language="php">
{`// Get facets results for index-field 'Brand':
// ===========================================
/** @var FacetResult $brandFacets */
$brandFacets = $results["Brand"];
$numberOfBrands = count($brandFacets->getValues()); // 3 brands

// Get the aggregated facet value for a specific Brand:
/** @var FacetValue $facetValue */
$facetValue = $brandFacets->getValues()[0];
// The brand name is available in the 'Range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index
$this::assertEquals("fuji", $facetValue->getRange());
// Number of documents for 'Fuji' is available in the 'Count' property
$this->assertEquals(4, $facetValue->getCount());
`}
</CodeBlock>
</TabItem>



## Facets - Aggregations

#### Facets definition:

* Aggregation of data is available for an index-field per unique Facet or Range item.  
  For example:  
  * Get the total number of UnitsInStock per Brand  
  * Get the highest MegaPixels value for documents that cost between 200 & 400   

* The following aggregation operations are available:  
  * sum
  * average
  * min
  * max

* Multiple operations can be added on each facet, for multiple fields.

<TabItem value="something-something" label="facets_16">
<CodeBlock language="php">
{`// Define the list of facets to query by:
// ======================================
$facetsWithAggregations = [];

// Define a Facet:
// ===============
$facet = new Facet();
$facet->setFieldName("Brand");

$aggregations = new AggregationArray();

$aggregations->set(
    // Set the aggregation operation:
    FacetAggregation::sum(),
    // Get total number of UnitsInStock for each group of documents per range specified
    [
        // Get total number of UnitsInStock per Brand
        new FacetAggregationField($name = "UnitsInStock")
    ]
);

$aggregations->set(FacetAggregation::average(), [
    // Get average Price per Brand
    new FacetAggregationField($name = "Price")
]);

$aggregations->set(FacetAggregation::min(), [
    // Get min Price per Brand
    new FacetAggregationField($name = "Price")
]);

$aggregations->set(FacetAggregation::max(), [
    // Get max MegaPixels per Brand
    new FacetAggregationField($name = "MegaPixels"),
    // Get max MaxFocalLength per Brand
    new FacetAggregationField($name = "MaxFocalLength")
]);

$facet->setAggregations($aggregations);

// Define a RangeFacet:
// ====================
$rangeFacet = new RangeFacet();
$rangeFacet->setRanges([
    "Price < 200",
    "Price >= 200 && Price < 400",
    "Price >= 400 && Price < 600",
    "Price >= 600 && Price < 800",
    "Price >= 800"
]);

$rangeAggregations = new AggregationArray();

$rangeAggregations->set(FacetAggregation::sum(), [
    // Get total number of UnitsInStock for each group of documents per range specified
    new FacetAggregationField($name = "UnitsInStock")
]);
$rangeAggregations->set(FacetAggregation::average(), [
    // Get average Price of each group of documents per range specified
    new FacetAggregationField($name = "Price")
]);
$rangeAggregations->set(FacetAggregation::min(), [
    // Get min Price of each group of documents per range specified
    new FacetAggregationField($name = "Price")
]);

$rangeAggregations->set(FacetAggregation::max(), [
    // Get max MegaPixels for each group of documents per range specified
    new FacetAggregationField($name = "MegaPixels"),
    // Get max MaxFocalLength for each group of documents per range specified
    new FacetAggregationField($name = "MaxFocalLength")

]);

$rangeFacet->setAggregations($rangeAggregations);
`}
</CodeBlock>
</TabItem>
#### Query the index for facets results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
     // Query the index
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Call 'AggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    ->aggregateBy($facetsWithAggregations)
    ->execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="php">
{`$results = $session
     // Query the index
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Call 'AggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    ->aggregateBy(function($builder) {

        return $builder
             // Specify an index-field (e.g. 'Brand') for which to get count per unique ITEM
            ->byField("Brand")
             // Specify the aggregations per the Brand facet:
            ->sumOn("UnitsInStock")
            ->averageOn("Price")
            ->minOn("Price")
            ->maxOn("MegaPixels")
            ->maxOn("MaxFocalLength");
    })
    ->andAggregateBy(function($builder) {
        return $builder
            // Specify ranges within an index field (e.g. 'Price') in order to get count per RANGE
            ->byRanges([
                "Price < 200",
                "Price >= 200 && Price < 400",
                "Price >= 400 && Price < 600",
                "Price >= 600 && Price < 800",
                "Price >= 800"
            ])
             // Specify the aggregations per the Price range:
            ->sumOn("UnitsInStock")
            ->averageOn("Price")
            ->minOn("Price")
            ->maxOn("MegaPixels")
            ->maxOn("MaxFocalLength");
    })
    ->execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="php">
{`$results = $session->advanced()
     // Query the index
     // Provide the RQL string to the RawQuery method
    ->rawQuery(Camera::class,
     "from index 'Cameras/ByFeatures'
            select
                facet(Brand,
                      sum(UnitsInStock),
                      avg(Price),
                      min(Price),
                      max(MegaPixels),
                      max(MaxFocalLength)),
                facet(Price < \\$p0,
                      Price >= \\$p1 and Price < \\$p2,
                      Price >= \\$p3 and Price < \\$p4,
                      Price >= \\$p5 and Price < \\$p6,
                      Price >= \\$p7,
                      sum(UnitsInStock),
                      avg(Price),
                      min(Price),
                      max(MegaPixels),
                      max(MaxFocalLength))"
     )
     // Add the parameters' values
    ->addParameter("p0", 200.0)
    ->addParameter("p1", 200.0)
    ->addParameter("p2", 400.0)
    ->addParameter("p3", 400.0)
    ->addParameter("p4", 600.0)
    ->addParameter("p5", 600.0)
    ->addParameter("p6", 800.0)
    ->addParameter("p7", 800.0)
     // Execute the query
    ->executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(Brand,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength)),
    facet(Price < $p0,
          Price >= $p1 and Price < $p2,
          Price >= $p3 and Price < $p4,
          Price >= $p5 and Price < $p6,
          Price >= $p7,
          sum(UnitsInStock),
          avg(Price),
          min(Price),
          max(MegaPixels),
          max(MaxFocalLength))
{"p0":200.0,"p1":200.0,"p2":400.0,"p3":400.0,"p4":600.0,"p5":600.0,"p6":800.0,"p7":800.0}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Query results:

<TabItem value="something-something" label="facets_21">
<CodeBlock language="php">
{`// The resulting items will contain (Showing partial results):
// ===========================================================

// For the "Brand" Facet:
//     "canon" Count:1, Sum: 30, Name: UnitsInStock
//     "canon" Count:1, Min: 200, Average: 200, Name: Price
//     "canon" Count:1, Max: 30.4, Name: MegaPixels
//     "canon" Count:1, Max: 400, Name: MaxFocalLength
//
//     "fuji" Count:4, Sum: 42, Name: UnitsInStock
//     "fuji" Count:4, Min: 410, Name: Price
//     "fuji" Count:4, Max: 102, Name: MegaPixels
//     "fuji" Count:4, Max: 800, Name: MaxFocalLength
//
//     etc.....

// For the "Price" Ranges:
//     "Price < 200.0" Count:3, Sum: 17, Name: UnitsInStock
//     "Price < 200.0" Count:3, Min: 100, Average: 133.33, Name: Price
//     "Price < 200.0" Count:3, Max: 32, Name: MegaPixels
//     "Price < 200.0" Count:3, Max: 300, Name: MaxFocalLength
//
//     "Price < 200.0 and Price > 400.0" Count:5, Sum: 75, Name: UnitsInStock
//     "Price < 200.0 and Price > 400.0" Count:5, Min: 200, Average: 252, Name: Price
//     "Price < 200.0 and Price > 400.0" Count:5, Max: 40, Name: MegaPixels
//     "Price < 200.0 and Price > 400.0" Count:5, Max: 600, Name: MaxFocalLength
//
//     etc.....
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_22">
<CodeBlock language="php">
{`// Get results for the 'Brand' Facets:
// ==========================================
/** @var FacetResult $brandFacets */
$brandFacets = $results["Brand"];

// Get the aggregated facet value for a specific Brand:
/** @var FacetValue $facetValue */
$facetValue = $brandFacets->getValues()[0];
// The brand name is available in the 'Range' property:
$this->assertEquals("canon", $facetValue->getRange());
// The index-field on which aggregation was done is in the 'Name' property:
$this->assertEquals("UnitsInStock", $facetValue->getName());
// The requested aggregation result:
$this->assertEquals(30, $facetValue->getSum());

// Get results for the 'Price' RangeFacets:
// =======================================
/** @var FacetResult $priceRangeFacets */
$priceRangeFacets = $results["Price"];

// Get the aggregated facet value for a specific Brand:
/** @var FacetValue $facetValue */
$facetValue = $priceRangeFacets->getValues()[0];
// The range string is available in the 'Range' property:
$this->assertEquals("Price < 200.0", $facetValue->getRange());
// The index-field on which aggregation was done is in the 'Name' property:
$this->assertEquals("UnitsInStock", $facetValue->getName());
// The requested aggregation result:
$this->assertEquals(17, $facetValue->getSum());
`}
</CodeBlock>
</TabItem>



## Storing facets definition in a document

#### Define and store facets in a document:

* The facets definitions can be stored in a document.

* That document can then be used by a faceted search query.

<TabItem value="something-something" label="facets_23">
<CodeBlock language="php">
{`// Create a FacetSetup object:
// ===========================
$facetSetup = new FacetSetup();
// Provide the ID of the document in which the facet setup will be stored.
// This is optional -
// if not provided then the session will assign an ID for the stored document.
$facetSetup->setId("customDocumentID");

// Define Facets and RangeFacets to query by:
$facetSetup->setFacets([
    new Facet("Brand")
]);


$facetSetup->setRangeFacets([
    new RangeFacet(
        $parent = null,
        $ranges = [
            "MegaPixels < 20",
            "MegaPixels >= 20 && MegaPixels < 30",
            "MegaPixels >= 30 && MegaPixels < 50",
            "MegaPixels >= 50"
        ]
    )
]);

// Store the facet setup document and save changes:
// ================================================
$session->store($facetSetup);
$session->saveChanges();

// The document will be stored under the 'FacetSetups' collection
`}
</CodeBlock>
</TabItem>
#### Query using facets from document:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
     // Query the index
    ->query(Cameras_ByFeatures_IndexEntry::class, Cameras_ByFeatures::class)
     // Call 'AggregateUsing'
     // Pass the ID of the document that contains your facets setup
    ->aggregateUsing("customDocumentID")
    ->execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="php">
{`$results = $session->advanced()
     // Query the index
     // Provide the RQL string to the RawQuery method
    ->rawQuery(
        $className = Camera::class,
        $query = "from index 'Cameras/ByFeatures'                                        
                select facet(id('customDocumentID'))"
     )
     // Execute the query
    ->executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(id("customDocumentID"))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Syntax

<TabItem value="something-something" label="syntax_1">
<CodeBlock language="php">
{`public function aggregateBy(Callable|FacetBase|FacetBaseArray|array ...$builderOrFacets): AggregationDocumentQueryInterface;

// You can call it
//   ->aggregateBy(FacetBase $facet);
//   ->aggregateBy(FacetBase $facet1, FacetBase $facet2, ...);
//   ->aggregateBy(FacetBaseArray|array $facets);
//   ->aggregateBy(function(FacetBuilderInterface $builder) \{ ...\});

public function aggregateUsing(?string $facetSetupDocumentId): AggregationDocumentQueryInterface;
`}
</CodeBlock>
</TabItem>

| Parameter                    | Type                       | Description           |
|------------------------------|----------------------------|-----------------------|
| **builderOrFacets** | `Callable` **or** `FacetBase` **or** `FacetBaseArray` **or** `array` | Builder with a fluent API that constructs a `FacetBase` implementation instance **or** `FacetBase` implementation instance |
| **facets** | `FacetBaseArray` **or** `array` | A list of `FacetBase` implementations instances. |
| **facetSetupDocumentId**  | `string ` | ID of a document containing `FacetSetup` |

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="php">
{`class Facet
{
    private ?string $fieldName = null;
    private ?FacetOptions $options = null;

    // ... getters and setters
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="php">
{`class RangeFacet
{
    private StringArray $ranges;
    private ?FacetOptions $options = null;

    // ... getters and setters
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetBase" label="FacetBase">
<CodeBlock language="php">
{`class FacetBase
{
    private ?AggregationArray $aggregations = null;
    private ?string $displayFieldName = null;

    // ... getters and setters
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetAggregation" label="FacetAggregation">
<CodeBlock language="php">
{`interface FacetAggregation
{
    public function isNone(): bool;
    public function isMax(): bool;
    public function isMin(): bool;
    public function isAverage(): bool;
    public function isSum(): bool;

    public static function none(): FacetAggregation;
    public static function max(): FacetAggregation;
    public static function min(): FacetAggregation;
    public static function average(): FacetAggregation;
    public static function sum(): FacetAggregation;
}
`}
</CodeBlock>
</TabItem>
</Tabs>

**Fluent API builder methods**:

<TabItem value="something-something" label="syntax_6">
<CodeBlock language="php">
{`public function byField(string $fieldName): FacetOperationsInterface;
public function byRanges(?RangeBuilder $range, ?RangeBuilder ...$ranges): FacetOperationsInterface;

public function withDisplayName(string $displayName): FacetOperationsInterface;
public function withOptions(FacetOptions $options): FacetOperationsInterface;

public function sumOn(string $path, ?string $displayName = null): FacetOperationsInterface;
public function minOn(string $path, ?string $displayName = null): FacetOperationsInterface;
public function maxOn(string $path, ?string $displayName = null): FacetOperationsInterface;
public function averageOn(string $path, ?string $displayName = null): FacetOperationsInterface;
`}
</CodeBlock>
</TabItem>

| Parameter        | Type                        | Description |
|------------------|-----------------------------|-------------|
| **range** | `RangeBuilder` | A range of indexes |
| **ranges** | `RangeBuilder` | Multiple index ranges (at least one), separated by `,` |
| **fieldName** | `string` | The index-field to use for the facet |
| **path** | `string` | Points to the index-field to use for the facet (`ByRanges`, `ByField`) or for the aggregation (`SUM_ON`, `MIN_ON`, `MAX_ON`, `AVERAGE_ON`) |
| **displayName** | `string` | If set, results of a facet will be returned under this name |
| **options** | `FacetOptions` | Non-default options to use in the facet definition |



**Options**:

<TabItem value="something-something" label="syntax_7">
<CodeBlock language="php">
{`class FacetOptions
\{
    private FacetTermSortMode $termSortMode; // default value FacetTermSortMode::valueAsc()
    private bool $includeRemainingTerms = false;
    private int $start = 0;
    private int $pageSize = 0;

    // ... getters and setters
\}
`}
</CodeBlock>
</TabItem>

| Option                    | Type                | Description                                                                                                 |
|---------------------------|---------------------|-------------------------------------------------------------------------------------------------------------|
| **termSortMode** | `FacetTermSortMode` | Set the sort order on the resulting items<br/>(`VALUE_ASC` (Default), `VALUE_DESC`, `COUNT_ASC`, `COUNT_DESC`) |
| **start** | `int` | The position from which to send items (how many to skip) |
| **pageSize** | `int` | Number of items to return |
| **includeRemainingTerms** | `bool` | Indicates if remaining terms that didn't make it into the requested PageSize should be included in results<br/>Default value: `False` |




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* A **Faceted Search** provides an efficient way to explore and navigate through large datasets or search results.
 
* Multiple filters (facets) are applied to narrow down the search results according to different attributes or categories.

![Facets](./assets/CNET_faceted_search.jpg)
* In this page
   * [Define an index](../../indexes/querying/faceted-search#define-an-index)
   * [Facets - Basics](../../indexes/querying/faceted-search#facets---basics)
   * [Facets - Options](../../indexes/querying/faceted-search#facets---options)
   * [Facets - Aggregations](../../indexes/querying/faceted-search#facets---aggregations)
   * [Storing facets definition in a document](../../indexes/querying/faceted-search#storing-facets-definition-in-a-document)
   * [Syntax](../../indexes/querying/faceted-search#syntax)
   
</Admonition>
## Define an index

* To make a faceted search, **a static-index must be defined** for the fields you want to query and apply facets on.

* The examples in this article will be based on the following Class, Index, and Sample Data:

<Tabs groupId='languageSyntax'>
<TabItem value="Class" label="Class">
<CodeBlock language="nodejs">
{`class Camera {
    constructor(
        manufacturer = '',
        cost = 0,
        megaPixels = 0,
        maxFocalLength = 0,
        unitsInStock = 0
    ) {
        Object.assign(this, {
            manufacturer,
            cost,
            megaPixels,
            maxFocalLength,
            unitsInStock
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="nodejs">
{`class Cameras_ByFeatures extends AbstractJavaScriptIndexCreationTask {
    constructor () {
        super();

        this.map("Cameras", camera => {
            return {
                brand: camera.manufacturer,
                price: camera.cost,
                megaPixels: camera.megaPixels,
                maxFocalLength: camera.maxFocalLength,
                unitsInStock: camera.unitsInStock
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Sample_data" label="Sample_data">
<CodeBlock language="nodejs">
{`// Creating sample data for the examples in this article:
// ======================================================
const bulkInsert = store.bulkInsert();

const cameras = [
    new Camera("Sony", 100, 20.1, 200, 10),
    new Camera("Sony", 200, 29, 250, 15),
    new Camera("Nikon", 120, 22.3, 300, 2),
    new Camera("Nikon", 180, 32, 300, 5),
    new Camera("Nikon", 220, 40, 300, 20),
    new Camera("Canon", 200, 30.4, 400, 30),
    new Camera("Olympus", 250, 32.5, 600, 4),
    new Camera("Olympus", 390, 40, 600, 6),
    new Camera("Fuji", 410, 45, 700, 1),
    new Camera("Fuji", 590, 45, 700, 5),
    new Camera("Fuji", 650, 61, 800, 17),
    new Camera("Fuji", 850, 102, 800, 19)
];

for (const camera of cameras) {
    await bulkInsert.store(camera);
}

await bulkInsert.finish();
`}
</CodeBlock>
</TabItem>
</Tabs>



## Facets - Basics

<Admonition type="note" title="Note">

**Facets definition**:
* Define a list of facets by which to aggregate the data.

* There are two **Facet types**:
    * `Facet` - returns a count for each unique term found in the specified index-field.
    * `RangeFacet` - returns a count per range within the specified index-field.
  
<TabItem value="something-something" label="facets_1">
<CodeBlock language="nodejs">
{`// Define a Facet:
// ===============
const brandFacet = new Facet();
// Specify the index-field for which to get count of documents per unique ITEM
// e.g. get the number of Camera documents for each unique brand
brandFacet.fieldName = "brand";
// Set a display name for this field in the results (optional) 
brandFacet.displayFieldName = "Camera Brand";

// Define a RangeFacet:
// ====================
const priceRangeFacet = new RangeFacet();
// Specify ranges within an index-field in order to get count per RANGE
// e.g. get the number of Camera documents that cost below 200, between 200 & 400, etc...
priceRangeFacet.ranges = [
    "price < 200",
    "price >= 200 and price < 400",
    "price >= 400 and price < 600",
    "price >= 600 and price < 800",
    "price >= 800"
];
// Set a display name for this field in the results (optional) 
priceRangeFacet.displayFieldName = "Camera Price";

const facets = [brandFacet, priceRangeFacet];
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

**Query the index for facets results**:
* Query the index to get the aggregated facets information.  

* Either:  

  * Pass the facets definition from above directly to the query  
  
  * Or - construct a facet using a builder with the Fluent API option, as shown below.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
     // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Pass the defined facets from above
    .aggregateBy(...facets)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="nodejs">
{`// Define the index-field (e.g. 'price') that will be used by the range-facet in the query below 
const range = RangeBuilder.forPath("price");

const results = await session
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .aggregateBy(builder => builder
         // Specify the index-field (e.g. 'brand') for which to get count per unique ITEM
        .byField("brand"))
         // Set a display name for the field in the results (optional) 
        .withDisplayName("Camera Brand"))
     // Call 'andAggregateBy' to aggregate the data by also by range-facets
     // Use a builder as follows:
    .andAggregateBy(builder => builder                
        .byRanges(
            // Specify the ranges within index field 'price' in order to get count per RANGE
            range.isLessThan(200),
            range.isGreaterThanOrEqualTo(200).isLessThan(400),
            range.isGreaterThanOrEqualTo(400).isLessThan(600),
            range.isGreaterThanOrEqualTo(600).isLessThan(800),
            range.isGreaterThanOrEqualTo(800))
         // Set a display name for the field in the results (optional) 
        .withDisplayName("Camera Brand"))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select
                   facet(brand) as "Camera Brand",
                   facet(price < 200,
                         price >= 200 and price < 400,
                         price >= 400 and price < 600,
                         price >= 600 and price < 800,
                         price >= 800) as "Camera Price"\`)
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(brand) as "Camera Brand",
    facet(price < 200,
          price >= 200 and price < 400,
          price >= 400 and price < 600,
          price >= 600 and price < 800,
          price >= 800) as "Camera Price"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">

**Query results**:
* **Query results** are Not the collection documents, they are of type `FacetResultObject`  
  which is the facets results per index-field specified.  

* Using the sample data from this article, the resulting aggregations will be:

<TabItem value="something-something" label="facets_4">
<CodeBlock language="nodejs">
{`// The resulting aggregations per display name will contain:
// =========================================================

// For the "Camera Brand" Facet:
//     "canon"   - Count: 1
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2
//     "sony"    - Count: 2

// For the "Camera Price" Ranges:
//     "Price < 200"                      - Count: 3
//     "Price >= 200.0 and Price < 400.0" - Count: 5
//     "Price >= 400.0 and Price < 600.0" - Count: 2
//     "Price >= 600.0 and Price < 800.0" - Count: 1
//     "Price >= 800.0"                   - Count: 1
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_5">
<CodeBlock language="nodejs">
{`// Get facets results for index-field 'brand' using the display name specified:
// ============================================================================
const brandFacets = results["Camera Brand"];
const numberOfBrands = brandFacets.values.length; // 5 unique brands

// Get the aggregated facet value for a specific Brand:
let facetValue = brandFacets.values[0];
// The brand name is available in the 'range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index
assert.equal(facetValue.range, "canon");
// Number of documents for 'Canon' is available in the 'count' property
assert.equal(facetValue.count, 1);

// Get facets results for index-field 'price' using the display name specified:
// ============================================================================
const priceFacets = results["Camera Price"];
const numberOfRanges = priceFacets.values.length; // 5 different ranges

// Get the aggregated facet value for a specific Range:
facetValue = priceFacets.values[0];
assert.equal(facetValue.range, "price < 200"); // The range string
assert.equalfacetValue.count, 3); // Number of documents in this range
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="info" title="Info">

**Query further**:
* Typically, after presenting users with the initial facets results which show the available options,  
  users can select specific categories to explore further.

* For example, if the user selects Fuji and Nikon,  
  then your next query can include a filter to focus only on those selected brands.

<TabItem value="something-something" label="facets_6">
<CodeBlock language="nodejs">
{`const filteredResults = await session
    .query(\{ indexName: "Cameras/ByFeatures" \})
     // Limit query results to the selected brands: 
    .whereIn("brand", ["Fuji", "Nikon"])
    .aggregateBy(...facets)
    .execute();
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Options

<Admonition type="note" title="Note">

**Facets definition**:
* **Options** are available only for the `Facet` type.  

* Available options:  

    * `start` - The position from which to send items (how many to skip).  
    * `pageSize` - Number of items to return.  
    * `includeRemainingTerms` - Show summary of items that didn't make it into the requested pageSize.  
    * `termSortMode` - Set the sort order on the resulting items. 

<TabItem value="something-something" label="facets_7">
<CodeBlock language="nodejs">
{`// Define a Facet:
// ===============
const facet = new Facet();

// Specify the index-field for which to get count of documents per unique ITEM
facet.fieldName = "brand";

// Set some facet options 
// E.g.: Return top 3 brands with most items count
const facetOptions = new FacetOptions();
facetOptions.pageSize = 3;
facetOptions.termSortMode = "CountDesc";

facet.options = facetOptions;
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

**Query the index for facets results**:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
     // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Pass the defined facet from above
    .aggregateBy(facet)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="nodejs">
{`// Set facet options to use in the following query 
// E.g.: Return top 3 brands with most items count
const facetOptions = new FacetOptions();
facetOptions.pageSize = 3;
facetOptions.termSortMode = "CountDesc";

const results = await session
     //Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .aggregateBy(builder => builder
         // Specify the index-field (e.g. 'brand') for which to get count per unique ITEM
        .byField("brand")
         // Call 'withOptions', pass the facets options
        .withOptions(facetOptions))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select facet(brand, $p0)\`)
     // Add the facet options to the "p0" parameter
    .addParameter("p0", { "termSortMode": "CountDesc", "pageSize": 3 })
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(brand, $p0)
{"p0": { "termSortMode": "CountDesc", "pageSize": 3 }}
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">

**Query results**:
<TabItem value="something-something" label="facets_10">
<CodeBlock language="nodejs">
{`// The resulting items will contain:
// =================================

// For the "brand" Facet:
//     "fuji"    - Count: 4
//     "nikon"   - Count: 3
//     "olympus" - Count: 2

// As requested, only 3 unique items are returned, ordered by documents count descending:
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_11">
<CodeBlock language="nodejs">
{`// Get facets results for index-field 'brand':
// ===========================================
const brandFacets = results["brand"];
const numberOfBrands = brandFacets.values.length; // 3 brands

// Get the aggregated facet value for a specific Brand:
const facetValue = brandFacets.values[0];
// The brand name is available in the 'range' property
// Note: value is lower-case since the default RavenDB analyzer was used by the index 
assert.equal(facetValue.range, "fuji");
// Number of documents for 'Fuji' is available in the 'count' property
assert.equal(facetValue.count, 4);
`}
</CodeBlock>
</TabItem>

</Admonition>



## Facets - Aggregations

<Admonition type="note" title="Note">

**Facets definition**:
* Aggregation of data is available for an index-field per unique Facet or Range item.  
  For example:  
  * Get the total number of unitsInStock per Brand  
  * Get the highest megaPixels value for documents that cost between 200 & 400   

* The following aggregation operations are available:  
  * Sum
  * Average
  * Min
  * Max

* Multiple operations can be added on each facet, for multiple fields.

<TabItem value="something-something" label="facets_12">
<CodeBlock language="nodejs">
{`// Define a Facet:
// ===============
const facet = new Facet();
facet.fieldName = "brand";

// Define the index-fields to aggregate:
const unitsInStockAggregationField = new FacetAggregationField();
unitsInStockAggregationField.name = "unitsInStock";

const priceAggregationField = new FacetAggregationField();
priceAggregationField.name = "price";

const megaPixelsAggregationField = new FacetAggregationField();
megaPixelsAggregationField.name = "megaPixels";

const maxFocalLengthAggregationField = new FacetAggregationField();
maxFocalLengthAggregationField.name = "maxFocalLength";

// Define the aggregation operations:
facet.aggregations.set("Sum", [unitsInStockAggregationField]);
facet.aggregations.set("Average", [priceAggregationField]);
facet.aggregations.set("Min", [priceAggregationField]);
facet.aggregations.set("Max", [megaPixelsAggregationField, maxFocalLengthAggregationField]);

// Define a RangeFacet:
// ====================
const rangeFacet = new RangeFacet();
rangeFacet.ranges = [
    "price < 200",
    "price >= 200 and price < 400",
    "price >= 400 and price < 600",
    "price >= 600 and price < 800",
    "price >= 800"
];

// Define the aggregation operations:
rangeFacet.aggregations.set("Sum", [unitsInStockAggregationField]);
rangeFacet.aggregations.set("Average", [priceAggregationField]);
rangeFacet.aggregations.set("Min", [priceAggregationField]);
rangeFacet.aggregations.set("Max", [megaPixelsAggregationField, maxFocalLengthAggregationField]);

const facetsWithAggregations = [facet, rangeFacet];
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

**Query the index for facets results**:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
     // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Pass the defined facet from above
    .aggregateBy(...facetsWithAggregations)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_FluentAPI" label="Query_FluentAPI">
<CodeBlock language="nodejs">
{`// Define the index-field (e.g. 'price') that will be used by the range-facet in the query below 
const range = RangeBuilder.forPath("price");

const results = await session
    .query({ indexName: "Cameras/ByFeatures" })
     // Call 'aggregateBy' to aggregate the data by facets
     // Use a builder as follows:
    .aggregateBy(builder => builder
         // Specify the index-field (e.g. 'brand') for which to get count per unique ITEM
        .byField("brand")
         // Specify the aggregations per the brand facet:
        .sumOn("unitsInStock")
        .averageOn("price")
        .minOn("price")
        .maxOn("megaPixesls")
        .maxOn("maxFocalLength"))
     // Call 'andAggregateBy' to aggregate the data by also by range-facets
     // Use a builder as follows:
    .andAggregateBy(builder => builder
        .byRanges(
            // Specify the ranges within index field 'price' in order to get count per RANGE
            range.isLessThan(200),
            range.isGreaterThanOrEqualTo(200).isLessThan(400),
            range.isGreaterThanOrEqualTo(400).isLessThan(600),
            range.isGreaterThanOrEqualTo(600).isLessThan(800),
            range.isGreaterThanOrEqualTo(800))
         // Specify the aggregations per the price range:
        .sumOn("unitsInStock")
        .averageOn("price")
        .minOn("price")
        .maxOn("megaPixesls")
        .maxOn("maxFocalLength"))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select
                   facet(brand,
                         sum(unitsInStock),
                         avg(price),
                         min(price),
                         max(megaPixels),
                         max(maxFocalLength)),
                   facet(price < $p0,
                         price >= $p1 and price < $p2,
                         price >= $p3 and price < $p4,
                         price >= $p5 and price < $p6,
                         price >= $p7,
                         sum(unitsInStock),
                         avg(price),
                         min(price),
                         max(megaPixels),
                         max(maxFocalLength))\`)
     // Add the parameters' values
    .addParameter("p0", 200)
    .addParameter("p1", 200)
    .addParameter("p2", 400)
    .addParameter("p3", 400)
    .addParameter("p4", 600)
    .addParameter("p5", 600)
    .addParameter("p6", 800)
    .addParameter("p7", 800)
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select
    facet(brand,
          sum(unitsInStock),
          avg(price),
          min(price),
          max(megaPixels),
          max(maxFocalLength)),
    facet(price < 200,
          price >= 200 and price < 400,
          price >= 400 and price < 600,
          price >= 600 and price < 800,
          price >= 800,
          sum(unitsInStock),
          avg(price),
          min(price),
          max(megaPixels),
          max(maxFocalLength))
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">

**Query results**:
<TabItem value="something-something" label="facets_15">
<CodeBlock language="nodejs">
{`// The resulting items will contain (Showing partial results):
// ===========================================================

// For the "brand" Facet:
//     "canon" Count:1, Sum: 30, Name: unitsInStock
//     "canon" Count:1, Min: 200, Average: 200, Name: price
//     "canon" Count:1, Max: 30.4, Name: megaPixels
//     "canon" Count:1, Max: 400, Name: maxFocalLength
//
//     "fuji" Count:4, Sum: 42, Name: unitsInStock
//     "fuji" Count:4, Min: 410, Name: price
//     "fuji" Count:4, Max: 102, Name: megaPixels
//     "fuji" Count:4, Max: 800, Name: maxFocalLength
//     
//     etc.....

// For the "price" Ranges:
//     "Price < 200" Count:3, Sum: 17, Name: unitsInStock
//     "Price < 200" Count:3, Min: 100, Average: 133.33, Name: price
//     "Price < 200" Count:3, Max: 32, Name: megaPixels
//     "Price < 200" Count:3, Max: 300, Name: maxFocalLength
//
//     "Price < 200 and Price > 400" Count:5, Sum: 75, Name: unitsInStock
//     "Price < 200 and Price > 400" Count:5, Min: 200, Average: 252, Name: price
//     "Price < 200 and Price > 400" Count:5, Max: 40, Name: megaPixels
//     "Price < 200 and Price > 400" Count:5, Max: 600, Name: maxFocalLength
//     
//     etc.....
`}
</CodeBlock>
</TabItem>
<TabItem value="something-something" label="facets_16">
<CodeBlock language="nodejs">
{`// Get results for the 'brand' Facets:
// ==========================================
const brandFacets = results["brand"];

// Get the aggregated facet value for a specific brand:
let facetValue = brandFacets.values[0];
// The brand name is available in the 'range' property:
assert.equal(facetValue.range, "canon");
// The index-field on which aggregation was done is in the 'name' property:
assert.equal(facetValue.name, "unitsInStock");
// The requested aggregation result:
assert.equal(facetValue.sum, 30);

// Get results for the 'price' RangeFacets:
// =======================================
const priceRangeFacets = results["price"];

// Get the aggregated facet value for a specific Brand:
facetValue = priceRangeFacets.values[0];
// The range string is available in the 'range' property:
assert.equal(facetValue.range, "price < 200");
// The index-field on which aggregation was done is in the 'name' property:
assert.equal(facetValue.name, "unitsInStock");
// The requested aggregation result:
assert.equal(facetValue.sum, 17);
`}
</CodeBlock>
</TabItem>

</Admonition>



## Storing facets definition in a document



<Admonition type="note" title="Note">

**Define and store facets in a document**:
* The facets definitions can be stored in a document.

* That document can then be used by a faceted search query.

<TabItem value="something-something" label="facets_17">
<CodeBlock language="nodejs">
{`// Create a FacetSetup object:
// ===========================
const facetSetup = new FacetSetup();

// Provide the ID of the document in which the facet setup will be stored.
// This is optional -
// if not provided then the session will assign an ID for the stored document.
facetSetup.id = "customDocumentID";

// Define Facets and RangeFacets to query by:
const facet = new Facet();
facet.fieldName = 'brand';

facetSetup.facets = [facet];

const rangeFacet = new RangeFacet();
rangeFacet.ranges = [
    "megaPixels < 20",
    "megaPixels >= 20 and megaPixels < 30",
    "megaPixels >= 30 and megaPixels < 50",
    "megaPixels >= 50"
];

facetSetup.rangeFacets = [rangeFacet];

// Store the facet setup document and save changes:
// ================================================
await session.store(facetSetup);
await session.saveChanges();

// The document will be stored under the 'FacetSetups' collection
`}
</CodeBlock>
</TabItem>

</Admonition>

<Admonition type="note" title="Note">

**Query using facets from document**:
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const results = await session
    // Query the index
    .query({ indexName: "Cameras/ByFeatures" })
    // Call 'aggregateUsing'
    // Pass the ID of the document that contains your facets setup
    .aggregateUsing("customDocumentID")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="nodejs">
{`const results = await session.advanced
     // Query the index
     // Provide the RQL string to the rawQuery method
    .rawQuery(\`from index "Cameras/ByFeatures"
               select facet(id("customDocumentID"))\`)
     // Execute the query
    .executeAggregation();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Cameras/ByFeatures"
select facet(id("customDocumentID"))
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



## Syntax

<TabItem value="something-something" label="syntax_1">
<CodeBlock language="nodejs">
{`// Aggregate data by Facets:
aggregateBy(facet);
aggregateBy(...facet);
aggregateBy(action);

// Aditional aggregation for another Facet/RangeFacet (use with fluent API) 
andAggregateBy(facet);
andAggregateBy(builder);

// Aggregate data by Facets stored in a document 
aggregateUsing(facetSetupDocumentId);
`}
</CodeBlock>
</TabItem>

| Parameter                | Type                       | Description                                                                                       |
|--------------------------|----------------------------|---------------------------------------------------------------------------------------------------|
| **facet**                | `FacetBase`                | `FacetBase` implementation defining the facet and its options.<br/>Either `Facet` or `RangeFacet`. |
| **...facet**             | `FacetBase[]`              | List containing `FacetBase` implementations.                                                      |
| **action** / **builder** | `(builder) => void`        | Builder with a fluent API that constructs a `FacetBase` instance.                                 |
| **facetSetupDocumentId** | `string`                   | ID of a document containing `FacetSetup`.                                                         |

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="nodejs">
{`class Facet {
    fieldName;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="nodejs">
{`class RangeFacet {
    ranges;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetBase" label="FacetBase">
<CodeBlock language="nodejs">
{`class FacetBase {
    displayFieldName;
    options;
    aggregations; // "None" | "Max" | "Min" | "Average" | "Sum"
}
`}
</CodeBlock>
</TabItem>
</Tabs>

**builder methods**:

<TabItem value="something-something" label="syntax_5">
<CodeBlock language="nodejs">
{`byField(fieldName);
byRanges(range, ...ranges);

withDisplayName(displayName);
withOptions(options);

sumOn(path);
sumOn(path, displayName);

minOn(path);
minOn(path, displayName);

maxOn(path);
maxOn(path, displayName);

averageOn(path);
averageOn(path, displayName);
`}
</CodeBlock>
</TabItem>

| Parameter       | Type           | Description                                                                                                                  |
|-----------------|----------------|------------------------------------------------------------------------------------------------------------------------------|
| **fieldName**   | `string`       | The index-field to use for the facet                                                                                         |
| **path**        | `string`       | The index-field to use for the facet (`byRanges`, `byField`) or for the aggregation (`sumOn`, `minOn`, `maxOn`, `averageOn`) |
| **displayName** | `string`       | If set, results of a facet will be returned under this name                                                                  |
| **options**     | `FacetOptions` | Non-default options to use in the facet definition                                                                           |

**Options**:

<TabItem value="something-something" label="syntax_6">
<CodeBlock language="nodejs">
{`class FacetOptions \{
    termSortMode;
    includeRemainingTerms; 
    start;
    pageSize;
\}
`}
</CodeBlock>
</TabItem>

| Option                    | Type                | Description                                                                                                 |
|---------------------------|---------------------|-------------------------------------------------------------------------------------------------------------|
| **termSortMode**          | `FacetTermSortMode` | Set the sort order on the resulting items<br/>(`ValueAsc` (Default), `ValueDesc`, `CountAsc`, `CountDesc`)   |
| **start**                 | `number`            | The position from which to send items (how many to skip)                                                    |
| **pageSize**              | `number`            | Number of items to return                                                                                   |
| **includeRemainingTerms** | `boolean`           | Indicates if remaining terms that didn't make it into the requested PageSize should be included in results  |




</LanguageContent>

<!---
### Client API
- [Query Overview](../../client-api/session/querying/how-to-query)
- [How to Perform a Faceted Search](../../client-api/session/querying/how-to-perform-a-faceted-search)


-->