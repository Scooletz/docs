---
title: "Paging Query Results"
hide_table_of_contents: true
sidebar_label: Paging
sidebar_position: 3
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Paging Query Results
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

* **Paging**:  
  Paging is the process of fetching a subset (a page) of results from a dataset, rather than retrieving the entire results at once.
  This method enables processing query results one page at a time.

* **Default page size**:  

    * Querying **Lucene** indexes:  
      If the client's query definition does Not explicitly specify the page size, the server will default to `int.MaxValue` (2,147,483,647).
      In such case, all results will be returned in a single server call.
  
    * Querying **Corax** indexes:  
      The default page size is the same as the one employed by Lucene.  
      Note: when using [Corax](../../indexes/search-engine/corax.mdx) as the search engine, indexes with more than `int.MaxValue` entries can be created and used.
      To match this capacity, queries over Corax indexes can skip a number of results that exceed this max value and take documents from that location.

* **Performance**:  
  Using paging is beneficial when handling large result datasets, contributing to improved performance.  
  See [paging and performance](../../indexes/querying/paging.mdx#paging-and-performance) here below.

* In this page:

    * [No-paging example](../../indexes/querying/paging.mdx#no---paging-example)
    * [Paging examples](../../indexes/querying/paging.mdx#paging-examples)
    * [Paging and performance](../../indexes/querying/paging.mdx#paging-and-performance)
    * [Paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results)

</Admonition>
## No-paging example

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// A simple query without paging:
// ==============================

List<Product> allResults = session
    .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
    .Where(x => x.UnitsInStock > 10)
    .OfType<Product>()
    .ToList();

// Executing the query on the Northwind sample data
// will result in all 47 Product documents that match the query predicate.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// A simple query without paging:
// ==============================

List<Product> allResults = await asyncSession
    .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
    .Where(x => x.UnitsInStock > 10)
    .OfType<Product>()
    .ToListAsync();

// Executing the query on the Northwind sample data
// will result in all 47 Product documents that match the query predicate.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// A simple DocumentQuery without paging:
// ======================================

List<Product> allResults = session.Advanced
    .DocumentQuery<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
    .WhereGreaterThan(x => x.UnitsInStock, 10)
    .OfType<Product>()
    .ToList();

// Executing the query on the Northwind sample data
// will result in all 47 Product documents that match the query predicate.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Products_ByUnitsInStock : AbstractIndexCreationTask<Product>
{
    public class IndexEntry
    {
        public int UnitsInStock { get; set; }
    }
    
    public Products_ByUnitsInStock()
    {
        Map = products => from product in products
            select new
            {
                UnitsInStock = product.UnitsInStock
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging examples

#### Retrieve a specific page:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Retrieve only the 3'rd page - when page size is 10:
// ===================================================

List<Product> thirdPageResults = session
    .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
     // Get the query stats if you wish to know the TOTAL number of results
    .Statistics(out QueryStatistics stats)
     // Apply some filtering condition as needed
    .Where(x => x.UnitsInStock > 10)
    .OfType<Product>()
     // Call 'Skip', pass the number of items to skip from the beginning of the result set
     // Skip the first 20 resulting documents
    .Skip(20)
     // Call 'Take' to define the number of documents to return
     // Take up to 10 products => so 10 is the "Page Size"
    .Take(10)
    .ToList();

// When executing this query on the Northwind sample data,
// results will include only 10 Product documents ("products/45-A" to "products/54-A")

long totalResults = stats.TotalResults;

// While the query returns only 10 results,
// \`totalResults\` will hold the total number of matching documents (47).
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Retrieve only the 3'rd page - when page size is 10:
// ===================================================

List<Product> thirdPageResults = await asyncSession
    .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
     // Get the query stats if you wish to know the TOTAL number of results
    .Statistics(out QueryStatistics stats)
     // Apply some filtering condition as needed
    .Where(x => x.UnitsInStock > 10)
    .OfType<Product>()
     // Call 'Skip', pass the number of items to skip from the beginning of the result set
     // Skip the first 20 resulting documents
    .Skip(20)
     // Call 'Take' to define the number of documents to return
     // Take up to 10 products => so 10 is the "Page Size"
    .Take(10)
    .ToListAsync();

// When executing this query on the Northwind sample data,
// results will include only 10 Product documents ("products/45-A" to "products/54-A")

long totalResults = stats.TotalResults;

// While the query returns only 10 results,
// \`totalResults\` will hold the total number of matching documents (47).
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Retrieve only the 3'rd page - when page size is 10:
// ===================================================

List<Product> thirdPageResults = session.Advanced
    .DocumentQuery<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
     // Get the query stats if you wish to know the TOTAL number of results
    .Statistics(out QueryStatistics stats)
     // Apply some filtering condition as needed
    .WhereGreaterThan(x => x.UnitsInStock, 10)
    .OfType<Product>()
     // Call 'Skip', pass the number of items to skip from the beginning of the result set
     // Skip the first 20 resulting documents
    .Skip(20)
     // Call 'Take' to define the number of documents to return
     // Take up to 10 products => so 10 is the "Page Size"
    .Take(10)
    .ToList();

// When executing this query on the Northwind sample data,
// results will include only 10 Product documents ("products/45-A" to "products/54-A")

long totalResults = stats.TotalResults;

// While the query returns only 10 results,
// \`totalResults\` will hold the total number of matching documents (47).
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Products_ByUnitsInStock : AbstractIndexCreationTask<Product>
{
    public class IndexEntry
    {
        public int UnitsInStock { get; set; }
    }
    
    public Products_ByUnitsInStock()
    {
        Map = products => from product in products
            select new
            {
                UnitsInStock = product.UnitsInStock
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 20, 10 // skip 20, take 10
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Page through all results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`// Query for all results - page by page:
// =====================================

List<Product> pagedResults;
int pageNumber = 0;
int pageSize = 10;
                
do
{
    pagedResults = session
        .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
         // Apply some filtering condition as needed
        .Where(x => x.UnitsInStock > 10)
        .OfType<Product>()
         // Skip the number of results that were already fetched
        .Skip(pageNumber * pageSize)
         // Request to get 'pageSize' results
        .Take(pageSize)
        .ToList();
    
    pageNumber++;
    
    // Make any processing needed with the current paged results here
    // ...
}
while (pagedResults.Count > 0); // Fetch next results
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`// Query for all results - page by page:
// =====================================

List<Product> pagedResults;
int pageNumber = 0;
int pageSize = 10;
                
do
{
    pagedResults = await asyncSession
        .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
         // Apply some filtering condition as needed
        .Where(x => x.UnitsInStock > 10)
        .OfType<Product>()
         // Skip the number of results that were already fetched
        .Skip(pageNumber * pageSize)
         // Request to get 'pageSize' results
        .Take(pageSize)
        .ToListAsync();
    
    pageNumber++;
    
    // Make any processing needed with the current paged results here
    // ...
}
while (pagedResults.Count > 0); // Fetch next results
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`// Query for all results - page by page:
// =====================================

List<Product> pagedResults;
int pageNumber = 0;
int pageSize = 10;
                
do
{
    pagedResults = session.Advanced
        .DocumentQuery<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
         // Apply some filtering condition as needed
        .WhereGreaterThan(x => x.UnitsInStock, 10)
        .OfType<Product>()
         // Skip the number of results that were already fetched
        .Skip(pageNumber * pageSize)
         // Request to get 'pageSize' results
        .Take(pageSize)
        .ToList();
    
    pageNumber++;
    
    // Make any processing needed with the current paged results here
    // ...
}
while (pagedResults.Count > 0); // Fetch next results
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Products_ByUnitsInStock : AbstractIndexCreationTask<Product>
{
    public class IndexEntry
    {
        public int UnitsInStock { get; set; }
    }
    
    public Products_ByUnitsInStock()
    {
        Map = products => from product in products
            select new
            {
                UnitsInStock = product.UnitsInStock
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 0, 10 // First loop will skip 0, take 10

// The next loops in the code will each generate the above RQL with an increased 'skip' value:
// limit 10, 10
// limit 20, 10
// limit 30, 10
// ...
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging and performance

#### Better performance:

It is recommended to explicitly set a page size when making a query that is expected to generate a significant number of results.
This practice has several benefits:

* Optimizes bandwidth usage by reducing data transfer between the server and client.
* Prevents delays in response times caused by sending too much data over the network.
* Avoids high memory consumption when dealing with numerous documents.
* Ensures a more manageable user experience by not overwhelming users with massive datasets at once.
#### Performance hints:

* By default, if the number of returned results exceeds **2048**, the server will issue a "Page size too big" notification (visible in the Studio) with information about the query.

* This threshold can be customized by modifying the value of the [PerformanceHints.MaxNumberOfResults](../../server/configuration/performance-hints-configuration.mdx#performancehintsmaxnumberofresults) configuration key.

* As suggested by the hint, you may consider using [Streaming query results](../../client-api/session/querying/how-to-stream-query-results.mdx) instead of paging.

![Figure 1. Performance Hint](./assets/performance-hint.png)



## Paging through tampered results

* The `QueryStatistics` object contains the `TotalResults` property,  
  which represents the total number of matching documents found in the query results.

* The `QueryStatistics` object also contains the `SkippedResults` property.  
  Whenever this property is greater than **0**, that implies the server has skipped that number of results from the index.

* The server will skip duplicate results internally in the following two scenarios:

    1. When making a [Projection query](../../indexes/querying/projections.mdx) with [Distinct](../../indexes/querying/distinct.mdx).

    2. When querying a [Fanout index](../../indexes/indexing-nested-data.mdx#fanout-index---multiple-index-entries-per-document).

* In those cases:

    * The `SkippedResults` property from the stats object will hold the count of skipped (duplicate) results.

    * The `TotalResults` property will be invalidated -  
      it will Not deduct the number of skipped results from the total number of results.

* In order to do proper paging in those scenarios:  
  include the `SkippedResults` value when specifying the number of documents to skip for each page using:  
  `(currentPage * pageSize) + SkippedResults`.

## Examples

#### A projection query with Distinct:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<ProjectedClass> pagedResults;

long totalResults = 0;
long skippedResults = 0;
int totalUniqueResults = 0;

int pageNumber = 0;
int pageSize = 10;
                
do
{
    pagedResults = session
        .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
        .Statistics(out QueryStatistics stats)
        .Where(x => x.UnitsInStock > 10)
        .OfType<Product>()
         // Define a projection
        .Select(x => new ProjectedClass
        {
            Category = x.Category,
            Supplier = x.Supplier
        })
         // Call Distinct to remove duplicate projected results
        .Distinct()
         // Add the number of skipped results to the "start location"  
        .Skip((pageNumber * pageSize) + skippedResults)
         // Define how many items to return
        .Take(pageSize)
        .ToList();
    
    totalResults = stats.TotalResults;        // Number of total matching documents (includes duplicates)
    skippedResults += stats.SkippedResults;   // Number of duplicate results that were skipped
    totalUniqueResults += pagedResults.Count; // Number of unique results returned in this server call
    
    pageNumber++;
}
while (pagedResults.Count > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total matching results reported in the stats is 47 (totalResults),
// but the total unique objects returned while paging the results is only 29 (totalUniqueResults)
// due to the 'Distinct' usage which removes duplicates.

// This is solved by adding the skipped results count to Skip().
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<ProjectedClass> pagedResults;

long totalResults = 0;
long skippedResults = 0;
int totalUniqueResults = 0;

int pageNumber = 0;
int pageSize = 10;
                
do
{
    pagedResults = await asyncSession
        .Query<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
        .Statistics(out QueryStatistics stats)
        .Where(x => x.UnitsInStock > 10)
        .OfType<Product>()
         // Define a projection
        .Select(x => new ProjectedClass
        {
            Category = x.Category,
            Supplier = x.Supplier
        })
         // Call Distinct to remove duplicate projected results
        .Distinct()
         // Add the number of skipped results to the "start location"  
        .Skip((pageNumber * pageSize) + skippedResults)
        .Take(pageSize)
        .ToListAsync();
    
    totalResults = stats.TotalResults;        // Number of total matching documents (includes duplicates)
    skippedResults += stats.SkippedResults;   // Number of duplicate results that were skipped
    totalUniqueResults += pagedResults.Count; // Number of unique results returned in this server call
    
    pageNumber++;
}
while (pagedResults.Count > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total matching results reported in the stats is 47 (totalResults),
// but the total unique objects returned while paging the results is only 29 (totalUniqueResults)
// due to the 'Distinct' usage which removes duplicates.

// This is solved by adding the skipped results count to Skip().
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<ProjectedClass> pagedResults;

long totalResults = 0;
long skippedResults = 0;
int totalUniqueResults = 0;

int pageNumber = 0;
int pageSize = 10;
                
do
{
    pagedResults = session.Advanced
        .DocumentQuery<Products_ByUnitsInStock.IndexEntry, Products_ByUnitsInStock>()
        .Statistics(out QueryStatistics stats)
        .WhereGreaterThan(x => x.UnitsInStock, 10)
        .OfType<Product>()
         // Define a projection
        .SelectFields<ProjectedClass>()
         // Call Distinct to remove duplicate projected results
        .Distinct()
         // Add the number of skipped results to the "start location"  
        .Skip((pageNumber * pageSize) + skippedResults)
        .Take(pageSize)
        .ToList();
    
    totalResults = stats.TotalResults;        // Number of total matching documents (includes duplicates)
    skippedResults += stats.SkippedResults;   // Number of duplicate results that were skipped
    totalUniqueResults += pagedResults.Count; // Number of unique results returned in this server call
    
    pageNumber++;
}
while (pagedResults.Count > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total matching results reported in the stats is 47 (totalResults),
// but the total unique objects returned while paging the results is only 29 (totalUniqueResults)
// due to the 'Distinct' usage which removes duplicates.

// This is solved by adding the skipped results count to Skip().
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Products_ByUnitsInStock : AbstractIndexCreationTask<Product>
{
    public class IndexEntry
    {
        public int UnitsInStock { get; set; }
    }
    
    public Products_ByUnitsInStock()
    {
        Map = products => from product in products
            select new
            {
                UnitsInStock = product.UnitsInStock
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Projected_class" label="Projected_class">
<CodeBlock language="csharp">
{`public class ProjectedClass
{
    public string Category { get; set; }
    public string Supplier { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
select distinct Category, Supplier
limit 0, 10  // First loop will skip 0, take 10, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Querying a Fanout index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Order> pagedResults;

long totalResults = 0;
long skippedResults = 0;
int totalUniqueResults = 0;

int pageNumber = 0;
int pageSize = 50;
                
do
{
    pagedResults = session
        .Query<Orders_ByProductName.IndexEntry, Orders_ByProductName>()
        .Statistics(out QueryStatistics stats)
        .OfType<Order>()
         // Add the number of skipped results to the "start location"  
        .Skip((pageNumber * pageSize) + skippedResults)
        .Take(pageSize)
        .ToList();
    
    totalResults = stats.TotalResults;
    skippedResults += stats.SkippedResults;
    totalUniqueResults += pagedResults.Count;
    
    pageNumber++;
}
while (pagedResults.Count > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total results reported in the stats is 2155 (totalResults),
// which represent the multiple index-entries generated as defined by the fanout index.

// By adding the skipped results count to the Skip() method,
// we get the correct total unique results which is 830 Order documents.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Order> pagedResults;

long totalResults = 0;
long skippedResults = 0;
int totalUniqueResults = 0;

int pageNumber = 0;
int pageSize = 50;
                
do
{
    pagedResults = await asyncSession
        .Query<Orders_ByProductName.IndexEntry, Orders_ByProductName>()
        .Statistics(out QueryStatistics stats)
        .OfType<Order>()
         // Add the number of skipped results to the "start location"  
        .Skip((pageNumber * pageSize) + skippedResults)
        .Take(pageSize)
        .ToListAsync();
    
    totalResults = stats.TotalResults;
    skippedResults += stats.SkippedResults;
    totalUniqueResults += pagedResults.Count;
    
    pageNumber++;
}
while (pagedResults.Count > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total results reported in the stats is 2155 (totalResults),
// which represent the multiple index-entries generated as defined by the fanout index.

// By adding the skipped results count to the Skip() method,
// we get the correct total unique results which is 830 Order documents.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Order> pagedResults;

long totalResults = 0;
long skippedResults = 0;
int totalUniqueResults = 0;

int pageNumber = 0;
int pageSize = 50;
                
do
{
    pagedResults = session.Advanced
        .DocumentQuery<Orders_ByProductName.IndexEntry, Orders_ByProductName>()
        .Statistics(out QueryStatistics stats)
        .OfType<Order>()
         // Add the number of skipped results to the "start location"  
        .Skip((pageNumber * pageSize) + skippedResults)
        .Take(pageSize)
        .ToList();
    
    totalResults = stats.TotalResults;
    skippedResults += stats.SkippedResults;
    totalUniqueResults += pagedResults.Count;
    
    pageNumber++;
}
while (pagedResults.Count > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total results reported in the stats is 2155 (totalResults),
// which represent the multiple index-entries generated as defined by the fanout index.

// By adding the skipped results count to the Skip() method,
// we get the correct total unique results which is 830 Order documents.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`// A fanout index - creating MULTIPLE index-entries per document:
// ==============================================================

public class Orders_ByProductName : AbstractIndexCreationTask<Order>
{
    public class IndexEntry
    {
        public string ProductName { get; set; }
    }
    
    public Orders_ByProductName()
    {
        Map = orders => 
            from order in orders
            from line in order.Lines
            select new IndexEntry
            {
                ProductName = line.ProductName
            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByProductName"
limit 0, 50  // First loop will skip 0, take 50, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="">

* **Paging**:  
  Paging is the process of fetching a subset (a page) of results from a dataset, rather than retrieving the entire results at once.
  This method enables processing query results one page at a time.

* **Default page size**:

    * Querying **Lucene** indexes:  
      If the client's query definition does Not explicitly specify the page size, the server will default to `int.MaxValue` (2,147,483,647).
      In such case, all results will be returned in a single server call.

    * Querying **Corax** indexes:  
      The default page size is the same as the one employed by Lucene.  
      Note: when using [Corax](../../indexes/search-engine/corax.mdx) as the search engine, indexes with more than `int.MaxValue` entries can be created and used.
      To match this capacity, queries over Corax indexes can skip a number of results that exceed this max value and take documents from that location.  

* **Performance**:  
  Using paging is beneficial when handling large result datasets, contributing to improved performance.  
  See [paging and performance](../../indexes/querying/paging.mdx#paging-and-performance) here below.

* In this page:

    * [No-paging example](../../indexes/querying/paging.mdx#no---paging-example)
    * [Paging examples](../../indexes/querying/paging.mdx#paging-examples)
    * [Paging and performance](../../indexes/querying/paging.mdx#paging-and-performance)
    * [Paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results)

</Admonition>
## No-paging example

The queries below will return all the results available.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Product> results = session
    .query(Product.class, Products_ByUnitsInStock.class)
    .whereGreaterThan("UnitsInStock", 10)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {
    public Products_ByUnitsInStock() {
        map = "docs.Products.Select(product => new {" +
            "    UnitsInStock = product.UnitsInStock" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging examples

#### Basic paging:

Let's assume that our page size is `10`, and we want to retrieve the 3rd page. To do this, we need to issue following query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Product> results = session
    .query(Product.class, Products_ByUnitsInStock.class)
    .whereGreaterThan("UnitsInStock", 10)
    .skip(20) // skip 2 pages worth of products
    .take(10) // take up to 10 products
    .toList(); // execute query
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {
    public Products_ByUnitsInStock() {
        map = "docs.Products.Select(product => new {" +
            "    UnitsInStock = product.UnitsInStock" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 20, 10 // skip 20, take 10
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Find total results count when paging:

While paging, you sometimes need to know the exact number of results returned from the query. The Client API supports this explicitly:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`Reference<QueryStatistics> stats = new Reference<QueryStatistics>();

List<Product> results = session
    .query(Product.class, Products_ByUnitsInStock.class)
    .statistics(stats)
    .whereGreaterThan("UnitsInStock", 10)
    .skip(20)
    .take(10)
    .toList();

int totalResults = stats.value.getTotalResults();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {
    public Products_ByUnitsInStock() {
        map = "docs.Products.Select(product => new {" +
            "    UnitsInStock = product.UnitsInStock" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 20, 10 // skip 20, take 10
`}
</CodeBlock>
</TabItem>
</Tabs>

While the query will return with just 10 results, `totalResults` will hold the total number of matching documents.



## Paging and performance

#### Better performance:

It is recommended to explicitly set a page size when making a query that is expected to generate a significant number of results.
This practice has several benefits:

* Optimizes bandwidth usage by reducing data transfer between the server and client.
* Prevents delays in response times caused by sending too much data over the network.
* Avoids high memory consumption when dealing with numerous documents.
* Ensures a more manageable user experience by not overwhelming users with massive datasets at once.
#### Performance hints:

* By default, if the number of returned results exceeds **2048**, the server will issue a "Page size too big" notification (visible in the Studio) with information about the query.

* This threshold can be customized by modifying the value of the [PerformanceHints.MaxNumberOfResults](../../server/configuration/performance-hints-configuration.mdx#performancehintsmaxnumberofresults) configuration key.

* As suggested by the hint, you may consider using [Streaming query results](../../client-api/session/querying/how-to-stream-query-results.mdx) instead of paging.

![Figure 1. Performance Hint](./assets/performance-hint.png)



## Paging through tampered results

* The `QueryStatistics` object contains the `TotalResults` property,  
  which represents the total number of matching documents found in the query results.

* The `QueryStatistics` object also contains the `SkippedResults` property.  
  Whenever this property is greater than **0**, that implies the server has skipped that number of results from the index.

* The server will skip duplicate results internally in the following two scenarios:

    1. When making a [Projection query](../../indexes/querying/projections.mdx) with [Distinct](../../indexes/querying/distinct.mdx).

    2. When querying a [Fanout index](../../indexes/indexing-nested-data.mdx#fanout-index---multiple-index-entries-per-document).

* In those cases:

    * The `SkippedResults` property from the stats object will hold the count of skipped (duplicate) results.

    * The `TotalResults` property will be invalidated -  
      it will Not deduct the number of skipped results from the total number of results.

* In order to do proper paging in those scenarios:  
  include the `SkippedResults` value when specifying the number of documents to skip for each page using:  
  `(currentPage * pageSize) + SkippedResults`.

## Examples

#### A projection query with Distinct:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Product> results;
int pageNumber = 0;
int pageSize = 10;
int skippedResults = 0;
Reference<QueryStatistics> stats = new Reference<>();

do {

    results = session
        .query(Product.class, Products_ByUnitsInStock.class)
        .statistics(stats)
        .skip((pageNumber * pageSize) + skippedResults)
        .take(pageSize)
        .whereGreaterThan("UnitsInStock", 10)
        .distinct()
        .toList();

    skippedResults += stats.value.getSkippedResults();
    pageNumber++;
} while (results.size() > 0);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {
    public Products_ByUnitsInStock() {
        map = "docs.Products.Select(product => new {" +
            "    UnitsInStock = product.UnitsInStock" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
select distinct *
limit 0, 10  // First loop will skip 0, take 10, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Querying a Fanout index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Order> results;
int pageNumber = 0;
int pageSize = 50;
int skippedResults = 0;
Reference<QueryStatistics> stats = new Reference<>();

do {
    results = session
        .query(Order.class, Order_ByOrderLines_ProductName.class)
        .statistics(stats)
        .skip((pageNumber * pageSize) + skippedResults)
        .take(pageSize)
        .toList();

    skippedResults += stats.value.getSkippedResults();
    pageNumber++;
} while (results.size() > 0);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Orders_ByOrderLines_ProductName extends AbstractIndexCreationTask {
    public Orders_ByOrderLines_ProductName() {
        map = "docs.Orders.SelectMany(order => order.Lines, (order, line) => new {" +
            "    Product = line.ProductName " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Order/ByOrderLines/ProductName"
limit 0, 50  // First loop will skip 0, take 50, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="">

* **Paging**:  
  Paging is the process of fetching a subset (a page) of results from a dataset, rather than retrieving the entire results at once.
  This method enables processing query results one page at a time.

* **Default page size**:  

    * Querying **Lucene** indexes:  
      If the client's query definition does Not explicitly specify the page size, 
      the server will default to a C# `int.MaxValue` (2,147,483,647).
      In such a case, all results will be returned in a single server call.
  
    * Querying **Corax** indexes:  
      The default page size is the same as the one employed by Lucene.  
      Note: when using [Corax](../../indexes/search-engine/corax.mdx) as the search engine, 
      indexes with more than a C# `int.MaxValue` entries can be created and used.  
      To match this capacity, queries over Corax indexes can skip a number of results that exceed this max value and take documents from that location.

* **Performance**:  
  Using paging is beneficial when handling large result datasets, contributing to improved performance.  
  See [paging and performance](../../indexes/querying/paging.mdx#paging-and-performance) here below.

* In this page:

    * [No-paging example](../../indexes/querying/paging.mdx#no---paging-example)
    * [Paging examples](../../indexes/querying/paging.mdx#paging-examples)
    * [Paging and performance](../../indexes/querying/paging.mdx#paging-and-performance)
    * [Paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results)

</Admonition>
## No-paging example

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`# A simple query without paging:
# ==============================
all_results = list(
    session.query_index_type(Products_ByUnitsInStock, Products_ByUnitsInStock.IndexEntry)
    .where_greater_than("units_in_stock", 10)
    .of_type(Product)
)

# Executing the query on the Northwind sample data
# will result in all 47 Product documents that match the query predicate.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Products_ByUnitsInStock(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from product in docs.Products select new { units_in_stock = product.UnitsInStock }"

    class IndexEntry:
        def __init__(self, units_in_stock: int = None):
            self.units_in_stock = units_in_stock
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging examples

#### Retrieve a specific page:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`# Retrieve only the 3'rd page - when page size is 10:
# ===================================================
def __stats_callback(statistics: QueryStatistics):
    total_results = statistics.total_results
    # While the query below returns only 10 results,
    # 'total_results' will hold the total number of matching documents (47).

third_page_results = list(
    session.query_index_type(Products_ByUnitsInStock, Products_ByUnitsInStock.IndexEntry)
    # Get the query stats if you wish to know the TOTAL number of results
    .statistics(__stats_callback)
    # Apply some filtering condition as needed
    .where_greater_than("units_in_stock", 10).of_type(Product)
    # Call 'skip', pass the number of items to skip from the beginning of the result set
    # Skip the first 20 resulting documents
    .skip(20)
    # Call 'take' to define the number of documents to return
    # Take up to 10 products => so 10 is the "Page Size"
    .take(10)
)

en executing this query on the Northwind sample data,
sults will include only 10 Product documents ("products/45-A" to "products/54-A")

 store.open_session() as session:
# region paging_2_1
# Query for all results - page by page:
# =====================================
paged_results: List[Product] = []
page_number = 0
page_size = 10

while True:
    paged_results = list(
        session.query_index_type(Products_ByUnitsInStock, Products_ByUnitsInStock.IndexEntry)
        # Apply some filtering condition as needed
        .where_greater_than("units_in_stock", 10).of_type(Product)
        # Skip the number of results that were already fetched
        .skip(page_number * page_size)
        # Request to get 'page_size' results
        .take(page_size)
    )
    page_number += 1

    if len(paged_results) == 0:
        break

    # Make any processing needed with the current paged results here
    # ...
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Products_ByUnitsInStock(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from product in docs.Products select new { units_in_stock = product.UnitsInStock }"

    class IndexEntry:
        def __init__(self, units_in_stock: int = None):
            self.units_in_stock = units_in_stock
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 20, 10 // skip 20, take 10
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Page through all results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`# Query for all results - page by page:
# =====================================
paged_results: List[Product] = []
page_number = 0
page_size = 10

while True:
    paged_results = list(
        session.query_index_type(Products_ByUnitsInStock, Products_ByUnitsInStock.IndexEntry)
        # Apply some filtering condition as needed
        .where_greater_than("units_in_stock", 10).of_type(Product)
        # Skip the number of results that were already fetched
        .skip(page_number * page_size)
        # Request to get 'page_size' results
        .take(page_size)
    )
    page_number += 1

    if len(paged_results) == 0:
        break

    # Make any processing needed with the current paged results here
    # ...
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Products_ByUnitsInStock(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from product in docs.Products select new { units_in_stock = product.UnitsInStock }"

    class IndexEntry:
        def __init__(self, units_in_stock: int = None):
            self.units_in_stock = units_in_stock
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 0, 10 // First loop will skip 0, take 10

// The next loops in the code will each generate the above RQL with an increased 'skip' value:
// limit 10, 10
// limit 20, 10
// limit 30, 10
// ...
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging and performance

#### Better performance:

It is recommended to explicitly set a page size when making a query that is expected to generate a significant number of results.
This practice has several benefits:

* Optimizes bandwidth usage by reducing data transfer between the server and client.
* Prevents delays in response times caused by sending too much data over the network.
* Avoids high memory consumption when dealing with numerous documents.
* Ensures a more manageable user experience by not overwhelming users with massive datasets at once.
#### Performance hints:

* By default, if the number of returned results exceeds **2048**, the server will issue a "Page size too big" notification (visible in the Studio) with information about the query.

* This threshold can be customized by modifying the value of the [PerformanceHints.MaxNumberOfResults](../../server/configuration/performance-hints-configuration.mdx#performancehintsmaxnumberofresults) configuration key.

* As suggested by this performance hint, you may consider using [Streaming query results](../../client-api/session/querying/how-to-stream-query-results.mdx) instead of paging.
  
     ![Figure 1. Performance Hint](./assets/performance-hint.png)



## Paging through tampered results

* The `QueryStatistics` object contains the `total_results` property,  
  which represents the total number of matching documents found in the query results.

* The `QueryStatistics` object also contains the `skipped_results` property.  
  Whenever this property is greater than **0**, that implies the server has skipped that number of results from the index.

* The server will skip duplicate results internally in the following two scenarios:

    1. When making a [Projection query](../../indexes/querying/projections.mdx) with [Distinct](../../indexes/querying/distinct.mdx).

    2. When querying a [Fanout index](../../indexes/indexing-nested-data.mdx#fanout-index---multiple-index-entries-per-document).

* In these cases:

    * The `skipped_results` property from the stats object will hold the count of skipped (duplicate) results.

    * The `total_results` property will be invalidated -  
      it will Not deduct the number of skipped results from the total number of results.

* To do proper paging in these scenarios:  
  include the `skipped_results` value when specifying the number of documents to skip for each page using:  
  `(current_page * page_size) + skipped_results`.

## Examples

#### A projection query with Distinct:

<Tabs groupId='languageSyntax'>
<TabItem value="query_index_type" label="query_index_type">
<CodeBlock language="python">
{`paged_results: List[ProjectedClass] = []

total_results = 0
total_unique_results = 0
skipped_results = 0

page_number = 0
page_size = 10

def __stats_callback(statistics: QueryStatistics):
    total_results = statistics.total_results
    nonlocal skipped_results
    skipped_results += statistics.skipped_results

while True:
    paged_results = list(
        session.query_index_type(Products_ByUnitsInStock, Products_ByUnitsInStock.IndexEntry)
        .statistics(__stats_callback)
        .where_greater_than("units_in_stock", 10)
        .of_type(Product)
        # Define a projection
        .select_fields(ProjectedClass)
        # Call distinct to remove duplicate projected results
        .distinct()
        # Add the number of skipped results to the "start location"
        .skip((page_size * page_size) + skipped_results)
        .take(page_size)
    )

    total_unique_results += len(paged_results)

    if len(paged_results) == 0:
        break

# When executing the query on the Northwind sample data:
# ======================================================

# The total matching results reported in the stats is 47 (totalResults),
# but the total unique objects returned while paging the results is only 29 (totalUniqueResults)
# due to the 'Distinct' usage which removes duplicates.

# This is solved by adding the skipped results count to Skip().
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Products_ByUnitsInStock(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from product in docs.Products select new { units_in_stock = product.UnitsInStock }"

    class IndexEntry:
        def __init__(self, units_in_stock: int = None):
            self.units_in_stock = units_in_stock
`}
</CodeBlock>
</TabItem>
<TabItem value="Projected_class" label="Projected_class">
<CodeBlock language="python">
{`class ProjectedClass:
    def __init__(self, category: str = None, supplier: str = None):
        self.category = category
        self.supplier = supplier

    # Handle different casing by implementing from_json class method
    @classmethod
    def from_json(cls, json_dict: Dict[str, Any]):
        return cls(json_dict["Category"], json_dict["Supplier"])
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
select distinct Category, Supplier
limit 0, 10  // First loop will skip 0, take 10, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Querying a Fanout index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`paged_results: List[Order] = []

total_results = 0
total_unique_results = 0
skipped_results = 0

page_number = 0
page_size = 50

def __stats_callback(statistics: QueryStatistics):
    nonlocal skipped_results
    skipped_results += statistics.skipped_results
    total_results = statistics.total_results

while True:
    paged_results = list(
        session.query_index_type(Orders_ByProductName, Orders_ByProductName.IndexEntry)
        .statistics(__stats_callback)
        .of_type(Order)
        # Add the number of skipped results to the "start location"
        .skip((page_size * page_size) + skipped_results)
        .take(page_size)
    )

    total_unique_results += len(paged_results)

    if len(paged_results) == 0:
        break

# When executing the query on the Northwind sample data:
# ======================================================

# The total results reported in the stats is 2155 (total_results),
# which represent the multiple index-entries generated as defined by the fanout index.

# By adding the skipped results count to the skip() method,
# we get the correct total unique results which is 830 Order documents.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`# A fanout index - creating MULTIPLE index-entries per document:
# ==============================================================
class Orders_ByProductName(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, product_name: str = None):
            self.product_name = product_name

    def __init__(self):
        super().__init__()
        self.map = "from order in docs.Orders from line in order.Lines select new { product_name = line.ProductName }"
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByProductName"
limit 0, 50  // First loop will skip 0, take 50, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="">

* **Paging**:  
  Paging is the process of fetching a subset (a page) of results from a dataset, rather than retrieving the entire results at once.
  This method enables processing query results one page at a time.

* **Default page size**:  

    * Querying **Lucene** indexes:  
      If the client's query definition does Not explicitly specify the page size, 
      the server will default to a C# `int.MaxValue` (2,147,483,647).
      In such a case, all results will be returned in a single server call.
  
    * Querying **Corax** indexes:  
      The default page size is the same as the one employed by Lucene.  
      Note: when using [Corax](../../indexes/search-engine/corax.mdx) as the search engine, 
      indexes with more than a C# `int.MaxValue` entries can be created and used.  
      To match this capacity, queries over Corax indexes can skip a number of results that exceed this max value and take documents from that location.

* **Performance**:  
  Using paging is beneficial when handling large result datasets, contributing to improved performance.  
  See [paging and performance](../../indexes/querying/paging.mdx#paging-and-performance) here below.

* In this page:

  * [No-paging example](../../indexes/querying/paging.mdx#no-paging-example)
  * [Paging examples](../../indexes/querying/paging.mdx#paging-examples)
  * [Paging and performance](../../indexes/querying/paging.mdx#paging-and-performance)
  * [Paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results)

</Admonition>
## No-paging example

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`// A simple query without paging:
// ==============================

/** @var array<Product> $allResults */
$allResults = $session
    ->query(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
    ->whereGreaterThan("UnitsInStock", 10)
    ->ofType(Product::class)
    ->toList();

// Executing the query on the Northwind sample data
// will result in all 47 Product documents that match the query predicate.
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`// A simple DocumentQuery without paging:
// ======================================

/** @var array<Product> $allResults */
$allResults = $session->advanced()
    ->documentQuery(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
    ->whereGreaterThan("UnitsInStock", 10)
    ->ofType(Product::class)
    ->toList();

// Executing the query on the Northwind sample data
// will result in all 47 Product documents that match the query predicate.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Products_ByUnitsInStock_IndexEntry
{
    private ?int $unitsInStock = null;

    public function getUnitsInStock(): ?int
    {
        return $this->unitsInStock;
    }

    public function setUnitsInStock(?int $unitsInStock): void
    {
        $this->unitsInStock = $unitsInStock;
    }
}

class Products_ByUnitsInStock extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.Products.Select(product => new {" .
            "    UnitsInStock = product.UnitsInStock" .
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging examples

#### Retrieve a specific page:  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`// Retrieve only the 3'rd page - when page size is 10:
// ===================================================

$stats = new QueryStatistics();

/** @var array<Product> $thirdPageResults */
$thirdPageResults = $session
    ->query(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
     // Get the query stats if you wish to know the TOTAL number of results
    ->statistics($stats )
     // Apply some filtering condition as needed
    ->whereGreaterThan("UnitsInStock", 10)
    ->ofType(Product::class)
     // Call 'Skip', pass the number of items to skip from the beginning of the result set
     // Skip the first 20 resulting documents
    ->skip(20)
     // Call 'Take' to define the number of documents to return
     // Take up to 10 products => so 10 is the "Page Size"
    ->take(10)
    ->toList();

// When executing this query on the Northwind sample data,
// results will include only 10 Product documents ("products/45-A" to "products/54-A")

$totalResults = $stats->getTotalResults();

// While the query returns only 10 results,
// \`totalResults\` will hold the total number of matching documents (47).
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`// Retrieve only the 3'rd page - when page size is 10:
// ===================================================

$stats = new QueryStatistics();

/** @var array<Product> $thirdPageResults */
$thirdPageResults = $session->advanced()
    ->documentQuery(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
     // Get the query stats if you wish to know the TOTAL number of results
    ->statistics($stats)
     // Apply some filtering condition as needed
    ->whereGreaterThan("UnitsInStock", 10)
    ->ofType(Product::class)
     // Call 'Skip', pass the number of items to skip from the beginning of the result set
     // Skip the first 20 resulting documents
    ->skip(20)
     // Call 'Take' to define the number of documents to return
     // Take up to 10 products => so 10 is the "Page Size"
    ->take(10)
    ->toList();

// When executing this query on the Northwind sample data,
// results will include only 10 Product documents ("products/45-A" to "products/54-A")

$totalResults = $stats->getTotalResults();

// While the query returns only 10 results,
// \`totalResults\` will hold the total number of matching documents (47).
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Products_ByUnitsInStock_IndexEntry
{
    private ?int $unitsInStock = null;

    public function getUnitsInStock(): ?int
    {
        return $this->unitsInStock;
    }

    public function setUnitsInStock(?int $unitsInStock): void
    {
        $this->unitsInStock = $unitsInStock;
    }
}

class Products_ByUnitsInStock extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.Products.Select(product => new {" .
            "    UnitsInStock = product.UnitsInStock" .
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10 
limit 20, 10 // skip 20, take 10
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Page through all results:  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`// Query for all results - page by page:
// =====================================

$pagedResults = null;
$pageNumber = 0;
$pageSize = 10;

do
{
    $pagedResults = $session
        ->query(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
         // Apply some filtering condition as needed
        ->whereGreaterThan("UnitsInStock", 10)
        ->ofType(Product::class)
         // Skip the number of results that were already fetched
        ->skip($pageNumber * $pageSize)
         // Request to get 'pageSize' results
        ->take($pageSize)
        ->toList();

    $pageNumber++;

    // Make any processing needed with the current paged results here
    // ...
}
while (count($pagedResults) > 0); // Fetch next results
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`// Query for all results - page by page:
// =====================================

$pagedResults = null;
$pageNumber = 0;
$pageSize = 10;

do
{
    $pagedResults = $session->advanced()
        ->documentQuery(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
        // Apply some filtering condition as needed
        ->whereGreaterThan("UnitsInStock", 10)
        ->ofType(Product::class)
        // Skip the number of results that were already fetched
        ->skip($pageNumber * $pageSize)
        // Request to get 'pageSize' results
        ->take($pageSize)
        ->toList();

    $pageNumber++;

    // Make any processing needed with the current paged results here
    // ...
}
while (count($pagedResults) > 0); // Fetch next results
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Products_ByUnitsInStock_IndexEntry
{
    private ?int $unitsInStock = null;

    public function getUnitsInStock(): ?int
    {
        return $this->unitsInStock;
    }

    public function setUnitsInStock(?int $unitsInStock): void
    {
        $this->unitsInStock = $unitsInStock;
    }
}

class Products_ByUnitsInStock extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.Products.Select(product => new {" .
            "    UnitsInStock = product.UnitsInStock" .
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 0, 10 // First loop will skip 0, take 10  

// The next loops in the code will each generate the above RQL with an increased 'skip' value:
// limit 10, 10
// limit 20, 10
// limit 30, 10
// ...
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging and performance

#### Better performance:

It is recommended to explicitly set a page size when making a query that is expected to generate a significant number of results.
This practice has several benefits:

* Optimizes bandwidth usage by reducing data transfer between the server and client.
* Prevents delays in response times caused by sending too much data over the network.
* Avoids high memory consumption when dealing with numerous documents.
* Ensures a more manageable user experience by not overwhelming users with massive datasets at once.
#### Performance hints:

* By default, if the number of returned results exceeds **2048**, the server will issue a "Page size too big" notification (visible in the Studio) with information about the query.

* This threshold can be customized by modifying the value of the [PerformanceHints.MaxNumberOfResults](../../server/configuration/performance-hints-configuration.mdx#performancehintsmaxnumberofresults) configuration key.

* As suggested by this performance hint, you may consider using [Streaming query results](../../client-api/session/querying/how-to-stream-query-results.mdx) instead of paging.
  
     ![Figure 1. Performance Hint](./assets/performance-hint.png)



## Paging through tampered results

* The `QueryStatistics` object contains the `totalResults` property,  
  which represents the total number of matching documents found in the query results.

* The `QueryStatistics` object also contains the `skippedResults` property.  
  Whenever this property is greater than **0**, that implies the server has skipped that number of results from the index.

* The server will skip duplicate results internally in the following two scenarios:  

    1. When making a [Projection query](../../indexes/querying/projections.mdx) with [Distinct](../../indexes/querying/distinct.mdx).
  
    2. When querying a [Fanout index](../../indexes/indexing-nested-data.mdx#fanout-index---multiple-index-entries-per-document).

* In these cases:

    * The `skippedResults` property from the stats object will hold the count of skipped (duplicate) results.

    * The `totalResults` property will be invalidated -  
      it will Not deduct the number of skipped results from the total number of results.

* To do proper paging in these scenarios:  
  include the `skippedResults` value when specifying the number of documents to skip for each page using:  
  `(currentPage * pageSize) + skippedResults`.

## Examples

#### A projection query with Distinct:

<Tabs groupId='languageSyntax'>
<TabItem value="query" label="query">
<CodeBlock language="php">
{`$pagedResults = null;

$totalResults = 0;
$totalUniqueResults = 0;
$skippedResults = 0;

$pageNumber = 0;
$pageSize = 10;

do
{
    $pagedResults = $session
            ->query(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
            ->statistics($stats)
            ->whereGreaterThan("UnitsInStock", 10)
            ->ofType(Product::class)
            // Define a projection
            ->selectFields(ProjectedClass::class)
             // Call Distinct to remove duplicate projected results
            ->distinct()
             // Add the number of skipped results to the "start location"
            ->skip(($pageNumber * $pageSize) + $skippedResults)
             // Define how many items to return
            ->take($pageSize)
            ->toList();

    $totalResults = $stats->getTotalResults();        // Number of total matching documents (includes duplicates)
    $skippedResults += $stats->getSkippedResults();   // Number of duplicate results that were skipped
    $totalUniqueResults += count($pagedResults); // Number of unique results returned in this server call

    $pageNumber++;
}
while (count($pagedResults) > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total matching results reported in the stats is 47 (totalResults),
// but the total unique objects returned while paging the results is only 29 (totalUniqueResults)
// due to the 'Distinct' usage which removes duplicates.

// This is solved by adding the skipped results count to Skip().
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`$pagedResults = null;

$totalResults = 0;
$totalUniqueResults = 0;
$skippedResults = 0;

$pageNumber = 0;
$pageSize = 10;

do
{
    $pagedResults = $session->advanced()
        ->documentQuery(Products_ByUnitsInStock_IndexEntry::class, Products_ByUnitsInStock::class)
        ->statistics($stats)
        ->whereGreaterThan("UnitsInStock", 10)
        ->ofType(Product::class)
         // Define a projection
        ->selectFields(ProjectedClass::class)
         // Call Distinct to remove duplicate projected results
        ->distinct()
         // Add the number of skipped results to the "start location"
        ->skip(($pageNumber * $pageSize) + $skippedResults)
        ->take($pageSize)
        ->toList();

    $totalResults = $stats->getTotalResults();        // Number of total matching documents (includes duplicates)
    $skippedResults += $stats->getSkippedResults();   // Number of duplicate results that were skipped
    $totalUniqueResults += count($pagedResults);      // Number of unique results returned in this server call

    $pageNumber++;
}
while (count($pagedResults) > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total matching results reported in the stats is 47 (totalResults),
// but the total unique objects returned while paging the results is only 29 (totalUniqueResults)
// due to the 'Distinct' usage which removes duplicates.

// This is solved by adding the skipped results count to Skip().
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Products_ByUnitsInStock_IndexEntry
{
    private ?int $unitsInStock = null;

    public function getUnitsInStock(): ?int
    {
        return $this->unitsInStock;
    }

    public function setUnitsInStock(?int $unitsInStock): void
    {
        $this->unitsInStock = $unitsInStock;
    }
}

class Products_ByUnitsInStock extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.Products.Select(product => new {" .
            "    UnitsInStock = product.UnitsInStock" .
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Projected_class" label="Projected_class">
<CodeBlock language="php">
{`class ProjectedClass
{
    public ?string $category = null;
    public ?string $supplier = null;

    public function getCategory(): ?string
    {
        return $this->category;
    }

    public function setCategory(?string $category): void
    {
        $this->category = $category;
    }

    public function getSupplier(): ?string
    {
        return $this->supplier;
    }

    public function setSupplier(?string $supplier): void
    {
        $this->supplier = $supplier;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
select distinct Category, Supplier
limit 0, 10  // First loop will skip 0, take 10, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Querying a Fanout index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$pagedResults = null;

$totalResults = 0;
$totalUniqueResults = 0;
$skippedResults = 0;

$pageNumber = 0;
$pageSize = 50;

do
{
    $pagedResults = $session
        ->query(Orders_ByProductName_IndexEntry::class, Orders_ByProductName::class)
        ->statistics($stats)
        ->ofType(Order::class)
         // Add the number of skipped results to the "start location"
        ->skip(($pageNumber * $pageSize) + $skippedResults)
        ->take($pageSize)
        ->toList();

    $totalResults = $stats->getTotalResults();
    $skippedResults += $stats->getSkippedResults();
    $totalUniqueResults += count($pagedResults);

    $pageNumber++;
}
while (count($pagedResults) > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total results reported in the stats is 2155 (totalResults),
// which represent the multiple index-entries generated as defined by the fanout index.

// By adding the skipped results count to the Skip() method,
// we get the correct total unique results which is 830 Order documents.
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`$pagedResults = null;

$totalResults = 0;
$totalUniqueResults = 0;
$skippedResults = 0;

$pageNumber = 0;
$pageSize = 50;

do
{
    $pagedResults = $session->advanced()
        ->documentQuery(Orders_ByProductName_IndexEntry::class, Orders_ByProductName::class)
        ->statistics($stats)
        ->ofType(Order::class)
         // Add the number of skipped results to the "start location"
        ->skip(($pageNumber * $pageSize) + $skippedResults)
        ->take($pageSize)
        ->toList();

    $totalResults = $stats->getTotalResults();
    $skippedResults += $stats->getSkippedResults();
    $totalUniqueResults += count($pagedResults);

    $pageNumber++;
}
while (count($pagedResults) > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total results reported in the stats is 2155 (totalResults),
// which represent the multiple index-entries generated as defined by the fanout index.

// By adding the skipped results count to the Skip() method,
// we get the correct total unique results which is 830 Order documents.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`// A fanout index - creating MULTIPLE index-entries per document:
// ==============================================================

class Orders_ByProductName_IndexEntry
{
    private ?string $productName = null;

    public function getProductName(): ?string
    {
        return $this->productName;
    }

    public function setProductName(?string $productName): void
    {
        $this->productName = $productName;
    }
}
class Orders_ByProductName extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "docs.Orders.SelectMany(order => order.Lines, (order, line) => new {" .
                "    Product = line.ProductName " .
                "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByProductName"
limit 0, 50  // First loop will skip 0, take 50, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">

* **Paging**:  
  Paging is the process of fetching a subset (a page) of results from a dataset, rather than retrieving the entire results at once.
  This method enables processing query results one page at a time.

* **Default page size**:

    * Querying **Lucene** indexes:  
      If the client's query definition does Not explicitly specify the page size, the server will default to `2,147,483,647` (equivalent to  `int.MaxValue` in C#). 
      In such case, all results will be returned in a single server call.

    * Querying **Corax** indexes:  
      The default page size is the same as the one employed by Lucene.  
      Note: when using [Corax](../../indexes/search-engine/corax.mdx) as the search engine, indexes with more than `2,147,483,647` entries can be created and used.
      To match this capacity, queries over Corax indexes can skip a number of results that exceed this max value and take documents from that location.  

* **Performance**:  
  Using paging is beneficial when handling large result datasets, contributing to improved performance.  
  See [paging and performance](../../indexes/querying/paging.mdx#paging-and-performance) here below.

* In this page:

    * [No-paging example](../../indexes/querying/paging.mdx#no---paging-example)
    * [Paging examples](../../indexes/querying/paging.mdx#paging-examples)
    * [Paging and performance](../../indexes/querying/paging.mdx#paging-and-performance)
    * [Paging through tampered results](../../indexes/querying/paging.mdx#paging-through-tampered-results)

</Admonition>
## No-paging example

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// A simple query without paging:
// ==============================

const allResults = await session
    .query({ indexName: "Products/ByUnitsInStock" })
    .whereGreaterThan("UnitsInStock", 10)
    .all();

// Executing the query on the Northwind sample data
// will result in all 47 Product documents that match the query predicate.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Products_ByUnitsInStock extends AbstractJavaScriptIndexCreationTask  {
    constructor() {
        super();

        this.map("Products", p => ({
            UnitsInStock: p.UnitsInStock
        }));
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging examples

#### Retrieve a specific page:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Retrieve only the 3'rd page - when page size is 10:
// ===================================================

// Define an output param for getting the query stats
let stats;

const thirdPageResults = await session
    .query({ indexName: "Products/ByUnitsInStock" })
     // Get the query stats if you wish to know the TOTAL number of results
    .statistics(s => stats = s)
     // Apply some filtering condition as needed
    .whereGreaterThan("UnitsInStock", 10)
     // Call 'Skip', pass the number of items to skip from the beginning of the result set
     // Skip the first 20 resulting documents
    .skip(20)
     // Call 'Take' to define the number of documents to return
     // Take up to 10 products => so 10 is the "Page Size"
    .take(10)
    .all();

// When executing this query on the Northwind sample data,
// results will include only 10 Product documents ("products/45-A" to "products/54-A")

const totalResults = stats.totalResults;

// While the query returns only 10 results,
// \`totalResults\` will hold the total number of matching documents (47).
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Products_ByUnitsInStock extends AbstractJavaScriptIndexCreationTask  {
    constructor() {
        super();

        this.map("Products", p => ({
            UnitsInStock: p.UnitsInStock
        }));
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 20, 10 // skip 20, take 10
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Page through all results:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Query for all results - page by page:
// =====================================

const PAGE_SIZE = 10;
let pageNumber = 0;
let pagedResults;

do {
    pagedResults = await session
        .query({ indexName: "Products/ByUnitsInStock" })
         // Apply some filtering condition as needed
        .whereGreaterThan("UnitsInStock", 10)
         // Skip the number of results that were already fetched
        .skip(pageNumber * PAGE_SIZE)
         // Request to get 'pageSize' results
        .take(PAGE_SIZE)
        .all();

    pageNumber++;

    // Make any processing needed with the current paged results here
    // ... 
}
while (pagedResults.length > 0); // Fetch next results
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Products_ByUnitsInStock extends AbstractJavaScriptIndexCreationTask  {
    constructor() {
        super();

        this.map("Products", p => ({
            UnitsInStock: p.UnitsInStock
        }));
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
limit 0, 10 // First loop will skip 0, take 10

// The next loops in the code will each generate the above RQL with an increased 'skip' value:
// limit 10, 10
// limit 20, 10
// limit 30, 10
// ...
`}
</CodeBlock>
</TabItem>
</Tabs>



## Paging and performance
**Better performance**:

It is recommended to explicitly set a page size when making a query that is expected to generate a significant number of results.
This practice has several benefits:

* Optimizes bandwidth usage by reducing data transfer between the server and client.
* Prevents delays in response times caused by sending too much data over the network.
* Avoids high memory consumption when dealing with numerous documents.
* Ensures a more manageable user experience by not overwhelming users with massive datasets at once.
**Performance hints**:

* By default, if the number of returned results exceeds **2048**, the server will issue a "Page size too big" notification (visible in the Studio) with information about the query.

* This threshold can be customized by modifying the value of the [PerformanceHints.MaxNumberOfResults](../../server/configuration/performance-hints-configuration.mdx#performancehintsmaxnumberofresults) configuration key.

* As suggested by the hint, you may consider using [Streaming query results](../../client-api/session/querying/how-to-stream-query-results.mdx) instead of paging.

![Figure 1. Performance Hint](./assets/performance-hint.png)



## Paging through tampered results

* The `QueryStatistics` object contains the `totalResults` property,  
  which represents the total number of matching documents found in the query results.

* The `QueryStatistics` object also contains the `skippedResults` property.  
  Whenever this property is greater than **0**, that implies the server has skipped that number of results from the index.

* The server will skip duplicate results internally in the following two scenarios:

    1. When making a [Projection query](../../indexes/querying/projections.mdx) with [distinct](../../indexes/querying/distinct.mdx).

    2. When querying a [Fanout index](../../indexes/indexing-nested-data.mdx#fanout-index---multiple-index-entries-per-document).

* In those cases:

    * The `skippedResults` property from the stats object will hold the count of skipped (duplicate) results.

    * The `totalResults` property will be invalidated -  
      it will Not deduct the number of skipped results from the total number of results.

* In order to do proper paging in those scenarios:  
  include the `skippedResults` value when specifying the number of documents to skip for each page using:  
  `(currentPage * pageSize) + skippedResults`.

## Examples

#### A projection query with Distinct:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let pagedResults;
let stats;

let totalResults = 0;
let totalUniqueResults = 0;
let skippedResults = 0;

let pageNumber = 0;
const PAGE_SIZE = 10;

do {
    pagedResults = await session
        .query({ indexName: "Products/ByUnitsInStock" })
        .statistics(s => stats = s)
        .whereGreaterThan("UnitsInStock", 10)
         // Define a projection
        .selectFields(["Category", "Supplier"])
         // Call Distinct to remove duplicate projected results
        .distinct()
         // Add the number of skipped results to the "start location"  
        .skip((pageNumber * PAGE_SIZE) + skippedResults)
         // Define how many items to return
        .take(PAGE_SIZE)
        .all();

    totalResults = stats.totalResults;         // Number of total matching documents (includes duplicates)
    skippedResults += stats.skippedResults;    // Number of duplicate results that were skipped
    totalUniqueResults += pagedResults.length; // Number of unique results returned in this server call 

    pageNumber++;
}
while (pagedResults.length > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total matching results reported in the stats is 47 (totalResults),
// but the total unique objects returned while paging the results is only 29 (totalUniqueResults)
// due to the 'distinct' usage which removes duplicates.

// This is solved by adding the skipped results count to skip().
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Products_ByUnitsInStock extends AbstractJavaScriptIndexCreationTask  {
    constructor() {
        super();

        this.map("Products", p => ({
            UnitsInStock: p.UnitsInStock
        }));
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByUnitsInStock"
where UnitsInStock > 10
select distinct Category, Supplier
limit 0, 10  // First loop will skip 0, take 10, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Querying a Fanout index:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let pagedResults;
let stats;

let totalResults = 0;
let totalUniqueResults = 0;
let skippedResults = 0;

let pageNumber = 0;
const PAGE_SIZE = 50;

do {
    pagedResults = await session
        .query({ indexName: "Orders/ByProductName" })
        .statistics(s => stats = s)
         // Add the number of skipped results to the "start location"  
        .skip((pageNumber * PAGE_SIZE) + skippedResults)
        .take(PAGE_SIZE)
        .all();

    totalResults = stats.totalResults;
    skippedResults += stats.skippedResults;
    totalUniqueResults += pagedResults.length;

    pageNumber++;
}
while (pagedResults.length > 0); // Fetch next results

// When executing the query on the Northwind sample data:
// ======================================================

// The total results reported in the stats is 2155 (totalResults),
// which represent the multiple index-entries generated as defined by the fanout index.

// By adding the skipped results count to the Skip() method,
// we get the correct total unique results which is 830 Order documents.
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`// A fanout index - creating MULTIPLE index-entries per document:
// ==============================================================

class Orders_ByProductName extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        this.map("Orders", order => {
            return order.Lines.map(line => {
                return {
                    ProductName: line.ProductName
                };
            });
        });
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Orders/ByProductName"
limit 0, 50  // First loop will skip 0, take 50, etc.
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>

<!---
### Querying
- [Query overview](../../client-api/session/querying/how-to-query)
- [Stream query results](../../client-api/session/querying/how-to-stream-query-results)
- [Get query statistics](../../client-api/session/querying/how-to-get-query-statistics)
- [Basics](../../indexes/querying/query-index)
- [Filtering](../../indexes/querying/filtering)
- [Sorting](../../indexes/querying/sorting)

### Indexes
- [Indexing basics](../../indexes/indexing-basics)
- [Query an index](../../indexes/querying/query-index)
- [Filtering](../../indexes/querying/filtering)
- [Sorting](../../indexes/querying/sorting)


-->