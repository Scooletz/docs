---
title: "Indexes: Sorting & Collation"
hide_table_of_contents: true
sidebar_label: Sorting & Collation
sidebar_position: 10
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];


#  Indexes: Sorting & Collation
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Starting from version 4.0, RavenDB automatically determines sorting based on an indexed value. All values will have a capability to be sorted `lexicographically`. Numerical values will also be sortable by their `double` and `long` value.

## Date types

Dates are written to the index in a form which preserves lexicography order, and is readable by both human and machine (like so: `2011-04-04T11:28:46.0404749+03:00`). This requires no user intervention.

## Example

Please read our dedicated article describing `sorting` capabilities when queries are executed. It can be found [here](../indexes/querying/sorting.mdx).

## Collation

RavenDB supports using collations for documents sorting and indexing. You can setup a specific collation for an index field, so you can sort based of culture specific rules.

The following is an example of an index definition which allows sorting based on the Swedish lexical sorting rules:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="csharp">
{`public class Products_ByName : AbstractIndexCreationTask<Product>
{
    public Products_ByName()
    {
        Map = products => from product in products
                          select new
                          {
                              product.Name
                          };

        Analyzers.Add(x => x.Name, "Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SvCollationAnalyzer, Raven.Server");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="csharp">
{`private class Products_ByName : AbstractJavaScriptIndexCreationTask
{
    public Products_ByName()
    {
        Maps = new HashSet<string>
        {
            @"map('products', function (u){
                            return {
                                Name: u.Name,
                                _: {$value: u.Name, $name:'AnalyzedName'}
                            };
                        })",
        };
        Fields = new Dictionary<string, IndexFieldOptions>
        {
            {
                "AnalyzedName", new IndexFieldOptions()
                {
                    Indexing = FieldIndexing.Search,
                    Analyzer = "StandardAnalyzer"
                }
            }
        };
    }
    public class Result
    {
        public string AnalyzedName { get; set; }
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

In general, you can sort using `Raven.Database.Indexing.Collation.Cultures.<two-letters-culture-name>CollationAnalyzer`, and _all_ the cultures supported by the .NET framework are supported.


</LanguageContent>
<LanguageContent language="java">


Starting from version 4.0, RavenDB automatically determines sorting based on an indexed value. All values will have a capability to be sorted `lexicographically`. Numerical values will also be sortable by their `double` and `long` value.

## Date types

Dates are written to the index in a form which preserves lexicography order, and is readable by both human and machine (like so: `2011-04-04T11:28:46.0404749+03:00`). This requires no user intervention.

## Example

Please read our dedicated article describing `sorting` capabilities when queries are executed. It can be found [here](../indexes/querying/sorting.mdx).

## Collation

RavenDB supports using collations for documents sorting and indexing. You can setup a specific collation for an index field, so you can sort based of culture specific rules.

The following is an example of an index definition which allows sorting based on the Swedish lexical sorting rules:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="java">
{`public static class Products_ByName extends AbstractIndexCreationTask {
    public Products_ByName() {
        map = "docs.Products.Select(product => new { " +
            "    Name = product.Name " +
            "})";

        analyze("Name", "Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SvCollationAnalyzer, Raven.Server");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`private static class Products_ByName extends AbstractJavaScriptIndexCreationTask {
    public Products_ByName() {
        setMaps(Sets.newHashSet("map('products', function (u){\\n" +
            "    return {\\n" +
            "        Name: u.Name,\\n" +
            "        _: {$value: u.Name, $name:'AnalyzedName'}\\n" +
            "        };\\n" +
            "    })"));

        IndexFieldOptions indexFieldOptions = new IndexFieldOptions();
        indexFieldOptions.setIndexing(FieldIndexing.SEARCH);
        indexFieldOptions.setAnalyzer("StandardAnalyzer");

        HashMap<String, IndexFieldOptions> fields = new HashMap<>();
        fields.put("AnalyzedName", indexFieldOptions);

        setFields(fields);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

In general, you can sort using `Raven.Database.Indexing.Collation.Cultures.<two-letters-culture-name>CollationAnalyzer`, and _all_ the cultures supported by the .NET framework are supported.


</LanguageContent>

<!---
### Indexes
- [Map Indexes](../indexes/map-indexes)
- [What are Indexes](../indexes/what-are-indexes)

### Querying
- [Query Overview](../client-api/session/querying/how-to-query)
- [Sorting](../indexes/querying/sorting)
- [Basics](../indexes/querying/query-index)


-->