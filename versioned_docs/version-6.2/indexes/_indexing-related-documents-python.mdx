import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* As described in [modeling considerations in RavenDB](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#summary),  
  it is recommended for documents to be: independent, isolated, and coherent.  
  However, to accommodate varied models, **documents can reference other documents**.  

* The related data from a referenced (related) document can be indexed,  
  this will allow querying the collection by the indexed related data.

* The related documents that are loaded in the index definition can be either **Tracked** or **Not-Tracked**.

* In this page:

   * [What are related documents](../indexes/indexing-related-documents.mdx#what-are-related-documents)


   * [Index related documents - With tracking](../indexes/indexing-related-documents.mdx#index-related-documents---with-tracking)
     * [Example I - basic](../indexes/indexing-related-documents.mdx#example-i---basic)
     * [Example II - list](../indexes/indexing-related-documents.mdx#example-ii---list)
     * [Tracking implications](../indexes/indexing-related-documents.mdx#tracking-implications)
   * [Index related documents - No tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [Example III - no tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [No-tracking implications](../indexes/indexing-related-documents.mdx#no-tracking-implications)
   * [Document changes that cause re-indexing](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)
   * [LoadDocument Syntax](../indexes/indexing-related-documents.mdx#loaddocument-syntax)
  
</Admonition>

## What are related documents

* Whenever a document references another document, the referenced document is called a **Related Document**.  

* In the image below, document `products/34-A` references documents `categories/1-A` & `suppliers/16-A`,  
  which are considered Related Documents.
  ![Referencing related documents](./assets/index-related-documents.png)



## Index related documents - With tracking

### Example I - basic

* **What is tracked**:  
  Both the documents from the **indexed collection** and the **indexed related documents** are tracked for changes.  
  Re-indexing will be triggered per any change in either collection.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
  Following the above `Product - Category` relationship from the Northwind sample database,  
  an index defined on the Products collection can index data from the related Category document.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="python">
{`class Products_ByCategoryName(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, category_name: str = None):
            self.category_name = category_name

    def __init__(self):
        super().__init__()
        self.map = (
            "from product in docs.Products "
            'let category = this.LoadDocument(product.Category, "Categories") '
            "select new { category_name = category.Name }"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="python">
{`class Products_ByCategoryName_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            # Call method 'load' to load the related Category document
            # The document ID to load is specified by 'product.Category'
            # The Name field from the related Category document will be indexed
            """
            map('products', function(product) {
                let category = load(product.Category, 'Categories')
                return {
                    category_name: category.Name
                };
            })
            """
            # Since no_tracking was not specified,
            # then any change to either Products or Categories will trigger reindexing
        }
`}
</CodeBlock>
</TabItem>
     </Tabs>

* **The query**:  
  We can now query the index for Product documents by `CategoryName`,  
  i.e. get all matching Products that reference a Category that has the specified name term.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`matching_products = list(
    session.query_index_type(Products_ByCategoryName, Products_ByCategoryName.IndexEntry)
    .where_equals("category_name", "Beverages")
    .of_type(Product)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
### Example II - list

* **The documents**:  
<TabItem value="indexing_related_documents_3" label="indexing_related_documents_3">
<CodeBlock language="python">
{`# The referencing document
class Author:
    def __init__(self, Id: str = None, name: str = None, book_ids: List[str] = None):
        self.Id = Id
        self.name = name

        # Referencing a list of related document IDs
        self.book_ids = book_ids


# The related document
class Book:
    def __init__(self, Id: str = None, name: str = None):
        self.Id = Id
        self.name = name
`}
</CodeBlock>
</TabItem>

* **The index**:  
  This index will index all names of the related Book documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="python">
{`class Authors_ByBooks(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, book_names: List[str] = None):
            self.book_names = book_names

    def __init__(self):
        super().__init__()
        self.map = (
            "from author in docs.Authors "
            "select new "
            "{"
            # For each Book ID, call LoadDocument and index the book's name
            '    book_names = author.book_ids.Select(x => LoadDocument(x, "Books").Name)'
            "}"
        )
        # Since no_tracking was not specified,
        # then any change to either Authors or Books will trigger reindexing
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="python">
{`class Authors_ByBooks_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            # For each Book ID, call 'load' and index the book's name
            """
            map('Author', function(author) {
                return {
                    books: author.BooksIds.map(x => load(x, 'Books').Name)
                }
            })
            """
            # Since no_tracking was not specified,
            # then any change to either Authors or Books will trigger reindexing
        }
`}
</CodeBlock>
</TabItem>
     </Tabs>
     
* **The query**:  
  We can now query the index for Author documents by a book's name,  
  i.e. get all Authors that have the specified book's name in their list.
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`# Get all authors that have books with title: "The Witcher"
matching_authors = list(
    session.query_index_type(Authors_ByBooks, Authors_ByBooks.IndexEntry)
    .where_in("book_names", ["The Witcher"])
    .of_type(Author)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Get all authors that have books with title: "The Witcher"
from index "Authors/ByBooks"
where BookNames = "The Witcher"
`}
</CodeBlock>
</TabItem>
  </Tabs>
<Admonition type="info" title="">
### Tracking implications

* Indexing related data with tracking can be a useful way to query documents by their related data.  
  However, that may come with performance costs.

* **Re-indexing** will be triggered whenever any document in the collection that is referenced by `LoadDocument` is changed. 
  Even when indexing just a single field from the related document, any change to any other field will cause re-indexing. 
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* Frequent re-indexing will increase CPU usage and reduce performance,  
  and index results may be stale for prolonged periods.

* Tracking indexed related data is more useful when the indexed related collection is known not to change much.

</Admonition>



## Index related documents - No tracking

### Example III - no tracking

* **What is tracked**:  
   * Only the documents from the **indexed collection** are tracked for changes and can trigger re-indexing.  
     Any change done to any document in the **indexed related documents** will Not trigger re-indexing.  
     (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="python">
{`class Products_ByCategoryName_NoTracking(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, category_name: str = None):
            self.category_name = category_name

    def __init__(self):
        super().__init__()
        self.map = (
            "from product in docs.Products "
            # Call NoTracking.LoadDocument to load the related Category document w/o tracking
            'let category = NoTracking.LoadDocument(product.Category, "Categories") '
            "select new {"
            # Index the name field from the related Category document
            " category_name = category.Name "
            "}"
        )
        # Since NoTracking is used -
        # then only the changes to Products will trigger reindexing
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="python">
{`class Products_ByCategoryName_NoTracking_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            # Call 'noTracking.load' to load the related Category document w/o tracking
            """
            map('products', function(product) {
                let category = noTracking.load(product.Category, 'Categories')
                return {
                    category_name: category.Name
                };
            })
            """
        }
        # Since noTracking is used -
        # then only the changes to Products will trigger reindexing
`}
</CodeBlock>
</TabItem>
  </Tabs>

* **The query**:  
  When querying the index for Product documents by `CategoryName`,   
  results will be based on the related data that was **first indexed** when the index was deployed.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`matching_products = list(
    session.query_index_type(
        Products_ByCategoryName_NoTracking, Products_ByCategoryName_NoTracking.IndexEntry
    )
    .where_equals("category_name", "Beverages")
    .of_type(Product)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName/NoTracking"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
<Admonition type="info" title="">
### No-tracking implications

* Indexing related data with no-tracking can be a useful way to query documents by their related data.  
  However, that may come with some data accuracy costs.

* **Re-indexing** will Not be triggered when documents in the collection that is referenced by `LoadDocument` are changed. 
  Although this may save system resources, the index entries and the indexed terms may not be updated with the current state of data.

* Indexing related data without tracking is useful when the indexed related data is fixed and not supposed to change.

</Admonition>



## Document changes that cause re-indexing

* The following changes done to a document will trigger re-indexing:  
   * Any modification to any document field (not just to the indexed fields)
   * Adding/Deleting an attachment
   * Creating a new Time series (modifying existing will not trigger)
   * Creating a new Counter (modifying existing will not trigger)

* Any such change done on any document in the **indexed collection** will trigger re-indexing.

* Any such change done on any document in the **indexed related documents** will trigger re-indexing  
  only if `NoTracking` was Not used in the index definition.



## LoadDocument syntax

<TabItem value="syntax" label="syntax">
<CodeBlock language="python">
{`T LoadDocument<T>(string relatedDocumentId);

T LoadDocument<T>(string relatedDocumentId, string relatedCollectionName);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds, string relatedCollectionName);
`}
</CodeBlock>
</TabItem>
#### Syntax for JavaScript-index:

<TabItem value="syntax_JS" label="syntax_JS">
<CodeBlock language="js">
{`object load(relatedDocumentId, relatedCollectionName);
`}
</CodeBlock>
</TabItem>

| Parameters                |                       |                                        |
|---------------------------|-----------------------|----------------------------------------|
| **relatedDocumentId**     | `string`              | ID of the related document to load     |
| **relatedCollectionName** | `string`              | The related collection name            |
| **relatedDocumentIds**    | `IEnumerable<string>` | A list of related document IDs to load |




