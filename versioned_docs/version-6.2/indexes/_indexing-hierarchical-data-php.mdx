import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Use the `Recurse` method to traverse the layers of a hierarchical document and index its fields.

* In this Page:  
   * [Hierarchical data](../indexes/indexing-hierarchical-data.mdx#hierarchical-data)  
   * [Index hierarchical data](../indexes/indexing-hierarchical-data.mdx#index-hierarchical-data)  
   * [Query the index](../indexes/indexing-hierarchical-data.mdx#query-the-index)  

</Admonition>
## Hierarchical data

One significant advantage of document databases is their tendency not to impose limits on data structuring.
**Hierarchical data structures** exemplify this quality well; for example, consider the commonly used comment thread, implemented using objects such as:

<TabItem value="indexes_1" label="indexes_1">
<CodeBlock language="php">
{`class BlogPost
\{
    private ?string $author = null;
    private ?string $title = null;
    private ?string $text = null;

    // Blog post readers can leave comments
    public ?BlogPostCommentList $comments = null;

    public function getAuthor(): ?string
    \{
        return $this->author;
    \}

    public function setAuthor(?string $author): void
    \{
        $this->author = $author;
    \}

    public function getTitle(): ?string
    \{
        return $this->title;
    \}

    public function setTitle(?string $title): void
    \{
        $this->title = $title;
    \}

    public function getText(): ?string
    \{
        return $this->text;
    \}

    public function setText(?string $text): void
    \{
        $this->text = $text;
    \}

    public function getComments(): ?BlogPostCommentList
    \{
        return $this->comments;
    \}

    public function setComments(?BlogPostCommentList $comments): void
    \{
        $this->comments = $comments;
    \}
\}

class BlogPostComment
\{
    private ?string $author = null;
    private ?string $text = null;

    // Comments can be left recursively
    private ?BlogPostCommentList $comments = null;

    public function getAuthor(): ?string
    \{
        return $this->author;
    \}

    public function setAuthor(?string $author): void
    \{
        $this->author = $author;
    \}

    public function getText(): ?string
    \{
        return $this->text;
    \}

    public function setText(?string $text): void
    \{
        $this->text = $text;
    \}

    public function getComments(): ?BlogPostCommentList
    \{
        return $this->comments;
    \}

    public function setComments(?BlogPostCommentList $comments): void
    \{
        $this->comments = $comments;
    \}
\}

class BlogPostCommentList extends TypedList
\{
    public function __construct()
    \{
        parent::__construct(BlogPost::class);
    \}
\}
`}
</CodeBlock>
</TabItem>

Readers of a post created using the above `BlogPost` structure can add `BlogPostComment` entries to the post's _comments_ field,
and readers of these comments can reply with comments of their own, creating a recursive hierarchical structure. 

For example, the following document, `BlogPosts/1-A`, represents a blog post by John that contains multiple layers of comments from various authors.  

`BlogPosts/1-A`:  

<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{
    "Author": "John",
    "Title": "Post title..",
    "Text": "Post text..",
    "Comments": [
        \{
            "Author": "Moon",
            "Text": "Comment text..",
            "Comments": [
                \{
                    "Author": "Bob",
                    "Text": "Comment text.."
                \},
                \{
                    "Author": "Adel",
                    "Text": "Comment text..",
                    "Comments": \{
                        "Author": "Moon",
                        "Text": "Comment text.."
                    \}
                \}
            ]
        \}
    ],
    "@metadata": \{
        "@collection": "BlogPosts"
    \}
\}
`}
</CodeBlock>
</TabItem>



## Index hierarchical data

To index the elements of a hierarchical structure like the one above, use RavenDB's `Recurse` method.

The sample index below shows how to use `Recurse` to traverse the comments in the post thread and index them by their authors.
We can then [query the index](../indexes/indexing-hierarchical-data.mdx#query-the-index) for all blog posts that contain comments by specific authors.

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="php">
{`class BlogPosts_ByCommentAuthor_Result
{
    private ?StringArray $authors = null;

    public function getAuthors(): ?StringArray
    {
        return $this->authors;
    }

    public function setAuthors(?StringArray $authors): void
    {
        $this->authors = $authors;
    }
}

class BlogPosts_ByCommentAuthor extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "from blogpost in docs.Blogposts let authors = Recurse(blogpost, x => x.comments) select new { authors = authors.Select(x => x.author) }";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="php">
{`$indexDefinition = new IndexDefinition();
$indexDefinition->setName("BlogPosts/ByCommentAuthor");
$indexDefinition->setMaps([
    "from blogpost in docs.BlogPosts
    from comment in Recurse(blogpost, (Func<dynamic, dynamic>)(x => x.Comments))
    select new
    {
        Author = comment.Author
    }"
]);

$store->maintenance()->send(new PutIndexesOperation($indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>



## Query the index

The index can be queried for all blog posts that contain comments made by specific authors.

**Query the index using code**:  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<BlogPost> $results */
$results = $session
    ->query(BlogPosts_ByCommentAuthor_Result::class, BlogPosts_ByCommentAuthor::class)
    ->whereEquals("authors", "john")
    ->ofType(BlogPost::class)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`/** @var array<BlogPost> $results */
$results = $session
        ->advanced()
        ->documentQuery(BlogPost::class, BlogPosts_ByCommentAuthor::class)
        ->whereEquals("authors", "John")
        ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "BlogPosts/ByCommentAuthor"
where Authors == "Moon"
`}
</CodeBlock>
</TabItem>
</Tabs>

**Query the index using Studio**:

  * Query the index from Studio's [List of Indexes](../studio/database/indexes/indexes-list-view.mdx#indexes-list-view) view:  
     
      !["List of Indexes view"](./assets/list-of-indexes-view.png)

  * View the query results in the [Query](../studio/database/queries/query-view.mdx) view:  
    
      !["Query View"](./assets/query-view.png)
    
  * View the list of terms indexed by the `Recurse` method:

      !["Click to View Index Terms"](./assets/click-to-view-terms.png)

      !["Index Terms"](./assets/index-terms.png)




