---
title: "Indexes: Indexing LINQ Extensions"
sidebar_label: Indexing LINQ Extensions
sidebar_position: 19
hide_table_of_contents: true
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexes: Indexing LINQ Extensions
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Various indexing LINQ extensions are available to enhance the usability and reduce the complexity of the indexing functions. The available extensions are:

- [Boost](../indexes/indexing-linq-extensions.mdx#boost)
- [Reverse](../indexes/indexing-linq-extensions.mdx#reverse)
- [IfEntityIs](../indexes/indexing-linq-extensions.mdx#ifentityis)
- [WhereEntityIs](../indexes/indexing-linq-extensions.mdx#whereentityis)
- [ParseInt, ParseLong, ParseDecimal, ParseDouble](../indexes/indexing-linq-extensions.mdx#parsing-numbers)

## **Boost**

You can read more about boosting [here](../indexes/boosting.mdx).



## **Reverse**

**Strings** and **enumerables** can be reversed by using `Reverse` extension.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByReversedFirstName : AbstractIndexCreationTask<Employee>
{
	public Employees_ByReversedFirstName()
	{
		Map = employees => from employee in employees
					select new
					{
						FirstName = employee.FirstName.Reverse()
					};
	}
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Employee> results = session
	.Query<Employee, Employees_ByReversedFirstName>()
	.Where(x => x.FirstName == "treboR")
	.ToList();
`}
</CodeBlock>
</TabItem>
</Tabs>



## **WhereEntityIs**

`WhereEntityIs` can be used to check if given `Raven-Entity-Name` value in metadata for the given document matches any of the given values. This can be useful when indexing polymorphic data. Please visit our dedicated article to get more information (or click [here](../indexes/indexing-polymorphic-data.mdx#other-ways)).



## **IfEntityIs**

`IfEntityIs` is similar to `WhereEntityIs`, yet it checks only against one value.



## **Parsing numbers**

String values can be safely parsed to `int`, `long`, `decimal` and `double` using the appropriate methods:

- ParseInt,
- ParseLong,
- ParseDecimal,
- ParseDouble

There are two overrides for each method: The first one returns the default value in case of parsing failure. The second one accepts the value that should be returned when failure occurs.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Item_Parse : AbstractIndexCreationTask<Item>
{
	public class Result
	{
		public int MajorWithDefault { get; set; }

		public int MajorWithCustomDefault { get; set; }
	}

	public Item_Parse()
	{
		Map = items => from item in items
					let parts = item.Version.Split('.', StringSplitOptions.None)
					select new
					{
						MajorWithDefault = parts[0].ParseInt(),			// will return default(int) in case of parsing failure
						MajorWithCustomDefault = parts[0].ParseInt(-1)	// will return -1 in case of parsing failure
					};

		StoreAllFields(FieldStorage.Yes);
	}
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Item" label="Item">
<CodeBlock language="csharp">
{`public class Item
{
	public string Version { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Example" label="Example">
<CodeBlock language="csharp">
{`session.Store(new Item { Version = "3.0.1" });
session.Store(new Item { Version = "Unknown" });

session.SaveChanges();

var results = session
	.Query<Item_Parse.Result, Item_Parse>()
	.ToList();

Assert.Equal(2, results.Count);
Assert.True(results.Any(x => x.MajorWithDefault == 3));
Assert.True(results.Any(x => x.MajorWithCustomDefault == 3));
Assert.True(results.Any(x => x.MajorWithDefault == 0));
Assert.True(results.Any(x => x.MajorWithCustomDefault == -1));
`}
</CodeBlock>
</TabItem>
</Tabs>

## Remarks

<Admonition type="info" title="Info">
Default `Storage` value for the `StoreAllFields()` method is `FieldStorage.No`. Keep in mind that storing fields will increase disk space usage.
</Admonition>




</LanguageContent>
<LanguageContent language="java">


Various indexing LINQ extensions are available to enhance the usability and reduce the complexity of the indexing functions. The available extensions are:

- [Boost](../indexes/indexing-linq-extensions.mdx#boost)
- [Reverse](../indexes/indexing-linq-extensions.mdx#reverse)
- [IfEntityIs](../indexes/indexing-linq-extensions.mdx#ifentityis)
- [WhereEntityIs](../indexes/indexing-linq-extensions.mdx#whereentityis)
- [ParseInt, ParseLong, ParseDecimal, ParseDouble](../indexes/indexing-linq-extensions.mdx#parsing-numbers)

## **Boost**

You can read more about boosting [here](../indexes/boosting.mdx).



## **Reverse**

**Strings** and **enumerables** can be reversed by using `Reverse` extension.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByReversedFirstName extends AbstractIndexCreationTask {
    public Employees_ByReversedFirstName() {
        map = "docs.Employees.Select(employee => new { " +
            "    FirstName = employee.FirstName.Reverse() " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Employee> results = session
    .query(Employee.class, Employees_ByReversedFirstName.class)
    .whereEquals("FirstName", "treboR")
    .toList();
`}
</CodeBlock>
</TabItem>
</Tabs>



## **WhereEntityIs**

`WhereEntityIs` can be used to check if given `Raven-Entity-Name` value in metadata for the given document matches any of the given values. This can be useful when indexing polymorphic data. Please visit our dedicated article to get more information (or click [here](../indexes/indexing-polymorphic-data.mdx#other-ways)).



## **IfEntityIs**

`IfEntityIs` is similar to `WhereEntityIs`, yet it checks only against one value.



## **Parsing numbers**

String values can be safely parsed to `int`, `long`, `decimal` and `double` using the appropriate methods:

- ParseInt,
- ParseLong,
- ParseDecimal,
- ParseDouble

There are two overrides for each method: The first one returns the default value in case of parsing failure. The second one accepts the value that should be returned when failure occurs.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Item_Parse extends AbstractIndexCreationTask {
    public static class Result {
        private int majorWithDefault;
        private int majorWithCustomDefault;

        public int getMajorWithDefault() {
            return majorWithDefault;
        }

        public void setMajorWithDefault(int majorWithDefault) {
            this.majorWithDefault = majorWithDefault;
        }

        public int getMajorWithCustomDefault() {
            return majorWithCustomDefault;
        }

        public void setMajorWithCustomDefault(int majorWithCustomDefault) {
            this.majorWithCustomDefault = majorWithCustomDefault;
        }
    }

    public Item_Parse() {
        map = "docs.Items.Select(item => new {" +
            "    item = item, " +
            "    parts = item.version.Split('.', System.StringSplitOptions.None) " +
            "}).Select(this0 => new { " +
            "    majorWithDefault = this0.parts[0].ParseInt(), " + // will return default(int) in case of parsing failure
            "    majorWithCustomDefault = this0.parts[0].ParseInt(-1) " + // will return -1 in case of parsing failure
            "})";

        storeAllFields(FieldStorage.YES);
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Item" label="Item">
<CodeBlock language="java">
{`public static class Item {
    private String version;

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Example" label="Example">
<CodeBlock language="java">
{`Item item1 = new Item();
item1.setVersion("3.0.1");

Item item2 = new Item();
item2.setVersion("Unknown");

session.store(item1);
session.store(item2);

session.saveChanges();

List<Item_Parse.Result> results = session
    .query(Item_Parse.Result.class, Item_Parse.class)
    .toList();

Assert.assertEquals(2, results.size());
Assert.assertTrue(results.stream().anyMatch(x -> x.getMajorWithDefault() == 3));
Assert.assertTrue(results.stream().anyMatch(x -> x.getMajorWithCustomDefault() == 3));
Assert.assertTrue(results.stream().anyMatch(x -> x.getMajorWithDefault() == 0));
Assert.assertTrue(results.stream().anyMatch(x -> x.getMajorWithCustomDefault() == -1));
`}
</CodeBlock>
</TabItem>
</Tabs>



## Remarks

<Admonition type="info" title="Info">
Default `storage` value for the `storeAllFields()` method is `FieldStorage.NO`. Keep in mind that storing fields will increase disk space usage.
</Admonition>



</LanguageContent>
<LanguageContent language="nodejs">


Various indexing LINQ extensions are available to enhance the usability and reduce the complexity of the indexing functions. The available extensions are:

- [Boost](../indexes/indexing-linq-extensions.mdx#boost)
- [Reverse](../indexes/indexing-linq-extensions.mdx#reverse)
- [IfEntityIs](../indexes/indexing-linq-extensions.mdx#ifentityis)
- [WhereEntityIs](../indexes/indexing-linq-extensions.mdx#whereentityis)
- [ParseInt, ParseLong, ParseDecimal, ParseDouble](../indexes/indexing-linq-extensions.mdx#parsing-numbers)

## **Boost**

You can read more about boosting [here](../indexes/boosting.mdx).



## **Reverse**

**Strings** and **enumerables** can be reversed by using `Reverse` extension.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByReversedFirstName extends AbstractIndexCreationTask {
    constructor() {
        super();

        this.map = "docs.Employees.Select(employee => new { " +
            "    FirstName = employee.FirstName.Reverse() " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    .query({ indexName: "Employees/ByReversedFirstName" })
    .whereEquals("firstName", "treboR")
    .all();
`}
</CodeBlock>
</TabItem>
</Tabs>



## **WhereEntityIs**

`WhereEntityIs` can be used to check if given `Raven-Entity-Name` value in metadata for the given document matches any of the given values. This can be useful when indexing polymorphic data. Please visit our dedicated article to get more information (or click [here](../indexes/indexing-polymorphic-data.mdx#other-ways)).



## **IfEntityIs**

`IfEntityIs` is similar to `WhereEntityIs`, yet it checks only against one value.



## **Parsing numbers**

String values can be safely parsed to `int`, `long`, `decimal` and `double` using the appropriate methods:

- ParseInt,
- ParseLong,
- ParseDecimal,
- ParseDouble

There are two overrides for each method: The first one returns the default value in case of parsing failure. The second one accepts the value that should be returned when failure occurs.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Item_Parse extends AbstractIndexCreationTask {
    constructor() {
        super();

        this.map = "docs.Items.Select(item => new {" +
            "    item = item, " +
            "    parts = item.version.Split('.', System.StringSplitOptions.None) " +
            "}).Select(this0 => new { " +
            "    majorWithDefault = this0.parts[0].ParseInt(), " + // will return default(int) in case of parsing failure
            "    majorWithCustomDefault = this0.parts[0].ParseInt(-1) " + // will return -1 in case of parsing failure
            "})";

        this.storeAllFields("Yes");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Item" label="Item">
<CodeBlock language="js">
{`class Item {
    constructor(version) {
        this.version = version;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Example" label="Example">
<CodeBlock language="js">
{`const item1 = new Item("3.0.1");
const item2 = new Item("Unknown");

await session.store(item1);
await session.store(item2);

await session.saveChanges();

const results = await session
    .query({ indexName: "Item/Parse" })
    .all();

assert.strictEqual(2, results.length);
assert.ok(results.some(x => x.majorWithDefault === 3));
assert.ok(results.some(x => x.majorWithCustomDefault === 3));
assert.ok(results.some(x => x.majorWithDefault === 0));
assert.ok(results.some(x => x.majorWithCustomDefault === -1));
`}
</CodeBlock>
</TabItem>
</Tabs>




</LanguageContent>

<!---
### Indexes
- [Map Indexes](../indexes/map-indexes)
- [Boosting](../indexes/boosting)


-->