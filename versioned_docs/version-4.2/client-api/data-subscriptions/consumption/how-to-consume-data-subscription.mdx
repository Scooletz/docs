---
title: "Data Subscriptions: How to Consume a Data Subscription"
hide_table_of_contents: true
sidebar_label: How to Consume a Data Subscription
sidebar_position: 0
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Data Subscriptions: How to Consume a Data Subscription
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

Subscriptions are consumed by processing batches of documents received from the server. 
A `SubscriptionWorker` object manages the documents processing and the communication between the client and the server according to a set of configurations received upon it's creation. 
We've introduced several ways to create and configure a SubscriptionWorker, starting from just giving a subscription name, and ending with a detailed configuration object - `SubscriptionWorkerOptions`.

In this page:

[SubscriptionWorker lifecycle](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#subscriptionworker-lifecycle)  
[Error handling](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#error-handling)  
[Workers interplay](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#workers-interplay)

</Admonition>
## SubscriptionWorker lifecycle
A `SubscriptionWorker` object starts its life from being generated by the `DocumentsStore.Subscriptions`:

<TabItem value="subscription_open_simple" label="subscription_open_simple">
<CodeBlock language="csharp">
{`subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
`}
</CodeBlock>
</TabItem>

At this point, the worker has only got its configuration. No connection or processing happens at this moment. 
In order to start processing, the `Run` method should be called. The Run method receives the batch processing logic that should be performed:

<TabItem value="subscription_run_simple" label="subscription_run_simple">
<CodeBlock language="csharp">
{`subscriptionRuntimeTask = subscriptionWorker.Run(batch =>
\{
    // your logic here
\});
`}
</CodeBlock>
</TabItem>

From this point on, the subscription worker will start processing batches. If for any reason, the processing is aborted, and the returned task (`subscriptionRuntimeTask`) will be finished with an exception.




## Error handling
There are two categories of errors that may occur during subscription processing:

<Admonition type="info" title="Internal mechanism errors" id="internal-mechanism-errors" href="#internal-mechanism-errors">
Those errors occur during the normal server-client communication between the worker and the server.  
If an unexpected error occurs, the worker will try to reconnect to the server. There are conditions in which the worker will cease its operation and will not try to reconnect:  

* The subscription does not exist or was deleted  
* Another worker took over the subscription (see connection strategy)
* The worker could not connect to any of the servers
* The worker could not receive the node in charge of the task (this can happen when there is no leader)
* Authorization exception
* Exception during connection establishment

</Admonition>

<Admonition type="info" title="User's batch processing logic unhandled exception" id="user-s-batch-processing-logic-unhandled-exception" href="#user-s-batch-processing-logic-unhandled-exception">
Example:
<TabItem value="throw_during_user_logic" label="throw_during_user_logic">
<CodeBlock language="csharp">
{`_ = workerWBatch.Run(x => throw new Exception());
`}
</CodeBlock>
</TabItem>

If an exception is thrown, the worker will abort the current batch process. 
A worker can be configured to treat the thrown exception by either of the following two ways:  

* By default, the worker will wrap the thrown exception with a `SubscriberErrorException` exception and rethrow it,  
  terminating the subscription execution without acknowledging progress or retrying. The task returned by the `Run` function will
  be terminated with an erroneous state, throwing a `SubscriberErrorException` exception.

* If `SubscriptionWorkerOptions`'s value `IgnoreSubscriberErrors` is set to true, the erroneous batch will get acknowledged without retrying and the next batches will continue processing. 
</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">
In the cases above, we described situations in which a worker will try to reconnect with the server. There are two key `SubscriptionWorkerOptions` fields controlling this state:

*  `TimeToWaitBeforeConnectionRetry` - The time that the worker will 'sleep' before trying to reconnect.
* `MaxErroneousPeriod` - The maximum time in which the worker is allowed to be in erroneous state. After that time passes, the worker will stop trying to reconnect
</Admonition>




## Workers interplay
There can only be one active subscription worker working on a subscription. 
Nevertheless, there are scenarios where it is required to interact between an existing subscription worker and one that tries to connect. 
This relationship and interoperation is configured by the `SubscriptionConnectionOptions` `Strategy` field.  
The strategy field is an enum, having the following values:  

* `OpenIfFree` - the server will allow the worker to connect only if there isn't any other currently connected workers.  
  If there is a existing connection, the incoming worker will throw a SubscriptionInUseException.  
* `WaitForFree` - If the client currently cannot open the subscription because it is used by another client, it will wait for the previous client to disconnect and only then will connect.  
  This is useful in client failover scenarios where there is one active client and another one already waiting to take its place.  
* `TakeOver` - the server will allow an incoming connection to overthrow an existing one. It will behave according to the existing connection strategy:
  * The existing connection has a strategy that is not `TakeOver`. In this case, the incoming connection will take over it causing the existing connection to throw a SubscriptionInUseException exception.  
  * The existing connection has a strategy that is `TakeOver`. In this case, the incoming connection will throw a SubscriptionInUseException exception.  



</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="">

Subscriptions are consumed by processing batches of documents received from the server. 
A `SubscriptionWorker` object manages the documents processing and the communication between the client and the server according to a set of configurations received upon it's creation. 
We've introduced several ways to create and configure a SubscriptionWorker, starting from just giving a subscription name, and ending with a detailed configuration object - `SubscriptionWorkerOptions`.

In this page:

[SubscriptionWorker lifecycle](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#subscriptionworker-lifecycle)  
[Error handling](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#error-handling)  
[Workers interplay](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#workers-interplay)

</Admonition>
## SubscriptionWorker lifecycle
A `SubscriptionWorker` object starts its life from being generated by the `DocumentsStore.subscriptions`:

<TabItem value="subscription_open_simple" label="subscription_open_simple">
<CodeBlock language="java">
{`subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, subscriptionName);
`}
</CodeBlock>
</TabItem>

At this point, the worker has only got its configuration. No connection or processing happens at this moment. 
In order to start processing, the `run` method should be called. The `run` method receives the batch processing logic that should be performed:

<TabItem value="subscription_run_simple" label="subscription_run_simple">
<CodeBlock language="java">
{`subscriptionRuntimeTask = subscriptionWorker.run(batch -> \{
    // your logic here
\});
`}
</CodeBlock>
</TabItem>

From this point on, the subscription worker will start processing batches. If for any reason, the processing is aborted, and the returned task (`subscriptionRuntimeTask`) will be finished with an exception.




## Error handling
There are two categories of errors that may occur during subscription processing:

<Admonition type="info" title="Internal mechanism errors" id="internal-mechanism-errors" href="#internal-mechanism-errors">
Those errors occur during the normal server-client communication between the worker and the server.  
If an unexpected error occurs, the worker will try to reconnect to the server. There are conditions in which the worker will cease its operation and will not try to reconnect:  

* The subscription does not exist or was deleted  
* Another worker took over the subscription (see connection strategy)
* The worker could not connect to any of the servers
* The worker could not receive the node in charge of the task (this can happen when there is no leader)
* Authorization exception
* Exception during connection establishment

</Admonition>

<Admonition type="info" title="User's batch processing logic unhandled exception" id="user-s-batch-processing-logic-unhandled-exception" href="#user-s-batch-processing-logic-unhandled-exception">
Example:
<TabItem value="throw_during_user_logic" label="throw_during_user_logic">
<CodeBlock language="java">
{`workerWBatch.run(x -> \{
    throw new RuntimeException();
\});
`}
</CodeBlock>
</TabItem>

If an exception is thrown, the worker will abort the current batch process. 
A worker can be configured to treat the thrown exception by either of the following two ways:  

* By default, the worker will wrap the thrown exception with a `SubscriberErrorException` exception and rethrow it,  
  terminating the subscription execution without acknowledging progress or retrying. The task returned by the `Run` function will
  be terminated with an erroneous state, throwing a `SubscriberErrorException` exception.

* If `SubscriptionWorkerOptions`'s value `ignoreSubscriberErrors` is set to true, the erroneous batch will get acknowledged without retrying and the next batches will continue processing. 
</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">
In the cases above, we described situations in which a worker will try to reconnect with the server. There are two key `SubscriptionWorkerOptions` fields controlling this state:

*  `timeToWaitBeforeConnectionRetry` - The time that the worker will 'sleep' before trying to reconnect.
* `maxErroneousPeriod` - The maximum time in which the worker is allowed to be in erroneous state. After that time passes, the worker will stop trying to reconnect
</Admonition>




## Workers interplay
There can only be one active subscription worker working on a subscription. 
Nevertheless, there are scenarios where it is required to interact between an existing subscription worker and one that tries to connect. 
This relationship and interoperation is configured by the `SubscriptionConnectionOptions` `Strategy` field.  
The strategy field is an enum, having the following values:  

* `OPEN_IF_FREE` - the server will allow the worker to connect only if there isn't any other currently connected workers.  
  If there is a existing connection, the incoming worker will throw a SubscriptionInUseException.  
* `WAIT_FOR_FREE` - If the client currently cannot open the subscription because it is used by another client, it will wait for the previous client to disconnect and only then will connect.  
  This is useful in client failover scenarios where there is one active client and another one already waiting to take its place.  
* `TAKE_OVER` - the server will allow an incoming connection to overthrow an existing one. It will behave according to the existing connection strategy:
  * The existing connection has a strategy that is not `TAKE_OVER`. In this case, the incoming connection will take over it causing the existing connection to throw a SubscriptionInUseException exception.  
  * The existing connection has a strategy that is `TAKE_OVER`. In this case, the incoming connection will throw a SubscriptionInUseException exception.  



</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">

Subscriptions are consumed by processing batches of documents received from the server. 
A `SubscriptionWorker` object manages the documents processing and the communication between the client and the server according to a set of configurations received upon it's creation. 
We've introduced several ways to create and configure a SubscriptionWorker, starting from just giving a subscription name, and ending with a detailed configuration object - `SubscriptionWorkerOptions`.

In this page:

[SubscriptionWorker lifecycle](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#subscriptionworker-lifecycle)  
[Error handling](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#error-handling)  
[Workers interplay](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#workers-interplay)

</Admonition>
## SubscriptionWorker lifecycle
A `SubscriptionWorker` object starts its life from being generated by the `DocumentsStore.subscriptions`:

<TabItem value="subscription_open_simple" label="subscription_open_simple">
<CodeBlock language="js">
{`const subscriptionWorker = store.subscriptions.getSubscriptionWorker(\{ subscriptionName \});
`}
</CodeBlock>
</TabItem>

The worker is going to connect to the server asynchronously, when a listener for the `"batch"` event is registered using `on()` method. 

<TabItem value="subscription_run_simple" label="subscription_run_simple">
<CodeBlock language="js">
{`subscriptionWorker.on("batch", (batch, callback) => \{
    // your logic here
    
    // report batch processing error passing it to callback
    // callback(err)
    callback();
\});

subscriptionWorker.on("error", error => \{
    // handle errors
\});
`}
</CodeBlock>
</TabItem>

From this point on, the subscription worker will start processing batches. If for any reason, the processing is aborted an `"error"` is going to be emitted with an `Error` argument.




## Error handling
There are two categories of errors that may occur during subscription processing:

<Admonition type="info" title="Internal mechanism errors" id="internal-mechanism-errors" href="#internal-mechanism-errors">
Those errors occur during the normal server-client communication between the worker and the server (those would not be emitted via `"error"` event).  
If an unexpected error occurs, the worker will try to reconnect to the server. There are conditions in which the worker will cease its operation and will not try to reconnect:  

* The subscription does not exist or was deleted  

* Another worker took over the subscription (see connection strategy)

* The worker could not connect to any of the servers

* The worker could not receive the node in charge of the task (this can happen when there is no leader)

* Authorization exception

* Exception during connection establishment

</Admonition>

<Admonition type="info" title="User's batch processing logic unhandled exception" id="user-s-batch-processing-logic-unhandled-exception" href="#user-s-batch-processing-logic-unhandled-exception">
Example:
<TabItem value="throw_during_user_logic" label="throw_during_user_logic">
<CodeBlock language="js">
{`workerWBatch.on("batch", (batch, callback) => \{
    callback(new Error("Error during processing batch."));
\});
`}
</CodeBlock>
</TabItem>

If an exception is thrown, the worker will abort the current batch process. 
A worker can be configured to treat the thrown exception by either of the following two ways:  

* By default, the worker will wrap the thrown exception with a `SubscriberErrorException` exception and rethrow it,  
  terminating the subscription execution without acknowledging progress or retrying. An `"error"` is going to be emitted.

* If `SubscriptionWorkerOptions`'s value `ignoreSubscriberErrors` is set to true, the erroneous batch will get acknowledged without retrying and the next batches will continue processing. 
</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">
In the cases above, we described situations in which a worker will try to reconnect with the server. There are two key `SubscriptionWorkerOptions` fields controlling this state:

* `timeToWaitBeforeConnectionRetry` - The time that the worker will 'sleep' before trying to reconnect.

* `maxErroneousPeriod` - The maximum time in which the worker is allowed to be in erroneous state. After that time passes, the worker will stop trying to reconnect
</Admonition>




## Workers interplay
There can only be one active subscription worker working on a subscription. 
Nevertheless, there are scenarios where it is required to interact between an existing subscription worker and one that tries to connect. 
This relationship and interoperation is configured by the `SubscriptionConnectionOptions` `Strategy` field.  
The strategy field is an enum, having the following values:  

* `OpenIfFree` - the server will allow the worker to connect only if there isn't any other currently connected workers.  
  If there is a existing connection, the incoming worker will throw a *SubscriptionInUseException*.  
* `WaitForFree` - If the client currently cannot open the subscription because it is used by another client, it will wait for the previous client to disconnect and only then will connect.  
  This is useful in client failover scenarios where there is one active client and another one already waiting to take its place.  
* `TakeOver` - the server will allow an incoming connection to overthrow an existing one. It will behave according to the existing connection strategy:
  * The existing connection has a strategy that is not `TakeOver`. In this case, the incoming connection will take over it causing the existing connection to throw a *SubscriptionInUseException* exception.  
  * The existing connection has a strategy that is `TakeOver`. In this case, the incoming connection will throw a *SubscriptionInUseException* exception.  



</LanguageContent>

<!---
### Data Subscriptions:
- [What are Data Subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions)
- [How to Create a Data Subscription](../../../client-api/data-subscriptions/creation/how-to-create-data-subscription)
- [How to Consume a Data Subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription)


-->