import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

There are various methods with many overloads that allow users to download documents from a database and convert them to entities. This article will cover the following methods:

- [Load](../../client-api/session/loading-entities.mdx#load)
- [Load with Includes](../../client-api/session/loading-entities.mdx#load-with-includes)
- [Load - multiple entities](../../client-api/session/loading-entities.mdx#load---multiple-entities)
- [LoadStartingWith](../../client-api/session/loading-entities.mdx#loadstartingwith)
- [Stream](../../client-api/session/loading-entities.mdx#stream)
- [IsLoaded](../../client-api/session/loading-entities.mdx#isloaded)

## Load

The most basic way to load a single entity is to use one of the `Load` methods.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`TResult Load<TResult>(string id);
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Task<TResult> LoadAsync<TResult>(string id);
`}
</CodeBlock>
</TabItem>
</Tabs> 

| Parameters | | |
| ------------- | ------------- | ----- |
| **id** | string | Identifier of a document that will be loaded. |

| Return Value | |
| ------------- | ----- |
| TResult | Instance of `TResult` or `null` if a document with a given ID does not exist. |

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`Employee employee = session.Load<Employee>("employees/1");
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Employee employee = await asyncSession.LoadAsync<Employee>("employees/1");
`}
</CodeBlock>
</TabItem>
</Tabs> 

<Admonition type="note" title="">
In 4.x RavenDB, only string identifiers are supported. If you are upgrading from 3.x, this is a major change, because in 3.x non-string identifiers are supported.
</Admonition>



## Load with Includes

When there is a 'relationship' between documents, those documents can be loaded in a single request call using the `Include + Load` methods.

<TabItem value="loading_entities_2_0" label="loading_entities_2_0">
<CodeBlock language="csharp">
{`ILoaderWithInclude<object> Include(string path);

ILoaderWithInclude<T> Include<T>(Expression<Func<T, string>> path);

ILoaderWithInclude<T> Include<T>(Expression<Func<T, IEnumerable<string>>> path);

ILoaderWithInclude<T> Include<T, TInclude>(Expression<Func<T, string>> path);

ILoaderWithInclude<T> Include<T, TInclude>(Expression<Func<T, IEnumerable<string>>> path);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **path** | string or Expression | Path in documents in which the server should look for 'referenced' documents. |

| Return Value | |
| ------------- | ----- |
| ILoaderWithInclude | The `Include` method by itself does not materialize any requests but returns loader containing methods such as `Load`. |

### Example I

We can use this code to also load an employee which made the order.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// loading 'products/1'
// including document found in 'Supplier' property
Product product = session
    .Include("Supplier")
    .Load<Product>("products/1");

Supplier supplier = session.Load<Supplier>(product.Supplier); // this will not make server call
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// loading 'products/1'
// including document found in 'Supplier' property
Product product = await asyncSession
    .Include("Supplier")
    .LoadAsync<Product>("products/1");

Supplier supplier = await asyncSession.LoadAsync<Supplier>(product.Supplier); // this will not make server call
`}
</CodeBlock>
</TabItem>
</Tabs> 

### Example II

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// loading 'products/1'
// including document found in 'Supplier' property
Product product = session
    .Include<Product>(x => x.Supplier)
    .Load<Product>("products/1");

Supplier supplier = session.Load<Supplier>(product.Supplier); // this will not make server call
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// loading 'products/1'
// including document found in 'Supplier' property
Product product = await asyncSession
    .Include<Product>(x => x.Supplier)
    .LoadAsync<Product>("products/1");

Supplier supplier = await asyncSession.LoadAsync<Supplier>(product.Supplier); // this will not make server call
`}
</CodeBlock>
</TabItem>
</Tabs> 



## Load - multiple entities

To load multiple entities at once, use one of the following `Load` overloads.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`Dictionary<string, TResult> Load<TResult>(IEnumerable<string> ids);
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Task<Dictionary<string, TResult>> LoadAsync<TResult>(IEnumerable<string> ids);
`}
</CodeBlock>
</TabItem>
</Tabs> 

| Parameters | | |
| ------------- | ------------- | ----- |
| **ids** | IEnumerable&lt;string&gt; | Multiple document identifiers to load |

| Return Value | |
| ------------- | ----- |
| Dictionary&lt;string, TResult&gt; | Instance of Dictionary which maps document identifiers to `TResult` or `null` if a document with given ID doesn't exist. |

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`Dictionary<string, Employee> employees = session.Load<Employee>(new[]
{
    "employees/1",
    "employees/2",
    "employees/3"
});
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Dictionary<string, Employee> employees = await asyncSession.LoadAsync<Employee>(new[]
{
    "employees/1",
    "employees/2",
});
`}
</CodeBlock>
</TabItem>
</Tabs> 



## LoadStartingWith

To load multiple entities that contain a common prefix, use the `LoadStartingWith` method from the `Advanced` session operations.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`T[] LoadStartingWith<T>(
    string idPrefix,
    string matches = null,
    int start = 0,
    int pageSize = 25,
    string exclude = null,
    string startAfter = null);

void LoadStartingWithIntoStream(
    string idPrefix,
    Stream output,
    string matches = null,
    int start = 0,
    int pageSize = 25,
    string exclude = null,
    string startAfter = null);
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Task<T[]> LoadStartingWithAsync<T>(
    string idPrefix,
    string matches = null,
    int start = 0,
    int pageSize = 25,
    string exclude = null,
    string startAfter = null);

Task LoadStartingWithIntoStreamAsync(
    string idPrefix,
    Stream output,
    string matches = null,
    int start = 0,
    int pageSize = 25,
    string exclude = null,
    string startAfter = null);
`}
</CodeBlock>
</TabItem>
</Tabs>

| Parameters | | |
| ------------- | ------------- | ----- |
| **idPrefix** | string |  prefix for which the documents should be returned  |
| **matches** | string | pipe ('&#124;') separated values for which document IDs (after 'idPrefix') should be matched ('?' any single character, '*' any characters) |
| **start** | int | number of documents that should be skipped  |
| **pageSize** | int | maximum number of documents that will be retrieved |
| **exclude** | string | pipe ('&#124;') separated values for which document IDs (after 'idPrefix') should **not** be matched ('?' any single character, '*' any characters) |
| **skipAfter** | string | skip document fetching until given ID is found and return documents after that ID (default: `null`) |

| Return Value | |
| ------------- | ----- |
| TResult[] | Array of entities matching given parameters. |
| Stream | Output entities matching given parameters as a stream. |

### Example I

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// return up to 128 entities with Id that starts with 'employees'
Employee[] result = session
    .Advanced
    .LoadStartingWith<Employee>("employees", null, 0, 128);
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// return up to 128 entities with Id that starts with 'employees'
Employee[] result = (await asyncSession
    .Advanced
    .LoadStartingWithAsync<Employee>("employees", null, 0, 128))
    .ToArray();
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`// return up to 128 entities with Id that starts with 'employees/' 
// and rest of the key begins with "1" or "2" e.g. employees/10, employees/25
Employee[] result = session
    .Advanced
    .LoadStartingWith<Employee>("employees/", "1*|2*", 0, 128);
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`// return up to 128 entities with Id that starts with 'employees/' 
// and rest of the key begins with "1" or "2" e.g. employees/10, employees/25
Employee[] result = (await asyncSession
    .Advanced
    .LoadStartingWithAsync<Employee>("employees/", "1*|2*", 0, 128))
    .ToArray();
`}
</CodeBlock>
</TabItem>
</Tabs>



## Stream

Entities can be streamed from the server using one of the following `Stream` methods from the `Advanced` session operations.

Streaming query results does not support the [`include` feature](../../client-api/how-to/handle-document-relationships.mdx#includes). 
Learn more in [How to Stream Query Results](../../client-api/session/querying/how-to-stream-query-results.mdx).  

<Admonition type="info" title="">
Entities loaded using `Stream` will be transient (not attached to session).
</Admonition>

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`IEnumerator<StreamResult<T>> Stream<T>(IQueryable<T> query);

IEnumerator<StreamResult<T>> Stream<T>(IQueryable<T> query, out StreamQueryStatistics streamQueryStats);

IEnumerator<StreamResult<T>> Stream<T>(IDocumentQuery<T> query);

IEnumerator<StreamResult<T>> Stream<T>(IRawDocumentQuery<T> query);

IEnumerator<StreamResult<T>> Stream<T>(IRawDocumentQuery<T> query, out StreamQueryStatistics streamQueryStats);

IEnumerator<StreamResult<T>> Stream<T>(IDocumentQuery<T> query, out StreamQueryStatistics streamQueryStats);

IEnumerator<StreamResult<T>> Stream<T>(string startsWith, string matches = null, int start = 0, int pageSize = int.MaxValue, string startAfter = null);
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Task<IAsyncEnumerator<StreamResult<T>>> StreamAsync<T>(IQueryable<T> query);

Task<IAsyncEnumerator<StreamResult<T>>> StreamAsync<T>(IQueryable<T> query, out StreamQueryStatistics streamQueryStats);

Task<IAsyncEnumerator<StreamResult<T>>> StreamAsync<T>(IDocumentQuery<T> query);

Task<IAsyncEnumerator<StreamResult<T>>> StreamAsync<T>(IRawDocumentQuery<T> query);

Task<IAsyncEnumerator<StreamResult<T>>> StreamAsync<T>(IRawDocumentQuery<T> query, out StreamQueryStatistics streamQueryStats);

Task<IAsyncEnumerator<StreamResult<T>>> StreamAsync<T>(IDocumentQuery<T> query, out StreamQueryStatistics streamQueryStats);

Task<IAsyncEnumerator<StreamResult<T>>> StreamAsync<T>(string startsWith, string matches = null, int start = 0, int pageSize = int.MaxValue, string startAfter = null);
`}
</CodeBlock>
</TabItem>
</Tabs>

| Parameter | Type | Description |
| ------------- | ------------- | ----- |
| **startsWith** | `string` | prefix for which documents should be streamed |
| **matches** | `string` | pipe ('&#124;') separated values for which document IDs should be matched ('?' any single character, '*' any characters) |
| **start** | `int` | number of documents that should be skipped  |
| **pageSize** | `int` | maximum number of documents that will be retrieved |
| **skipAfter** | `string` | skip document fetching until a given ID is found and returns documents after that ID (default: `null`) |
| **StreamQueryStats** | `streamQueryStats` (out parameter) | Information about the streaming query (amount of results, which index was queried, etc.) |

| Return Type | Description |
| ------------- | ----- |
| `IEnumerator<`[StreamResult](../../glossary/stream-result.mdx)`>` | Enumerator with entities. |
| `streamQueryStats` (out parameter) | Information about the streaming query (amount of results, which index was queried, etc.) |


### Example I

Stream documents for a ID prefix:

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`IEnumerator<StreamResult<Employee>> enumerator = session
    .Advanced
    .Stream<Employee>("employees/");

while (enumerator.MoveNext())
{
    StreamResult<Employee> employee = enumerator.Current;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Raven.Client.Util.IAsyncEnumerator<StreamResult<Employee>> enumerator = await asyncSession
    .Advanced
    .StreamAsync<Employee>("employees/");

while (await enumerator.MoveNextAsync())
{
    StreamResult<Employee> employee = enumerator.Current;
}
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example 2

Fetch documents for a ID prefix directly into a stream:

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`using (var outputStream = new MemoryStream())
{
    session
        .Advanced
        .LoadStartingWithIntoStream("employees/", outputStream);
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`using (var outputStream = new MemoryStream())
{
    await asyncSession
        .Advanced
        .LoadStartingWithIntoStreamAsync("employees/", outputStream);
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## IsLoaded

To check if an entity is attached to a session, e.g. it has been loaded previously, use the `IsLoaded` method from the **Advanced** session operations.  
  
`IsLoaded` checks if you've already tried to load a document during the current session.  
If you try to load a document that no longer exists with the `Load` method (perhaps it has been deleted),  
`IsLoaded` will then return `true` because `IsLoaded` shows that you've already tried to load the non-existent document.  
<TabItem value="loading_entities_6_0" label="loading_entities_6_0">
<CodeBlock language="csharp">
{`bool IsLoaded(string id);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **id** | string | Entity ID for which the check should be performed. |

| Return Value | |
| ------------- | ----- |
| bool | Indicates if an entity with a given ID is loaded. |

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`bool isLoaded = session.Advanced.IsLoaded("employees/1"); // false
Employee employee = session.Load<Employee>("employees/1");
isLoaded = session.Advanced.IsLoaded("employees/1"); // true
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`bool isLoaded = asyncSession.Advanced.IsLoaded("employees/1"); // false
Employee employee = await asyncSession.LoadAsync<Employee>("employees/1");
isLoaded = asyncSession.Advanced.IsLoaded("employees/1"); // true
`}
</CodeBlock>
</TabItem>
</Tabs>




