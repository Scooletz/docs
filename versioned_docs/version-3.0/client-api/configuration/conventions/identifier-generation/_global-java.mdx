import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

#Global identifier generation conventions



You can setup a custom key generation strategy by supplying a custom function `DocumentKeyGenerator`. By default a session uses [the HiLo algorithm](../../../../client-api/document-identifiers/hilo-algorithm.mdx):

<TabItem value="key_generator_hilo" label="key_generator_hilo">
<CodeBlock language="java">
{`final MultiDatabaseHiLoGenerator hiLoGenerator = new MultiDatabaseHiLoGenerator(32);
conventions.setDocumentKeyGenerator(new DocumentKeyGenerator() \{
  @Override
  public String generate(String dbName, IDatabaseCommands dbCommands, Object entity) \{
    return hiLoGenerator.generateDocumentKey(dbName, dbCommands, conventions, entity);
  \}
\});
`}
</CodeBlock>
</TabItem>

However if you want the session to use [an identity key generation strategy](../../../../client-api/document-identifiers/working-with-document-ids.mdx#identity-ids) by default, you can overwrite this convention in the following manner:

<TabItem value="key_generator_identityKeys" label="key_generator_identityKeys">
<CodeBlock language="java">
{`conventions.setDocumentKeyGenerator(new DocumentKeyGenerator() \{
  @Override
  public String generate(String dbName, IDatabaseCommands dbCommands, Object entity) \{
    return store.getConventions().getTypeTagName(entity.getClass()) + "/";
  \}
\});
`}
</CodeBlock>
</TabItem>

Function `getTypeTagName` will use either the convention specified in `findTypeTagName` (see below) or its default implementation.

### FindTypeTagName

Entity objects that share a common tag name belong to the same [collection](../../../../client-api/faq/what-is-a-collection.mdx) on the server side. Tag names are also used to build document keys.

<TabItem value="find_type_tagname" label="find_type_tagname">
<CodeBlock language="java">
{`conventions.setFindTypeTagName(new TypeTagNameFinder() \{
  @Override
  public String find(Class<?> clazz) \{
    // function that provides the collection name based on the entity type
    return clazz.getSimpleName();
  \}
\});
`}
</CodeBlock>
</TabItem>


### TransformTypeTagNameToDocumentKeyPrefix

Actually, tag names determined by recently described convention functions aren't directly used as prefixes in document keys. There is a convention function called `transformTypeTagNameToDocumentKeyPrefix` which takes the collection name and produces the prefix:

<TabItem value="transform_tag_name_to_prefix" label="transform_tag_name_to_prefix">
<CodeBlock language="java">
{`conventions.setTransformTypeTagNameToDocumentKeyPrefix(new TypeTagNameToDocumentKeyPrefixTransformer() \{
  @Override
  public String transform(String tag) \{
    // transform the tag name to the prefix of a key, e.g. [prefix]/12
    throw new CodeOmitted();
  \}
\});
`}
</CodeBlock>
</TabItem>

Its default behavior is that for a tag which contains one upper character it simply converts it to lower case string, e.g. `Users` would be transformed into `users`. For tag names containing more upper characters there will be no change, e.g. the tag name: `LineItems` would output the following prefix: `LineItems`.

### FindJavaClassName and FindJavaClass

In metadata of all documents stored in a database you can find the following property which specifies the client-side type. For instance:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{
    "Raven-Java-Class": "com.example.orders.Shipper"
\}
`}
</CodeBlock>
</TabItem>

This property is used by RavenDB client to perform a conversion between java object and JSON document stored in a database. A function responsible for retrieving the java class of an entity is defined by `findJavaClassName` convention:

<TabItem value="find_type_name" label="find_type_name">
<CodeBlock language="java">
{`conventions.setFindJavaClassName(new JavaClassNameFinder() \{
  @Override
  public String find(Class<?> clazz) \{
    // use reflection to determine the type;
    return clazz.getSimpleName();
  \}
\});
`}
</CodeBlock>
</TabItem>

To properly perform the revert conversion that is from a JSON result into a java object we need to retrieve the java class from `Raven-Java-Class` metadata:

<TabItem value="find_clr_type" label="find_clr_type">
<CodeBlock language="java">
{`conventions.setFindJavaClass(new JavaClassFinder() \{
  @Override
  public String find(String id, RavenJObject doc, RavenJObject metadata) \{
    return metadata.value(String.class, Constants.RAVEN_JAVA_CLASS);
  \}
\});
`}
</CodeBlock>
</TabItem>


### FindIdentityProperty

The client must know where in your entity an identifier is stored to be property able to transform it into JSON document. It uses `findIdentityProperty` convention for that. The default and very common convention is that a property named `Id` is the identifier, so it is the default one:

<TabItem value="find_identity_property" label="find_identity_property">
<CodeBlock language="java">
{`conventions.setFindIdentityProperty(new IdentityPropertyFinder() \{
  @SuppressWarnings("boxing")
  @Override
  public Boolean find(Field field) \{
    return "Id".equals(field.getName());
  \}
\});
`}
</CodeBlock>
</TabItem>

You can provide a customization based on the `field` parameter to indicate which field keeps the identifier. The client will iterate over all object fields and take the first one according to the defined predicate.

### FindIdentityPropertyNameFromEntityName

It can happen that sometimes the results returned by the server can haven't identifiers defined (for example if you run a projection query) however they have `Raven-Entity-Name` in metadata.
Then to perform the conversion into java object a function that finds the identity property name for a given entity name is applied:

<TabItem value="find_iden_propn_name_from_entity_name" label="find_iden_propn_name_from_entity_name">
<CodeBlock language="java">
{`conventions.setFindIdentityPropertyNameFromEntityName(new IdentityPropertyNameFinder() \{
  @Override
  public String find(String entityName) \{
    return "Id";
  \}
\});
`}
</CodeBlock>
</TabItem>

### IdentityPartsSeparator

According to the default, convention document keys have the following format: `[collectionName]/[identityValue]`. The slash character (`/`) separates the two parts of an identifier.
You can overwrite it by using `identityPartsSeparator` convention. Its default definition is:

<TabItem value="identity_part_separator" label="identity_part_separator">
<CodeBlock language="java">
{`conventions.setIdentityPartsSeparator("/");
`}
</CodeBlock>
</TabItem>

### IdentityTypeConvertors

RavenDB is designed to work with string identifiers. However it has the support for numeric and UUID ids. To be more exact it is able to work with `int`, `long` and `UUID` identifiers,
because it has dedicated converters for them:

<TabItem value="identity_type_convertors" label="identity_type_convertors">
<CodeBlock language="java">
{`conventions.setIdentityTypeConvertors(Arrays.asList(
  new UUIDConverter(),
  new Int32Converter(),
  new Int64Converter()
  ));
`}
</CodeBlock>
</TabItem>

If you need to have the support for different types of identifier properties, you can add a custom converter that implements `ITypeConverter` interface:

<TabItem value="custom_converter" label="custom_converter">
<CodeBlock language="java">
{`public static class UInt32Converter implements ITypeConverter \{

  @Override
  public boolean canConvertFrom(Class<?> sourceType) \{
    throw new CodeOmitted();
  \}

  @Override
  public String convertFrom(String tag, Object value, boolean allowNull) \{
    throw new CodeOmitted();
  \}

  @Override
  public Object convertTo(String value) \{
    throw new CodeOmitted();
  \}
\}
`}
</CodeBlock>
</TabItem>
<TabItem value="identity_type_convertors_2" label="identity_type_convertors_2">
<CodeBlock language="java">
{`conventions.getIdentityTypeConvertors().add(new UInt32Converter());
`}
</CodeBlock>
</TabItem>

### FindIdValuePartForValueTypeConversion

You need to remember that even if the identity property of your entry isn't a string, a document in a database always has a string key. E.g. for the `Orders` entity that has
a numeric ID and its value is `3`, the server side key will be `orders/3`. If such document is fetched by RavenDB client, the key needs to be converted into a number. By default
we look for the last part of the identifier after `identityPartsSeparator`:

<TabItem value="find_id_value_part_for_value_type_conversion" label="find_id_value_part_for_value_type_conversion">
<CodeBlock language="java">
{`conventions.setFindIdValuePartForValueTypeConversion(new IdValuePartFinder() \{
  @Override
  public String find(Object entity, String id) \{
    return id.split(conventions.getIdentityPartsSeparator())[1];
  \}
\});
`}
</CodeBlock>
</TabItem>

### FindFullDocumentKeyFromNonStringIdentifier

Sometimes the client needs to know the full id of the document that will be stored for an entity with non-sting identifier. We can use the following function:

<TabItem value="find_full_doc_key_from_non_string_identifier" label="find_full_doc_key_from_non_string_identifier">
<CodeBlock language="java">
{`conventions.setFindFullDocumentKeyFromNonStringIdentifier(new DocumentKeyFinder() \{

  @Override
  public String find(Object id, Class<?> type, Boolean allowNull) \{
    // by default returns [tagName]/[identityValue];
    throw new CodeOmitted();
  \}
\});
`}
</CodeBlock>
</TabItem>

to find the full key based on the type of a document and the value type identifier.


