---
title: "Indexing LINQ extensions"
hide_table_of_contents: true
sidebar_label: Indexing LINQ Extensions
sidebar_position: 19
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Indexing LINQ extensions

Various indexing LINQ extensions are available to enhance the usability and reduce the complexity of the indexing functions. The available extensions are:

- [StripHtml](../indexes/indexing-linq-extensions.mdx#striphtml)
- [Boost](../indexes/indexing-linq-extensions.mdx#boost)
- [Reverse](../indexes/indexing-linq-extensions.mdx#reverse)
- [IfEntityIs](../indexes/indexing-linq-extensions.mdx#ifentityis)
- [WhereEntityIs](../indexes/indexing-linq-extensions.mdx#whereentityis)
- [ParseInt, ParseLong, ParseDecimal, ParseDouble, ParseSingle](../indexes/indexing-linq-extensions.mdx#parsing-numbers)

## **StripHtml**

This extension can come in handy when you want to index a HTML without any HTML tags e.g. for full text search.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Article_Search : AbstractIndexCreationTask<Article>
{
	public class Result
	{
		public string Content { get; set; }
	}

	public Article_Search()
	{
		Map = articles => from article in articles
					select new
					{
						Content = article.ContentHtml.StripHtml()
					};

		Index(x => x.ContentHtml, FieldIndexing.Analyzed);
	}
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Article> results = session
	.Query<Article_Search.Result, Article_Search>()
	.Search(x => x.Content, "Raven*", escapeQueryOptions: EscapeQueryOptions.AllowPostfixWildcard)
	.OfType<Article>()
	.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Article" label="Article">
<CodeBlock language="csharp">
{`public class Article
{
	public string Id { get; set; }

	public string Title { get; set; }

	public string ContentHtml { get; set; }
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## **Boost**

You can read more about boosting [here](../indexes/boosting.mdx).



## **Reverse**

**Strings** and **enumerables** can be reversed by using `Reverse` extension.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByReversedFirstName : AbstractIndexCreationTask<Employee>
{
	public Employees_ByReversedFirstName()
	{
		Map = employees => from employee in employees
					select new
					{
						FirstName = employee.FirstName.Reverse()
					};
	}
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Employee> results = session
	.Query<Employee, Employees_ByReversedFirstName>()
	.Where(x => x.FirstName == "treboR")
	.ToList();
`}
</CodeBlock>
</TabItem>
</Tabs>



## **WhereEntityIs**

`WhereEntityIs` can be used to check if given `Raven-Entity-Name` value in metadata for the given document matches any of the given values. This can be useful when indexing polymorphic data. Please visit dedicated article to get more information (or click [here](../indexes/indexing-polymorphic-data.mdx#other-ways)).



## **IfEntityIs**

`IfEntityIs` is similar to `WhereEntityIs`, yet it checks only against one value.



## **Parsing numbers**

String values can be safely parsed to `int`, `long`, `decimal`, `double` and `single` using appropriate methods:

- ParseInt,
- ParseLong,
- ParseDecimal,
- ParseDouble,
- ParseSingle

There are two overrides for each method, first one returning default value in case of parsing failure, second one accepting value that should be returned when failure occurs.

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Item_Parse : AbstractIndexCreationTask<Item>
{
	public class Result
	{
		public int MajorWithDefault { get; set; }

		public int MajorWithCustomDefault { get; set; }
	}

	public Item_Parse()
	{
		Map = items => from item in items
		            let parts = item.Version.Split('.')
					select new
					{
						MajorWithDefault = parts[0].ParseInt(),			// will return default(int) in case of parsing failure
						MajorWithCustomDefault = parts[0].ParseInt(-1)	// will return -1 in case of parsing failure
					};

		StoreAllFields(FieldStorage.Yes);
	}
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Item" label="Item">
<CodeBlock language="csharp">
{`public class Item
{
	public string Version { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Example" label="Example">
<CodeBlock language="csharp">
{`session.Store(new Item { Version = "3.0.1" });
session.Store(new Item { Version = "Unknown" });

session.SaveChanges();

var results = session
	.Query<Item_Parse.Result, Item_Parse>()
	.ToList();

Assert.Equal(2, results.Count);
Assert.True(results.Any(x => x.MajorWithDefault == 3));
Assert.True(results.Any(x => x.MajorWithCustomDefault == 3));
Assert.True(results.Any(x => x.MajorWithDefault == 0));
Assert.True(results.Any(x => x.MajorWithCustomDefault == -1));
`}
</CodeBlock>
</TabItem>
</Tabs>



