---
title: "What are indexes?"
hide_table_of_contents: true
sidebar_label: What are Indexes
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# What are indexes?

Indexes are server-side functions that define using which fields (and what values) document can be searched on and are _the only way_ to satisfy queries in RavenDB. The whole indexing process is done in the background and is triggered whenever data is added or changed. This approach allows the server to respond quickly even when the large amounts of data have changed and avoid costly table scans operations, however implication of this choice is that the results might be stale (you can read more about staleness implications and the ways to handle it [here](../indexes/stale-indexes.mdx)).

The core of every index is its mapping function with LINQ-like syntax and the result of such a mapping is converted to [Lucene](http://lucene.apache.org/) index entry, which is persisted for future use to avoid re-indexation each time the query is issued and to achieve fast response times.

## Basic example

In our example, we will create an index that will map documents from the `Employees` [collection](../client-api/faq/what-is-a-collection.mdx) and enable querying by `FirstName`, `LastName`, or both.

- first, we need to create an index. One way to create it is to use the `AbstractIndexCreationTask`, but there are other ways available as well (you can read about them [here](../indexes/creating-and-deploying.mdx)).

<TabItem value="indexes_1" label="indexes_1">
<CodeBlock language="csharp">
{`// Define the index:
// =================

public class Employees_ByNameAndCountry : AbstractIndexCreationTask<Employee>
\{
    public class IndexEntry
    \{
        // The index-fields
        public string LastName \{ get; set; \}
        public string FullName \{ get; set; \}
        public string Country \{ get; set; \}
    \}
    
    public Employees_ByNameAndCountry()
    \{
        Map = employees => from employee in employees
                           select new IndexEntry()
                           \{
                               // Define the content for each index-field
                               LastName = employee.LastName,
                               FullName = employee.FirstName + " " + employee.LastName,
                               Country = employee.Address.Country
                           \};
    \}
\}
`}
</CodeBlock>
</TabItem>

- next step is to send an index to a server (more about index deployment options can be found [here](../indexes/creating-and-deploying.mdx)), so indexing process can start indexing documents.

<TabItem value="indexes_2" label="indexes_2">
<CodeBlock language="csharp">
{`// Deploy the index to the server:
// ===============================

new Employees_ByNameAndCountry().Execute(store);
`}
</CodeBlock>
</TabItem>

- now, our index can be queried, and indexed results can be returned.

<TabItem value="indexes_3" label="indexes_3">
<CodeBlock language="csharp">
{`// Query the database using the index: 
// ===================================

IList<Employee> employeesFromUK = session
    .Query<Employees_ByNameAndCountry.IndexEntry, Employees_ByNameAndCountry>()
     // Here we query for all Employee documents that are from the UK
     // and have 'King' in their LastName field:
    .Where(x => x.LastName == "King" && x.Country == "UK")
    .OfType<Employee>()
    .ToList();
`}
</CodeBlock>
</TabItem>

More examples with detailed descriptions can be found [here](../indexes/indexing-basics.mdx).

## Remarks

<Admonition type="warning" title="Remember" id="remember" href="#remember">
A frequent mistake is to treat indexes as SQL Views, but this is not the case. The **result of a query for the given index is a full document**, not only the fields that were indexed. 

This behavior can be altered by [storing](../indexes/storing-data-in-index.mdx) fields and doing [projections](../indexes/querying/projections.mdx).
</Admonition>

