---
title: "Dynamic aggregation"
hide_table_of_contents: true
sidebar_label: Dynamic aggregation
sidebar_position: 12
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];


# Dynamic aggregation
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


This feature is an another way to do aggregations and in contrast to [Map-Reduce](../../indexes/map-reduce-indexes.mdx) indexes, it allows to create much more complex queries. It gives you more options for reporting applications, dynamic selection and complex aggregation with additional filtering. 

When working with a map/reduce index we are able to do only limited amount of queries. Let's imagine a sample SQL query:

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`select sum(Total) from Orders where Total > 500 group by Product
`}
</CodeBlock>
</TabItem>

In order give you the ability to query like this, we introduced the dynamic aggregation feature. Thanks this you can build the following query:

<TabItem value="dynamic_aggregation_1" label="dynamic_aggregation_1">
<CodeBlock language="csharp">
{`FacetResults facetResults = session
	.Query<Order, Orders_All>()
	.Where(x => x.Total > 500)
	.AggregateBy(x => x.Product)
		.SumOn(x => x.Total)
	.ToList();
`}
</CodeBlock>
</TabItem>

Assuming that your classes look like this:

<TabItem value="currency" label="currency">
<CodeBlock language="csharp">
{`public enum Currency
\{
	EUR,
	USD
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="order" label="order">
<CodeBlock language="csharp">
{`public class Order
\{
	public double Total \{ get; set; \}

	public string Product \{ get; set; \}

	public Currency Currency \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

The _Orders/All_ index used in the query is a simple map-only index. The only difference is that you **have to** specify sort options for numeric fields used in the query. This is needed for recognizing by RavenDB types of numeric fields when such a query will come in.

<TabItem value="dynamic_aggregation_index_def" label="dynamic_aggregation_index_def">
<CodeBlock language="csharp">
{`public class Orders_All : AbstractIndexCreationTask<Order>
\{
	public Orders_All()
	\{
		Map = orders => from order in orders
				select new
				\{
					order.Total,
					order.Product,
					Concurrency = order.Currency
				\};

		Sort(x => x.Total, SortOptions.Double);
	\}
\}
`}
</CodeBlock>
</TabItem>

<Admonition type="warning" title="">
Not specifying appropriate `SortOptions` for numerical fields will result in an **exception** when aggregation query is executed.
</Admonition>

<Admonition type="note" title="">
Results of a dynamic aggregation query are calculated on the fly, while results of map/reduce index are precomputed. Most cases is fast enough but note that you can hit a lot of data. This feature should be used only for complex aggregate queries that cannot be done by using standard map/reduce.
</Admonition>

## Extended faceted search

Under the covers this is [a faceted search](../../indexes/querying/faceted-search.mdx) with an extended support for doing aggregations. For example you can aggregate ranges:

<TabItem value="dynamic_aggregation_range" label="dynamic_aggregation_range">
<CodeBlock language="csharp">
{`FacetResults facetResults = session.Query<Order, Orders_All>()
				.AggregateBy(x => x.Product)
				.AddRanges(
					x => x.Total < 100,
					x => x.Total >= 100 && x.Total < 500,
					x => x.Total >= 500 && x.Total < 1500,
					x => x.Total >= 1500
				)
				.SumOn(x => x.Total)
				.ToList();
`}
</CodeBlock>
</TabItem>

It also supports an aggregation on multiple levels:

<TabItem value="dynamic_aggregation_multiple_items" label="dynamic_aggregation_multiple_items">
<CodeBlock language="csharp">
{`FacetResults facetResults = session.Query<Order, Orders_All>()
				.AggregateBy(x => x.Product)
					.SumOn(x => x.Total)
					.CountOn(x => x.Total)
				.AndAggregateOn(x => x.Currency)
					.MinOn(x => x.Total)
				.ToList();
`}
</CodeBlock>
</TabItem>

Another example is an aggregation on different fields based on same facet:

<TabItem value="dynamic_aggregation_different_fieldss" label="dynamic_aggregation_different_fieldss">
<CodeBlock language="csharp">
{`FacetResults facetResults = session.Query<Order, Orders_All>()
				.AggregateBy(x => x.Product)
					.MaxOn(x => x.Total)
					.MinOn(x => x.Currency)
				.ToList();
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="warning" title="">
`AggregateBy` only supports aggregation by single field, if you want to aggregate by a multiple fields you need to emit a single field that contains all values.
</Admonition>


</LanguageContent>
<LanguageContent language="java">


This feature is an another way to do aggregations and in contrast to [Map-Reduce](../../indexes/map-reduce-indexes.mdx) indexes, it allows to create much more complex queries. It gives you more options for reporting applications, dynamic selection and complex aggregation with additional filtering. 

When working with a map/reduce index we are able to do only limited amount of queries. Let's imagine a sample SQL query:

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`select sum(Total) from Orders where Total > 500 group by Product
`}
</CodeBlock>
</TabItem>

In order give you the ability to query like this, we introduced the dynamic aggregation feature. Thanks this you can build the following query:

<TabItem value="dynamic_aggregation_1" label="dynamic_aggregation_1">
<CodeBlock language="java">
{`QDynamicAggregation_Order o = QDynamicAggregation_Order.order;
FacetResults facetResults = session
  .query(Order.class, Orders_All.class)
  .where(o.total.gt(500))
  .aggregateBy(o.product)
    .sumOn(o.total)
  .toList();
`}
</CodeBlock>
</TabItem>

Assuming that your classes look like this:

<TabItem value="currency" label="currency">
<CodeBlock language="java">
{`public enum Currency \{
  EUR,
  USD
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="order" label="order">
<CodeBlock language="java">
{`@QueryEntity
public static class Order \{
  private double total;
  private String product;
  private Currency currency;

  public double getTotal() \{
    return total;
  \}
  public void setTotal(double total) \{
    this.total = total;
  \}
  public String getProduct() \{
    return product;
  \}
  public void setProduct(String product) \{
    this.product = product;
  \}
  public Currency getCurrency() \{
    return currency;
  \}
  public void setCurrency(Currency currency) \{
    this.currency = currency;
  \}
\}
`}
</CodeBlock>
</TabItem>

The _Orders/All_ index used in the query is a simple map-only index. The only difference is that you **have to** specify sort options for numeric fields used in the query. This is needed for recognizing by RavenDB types of numeric fields when such a query will come in.

<TabItem value="dynamic_aggregation_index_def" label="dynamic_aggregation_index_def">
<CodeBlock language="java">
{`public static class Orders_All extends AbstractIndexCreationTask \{
  public Orders_All() \{
    QDynamicAggregation_Order o = QDynamicAggregation_Order.order;
    map =
     " from order in docs.Orders         " +
     " select new                        " +
     " \{                                 " +
     "     order.Total,                  " +
     "     order.Product,                " +
     "     Concurrency = order.Currency  " +
     " \}; ";

    sort(o.total, SortOptions.DOUBLE);
  \}
\}
`}
</CodeBlock>
</TabItem>

<Admonition type="warning" title="">
Not specifying appropriate `SortOptions` for numerical fields will result in an **exception** when aggregation query is executed.
</Admonition>

<Admonition type="note" title="">
Results of a dynamic aggregation query are calculated on the fly, while results of map/reduce index are precomputed. Most cases is fast enough but note that you can hit a lot of data. This feature should be used only for complex aggregate queries that cannot be done by using standard map/reduce.
</Admonition>

## Extended faceted search

Under the covers this is [a faceted search](../../indexes/querying/faceted-search.mdx) with an extended support for doing aggregations. For example you can aggregate ranges:

<TabItem value="dynamic_aggregation_range" label="dynamic_aggregation_range">
<CodeBlock language="java">
{`QDynamicAggregation_Order o = QDynamicAggregation_Order.order;
FacetResults facetResults = session
  .query(Order.class, Orders_All.class)
  .aggregateBy(o.product)
  .addRanges(
    o.total.lt(100),
    o.total.goe(100).and(o.total.lt(500)),
    o.total.goe(500).and(o.total.lt(1500)),
    o.total.goe(1500)
  )
  .sumOn(o.total)
  .toList();
`}
</CodeBlock>
</TabItem>

It also supports an aggregation on multiple levels:

<TabItem value="dynamic_aggregation_multiple_items" label="dynamic_aggregation_multiple_items">
<CodeBlock language="java">
{`QDynamicAggregation_Order o = QDynamicAggregation_Order.order;
FacetResults facetResults = session
  .query(Order.class, Orders_All.class)
  .aggregateBy(o.product)
    .sumOn(o.total)
    .countOn(o.total)
  .andAggregateOn(o.currency)
    .minOn(o.total)
  .toList();
`}
</CodeBlock>
</TabItem>

Another example is an aggregation on different fields based on same facet:

<TabItem value="dynamic_aggregation_different_fieldss" label="dynamic_aggregation_different_fieldss">
<CodeBlock language="java">
{`QDynamicAggregation_Order o = QDynamicAggregation_Order.order;
FacetResults facetResults = session
  .query(Order.class, Orders_All.class)
  .aggregateBy(o.product)
    .maxOn(o.total)
    .minOn(o.currency)
  .toList();
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="warning" title="">
`aggregateBy` only supports aggregation by single field, if you want to aggregate by a multiple fields you need to emit a single field that contains all values.
</Admonition>


</LanguageContent>

<!---
- [Querying : Faceted search](../../indexes/querying/faceted-search)

-->