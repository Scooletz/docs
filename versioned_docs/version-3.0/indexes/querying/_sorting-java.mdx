import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">
This article focuses only on querying side of the sorting. If you are interested in reading how to create indexes and change default sorting behavior go [here](../../indexes/customizing-results-order.mdx).
</Admonition>

## Basics

By default, all index values are sorted lexicographically, this can be changed in index definition, but sorting is **not applied** until you request it by using appropriate methods, so following queries will not return sorted results, even if we define in our index appropriate sorting option:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.query(Product.class, Products_ByUnitsInStock.class)
    .where(p.unitsInStock.gt(10)).toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.advanced().documentQuery(Product.class, Products_ByUnitsInStock.class)
    .whereGreaterThan(p.unitsInStock, 10).toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`QueryResult result = store.getDatabaseCommands()
    .query("Products/ByUnitsInStock", new IndexQuery("UnitsInStock_Range:{Ix10 TO NULL}"));
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {

    public Products_ByUnitsInStock() {
        map = " from product in docs.Products " +
            " select new                    " +
            "   {                           " +
            "       product.UnitsInStock    " +
            "   };";

        QProduct p = QProduct.product;
        sort(p.unitsInStock, SortOptions.INT);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

So, to start sorting, we need to request to order by some specified index field. In our case we will order by `UnitsInStock` in descending order:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.query(Product.class, Products_ByUnitsInStock.class)
    .where(p.unitsInStock.gt(10)).orderBy(p.unitsInStock.desc()).toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.advanced().documentQuery(Product.class, Products_ByUnitsInStock.class)
    .whereGreaterThan(p.unitsInStock, 10).orderByDescending(p.unitsInStock).toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`IndexQuery query = new IndexQuery();
query.setQuery("UnitsInStock_Range:{Ix10 TO NULL}");
query.setSortedFields(new SortedField[] {new SortedField("-UnitsInStock_Range")});
QueryResult result = store.getDatabaseCommands().query("Products/ByUnitsInStock", query);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {

    public Products_ByUnitsInStock() {
        map = " from product in docs.Products " +
            " select new                    " +
            "   {                           " +
            "       product.UnitsInStock    " +
            "   };";

        QProduct p = QProduct.product;
        sort(p.unitsInStock, SortOptions.INT);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="info" title="Convention" id="convention" href="#convention">
You probably noticed that we used `-` in a name of a field passed to `SortedField` that was used in **commands**, which means that we want to sort our results in a descending order. Using `+` symbol or no prefix means that ascending sorting is requested. 

Of course you can change order and field name in `SortedField` later since all properties have public access.
</Admonition>

## Ordering by score

When query is issued, each index entry is scored by Lucene (you can read more about Lucene scoring [here](http://lucene.apache.org/core/3_3_0/scoring.html)) and this value is available in metadata information of a document under `Temp-Index-Score` (the higher the value, the better the match). To order by this value you can use `orderByScore` or `orderByScoreDescending` methods:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.query(Product.class, Products_ByUnitsInStock.class)
    .where(p.unitsInStock.gt(10)).orderByScore().toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.advanced().documentQuery(Product.class, Products_ByUnitsInStock.class)
    .whereGreaterThan(p.unitsInStock, 10).orderByScore().toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`IndexQuery query = new IndexQuery();
query.setQuery("UnitsInStock_Range:{Ix10 TO NULL}");
query.setSortedFields(new SortedField[] {new SortedField(Constants.TEMPORARY_SCORE_VALUE)});
QueryResult result = store.getDatabaseCommands().query("Products/ByUnitsInStock", query);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {

    public Products_ByUnitsInStock() {
        map = " from product in docs.Products " +
            " select new                    " +
            "   {                           " +
            "       product.UnitsInStock    " +
            "   };";

        QProduct p = QProduct.product;
        sort(p.unitsInStock, SortOptions.INT);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

## Random ordering

If you want to randomize the order of your results each time the query is executed you can use `randomOrdering` method (API reference [here](../../client-api/session/querying/how-to-customize-query.mdx#randomordering)):

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.query(Product.class, Products_ByUnitsInStock.class)
    .customize(new DocumentQueryCustomizationFactory().randomOrdering()).where(p.unitsInStock.gt(10))
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`QProduct p = QProduct.product;
List<Product> results = session.advanced().documentQuery(Product.class, Products_ByUnitsInStock.class)
    .randomOrdering().whereGreaterThan(p.unitsInStock, 10).toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`IndexQuery query = new IndexQuery();
query.setQuery("UnitsInStock_Range:{Ix10 TO NULL}");
query.setSortedFields(
    new SortedField[] {new SortedField(Constants.RANDOM_FIELD_NAME + ";" + UUID.randomUUID())});
QueryResult result = store.getDatabaseCommands().query("Products/ByUnitsInStock", query);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByUnitsInStock extends AbstractIndexCreationTask {

    public Products_ByUnitsInStock() {
        map = " from product in docs.Products " +
            " select new                    " +
            "   {                           " +
            "       product.UnitsInStock    " +
            "   };";

        QProduct p = QProduct.product;
        sort(p.unitsInStock, SortOptions.INT);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

## Ordering when field is Analyzed

When sorting must be done on field that is marked as [Analyzed](../../indexes/using-analyzers.mdx) then due to [Lucene](https://lucene.apache.org/) limitations sorting on such a field is not supported. To overcome this, the solution is to create another field that is not marked as Analyzed and sort by it.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QSorting_Products_ByName_Search_Result p = QSorting_Products_ByName_Search_Result.result;
List<Products_ByName_Search.Result> results = session
    .query(Products_ByName_Search.Result.class, Products_ByName_Search.class)
    .search(p.name, "Louisiana").orderBy(p.nameForSorting.desc()).toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`List<Product> results = session.advanced().documentQuery(Product.class, Products_ByName_Search.class)
    .search("Name", "Louisiana").orderByDescending("NameForSorting").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`IndexQuery indexQuery = new IndexQuery();
indexQuery.setQuery("Name:Louisiana*");
indexQuery.setSortedFields(new SortedField[] {new SortedField("-NameForSorting")});

store.getDatabaseCommands().query("Products/ByName/Search", indexQuery);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Products_ByName_Search extends AbstractIndexCreationTask {

    @QueryEntity public static class Result {

        private String name;
        private String nameForSorting;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getNameForSorting() {
            return nameForSorting;
        }

        public void setNameForSorting(String nameForSorting) {
            this.nameForSorting = nameForSorting;
        }
    }

    public Products_ByName_Search() {
        QProduct p = QProduct.product;
        map = "from product in docs.products select new  { Name = product.Name, NameForSorting = product.Name } ";
        indexes.put(p.name, FieldIndexing.ANALYZED);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

## Custom sorting

If you want to sort using your custom algorithm you need create your own sorter that inherits from `IndexEntriesToComparablesGenerator` and deploy it to [plugins](../../server/plugins/what-are-plugins.mdx) folder on the server.

<TabItem value="sorting_5_1" label="sorting_5_1">
<CodeBlock language="csharp">
{`public abstract class IndexEntriesToComparablesGenerator
\{
	protected IndexQuery IndexQuery;

	protected IndexEntriesToComparablesGenerator(IndexQuery indexQuery)
	\{
		IndexQuery = indexQuery;
	\}

	public abstract IComparable Generate(IndexReader reader, int doc);
\}
`}
</CodeBlock>
</TabItem>

For example, if we want to sort by specified number of characters from an end, and we want to have an ability to specify number of characters explicitly, we can implement our sorter like this:

<TabItem value="sorting_5_2" label="sorting_5_2">
<CodeBlock language="csharp">
{`public class SortByNumberOfCharactersFromEnd : IndexEntriesToComparablesGenerator
\{
	private readonly int len;

	public SortByNumberOfCharactersFromEnd(IndexQuery indexQuery)
		: base(indexQuery)
	\{
		len = IndexQuery.TransformerParameters["len"].Value<int>();		// using transformer parameters to pass the length explicitly
	\}

	public override IComparable Generate(IndexReader reader, int doc)
	\{
		var document = reader.Document(doc);
		var name = document.GetField("FirstName").StringValue;			// this field is stored in index
		return name.Substring(name.Length - len, len);
	\}
\}
`}
</CodeBlock>
</TabItem>

And it can be used like this:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Employee> results = session.query(Employee.class, Employee_ByFirstName.class).customize(
    new DocumentQueryCustomizationFactory()
        .customSortUsing("AssemblyQualifiedName", true)).addTransformerParameter("len", 1).toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`List<Employee> results = session.advanced().documentQuery(Employee.class, Employee_ByFirstName.class)
    .customSortUsing("SortByNumberOfCharactersFromEnd", true)
    .setTransformerParameters(ImmutableMap.of("len", RavenJToken.fromObject(1))).toList();
            }

gion sorting_5_5
xQuery indexQuery = new IndexQuery();
edField sortedField = new SortedField(Constants.CUSTOM_SORT_FIELD_NAME +
"-" + // "-" - descending, "" - ascending
";" +
"SorterFullName");
xQuery.setSortedFields(new SortedField[] {sortedField});
xQuery.setTransformerParameters(ImmutableMap.of("len", RavenJToken.fromObject(1)));

e.getDatabaseCommands().query("Employees/ByFirstName", indexQuery);
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`IndexQuery indexQuery = new IndexQuery();
SortedField sortedField = new SortedField(Constants.CUSTOM_SORT_FIELD_NAME +
    "-" + // "-" - descending, "" - ascending
    ";" +
    "SorterFullName");
indexQuery.setSortedFields(new SortedField[] {sortedField});
indexQuery.setTransformerParameters(ImmutableMap.of("len", RavenJToken.fromObject(1)));

store.getDatabaseCommands().query("Employees/ByFirstName", indexQuery);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employee_ByFirstName extends AbstractIndexCreationTask {

    public Employee_ByFirstName() {
        QEmployee e = QEmployee.employee;
        map = "from employee in docs.employees select new  { employee.FirstName } ";
        store(e.firstName, FieldStorage.YES);
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>


