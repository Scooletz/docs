---
title: "Faceted Search"
hide_table_of_contents: true
sidebar_label: Faceted Search
sidebar_position: 12
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];


# Faceted Search
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


When displaying a large amount of data, often paging is used to make viewing the data manageable. However it's also useful to give some context of the entire data-set and a easy way to drill-down into particular categories. The common approach to doing this is "faceted search", as shown in the image below. __Note__ how the count of each category within the current search is across the top.

![Facets](./assets/CNET_faceted_search_2.jpg)

&lt;br /&gt;
To achieve this in RavenDB, let's say you have a document like this:

<TabItem value="camera" label="camera">
<CodeBlock language="csharp">
{`public class Camera
\{
	public DateTime DateOfListing \{ get; set; \}

	public string Model \{ get; set; \}

	public decimal Cost \{ get; set; \}

	public int Zoom \{ get; set; \}

	public double Megapixels \{ get; set; \}

	public bool ImageStabilizer \{ get; set; \}

	public string Manufacturer \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

## Step 1

Create an index to work against, this can be setup like so:

<TabItem value="step_2" label="step_2">
<CodeBlock language="csharp">
{`public class Cameras_ByManufacturerModelCostDateOfListingAndMegapixels : AbstractIndexCreationTask<Camera>
\{
    public Cameras_ByManufacturerModelCostDateOfListingAndMegapixels()
    \{
        Map = cameras => from camera in cameras
                         select new
                         \{
                             camera.Manufacturer,
                             camera.Model,
                             camera.Cost,
                             camera.DateOfListing,
                             camera.Megapixels
                         \};
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 2

Next you need to setup your facet definitions:

<TabItem value="step_1" label="step_1">
<CodeBlock language="csharp">
{`List<FacetBase> facets = new List<FacetBase>
\{
    new Facet
    \{
        FieldName = "Manufacturer"
    \},
    new RangeFacet<Camera>
    \{
        Ranges =
        \{
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m
        \}
    \},
    new RangeFacet<Camera>
    \{
        Ranges =
        \{
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0
        \}
    \}
\};
`}
</CodeBlock>
</TabItem>

This tells RavenDB that you would like to get the following facets:

* For the **Manufacturer** field look at the documents and return a count for each unique Term found
* For the **Cost** field, return the count of the following ranges:
 * Cost &lt;= 200.0
 * 200.0 &lt;= Cost &lt;= 400.0
 * 400.0 &lt;= Cost &lt;= 600.0
 * 600.0 &lt;= Cost &lt;= 800.0
 * Cost &gt;= 800.0
* For the **Megapixels** field, return the count of the following ranges:
 * Megapixels &lt;= 3.0
 * 3.0 &lt;= Megapixels &lt;= 7.0
 * 7.0 &lt;= Megapixels &lt;= 10.0
 * Megapixels &gt;= 10.0

## Step 3

Finally you can write the following code and you get back the data below:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`FacetResults facetResults = session
	.Query<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
	.Where(x => x.Cost >= 100 && x.Cost <= 300)
	.ToFacets(facets);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`FacetResults facetResults = session
	.Advanced
	.DocumentQuery<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
	.WhereBetweenOrEqual(x => x.Cost, 100, 300)
	.ToFacets(facets);
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="csharp">
{`FacetResults facetResults = store
	.DatabaseCommands
	.GetFacets(
		"Cameras/ByManufacturerModelCostDateOfListingAndMegapixels",
		new IndexQuery
		{
			Query = "Cost_Range:[Dx100 TO Dx300]"
		},
		facets);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`List<Facet> facets = new List<Facet>
{
	new Facet
	{
		Name = "Manufacturer"
	},
	new Facet<Camera>
	{
		Name = x => x.Cost,
		Ranges =
		{
			x => x.Cost < 200m,
			x => x.Cost > 200m && x.Cost < 400m,
			x => x.Cost > 400m && x.Cost < 600m,
			x => x.Cost > 600m && x.Cost < 800m,
			x => x.Cost > 800m
		}
	},
	new Facet<Camera>
	{
		Name = x => x.Megapixels,
		Ranges =
		{
			x => x.Megapixels < 3.0,
			x => x.Megapixels > 3.0 && x.Megapixels < 7.0,
			x => x.Megapixels > 7.0 && x.Megapixels < 10.0,
			x => x.Megapixels > 10.0
		}
	}
};
`}
</CodeBlock>
</TabItem>
</Tabs>

The data below represents the sample faceted data that satisfies above query:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{
   Manufacturer: [
      \{
         Range: 'canon',
         Count: 42
      \},
      \{
         Range: 'jessops',
         Count: 50
      \},
      \{
         Range: 'nikon',
         Count: 46
      \},
      \{
         Range: 'phillips',
         Count: 44
      \},
      \{
         Range: 'sony',
         Count: 35
      \}
   ],
   Cost_Range: [
      \{
         Range: '[NULL TO Dx200.0]',
         Count: 115
      \},
      \{
         Range: '[Dx200.0 TO Dx400.0]',
         Count: 102
      \}
   ],
   Megapixels_Range: [
      \{
         Range: '[NULL TO Dx3.0]',
         Count: 42
      \},
      \{
         Range: '[Dx3.0 TO Dx7.0]',
         Count: 79
      \},
      \{
         Range: '[Dx7.0 TO Dx10.0]',
         Count: 82
      \},
      \{
         Range: '[Dx10.0 TO NULL]',
         Count: 14
      \}
   ]
\}
`}
</CodeBlock>
</TabItem>

### Storing facets

Alternatively, if you do not have to change your facets dynamically, you can store your facets as `FacetSetup` document and pass the document Id instead of the list each time:

<TabItem value="step_4_0" label="step_4_0">
<CodeBlock language="csharp">
{`session.Store(new FacetSetup \{ Id = "facets/CameraFacets", Facets = facets, RangeFacets = rangeFacets \});
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`FacetResults facetResults = session
	.Query<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
	.Where(x => x.Cost >= 100 && x.Cost <= 300)
	.ToFacets("facets/CameraFacets");
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`FacetResults facetResults = session
	.Advanced
	.DocumentQuery<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
	.WhereBetweenOrEqual(x => x.Cost, 100, 300)
	.ToFacets("facets/CameraFacets");
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="csharp">
{`FacetResults facetResults = store
	.DatabaseCommands
	.GetFacets(
		"Cameras/ByManufacturerModelCostDateOfListingAndMegapixels",
		new IndexQuery
		{
			Query = "Cost_Range:[Dx100 TO Dx300]"
		},
		"facets/CameraFacets");
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`List<Facet> facets = new List<Facet>
{
	new Facet
	{
		Name = "Manufacturer"
	},
	new Facet<Camera>
	{
		Name = x => x.Cost,
		Ranges =
		{
			x => x.Cost < 200m,
			x => x.Cost > 200m && x.Cost < 400m,
			x => x.Cost > 400m && x.Cost < 600m,
			x => x.Cost > 600m && x.Cost < 800m,
			x => x.Cost > 800m
		}
	},
	new Facet<Camera>
	{
		Name = x => x.Megapixels,
		Ranges =
		{
			x => x.Megapixels < 3.0,
			x => x.Megapixels > 3.0 && x.Megapixels < 7.0,
			x => x.Megapixels > 7.0 && x.Megapixels < 10.0,
			x => x.Megapixels > 10.0
		}
	}
};
`}
</CodeBlock>
</TabItem>
</Tabs>

### Stale results

The faceted search does not take into account a staleness of an index. You can't wait for non stale results by customizing your query with one of `WaitForNonStaleResultsXXX` method.


</LanguageContent>
<LanguageContent language="java">


When displaying a large amount of data, often paging is used to make viewing the data manageable. However it's also useful to give some context of the entire data-set and a easy way to drill-down into particular categories. The common approach to doing this is "faceted search", as shown in the image below. __Note__ how the count of each category within the current search is across the top.

![Facets](./assets/CNET_faceted_search_2.jpg)

&lt;br /&gt;
To achieve this in RavenDB, let's say you have a document like this:

<TabItem value="camera" label="camera">
<CodeBlock language="java">
{`public class Camera \{
  private int id;

  private Date dateOfListing;
  private String manufacturer;
  private String model;
  private Double cost;

  private int zoom;
  private double megapixels;
  private boolean imageStabilizer;
  private List<String> advancedFeatures;

  public int getId() \{
    return id;
  \}
  public void setId(int id) \{
    this.id = id;
  \}
  public Date getDateOfListing() \{
    return dateOfListing;
  \}
  public void setDateOfListing(Date dateOfListing) \{
    this.dateOfListing = dateOfListing;
  \}
  public String getManufacturer() \{
    return manufacturer;
  \}
  public void setManufacturer(String manufacturer) \{
    this.manufacturer = manufacturer;
  \}
  public String getModel() \{
    return model;
  \}
  public void setModel(String model) \{
    this.model = model;
  \}
  public Double getCost() \{
    return cost;
  \}
  public void setCost(Double cost) \{
    this.cost = cost;
  \}
  public int getZoom() \{
    return zoom;
  \}
  public void setZoom(int zoom) \{
    this.zoom = zoom;
  \}
  public double getMegapixels() \{
    return megapixels;
  \}
  public void setMegapixels(double megapixels) \{
    this.megapixels = megapixels;
  \}
  public boolean isImageStabilizer() \{
    return imageStabilizer;
  \}
  public void setImageStabilizer(boolean imageStabilizer) \{
    this.imageStabilizer = imageStabilizer;
  \}
  public List<String> getAdvancedFeatures() \{
    return advancedFeatures;
  \}
  public void setAdvancedFeatures(List<String> advancedFeatures) \{
    this.advancedFeatures = advancedFeatures;
  \}
\}
`}
</CodeBlock>
</TabItem>

## Step 1

Create an index to work against, this can be setup like so:

<TabItem value="step_2" label="step_2">
<CodeBlock language="java">
{`public class Cameras_ByManufacturerModelCostDateOfListingAndMegapixels extends AbstractIndexCreationTask \{
    public Cameras_ByManufacturerModelCostDateOfListingAndMegapixels() \{
        map = "from camera in docs.Cameras " +
            "select new \{" +
            "   camera.manufacturer," +
            "   camera.model," +
            "   camera.cost," +
            "   camera.dateOfListing," +
            "   camera.megapixels" +
            "\} ";
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 2

Next you need to setup your facet definitions:

<TabItem value="step_1" label="step_1">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>

This tells RavenDB that you would like to get the following facets:

* For the **Manufacturer** field look at the documents and return a count for each unique Term found
* For the **Cost** field, return the count of the following ranges:
 * Cost &lt;= 200.0
 * 200.0 &lt;= Cost &lt;= 400.0
 * 400.0 &lt;= Cost &lt;= 600.0
 * 600.0 &lt;= Cost &lt;= 800.0
 * Cost &gt;= 800.0
* For the **Megapixels** field, return the count of the following ranges:
 * Megapixels &lt;= 3.0
 * 3.0 &lt;= Megapixels &lt;= 7.0
 * 7.0 &lt;= Megapixels &lt;= 10.0
 * Megapixels &gt;= 10.0

## Step 3

Finally you can write the following code and you get back the data below:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QCamera c = QCamera.camera;
FacetResults facetResults = session
  .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
  .where(c.cost.goe(100).and(c.cost.loe(300)))
  .toFacets(facets);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`QCamera c = QCamera.camera;
FacetResults facetResults = session
  .advanced()
  .documentQuery(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
  .whereBetweenOrEqual(c.cost, 100.0, 300.0)
  .toFacets(facets);
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`FacetResults facetResults = store
  .getDatabaseCommands()
  .getFacets("Cameras/ByManufacturerModelCostDateOfListingAndMegapixels",
    new IndexQuery("Cost_Range:[Dx100 TO Dx300]"),
    facets);
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`QCamera c = QCamera.camera;

List<Facet> facets = new ArrayList<>();
Facet f1 = new Facet();
f1.setName(c.manufacturer);
facets.add(f1);

Facet f2 = new Facet();
f2.setName(c.cost);
f2.setRanges(c.cost.lt(200),
    c.cost.gt(200).and(c.cost.lt(400)),
    c.cost.gt(400).and(c.cost.lt(600)),
    c.cost.gt(600).and(c.cost.lt(800)),
    c.cost.gt(800));
facets.add(f2);

Facet f3 = new Facet();
f3.setName(c.megapixels);
f3.setRanges(c.megapixels.lt(3),
    c.megapixels.gt(3).and(c.megapixels.lt(7)),
    c.megapixels.gt(7).and(c.megapixels.lt(10)),
    c.megapixels.gt(10));
facets.add(f3);
`}
</CodeBlock>
</TabItem>
</Tabs>

The data below represents the sample faceted data that satisfies above query:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{
   Manufacturer: [
      \{
         Range: 'canon',
         Count: 42
      \},
      \{
         Range: 'jessops',
         Count: 50
      \},
      \{
         Range: 'nikon',
         Count: 46
      \},
      \{
         Range: 'phillips',
         Count: 44
      \},
      \{
         Range: 'sony',
         Count: 35
      \}
   ],
   Cost_Range: [
      \{
         Range: '[NULL TO Dx200.0]',
         Count: 115
      \},
      \{
         Range: '[Dx200.0 TO Dx400.0]',
         Count: 102
      \}
   ],
   Megapixels_Range: [
      \{
         Range: '[NULL TO Dx3.0]',
         Count: 42
      \},
      \{
         Range: '[Dx3.0 TO Dx7.0]',
         Count: 79
      \},
      \{
         Range: '[Dx7.0 TO Dx10.0]',
         Count: 82
      \},
      \{
         Range: '[Dx10.0 TO NULL]',
         Count: 14
      \}
   ]
\}
`}
</CodeBlock>
</TabItem>

### Storing facets

Alternatively, if you do not have to change your facets dynamically, you can store your facets as `FacetSetup` document and pass the document Id instead of the list each time:

<TabItem value="step_4_0" label="step_4_0">
<CodeBlock language="java">
{`FacetSetup facetSetup = new FacetSetup();
facetSetup.setFacets(facets);
facetSetup.setRangeFacets(rangeFacets);

session.store(facetSetup, "facets/CameraFacets");
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QCamera c = QCamera.camera;
FacetResults facetResults = session
  .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
  .where(c.cost.goe(100).and(c.cost.loe(300)))
  .toFacets("facets/CameraFacets");
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="java">
{`QCamera c = QCamera.camera;
FacetResults facetResults = session
  .advanced()
  .documentQuery(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
  .whereBetweenOrEqual(c.cost, 100.0, 300.0)
  .toFacets("facets/CameraFacets");
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="java">
{`FacetResults facetResults = store
  .getDatabaseCommands()
  .getFacets("Cameras/ByManufacturerModelCostDateOfListingAndMegapixels",
    new IndexQuery("Cost_Range:[Dx100 TO Dx300]"),
    "facets/CameraFacets");
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`QCamera c = QCamera.camera;

List<Facet> facets = new ArrayList<>();
Facet f1 = new Facet();
f1.setName(c.manufacturer);
facets.add(f1);

Facet f2 = new Facet();
f2.setName(c.cost);
f2.setRanges(c.cost.lt(200),
    c.cost.gt(200).and(c.cost.lt(400)),
    c.cost.gt(400).and(c.cost.lt(600)),
    c.cost.gt(600).and(c.cost.lt(800)),
    c.cost.gt(800));
facets.add(f2);

Facet f3 = new Facet();
f3.setName(c.megapixels);
f3.setRanges(c.megapixels.lt(3),
    c.megapixels.gt(3).and(c.megapixels.lt(7)),
    c.megapixels.gt(7).and(c.megapixels.lt(10)),
    c.megapixels.gt(10));
facets.add(f3);
`}
</CodeBlock>
</TabItem>
</Tabs>

### Stale results

The faceted search does not take into account a staleness of an index. You can't wait for non stale results by customizing your query with one of `waitForNonStaleResultsXXX` method.


</LanguageContent>

<!---
- [Querying : Dynamic aggregation](../../indexes/querying/dynamic-aggregation)
- [Client API : Session : How to perform a faceted search?](../../client-api/session/querying/how-to-perform-a-faceted-search)

-->