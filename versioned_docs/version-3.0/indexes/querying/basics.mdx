---
title: "Basics"
hide_table_of_contents: true
sidebar_label: Basics
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];


# Basics
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Following article will introduce you into the querying. You probably read quite a few times by now, that indexes are used by RavenDB to satisfy queries, but what does that mean?

## Query-flow

Each query in RavenDB must be done against index and the query-flow is as follows:

1. First step, when query is issued, is to locate appropriate index. If our query specifies that index, the task is simple - use this index. Otherwise the query analysis is taking place and auto-index is created (if it does not exist already).
2. When we have our index, we scan it for records that match query predicate.
3. From each record server extracts appropriate fields. It always extracts `__document_id` field ([stored](../../indexes/storing-data-in-index.mdx) by default). Additionally when [projection](../../indexes/querying/projections.mdx) is taking place, then fields defined in projection are extracted from index (if stored).
4. Next, if query is not a projection query, then we load a document from storage. Otherwise, if we stored all requested fields in index, then we use them and continue, if not, then document is loaded from storage and missing fields are fetched from it.
5. In next step, our potential query results must pass [read triggers](../../server/plugins/triggers.mdx#read-triggers). 
6. _(Optional)_ If query indicates that [transformer](../../transformers/what-are-transformers.mdx) should be used, then all results that were not filtered out are processed by its projection function.
7. Return results.

## Querying using LINQ

RavenDB Client supports querying using LINQ, this functionality can be accessed using session `Query` method and is the most common and basic method for querying the database.

### Example I

Let's execute our first query and return all employees from Northwind database. To do that, we need to have a [document store](../../client-api/what-is-a-document-store.mdx) and [opened session](../../client-api/session/opening-a-session.mdx) and specify a [collection](../../client-api/faq/what-is-a-collection.mdx) type that we want to query (in our case `Employees`) by passing `Employee` as a generic parameter to `Query` method:

<TabItem value="basics_0_0" label="basics_0_0">
<CodeBlock language="csharp">
{`// load all entities from 'Employees' collection
IList<Employee> results = session
    .Query<Employee>()
    .ToList(); // send query
`}
</CodeBlock>
</TabItem>

Notice that by specifying `Employee` as a type parameter, we are also defining a result type.

<Admonition type="note" title="">
By default, if page size is not specified, the value will be set to `128`.
</Admonition>

### Example II - filtering

To filter out results use suitable LINQ method e.g. `Where`:

<TabItem value="basics_0_1" label="basics_0_1">
<CodeBlock language="csharp">
{`// load all entities from 'Employees' collection
// where 'FirstName' is 'Robert'
IList<Employee> results = session
    .Query<Employee>()
    .Where(x => x.FirstName == "Robert")
    .ToList(); // send query
`}
</CodeBlock>
</TabItem>

You can read more about filtering [here](../../indexes/querying/filtering.mdx).

### Example III - paging

Paging is very simple, methods `Take` and `Skip` can be used:

<TabItem value="basics_0_2" label="basics_0_2">
<CodeBlock language="csharp">
{`// load up to 10 entities from 'Products' collection
// where there are more than 10 units in stock
// skip first 5 results
IList<Product> results = session
    .Query<Product>()
    .Where(x => x.UnitsInStock > 10)
    .Skip(5)
    .Take(10)
    .ToList(); // send query
`}
</CodeBlock>
</TabItem>

You can read more about paging [here](../../indexes/querying/paging.mdx).

### Example IV - querying specified index

In above examples we **did not** specify an index that we want to query, in that case RavenDB will try to locate an appropriate index or create a new one. You can read more about creating indexes [here](../../indexes/creating-and-deploying.mdx).

In order to specify an index, we need to pass it as a second generic parameter to `Query` method or pass index name as a parameter.

<TabItem value="basics_0_3" label="basics_0_3">
<CodeBlock language="csharp">
{`// load all entities from 'Employees' collection
// where 'FirstName' is 'Robert'
// using 'Employees/ByFirstName' index
IList<Employee> results = session
    .Query<Employee, Employees_ByFirstName>()
    .Where(x => x.FirstName == "Robert")
    .ToList(); // send query
`}
</CodeBlock>
</TabItem>

<TabItem value="basics_0_4" label="basics_0_4">
<CodeBlock language="csharp">
{`// load all entities from 'Employees' collection
// where 'FirstName' is 'Robert'
// using 'Employees/ByFirstName' index
IList<Employee> results = session
    .Query<Employee>("Employees/ByFirstName")
    .Where(x => x.FirstName == "Robert")
    .ToList(); // send query
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="Remember" id="remember" href="#remember">
If you are filtering by fields that are not present in index, exception will be thrown.
</Admonition>

## Low-level query access

To take a full control over your queries, we introduced a `DocumentQuery` method that is available in advanced session operations. Basically it is a low-level access to the querying mechanism that user can take advantage of to shape queries according to needs.

### Example

<TabItem value="basics_1_0" label="basics_1_0">
<CodeBlock language="csharp">
{`// load all entities from 'Employees' collection
IList<Employee> results = await asyncSession
    .Query<Employee>()
    .ToListAsync(); // send query
`}
</CodeBlock>
</TabItem>

### Remarks

<Admonition type="info" title="">
You can check the API reference for the `DocumentQuery` [here](../../client-api/session/querying/lucene/how-to-use-lucene-in-queries.mdx).
</Admonition>

<Admonition type="info" title="">
There are some differences between `Query` and `DocumentQuery` and they are described in [this article](../../indexes/querying/query-vs-document-query.mdx).
</Admonition>


</LanguageContent>
<LanguageContent language="java">


Following article will introduce you into the querying. You probably read quite a few times by now, that indexes are used by RavenDB to satisfy queries, but what does that mean?

## Query-flow

Each query in RavenDB must be done against index and the query-flow is as follows:

1. First step, when query is issued, is to locate appropriate index. If our query specifies that index, the task is simple - use this index. Otherwise the query analysis is taking place and auto-index is created (if it does not exist already).
2. When we have our index, we scan it for records that match query predicate.
3. From each record server extracts appropriate fields. It always extracts `__document_id` field ([stored](../../indexes/storing-data-in-index.mdx) by default). Additionally when [projection](../../indexes/querying/projections.mdx) is taking place, then fields defined in projection are extracted from index (if stored).
4. Next, if query is not a projection query, then we load a document from storage. Otherwise, if we stored all requested fields in index, then we use them and continue, if not, then document is loaded from storage and missing fields are fetched from it.
5. In next step, our potential query results must pass [read triggers](../../server/plugins/triggers.mdx#read-triggers). 
6. _(Optional)_ If query indicates that [transformer](../../transformers/what-are-transformers.mdx) should be used, then all results that were not filtered out are processed by its projection function.
7. Return results.

## Querying using fluent syntax

RavenDB Client supports querying using fluent syntax (based on QueryDSL), this functionality can be accessed using session `query` method and is the most common and basic method for querying the database.

### Example I

Let's execute our first query and return all employees from Northwind database. To do that, we need to have a [document store](../../client-api/what-is-a-document-store.mdx) and [opened session](../../client-api/session/opening-a-session.mdx) and specify a [collection](../../client-api/faq/what-is-a-collection.mdx) type that we want to query (in our case `Employees`) by passing `Employee` class as a parameter to `query` method:

<TabItem value="basics_0_0" label="basics_0_0">
<CodeBlock language="java">
{`// load all entities from 'Employees' collection
List<Employee> results = session
    .query(Employee.class)
    .toList(); // send query
`}
</CodeBlock>
</TabItem>

Notice that by specifying `Employee` as a parameter, we are also defining a result type.

<Admonition type="note" title="">
By default, if page size is not specified, the value will be set to `128`.
</Admonition>

### Example II - filtering

To filter out results use suitable method e.g. `where`:

<TabItem value="basics_0_1" label="basics_0_1">
<CodeBlock language="java">
{`// load all entities from 'Employees' collection
// where 'firstName' is 'Robert'
List<Employee> results = session
    .query(Employee.class)
    .whereEquals("FirstName", "Robert")
    .toList(); // send query
`}
</CodeBlock>
</TabItem>

You can read more about filtering [here](../../indexes/querying/filtering.mdx).

### Example III - paging

Paging is very simple, methods `take` and `skip` can be used:

<TabItem value="basics_0_2" label="basics_0_2">
<CodeBlock language="java">
{`// load up to 10 entities from 'Products' collection
// where there are more than 10 units in stock
// skip first 5 results
List<Product> results = session
    .query(Product.class)
    .whereGreaterThan("UnitsInStock", 10)
    .skip(5)
    .take(10)
    .toList();//send query
`}
</CodeBlock>
</TabItem>

You can read more about paging [here](../../indexes/querying/paging.mdx).

### Example IV - querying specified index

In above examples we **did not** specify an index that we want to query, in that case RavenDB will try to locate an appropriate index or create a new one. You can read more about creating indexes [here](../../indexes/creating-and-deploying.mdx).

In order to specify a index, we need to pass it as a second parameter to `query` method or pass index name as a parameter.

<TabItem value="basics_0_3" label="basics_0_3">
<CodeBlock language="java">
{`// load all entities from 'Employees' collection
// where 'firstName' is 'Robert'
// using 'Employees/ByFirstName' index
session
    .query(Employee.class, Employees_ByFirstName.class)
    .whereEquals("FirstName", "Robert")
    .toList(); // send query
`}
</CodeBlock>
</TabItem>

<TabItem value="basics_0_4" label="basics_0_4">
<CodeBlock language="java">
{`// load all entities from 'Employees' collection
// where 'firstName' is 'Robert'
// using 'Employees/ByFirstName' index
session
    .query(Employee.class, Query.index("Employees/ByFirstName"))
    .whereEquals("FirstName", "Robert")
    .toList(); // send query
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="Remember" id="remember" href="#remember">
If you are filtering by fields that are not present in index, exception will be thrown.
</Admonition>

## Low-level query access

To take a full control over your queries, we introduced a `documentQuery` method that is available in advanced session operations. Basically it is a low-level access to the querying mechanism that user can take advantage of to shape queries according to needs.

### Example

<TabItem value="basics_1_0" label="basics_1_0">
<CodeBlock language="java">
{`// load up to 128 entities from 'Employees' collection
// where 'FirstName' is 'Robert'
// using 'Employees/ByFirstName' index
QEmployee e = QEmployee.employee;
List<Employee> results = session
  .advanced()
  .documentQuery(Employee.class, Employees_ByFirstName.class)
  .whereEquals(e.firstName, "Robert")
  .toList(); // send query
`}
</CodeBlock>
</TabItem>

### Remarks

<Admonition type="info" title="">
You can check the API reference for the `documentQuery` [here](../../client-api/session/querying/lucene/how-to-use-lucene-in-queries.mdx).
</Admonition>

<Admonition type="info" title="">
There are some differences between `query` and `documentQuery` and they are described in [this article](../../indexes/querying/query-vs-document-query.mdx).
</Admonition>


</LanguageContent>

<!---
- [Indexing : Basics](../../indexes/indexing-basics)
- [Querying : Filtering](../../indexes/querying/filtering)
- [Querying : Paging](../../indexes/querying/paging)
- [Querying : Handling document relationships](../../indexes/querying/handling-document-relationships)
- [Client API : What is a document store?](../../client-api/what-is-a-document-store)
- [Client API : Opening a session](../../client-api/session/opening-a-session)

-->