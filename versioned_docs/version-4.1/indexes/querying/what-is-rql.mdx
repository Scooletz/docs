---
title: "Querying: RQL - Raven Query Language"
hide_table_of_contents: true
sidebar_label: What is RQL
sidebar_position: 0
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Querying: RQL - Raven Query Language

## Overview

Queries in RavenDB use a SQL-like language called "RavenDB Query Language," henceforth known as RQL.  
It is designed to expose externally the RavenDB query pipeline in a way that is easy to understand, easy to use, and not overwhelming to the user.

### Query Optimizer
When a query hits a RavenDB instance, the very first thing that happens is that it will be analyzed by the query optimizer. The role of the query optimizer is to determine what indexes should be used by this particular query.   
In RavenDB, there are two types of queries.  
We may have a *dynamic query*, such as ```from Orders where ...```, which gives the query optimizer full freedom with regards to which index that query will use.  
Alternatively, a query can specify a specific index to be used, such as ```from index 'Orders/ByCompany' where ...```, which instructs RavenDB to use the ```Orders/ByCompany``` index.

<Admonition type="note" title="Queries are always going to use an index" id="queries-are-always-going-to-use-an-index" href="#queries-are-always-going-to-use-an-index">
In other databases, the query optimizer may fail to find a suitable index and fall back into querying using a full scan, RavenDB doesn't include support for full scans, and the query optimizer will _create_ a new index for the query if it cannot find an relevant index.  
You can read more about indexes [here](../indexing-basics.mdx).   
Queries in RavenDB will always use an index. RavenDB queries always use an index and can return results with the same speed regardless of the size of the data.  
</Admonition>

<Admonition type="note" title="Indexing and queries in RavenDB " id="indexing-and-queries-in-ravendb" href="#indexing-and-queries-in-ravendb">
Indexing in RavenDB is a background operation, which means the new query will be waiting for the index to complete indexing (or timeout). But at the same time, queries that can be answered using the existing indexes will proceed normally using these indexes. When the new index has caught up, RavenDB will clean up all the old indexes that are now superseded by the new one.
</Admonition>

## Keywords and methods

The following keywords and methods are available in RQL:

- DECLARE
- [FROM](../../indexes/querying/what-is-rql.mdx#from)
  - INDEX
- [GROUP BY](../../indexes/querying/what-is-rql.mdx#group-by)
  - [array()](../../client-api/session/querying/how-to-perform-group-by-query.mdx#by-array-content)
- [WHERE](../../indexes/querying/what-is-rql.mdx#where)
  - id()
  - [search()](../../indexes/querying/searching.mdx)
  - cmpxchg()
  - boost()
  - [regex()](../../client-api/session/querying/how-to-use-regex.mdx)
  - startsWith()
  - endsWith()
  - [lucene()](../../client-api/session/querying/document-query/how-to-use-lucene.mdx)
  - [exists()](../../client-api/session/querying/how-to-filter-by-field.mdx)
  - exact()
  - [intersect()](../../indexes/querying/intersection.mdx)
  - [spatial.within()](../../indexes/querying/spatial.mdx)
  - [spatial.contains()](../../indexes/querying/spatial.mdx)
  - [spatial.disjoint()](../../indexes/querying/spatial.mdx)
  - [spatial.intersects()](../../indexes/querying/spatial.mdx)
  - [moreLikeThis()](../../client-api/session/querying/how-to-use-morelikethis.mdx)
- [ORDER BY](../../indexes/querying/what-is-rql.mdx#order-by)
  - [ASC | ASCENDING](../../indexes/querying/sorting.mdx#basics)
  - [DESC | DESCEDING](../../indexes/querying/sorting.mdx#basics)
  - [AS](../../indexes/querying/sorting.mdx#basics)
    - [string](../../indexes/querying/sorting.mdx#basics)
    - [long](../../indexes/querying/sorting.mdx#basics)
    - [double](../../indexes/querying/sorting.mdx#basics)
    - [alphaNumeric](../../indexes/querying/sorting.mdx#alphanumeric-ordering)
  - [random()](../../indexes/querying/sorting.mdx#random-ordering)
  - [score()](../../indexes/querying/sorting.mdx#ordering-by-score)
  - [spatial.distance()](../../client-api/session/querying/how-to-query-a-spatial-index.mdx#orderbydistance)
- [LOAD](../../indexes/querying/what-is-rql.mdx#load)
- [SELECT](../../indexes/querying/what-is-rql.mdx#select)
  - DISTINCT
  - key()
  - sum()
  - count()
  - [facet()](../../indexes/querying/faceted-search.mdx)
- [UPDATE](../../indexes/querying/what-is-rql.mdx#update)
- [INCLUDE](../../indexes/querying/what-is-rql.mdx#include)

With the following operators:

- &gt;=
- &lt;=
- &lt;&gt; or !=
- &lt;
- &gt;
- = or ==
- BETWEEN
- IN
- ALL IN
- OR
- AND
- NOT
- (
- )

And the following values:

- true
- false
- null
- string e.g. 'John' or "John"
- number (long and double) e.g. 17
- parameter e.g. $param1



---

## DECLARE

The keyword `declare` gives you the ability to create a JS function that can be reused in `select` (when projection is done). You can read more about it [here](../../client-api/session/querying/how-to-project-query-results.mdx#example-iv---projection-with-).



---

## FROM

The keyword `from` is used to determine the source data that should be used when a query is executed. You have two options:

1. `from <collection>`

This option is used to perform:

- Collection queries that are doing basic ID filtering only, e.g. `from Companies where id() == 'companies/1-A'` where there is no need to query an index, we can return the document from the storage directly
- Dynamic queries that are being executed against [Auto Index](../../indexes/creating-and-deploying.mdx#auto-indexes)

<Admonition type="info" title="All Documents" id="all-documents" href="#all-documents">

In order to query all documents, the `@all_docs` keyword can be used:

- `from @all_docs where FirstName = 'Laura'`
- `from @all_docs where id() = 'companies/1-A'`.

</Admonition>

2. `from INDEX <index-name>`

This option is used to perform RQL operations against a given [static index].



## GROUP BY

The keyword `group by` is used to create an aggregation query. Please refer to the article about [dynamic group by queries](../../client-api/session/querying/how-to-perform-group-by-query.mdx) to find out more.



---

## WHERE

The keyword `where` is used to filter-out the documents from final results.

### Operator: &gt;= &lt;= &lt;&gt; != &lt; &gt; = ==

The operators above are considered basic and self-explanatory. They work on all value types including 'numbers' and 'strings'.

The simplest example would be to return results with the field value **equal** to a given input. If you want to return a document from the `@companies` collection (more about collection can be read [here](../../client-api/faq/what-is-a-collection.mdx)), you need to execute the following query:

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Companies
where Name = 'The Big Cheese'
`}
</CodeBlock>
</TabItem>

Filtering on **nested properties** is also supported, so in order to return all companies from 'Albuquerque' we need to execute following query:

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Companies
where Address.City = 'Albuquerque'
`}
</CodeBlock>
</TabItem>

### Operator: BETWEEN

The operator `between` returns results inclusively, and the type of border values used must match. It works on both 'numbers' and 'strings' and can be substituted with the `>=` and `<=` operators (see the example below).

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Products 
where PricePerUnit between 10.5 and 13.0
`}
</CodeBlock>
</TabItem>

or

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Products 
where PricePerUnit >= 10.5 and PricePerUnit <= 13.0
`}
</CodeBlock>
</TabItem>

### Operator: IN

The operator `in` is validating if a given field contains passed values. It will return results if a given field matches **any** of the passed values.

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Companies 
where Name IN ('The Big Cheese', 'Unknown company name')
`}
</CodeBlock>
</TabItem>

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Orders 
where Lines[].ProductName in ('Chang', 'Spegesild', 'Unknown product name') 
`}
</CodeBlock>
</TabItem>

### Operator: ALL IN

This operator checks if **all** passes values are matching a given field. Due to its mechanics, it is only useful when used on array fields.

The following query will yield no results in contrast to an 'in' operator.

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Orders 
where Lines[].ProductName all in ('Chang', 'Spegesild', 'Unknown product name') 
`}
</CodeBlock>
</TabItem>

but removing the 'Unknown product name' will give you orders that only contains products with both 'Chang' and 'Spegesild' names

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Orders 
where Lines[].ProductName all in ('Chang', 'Spegesild') 
`}
</CodeBlock>
</TabItem>

### Binary operators: AND OR NOT

Binary operators can be used to build more complex statements. The `NOT` operator can only be used with one of the other binary operators creating `OR NOT` or `AND NOT` ones.

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Companies
where Name = 'The Big Cheese' OR Name = 'Richter Supermarkt'
`}
</CodeBlock>
</TabItem>

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Orders
where Freight > 500 AND ShippedAt > '1998-01-01'
`}
</CodeBlock>
</TabItem>

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`from Orders
where Freight > 500 AND ShippedAt > '1998-01-01' AND NOT Freight = 830.75
`}
</CodeBlock>
</TabItem>

### Subclauses: ( )

Subclauses can be used along with binary operators to build even more complex logical statements. They are self-explanatory so no example will be given.



---

## ORDER BY

To perform sorting, the `order by` must be used. If you are interested in this subject, please read our dedicated sorting article [here](../../indexes/querying/sorting.mdx).



---

## LOAD

When there is a need to use data from an external document in projection, `load` can be used. Please refer to the following [projection article](../../indexes/querying/projections.mdx#example-vii---projection-using-a-loaded-document) to find out more about it.



---

## SELECT

Projections can be performed by using `select`. Please read our dedicated projection article [here](../../indexes/querying/projections.mdx).



---

## UPDATE

To patch documents on the server-side, use `update` with the desired JS script that will be applied to any documents matching the query criteria. For more information, please refer to our [patching article](../../client-api/operations/patching/set-based.mdx).



---

## INCLUDE

The keyword `include` has been introduced to support:

- [including additional documents](../../client-api/how-to/handle-document-relationships.mdx#includes) or counters to the query response
- [highlighting](../../client-api/session/querying/how-to-use-highlighting.mdx) results
- query timings
- explanations



