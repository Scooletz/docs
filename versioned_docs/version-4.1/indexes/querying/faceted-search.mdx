---
title: "Querying: Faceted (Aggregation) Search"
hide_table_of_contents: true
sidebar_label: Faceted Search
sidebar_position: 12
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Querying: Faceted (Aggregation) Search
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


When displaying a large amount of data, paging is often used to make viewing the data manageable. It's also useful to give some context of the entire data-set and a easy way to drill-down into particular categories. The common approach to doing this is a "faceted search", as shown in the image below. __Note__ how the count of each category within the current search is across the top.

![Facets](./assets/CNET_faceted_search_2.jpg)

&lt;br /&gt;
Let's start with defining a document like this:

<TabItem value="camera" label="camera">
<CodeBlock language="csharp">
{`public class Camera
\{
	public DateTime DateOfListing \{ get; set; \}

	public string Model \{ get; set; \}

	public decimal Cost \{ get; set; \}

	public int Zoom \{ get; set; \}

	public double Megapixels \{ get; set; \}

	public bool ImageStabilizer \{ get; set; \}

	public string Manufacturer \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

## Step 1

Create an index to work against. 

<TabItem value="step_2" label="step_2">
<CodeBlock language="csharp">
{`public class Cameras_ByManufacturerModelCostDateOfListingAndMegapixels : AbstractIndexCreationTask<Camera>
\{
    public Cameras_ByManufacturerModelCostDateOfListingAndMegapixels()
    \{
        Map = cameras => from camera in cameras
                         select new
                         \{
                             camera.Manufacturer,
                             camera.Model,
                             camera.Cost,
                             camera.DateOfListing,
                             camera.Megapixels
                         \};
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 2

Setup your facet definitions:

<TabItem value="step_1" label="step_1">
<CodeBlock language="csharp">
{`List<FacetBase> facets = new List<FacetBase>
\{
    new Facet
    \{
        FieldName = "Manufacturer"
    \},
    new RangeFacet<Camera>
    \{
        Ranges =
        \{
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m
        \}
    \},
    new RangeFacet<Camera>
    \{
        Ranges =
        \{
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0
        \}
    \}
\};
`}
</CodeBlock>
</TabItem>

This tells RavenDB that you would like to get the following facets:

* For the **Manufacturer** field, look at the documents and return a count for each unique Term found.

* For the **Cost** field, return the count of the following ranges:

 * Cost &lt; 200.0
 * 200.0 &lt;= Cost &lt; 400.0
 * 400.0 &lt;= Cost &lt; 600.0
 * 600.0 &lt;= Cost &lt; 800.0
 * Cost &gt;= 800.0
* For the **Megapixels** field, return the count of the following ranges:
 * Megapixels &lt;= 3.0
 * 3.0 &lt;= Megapixels &lt; 7.0
 * 7.0 &lt;= Megapixels &lt; 10.0
 * Megapixels &gt;= 10.0

## Step 3

You can write the following code to get back the data below:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facetResults = session
    .Query<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
    .Where(x => x.Cost >= 100 && x.Cost <= 300)
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facetResults = session
    .Advanced
    .DocumentQuery<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
    .WhereBetween(x => x.Cost, 100, 300)
    .AggregateBy(facets)
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="csharp">
{`List<FacetBase> facets = new List<FacetBase>
{
    new Facet
    {
        FieldName = "Manufacturer"
    },
    new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m
        }
    },
    new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0
        }
    }
};
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where Cost between 100 and 300
select facet(Manufacturer), facet(Cost <= 200, Cost between 200 and 400, Cost between 400 and 600, Cost between 600 and 800, Cost >= 800), facet(Megapixels <= 3, Megapixels between 3 and 7, Megapixels between 7 and 10, Megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

This data represents the sample faceted data that satisfies the above query:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`[
    \{
        "Name": "Manufacturer",
        "Values": [
            \{
                "Count": 1,
                "Range": "canon"
            \},
            \{
                "Count": 2,
                "Range": "jessops"
            \},
            \{
                "Count": 1,
                "Range": "nikon"
            \},
            \{
                "Count": 1,
                "Range": "phillips"
            \},
            \{
                "Count": 3,
                "Range": "sony"
            \}
        ]
    \},
    \{
        "Name": "Cost",
        "Values": [
            \{
                "Count": 6,
                "Range": "Cost <= 200"
            \},
            \{
                "Count": 2,
                "Range": "Cost between 200 and 400"
            \},
            \{
                "Count": 0,
                "Range": "Cost between 400 and 600"
            \},
            \{
                "Count": 0,
                "Range": "Cost between 600 and 800"
            \},
            \{
                "Count": 0,
                "Range": "Cost >= 800"
            \}
        ]
    \},
    \{
        "Name": "Megapixels",
        "Values": [
            \{
                "Count": 0,
                "Range": "Megapixels <= 3"
            \},
            \{
                "Count": 6,
                "Range": "Megapixels between 3 and 7"
            \},
            \{
                "Count": 1,
                "Range": "Megapixels between 7 and 10"
            \},
            \{
                "Count": 1,
                "Range": "Megapixels >= 10"
            \}
        ]
    \}
]
`}
</CodeBlock>
</TabItem>

### Storing Facets

If you do not have to change your facets dynamically, you can store your facets as a `FacetSetup` document and pass the document ID instead of the list each time:

<TabItem value="step_4_0" label="step_4_0">
<CodeBlock language="csharp">
{`session.Store(new FacetSetup \{ Id = "facets/CameraFacets", Facets = facets, RangeFacets = rangeFacets \});
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facetResults = session
    .Query<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
    .Where(x => x.Cost >= 100 && x.Cost <= 300)
    .AggregateUsing("facets/CameraFacets")
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facetResults = session
    .Advanced
    .DocumentQuery<Camera, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels>()
    .WhereBetween(x => x.Cost, 100, 300)
    .AggregateUsing("facets/CameraFacets")
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="csharp">
{`List<FacetBase> facets = new List<FacetBase>
{
    new Facet
    {
        FieldName = "Manufacturer"
    },
    new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m
        }
    },
    new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0
        }
    }
};
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where Cost between 100 and 300
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

### Stale Results

The faceted search does not take into account a staleness of an index. You can wait for non stale results by customizing your query with the `WaitForNonStaleResults` method.

### Fluent API

As an alternative for creating a list of facets and passing it to the `AggregateBy` method, RavenDB also exposes a dynamic API where you can create your facets using a builder. You can read more about those methods in our dedicated Client API article [here](../../client-api/session/querying/how-to-perform-a-faceted-search.mdx).


</LanguageContent>
<LanguageContent language="java">


When displaying a large amount of data, paging is often used to make viewing the data manageable. It's also useful to give some context of the entire data-set and a easy way to drill-down into particular categories. The common approach to doing this is a "faceted search", as shown in the image below. __Note__ how the count of each category within the current search is across the top.

![Facets](./assets/CNET_faceted_search_2.jpg)

&lt;br /&gt;
Let's start with defining a document like this:

<TabItem value="camera" label="camera">
<CodeBlock language="java">
{`public class Camera \{
    private Date dateOfListing;
    private String model;
    private double cost;
    private int zoom;
    private double megapixels;
    private boolean imageStabilizer;
    private String manufacturer;

    public Date getDateOfListing() \{
        return dateOfListing;
    \}

    public void setDateOfListing(Date dateOfListing) \{
        this.dateOfListing = dateOfListing;
    \}

    public String getModel() \{
        return model;
    \}

    public void setModel(String model) \{
        this.model = model;
    \}

    public double getCost() \{
        return cost;
    \}

    public void setCost(double cost) \{
        this.cost = cost;
    \}

    public int getZoom() \{
        return zoom;
    \}

    public void setZoom(int zoom) \{
        this.zoom = zoom;
    \}

    public double getMegapixels() \{
        return megapixels;
    \}

    public void setMegapixels(double megapixels) \{
        this.megapixels = megapixels;
    \}

    public boolean isImageStabilizer() \{
        return imageStabilizer;
    \}

    public void setImageStabilizer(boolean imageStabilizer) \{
        this.imageStabilizer = imageStabilizer;
    \}

    public String getManufacturer() \{
        return manufacturer;
    \}

    public void setManufacturer(String manufacturer) \{
        this.manufacturer = manufacturer;
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 1

Create an index to work against. 

<TabItem value="step_2" label="step_2">
<CodeBlock language="java">
{`public class Cameras_ByManufacturerModelCostDateOfListingAndMegapixels extends AbstractIndexCreationTask \{
    public Cameras_ByManufacturerModelCostDateOfListingAndMegapixels() \{
        map = "from camera in docs.Cameras " +
            "select new \{" +
            "   camera.manufacturer," +
            "   camera.model," +
            "   camera.cost," +
            "   camera.dateOfListing," +
            "   camera.megapixels" +
            "\} ";
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 2

Setup your facet definitions:

<TabItem value="step_1" label="step_1">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>

This tells RavenDB that you would like to get the following facets:

* For the **manufacturer** field, look at the documents and return a count for each unique Term found.

* For the **cost** field, return the count of the following ranges:

 * cost &lt; 200.0
 * 200.0 &lt;= cost &lt; 400.0
 * 400.0 &lt;= cost &lt; 600.0
 * 600.0 &lt;= cost &lt; 800.0
 * cost &gt;= 800.0
* For the **megapixels** field, return the count of the following ranges:
 * megapixels &lt;= 3.0
 * 3.0 &lt;= megapixels &lt; 7.0
 * 7.0 &lt;= megapixels &lt; 10.0
 * megapixels &gt;= 10.0

## Step 3

You can write the following code to get back the data below:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`Map<String, FacetResult> facetResults = session
    .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
    .whereBetween("cost", 100, 300)
    .aggregateBy(facets)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(manufacturer), facet(cost <= 200, cost between 200 and 400, cost between 400 and 600, cost between 600 and 800, cost >= 800), facet(megapixels <= 3, megapixels between 3 and 7, megapixels between 7 and 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

This data represents the sample faceted data that satisfies the above query:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`[
    \{
        "Name": "manufacturer",
        "Values": [
            \{
                "Count": 1,
                "Range": "canon"
            \},
            \{
                "Count": 2,
                "Range": "jessops"
            \},
            \{
                "Count": 1,
                "Range": "nikon"
            \},
            \{
                "Count": 1,
                "Range": "phillips"
            \},
            \{
                "Count": 3,
                "Range": "sony"
            \}
        ]
    \},
    \{
        "Name": "cost",
        "Values": [
            \{
                "Count": 6,
                "Range": "cost <= 200"
            \},
            \{
                "Count": 2,
                "Range": "cost between 200 and 400"
            \},
            \{
                "Count": 0,
                "Range": "cost between 400 and 600"
            \},
            \{
                "Count": 0,
                "Range": "cost between 600 and 800"
            \},
            \{
                "Count": 0,
                "Range": "cost >= 800"
            \}
        ]
    \},
    \{
        "Name": "megapixels",
        "Values": [
            \{
                "Count": 0,
                "Range": "megapixels <= 3"
            \},
            \{
                "Count": 6,
                "Range": "megapixels between 3 and 7"
            \},
            \{
                "Count": 1,
                "Range": "megapixels between 7 and 10"
            \},
            \{
                "Count": 1,
                "Range": "megapixels >= 10"
            \}
        ]
    \}
]
`}
</CodeBlock>
</TabItem>

### Storing Facets

If you do not have to change your facets dynamically, you can store your facets as a `FacetSetup` document and pass the document ID instead of the list each time:

<TabItem value="step_4_0" label="step_4_0">
<CodeBlock language="java">
{`FacetSetup facetSetup = new FacetSetup();
facetSetup.setFacets(facets);
facetSetup.setRangeFacets(rangeFacets);

session.store(facetSetup, "facets/CameraFacets");
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`Map<String, FacetResult> facetResults = session
    .query(Camera.class, Cameras_ByManufacturerModelCostDateOfListingAndMegapixels.class)
    .whereBetween("cost", 100, 300)
    .aggregateUsing("facets/CameraFacets")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="java">
{`Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

List<Facet> facets = Arrays.asList(facet1);
List<RangeFacet> rangeFacets = Arrays.asList(facet2, facet3);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

### Stale Results

The faceted search does not take into account a staleness of an index. You can wait for non stale results by customizing your query with the `waitForNonStaleResults` method.

### Fluent API

As an alternative for creating a list of facets and passing it to the `aggregateBy` method, RavenDB also exposes a dynamic API where you can create your facets using a builder. You can read more about those methods in our dedicated Client API article [here](../../client-api/session/querying/how-to-perform-a-faceted-search.mdx).


</LanguageContent>
<LanguageContent language="nodejs">


When displaying a large amount of data, paging is often used to make viewing the data manageable. It's also useful to give some context of the entire data-set and a easy way to drill-down into particular categories. The common approach to doing this is a "faceted search", as shown in the image below. __Note__ how the count of each category within the current search is across the top.

![Facets](./assets/CNET_faceted_search_2.jpg)

&lt;br /&gt;
Let's start with defining a document like this:

<TabItem value="camera" label="camera">
<CodeBlock language="js">
{`export class Camera \{
    constructor(manufacturer, model, \{
        dateOfListing,
        cost,
        zoom,
        megapixels,
        imageStabilizer
    \}) \{
        this.manufacturer = manufacturer;
        this.model = model;
        this.dateOfListing = dateOfListing;
        this.cost = cost;
        this.zoom = zoom;
        this.megapixels = megapixels;
        this.imageStabilizer = imageStabilizer;
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 1

Create an index to work against. 

<TabItem value="step_2" label="step_2">
<CodeBlock language="js">
{`class Cameras_ByManufacturerModelCostDateOfListingAndMegapixels extends AbstractIndexCreationTask \{
    constructor() \{
        super();

        this.map = \`from camera in docs.Cameras select new \{   
            camera.manufacturer,   
            camera.model,   
            camera.cost,   
            camera.dateOfListing,   
            camera.megapixels
        \}\`;
    \}
\}
`}
</CodeBlock>
</TabItem>

## Step 2

Setup your facet definitions:

<TabItem value="step_1" label="step_1">
<CodeBlock language="js">
{`const facet1 = new Facet();
facet1.fieldName = "manufacturer";

const facet2 = new RangeFacet();
facet2.ranges = [ 
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
];

const facet3 = new RangeFacet();
facet3.ranges = [ 
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
];

const facets = [ facet1 ];
const rangeFacets = [ facet2, facet3 ];
`}
</CodeBlock>
</TabItem>

This tells RavenDB that you would like to get the following facets:

* For the **manufacturer** field, look at the documents and return a count for each unique Term found.

* For the **cost** field, return the count of the following ranges:

 * cost &lt; 200.0
 * 200.0 &lt;= cost &lt; 400.0
 * 400.0 &lt;= cost &lt; 600.0
 * 600.0 &lt;= cost &lt; 800.0
 * cost &gt;= 800.0
* For the **megapixels** field, return the count of the following ranges:
 * megapixels &lt;= 3.0
 * 3.0 &lt;= megapixels &lt; 7.0
 * 7.0 &lt;= megapixels &lt; 10.0
 * megapixels &gt;= 10.0

## Step 3

You can write the following code to get back the data below:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const facetResults = await session
    .query({ indexName: "Cameras/ByManufacturerModelCostDateOfListingAndMegapixels" })
    .whereBetween("cost", 100, 300)
    .aggregateBy(facets)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="js">
{`const facet1 = new Facet();
facet1.fieldName = "manufacturer";

const facet2 = new RangeFacet();
facet2.ranges = [ 
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
];

const facet3 = new RangeFacet();
facet3.ranges = [ 
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
];

const facets = [ facet1 ];
const rangeFacets = [ facet2, facet3 ];
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(manufacturer), facet(cost <= 200, cost between 200 and 400, cost between 400 and 600, cost between 600 and 800, cost >= 800), facet(megapixels <= 3, megapixels between 3 and 7, megapixels between 7 and 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

This data represents the sample faceted data that satisfies the above query:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`[
    \{
        "Name": "manufacturer",
        "Values": [
            \{
                "Count": 1,
                "Range": "canon"
            \},
            \{
                "Count": 2,
                "Range": "jessops"
            \},
            \{
                "Count": 1,
                "Range": "nikon"
            \},
            \{
                "Count": 1,
                "Range": "phillips"
            \},
            \{
                "Count": 3,
                "Range": "sony"
            \}
        ]
    \},
    \{
        "Name": "cost",
        "Values": [
            \{
                "Count": 6,
                "Range": "cost <= 200"
            \},
            \{
                "Count": 2,
                "Range": "cost between 200 and 400"
            \},
            \{
                "Count": 0,
                "Range": "cost between 400 and 600"
            \},
            \{
                "Count": 0,
                "Range": "cost between 600 and 800"
            \},
            \{
                "Count": 0,
                "Range": "cost >= 800"
            \}
        ]
    \},
    \{
        "Name": "megapixels",
        "Values": [
            \{
                "Count": 0,
                "Range": "megapixels <= 3"
            \},
            \{
                "Count": 6,
                "Range": "megapixels between 3 and 7"
            \},
            \{
                "Count": 1,
                "Range": "megapixels between 7 and 10"
            \},
            \{
                "Count": 1,
                "Range": "megapixels >= 10"
            \}
        ]
    \}
]
`}
</CodeBlock>
</TabItem>

### Storing Facets

If you do not have to change your facets dynamically, you can store your facets as a `FacetSetup` document and pass the document ID instead of the list each time:

<TabItem value="step_4_0" label="step_4_0">
<CodeBlock language="js">
{`const facetSetup = new FacetSetup();
facetSetup.facets = facets;
facetSetup.rangeFacets = rangeFacets;

await session.store(facetSetup, "facets/CameraFacets");
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const facetResults = await session
    .query({ indexName: "Cameras/ByManufacturerModelCostDateOfListingAndMegapixels" })
    .whereBetween("cost", 100, 300)
    .aggregateUsing("facets/CameraFacets")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Facets" label="Facets">
<CodeBlock language="js">
{`const facet1 = new Facet();
facet1.fieldName = "manufacturer";

const facet2 = new RangeFacet();
facet2.ranges = [ 
    "cost <= 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
];

const facet3 = new RangeFacet();
facet3.ranges = [ 
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
];

const facets = [ facet1 ];
const rangeFacets = [ facet2, facet3 ];
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Cameras/ByManufacturerModelCostDateOfListingAndMegapixels' 
where cost between 100 and 300
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

### Stale Results

The faceted search does not take into account a staleness of an index. You can wait for non stale results by customizing your query with the `waitForNonStaleResults()` method.

### Fluent API

As an alternative for creating a list of facets and passing it to the `aggregateBy()` method, RavenDB also exposes a dynamic API where you can create your facets using a builder. You can read more about those methods in our dedicated Client API article [here](../../client-api/session/querying/how-to-perform-a-faceted-search.mdx).


</LanguageContent>

<!---
### Client API
- [How to Perform a Faceted Search](../../client-api/session/querying/how-to-perform-a-faceted-search)


-->