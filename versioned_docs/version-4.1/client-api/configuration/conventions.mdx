---
title: "Conventions"
hide_table_of_contents: true
sidebar_label: Conventions
sidebar_position: 0
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Conventions
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Conventions give you the ability to customize the Client API behavior. They are accessible from the `DocumentStore` object:

<TabItem value="conventions_1" label="conventions_1">
<CodeBlock language="csharp">
{`using (var store = new DocumentStore()
\{
    Conventions =
    \{
        // Set conventions HERE, e.g.:
        MaxNumberOfRequestsPerSession = 50,
        AddIdFieldToDynamicObjects = false
        // ...
    \}
\}.Initialize())
\{
    // * Here you can interact with the RavenDB store:
    //   open sessions, create or query for documents, perform operations, etc.
    
    // * Conventions CANNOT be set here after calling Initialize()
\}
`}
</CodeBlock>
</TabItem>

You will find many settings to overwrite, allowing you to adjust the client according to your needs. The conventions apply to many different client behaviors. Some of them are grouped and described in the separate articles of this section.

<Admonition type="info" title="Info">
All customizations need to be set before `DocumentStore.Initialize()` is called.
</Admonition>

## MaxHttpCacheSize

If you need to modify the maximum http cache size, you can use the following setting:

<TabItem value="MaxHttpCacheSize" label="MaxHttpCacheSize">
<CodeBlock language="csharp">
{`MaxHttpCacheSize = new Size(256, SizeUnit.Megabytes) // Set max cache size
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="Default size" id="default-size" href="#default-size">

The default value of this setting is configured as follows:

* running on 64 bits:
  * if usable memory is lower than or equal to 3GB: 64MB,
  * if usable memory is greater than 3GB and lower than or equal to 6GB: 128MB,
  * if usable memory is greater than 6GB: 512MB,

* running on 32 bits: 32MB.

The cache is created per database you use.

</Admonition>

<Admonition type="note" title="Disable caching" id="disable-caching" href="#disable-caching"> 

To disable the caching globally, you can set the `MaxHttpCacheSize` value to zero:

<TabItem value="disable_cache" label="disable_cache">
<CodeBlock language="csharp">
{`MaxHttpCacheSize = new Size(0, SizeUnit.Megabytes) // Disable caching
`}
</CodeBlock>
</TabItem>

**In this scenario, all the requests will be sent to the server to fetch the data.**

</Admonition>

## MaxNumberOfRequestsPerSession

Gets or sets maximum number of GET requests per session. Default: `30`.

<TabItem value="MaxNumberOfRequestsPerSession" label="MaxNumberOfRequestsPerSession">
<CodeBlock language="csharp">
{`Syntax
        // Syntax:
        public int MaxNumberOfRequestsPerSession \{ get; set; \}
`}
</CodeBlock>
</TabItem>

## UseOptimisticConcurrency

Controls whether optimistic concurrency is set to true by default for all future sessions. Default: `false`.

<TabItem value="UseOptimisticConcurrency" label="UseOptimisticConcurrency">
<CodeBlock language="csharp">
{`UseOptimisticConcurrency = true
`}
</CodeBlock>
</TabItem>

## RequestTimeout

It allows you to define the global request timeout value for all `RequestExecutors` created per database. Default: `null`.

<TabItem value="RequestTimeout" label="RequestTimeout">
<CodeBlock language="csharp">
{`RequestTimeout = TimeSpan.FromSeconds(90)
`}
</CodeBlock>
</TabItem>

## DisableTopologyUpdates

Forces you to disable updates of database topology. Default: `false`.

<TabItem value="DisableTopologyUpdates" label="DisableTopologyUpdates">
<CodeBlock language="csharp">
{`Syntax
        // Syntax:
        public bool DisableTopologyUpdates \{ get; set; \}
`}
</CodeBlock>
</TabItem>

## SaveEnumsAsIntegers

It determines if C# `enum` types should be saved as integers or strings and instructs the LINQ provider to query enums as integer values. Default: `false`.

<TabItem value="SaveEnumsAsIntegers" label="SaveEnumsAsIntegers">
<CodeBlock language="csharp">
{`Syntax
        // Syntax:
        public bool SaveEnumsAsIntegers \{ get; set; \} 
`}
</CodeBlock>
</TabItem>

## UseCompression

It determines if the client will send headers to the server indicating that it allows compression to be used. Default: `true`.

<TabItem value="UseCompression" label="UseCompression">
<CodeBlock language="csharp">
{`Syntax
        // Syntax:
        public bool UseCompression \{ get; set; \}
`}
</CodeBlock>
</TabItem>

## OperationStatusFetchMode

Changes the way the operation is fetching the operation status when waiting for completion. By default, the value is set to `ChangesApi` which underneath is using WebSocket protocol when connection is established with the server. On some older systems e.g. Windows 7, the WebSocket protocol might not be available due to the OS and .NET Framework limitations. For that reason, the value can be changed to `Polling` to bypass this issue.

<TabItem value="OperationStatusFetchMode" label="OperationStatusFetchMode">
<CodeBlock language="csharp">
{`OperationStatusFetchMode = OperationStatusFetchMode.ChangesApi // ChangesApi | Polling
`}
</CodeBlock>
</TabItem>

## Changing fields/properties naming convention 

By default whatever casing convention you use in your entities' fields will be reflected server-side.

If following language-specific field casing conventions RavenDB clients use different field/properties naming conventions:

| Language | Default convention | Example |
| ------------- | ----- | --- |
| C# | PascalCase | OrderLines |
| Java | camelCase | orderLines |
| JavaScript | camelCase | orderLines |

This can be configured to allow inter-language operability e.g. store data PascalCase, but keep fields in the application code camelCase.

### Using camelCase in C# client

You have to customize *JsonSerializer* and *PropertyNameConverter*.  

<TabItem value="FirstChar" label="FirstChar">
<CodeBlock language="csharp">
{`private string FirstCharToLower(string str) => $"\{Char.ToLower(str[0])\}\{str.Substring(1)\}";
`}
</CodeBlock>
</TabItem>

<TabItem value="PropertyCasing" label="PropertyCasing">
<CodeBlock language="csharp">
{`Serialization = new NewtonsoftJsonSerializationConventions
\{
    // .Net properties will be serialized as camelCase in the JSON document when storing an entity
    // and deserialized back to PascalCase
    CustomizeJsonSerializer = s => s.ContractResolver = new CamelCasePropertyNamesContractResolver()
\},

// In addition, the following convention is required when
// making a query that filters by a field name and when indexing. 
PropertyNameConverter = memberInfo => FirstCharToLower(memberInfo.Name)
`}
</CodeBlock>
</TabItem>

## TopologyCacheLocation

Changes the location of topology cache files. Setting this value will check directory existance and write permissions. By default it is set to the application base directory (`AppContext.BaseDirectory`).

<TabItem value="TopologyCacheLocation" label="TopologyCacheLocation">
<CodeBlock language="csharp">
{`TopologyCacheLocation = @"C:\\RavenDB\\TopologyCache"
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="java">


Conventions give you the ability to customize the Client API behavior. They are accessible from `DocumentStore` object:

<TabItem value="conventions_1" label="conventions_1">
<CodeBlock language="java">
{`try (IDocumentStore store = new DocumentStore()) \{
    DocumentConventions conventions = store.getConventions();
    // customizations go here

    store.initialize();
\}
`}
</CodeBlock>
</TabItem>

You will find many settings to overwrite, allowing you to adjust the client according to your needs. The conventions apply to many different client behaviors. Some of them are grouped and described in the separate articles of this section.

<Admonition type="info" title="Info">
All customizations need to be set before `DocumentStore.initialize()` is called.
</Admonition>

## MaxHttpCacheSize

If you need to modify the maximum http cache size, you can use the following setting:

<TabItem value="MaxHttpCacheSize" label="MaxHttpCacheSize">
<CodeBlock language="java">
{`conventions.setMaxHttpCacheSize(256 * 1024 * 1024);
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="Default size" id="default-size" href="#default-size">

The default value of this setting is configured to 128 MB.

The cache is created per database you use.

</Admonition>

<Admonition type="note" title="Disable caching" id="disable-caching" href="#disable-caching"> 

To disable the caching globally you can set the `maxHttpCacheSize` value to zero:

<TabItem value="disable_cache" label="disable_cache">
<CodeBlock language="java">
{`conventions.setMaxHttpCacheSize(0);
`}
</CodeBlock>
</TabItem>

**In this scenario, all the requests will be sent to the server to fetch the data.**

</Admonition>

## MaxNumberOfRequestsPerSession

Gets or sets maximum number of GET requests per session. Default: `30`.

<TabItem value="MaxNumberOfRequestsPerSession" label="MaxNumberOfRequestsPerSession">
<CodeBlock language="java">
{`conventions.setMaxNumberOfRequestsPerSession(10);
`}
</CodeBlock>
</TabItem>

## UseOptimisticConcurrency

Controls whether optimistic concurrency is set to true by default for all future sessions. Default: `false`.

<TabItem value="UseOptimisticConcurrency" label="UseOptimisticConcurrency">
<CodeBlock language="java">
{`conventions.setUseOptimisticConcurrency(true);
`}
</CodeBlock>
</TabItem>

## DisableTopologyUpdates

Forces you to disable updates of database topology. Default: `false`.

<TabItem value="DisableTopologyUpdates" label="DisableTopologyUpdates">
<CodeBlock language="java">
{`conventions.setDisableTopologyUpdates(false);
`}
</CodeBlock>
</TabItem>

## SaveEnumsAsIntegers

It determines if Java `Enum` types should be saved as integers or strings. Default: `false`.

<TabItem value="SaveEnumsAsIntegers" label="SaveEnumsAsIntegers">
<CodeBlock language="java">
{`conventions.setSaveEnumsAsIntegers(true);
`}
</CodeBlock>
</TabItem>


## UseCompression

It determines if the client will send headers to the server indicating that it allows compression to be used. Default: `true`.

<TabItem value="UseCompression" label="UseCompression">
<CodeBlock language="java">
{`conventions.setUseCompression(true);
`}
</CodeBlock>
</TabItem>

## Changing fields/properties naming convention 

By default whatever casing convention you use in your entities' fields will be reflected server-side.

If following language-specific field casing conventions RavenDB clients use different field/properties naming conventions:

| Language | Default convention | Example |
| ------------- | ----- | --- |
| C# | PascalCase | OrderLines |
| Java | camelCase | orderLines |
| JavaScript | camelCase | orderLines |

This can be configured to allow inter-language operability e.g. store data PascalCase, but keep fields in the application code camelCase.

### Using PascalCase in Java client

You have to set *property naming strategy*:

<TabItem value="PropertyCasing" label="PropertyCasing">
<CodeBlock language="java">
{`conventions.getEntityMapper()
    .setPropertyNamingStrategy(
        new JsonExtensions.DotNetNamingStrategy());
`}
</CodeBlock>
</TabItem>



</LanguageContent>
<LanguageContent language="nodejs">


Conventions give you the ability to customize the Client API behavior. They are accessible from `DocumentStore` object:

<TabItem value="conventions_1" label="conventions_1">
<CodeBlock language="js">
{`const documentStore = new DocumentStore(["serverUrl_1", "serverUrl_2", "..."], "DefaultDB");

// Set conventions HERE, e.g.:
documentStore.conventions.maxNumberOfRequestsPerSession = 50;
documentStore.conventions.disableTopologyUpdates = true;

documentStore.initialize();

// * Here you can interact with the RavenDB store:
//   open sessions, create or query for documents, perform operations, etc.

// * Conventions CANNOT be set here after calling initialize()
`}
</CodeBlock>
</TabItem>

You will find many settings to overwrite, allowing you to adjust the client according to your needs. The conventions apply to many different client behaviors. Some of them are grouped and described in the separate articles of this section.

<Admonition type="info" title="Info">
All customizations need to be set before `DocumentStore.initialize()` is called.
</Admonition>

## MaxHttpCacheSize

If you need to modify the maximum http cache size, you can use the following setting:

<TabItem value="MaxHttpCacheSize" label="MaxHttpCacheSize">
<CodeBlock language="js">
{`Syntax
    // Returns a number
    get maxHttpCacheSize();
    // Set a number
    set maxHttpCacheSize(value);
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="Default size" id="default-size" href="#default-size">

The default value of this setting is configured to 128 MB.

The cache is created per database you use.

</Admonition>

<Admonition type="note" title="Disable caching" id="disable-caching" href="#disable-caching"> 

To disable the caching globally you can set the `maxHttpCacheSize` value to zero:

<TabItem value="disable_cache" label="disable_cache">
<CodeBlock language="js">
{`conventions.maxHttpCacheSize = 0;
`}
</CodeBlock>
</TabItem>

**In this scenario, all the requests will be sent to the server to fetch the data.**

</Admonition>

## MaxNumberOfRequestsPerSession

Gets or sets maximum number of GET requests per session. Default: `30`.

<TabItem value="MaxNumberOfRequestsPerSession" label="MaxNumberOfRequestsPerSession">
<CodeBlock language="js">
{`Syntax
    // Returns a number
    get maxNumberOfRequestsPerSession();
    // Set a number
    set maxNumberOfRequestsPerSession(value);
`}
</CodeBlock>
</TabItem>

## UseOptimisticConcurrency

Controls whether optimistic concurrency is set to true by default for all future sessions. Default: `false`.

<TabItem value="UseOptimisticConcurrency" label="UseOptimisticConcurrency">
<CodeBlock language="js">
{`Syntax
    // Returns a boolean
    get useOptimisticConcurrency();
    // Set a boolean
    set useOptimisticConcurrency(value);
`}
</CodeBlock>
</TabItem>

## DisableTopologyUpdates

Forces you to disable updates of database topology. Default: `false`.

<TabItem value="DisableTopologyUpdates" label="DisableTopologyUpdates">
<CodeBlock language="js">
{`Syntax
    // Returns a boolean value
    get disableTopologyUpdates();
    // Set a boolean value
    set disableTopologyUpdates(value);
`}
</CodeBlock>
</TabItem>

## UseCompression

It determines if the client will send headers to the server indicating that it allows compression to be used. Default: `true`.

<TabItem value="UseCompression" label="UseCompression">
<CodeBlock language="js">
{`Syntax
    // Returns a boolean
    get useCompression();
    // Set a boolean
    set useCompression(value);
`}
</CodeBlock>
</TabItem>

## Changing fields/properties naming convention 

By default whatever casing convention you use in your entities' fields will be reflected server-side.

If following language-specific field casing conventions RavenDB clients use different field/properties naming conventions:

| Language | Default convention | Example |
| ------------- | ----- | --- |
| C# | PascalCase | OrderLines |
| Java | camelCase | orderLines |
| JavaScript | camelCase | orderLines |

This can be configured to allow inter-language operability e.g. store data PascalCase, but keep fields in the application code camelCase.

### Example: storing data PascalCase, have camelCase in application entities

If you'd like to transform field names to be PascalCase server-side, but keep using camelCase in your Node.js application. You need to set 2 properties (since JS is not aware of local classes/objects field names):

* `conventions.remoteEntityFieldNameConvention` - for transforming data before it's sent *to* the server

* `conventions.entityFieldNameConvention` - for transforming data once it's loaded *from* the server

You have to set *property naming strategy*:

<TabItem value="PropertyCasing" label="PropertyCasing">
<CodeBlock language="js">
{`conventions.remoteEntityFieldNameConvention = "pascal";
conventions.entityFieldNameConvention = "camel";
`}
</CodeBlock>
</TabItem>

## Dates storage conventions

By default all dates are stored in local time with no timezone information. There are 2 document conventions allowing to adjust storage of dates:

- store.conventions.storeDatesWithTimezoneInfo 
- store.conventions.storeDatesInUtc 

### StoreDatesWithTimezoneInfo

This convention allows you to store dates along with the timezone information, by storing dates in the following format: `YYYY-MM-DDTHH:mm:ss.SSS0000Z`. JavaScript's Date object's minimal precision is 1 ms, hence the zeroes in the date format for the nanoseconds. Default: `false`.

<TabItem value="StoreDatesWithTimezoneInfo" label="StoreDatesWithTimezoneInfo">
<CodeBlock language="js">
{`Syntax
    // Returns a boolean
    get storeDatesWithTimezoneInfo();
    // Set a boolean
    set storeDatesWithTimezoneInfo(value);
`}
</CodeBlock>
</TabItem>

### StoreDatesInUtc

If enabled, dates are going to be stored in UTC instead of local time. Default: `false`.

<TabItem value="StoreDatesInUtc" label="StoreDatesInUtc">
<CodeBlock language="js">
{`Syntax
    // Returns a boolean
    get storeDatesInUtc();
    // Set a boolean
    set storeDatesInUtc(value);
`}
</CodeBlock>
</TabItem>

## Entity types registration - registerEntityType()

Type information about the entity and its contents is by default stored in the document metadata. Based on that its types are revived when loaded from the server. Conventions object exposes a method `registerEntityType(type)` allowing you to register types of your entities and their subobjects in order to:

* revive object types when loading from the server

* avoid passing **documentType** argument every time on methods loading entites e.g. `load()`, `query()` etc.

<Admonition type="info" title="Entity type registration " id="entity-type-registration" href="#entity-type-registration">
To avoid passing **documentType** argument every time, you can register the type in the document conventions using the `registerEntityType()` method before calling DocumentStore's `initialize()` like so:

<TabItem value="query_1_8" label="query_1_8">
<CodeBlock language="js">
{`class Pet \{
    constructor(name) \{
        this.name = name;
    \}
\}

class Person \{
    constructor(name, pet) \{
        this.name = name;
        this.pet = pet;
    \}
\}

documentStore.conventions.registerEntityType(Person);
documentStore.conventions.registerEntityType(Pet);
// ...

documentStore.initialize();
`}
</CodeBlock>
</TabItem>

</Admonition>

If you fail to do so, entities (and all subobjects) loaded from the server are going to be plain object literals and not instances of the original type they were stored with.

## Storing object literals - findCollectionNameForObjectLiteral()

In order to comfortably use object literals as entities set the function getting collection name based on the content of the object - `store.conventions.findCollectionNameForObjectLiteral()`

<TabItem value="storing_literals_1" label="storing_literals_1">
<CodeBlock language="js">
{`const store = new DocumentStore(urls, database);
store.conventions.findCollectionNameForObjectLiteral = entity => entity["collection"];
// ...
store.initialize();
`}
</CodeBlock>
</TabItem>

If you fail to do so, your object literal based entites will land up in *@empty* collection having an *UUID* for an ID.


</LanguageContent>

<!---
### Conventions
- [Querying](../../client-api/configuration/querying)
- [Serialization](../../client-api/configuration/serialization)
- [Load Balance &amp; Failover](../../client-api/configuration/load-balance-and-failover)

### Document Identifiers
- [Working with Document Identifiers](../../client-api/document-identifiers/working-with-document-identifiers)
- [Global ID Generation Conventions](../../client-api/configuration/identifier-generation/global)
- [Type-specific ID Generation Conventions](../../client-api/configuration/identifier-generation/type-specific)

### Document Store
- [What is a Document Store](../../client-api/what-is-a-document-store)


-->