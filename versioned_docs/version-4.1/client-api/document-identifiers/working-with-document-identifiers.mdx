---
title: "Working with Document Identifiers"
hide_table_of_contents: true
sidebar_label: Working with Document Identifiers
sidebar_position: 0
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Working with Document Identifiers
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Each document in a RavenDB database has a unique string associated with its document called an identifier. Every entity that you store either by using [a session](../session/what-is-a-session-and-how-does-it-work.mdx) or with a [put document command](../commands/documents/put.mdx) will have such identifier assigned in the database. In RavenDB there are [four options](../../server/kb/document-identifier-generation.mdx) supported by the server to store a document and assign an identifier to it.
The client can directly take advantage of them. You can always handle the identifier generation using the knowledge of the type of the entity and the identifier number provided by the HiLo algorithm. This is how the identifier is generated by the session, which is described in details below.

* In this page:  
  * [Session Usage](../../client-api/document-identifiers/working-with-document-identifiers.mdx#session-usage)  
  * [Autogenerated IDs](../../client-api/document-identifiers/working-with-document-identifiers.mdx#autogenerated-ids)  
  * [Custom / Semantic IDs](../../client-api/document-identifiers/working-with-document-identifiers.mdx#custom--semantic-ids)  
  * [Server-side generated IDs](../../client-api/document-identifiers/working-with-document-identifiers.mdx#server-side-generated-ids)  
  * [Identities](../../client-api/document-identifiers/working-with-document-identifiers.mdx#identities)  
  * [Commands Usage](working-with-document-identifiers#commands-usage)  


## Session Usage

If you choose to use the session, you don't have to pay any special attention to the identifiers of the stored entities. The session will take care of it by generating the identifiers automatically.

It utilizes [conventions](../../client-api/configuration/conventions.mdx) and HiLo algorithms to produce the identifiers. Everything is handled by the session's mechanism and is transparent for the user. 
However, you can influence the identifier generation strategy by overwriting [the identifier generation conventions](../../client-api/configuration/identifier-generation/global.mdx). 

In this article we are going to consider the behavior in accordance with the default conventions.

<Admonition type="info" title="Identifiers in RavenDB are strings" id="identifiers-in-ravendb-are-strings" href="#identifiers-in-ravendb-are-strings">
Identifiers of documents in RavenDB database are always strings, so take this into consideration when you model your entities.
</Admonition>


## Autogenerated IDs

In order to figure out which property (or field) holds the entity's identifier, the convention `Conventions.FindIdentityProperty` is called. 
By default, it looks for the property or the field named `Id` (case sensitive). However, this property can have a `null` value or even not be present at all. Then the automatic identifier generation strategy is performed. The default convention is that entities get the identifiers in the following format `collection/number-tag`. 
RavenDB client first determines the name of [the collection](../../client-api/faq/what-is-a-collection.mdx) that the entity belongs to, then contacts the server in order to retrieve a numeric range of values. These values can be used as the `number` part.
The range of available numbers is calculated by using the `HiLo` algorithm and it is tracked per collection. The current maximum value in ranges are stored in documents `Raven/Hilo/collection`.

Let's see the example.

<TabItem value="session_id_not_provided" label="session_id_not_provided">
<CodeBlock language="csharp">
{`var order = new Order
\{
    Id = null // value not provided
\};

session.Store(order);
`}
</CodeBlock>
</TabItem>

What will be the identifier of this order? You can check it by calling:

<TabItem value="session_get_document_id" label="session_get_document_id">
<CodeBlock language="csharp">
{`var orderId = session.Advanced.GetDocumentId(order); // "orders/1-A"
`}
</CodeBlock>
</TabItem>

If this is the first `Order` entity in your database, then it will return `orders/1-A`. How does the identifier generation process proceed? The RavenDB client determines the collection name as `orders` (by default it is the plural form of the entity name).
Then it asks the server to give him the ID's range he can use (the first available range is 1 - 32). The server will handle the Raven/Hilo/orders document. 
The next available identifier value (always incrementing number) from the given range is `1` so its combination with the collection name and the node tag gives the result `orders/1-A`.

The next attempt to store another `Order` object within the same session will result in creating the `orders/2-A` identifier. However, this time asking the server about the possible range will not be necessary because the in-memory range (1 - 32) is enough, so simply the next number will be added as the identifier suffix.

<Admonition type="info" title="Identifier value numeric range generation" id="identifier-value-numeric-range-generation" href="#identifier-value-numeric-range-generation">

Each (in code) document store _instance_ handles the generation of the identifier value numeric range. The database stores the last requested number while the document store _instances_ request ranges and caches the returned range of available identities.

The database has a single document (per collection) which stores the last identifier value requested by a document store instance.

E.g. the document `Raven/HiLo/accounts` has the following value 
<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{ 
    "Max": "4000",
    "@metadata": \{
        "@collection": "@hilo"
    \} 
\}
`}
</CodeBlock>
</TabItem>

then the next range will be `4001 - 4032`, if 32 was range size (by default, it's 32).

The number of sessions per document store instance plays no part in identifier value generation. When the store is disposed, the client sends to the server the last value that he used and the max value he got from the server. Then the server will write it in the HiLo document (If the Max number is equal to the max number from the client and bigger or equal to the last used value by the client)
</Admonition>

If your intention is to skip the identifier creation strategy that relies on the collection and HiLo value pair, then you can allow the RavenDB database to assign the Guid identifier to the stored document. Then you have to provide the `string.Empty` as the value of the `Id` property:

<TabItem value="session_empty_string_id" label="session_empty_string_id">
<CodeBlock language="csharp">
{`var orderEmptyId = new Order
\{
    Id = string.Empty // database will create a GUID value for it
\};

session.Store(orderEmptyId);

session.SaveChanges();

var guidId = session.Advanced.GetDocumentId(orderEmptyId); // "bc151542-8fa7-45ac-bc04-509b343a8720"
`}
</CodeBlock>
</TabItem>

This time the check for the document ID is called after `SaveChanges` because only then we go to the server while the entity's identifier is generated there.

## Custom / Semantic IDs

The session also supports the option to store the entity and explicitly tell under what identifier it should be stored in the database. To do this, you can either set the `Id` property of the object:

<TabItem value="session_semantic_id_1" label="session_semantic_id_1">
<CodeBlock language="csharp">
{`var product = new Product
\{
    Id = "products/ravendb",
    Name = "RavenDB"
\};

session.Store(product);
`}
</CodeBlock>
</TabItem>

or use the following `Store` method overload:

<TabItem value="session_semantic_id_2" label="session_semantic_id_2">
<CodeBlock language="csharp">
{`session.Store(new Product
\{
    Name = "RavenDB"
\}, "products/ravendb");
`}
</CodeBlock>
</TabItem>

## Server-side generated IDs

RavenDB also supports the notion of the identifier without the usage of the HiLo. By creating a string ID property in your entity and setting it to a value ending with a slash (`/`), you can ask RavenDB to assign a document ID to a new document when it is saved.

<TabItem value="session_auto_id" label="session_auto_id">
<CodeBlock language="csharp">
{`session.Store(new Company
\{
    Id = "companies/"
\});

session.SaveChanges();
`}
</CodeBlock>
</TabItem>
 
Using `/` at the end of the ID will create an ID at the server side by appending a numeric value and the node tag.
After executing the code above we will get from the server ID something that looks like `companies/000000000000000027-A`.

<Admonition type="info" title="Info">
Be aware that the only guarantee for the numeric part is that it will always be increasing only within the same node.
</Admonition>

## Identities

If you need IDs to increment across the cluster, you can use the **Identity** option.  
To do so you need to use a pipe (`|`) as a suffix to the provided ID. This will instruct RavenDB 
to create the ID when the document is saved, using a special cluster-wide integer value that is 
continuously incremented.  

<Admonition type="note" title="Note">
Using an identity guarantees that IDs will be incremental, but does **not** guarantee 
that there wouldn't be gaps in the sequence.  
The IDs sequence can therefore be, for example, `companies/1`, `companies/2`, `companies/4`..  
This is because -  

 *  Documents could have been deleted.  
 *  A failed transaction still increments the identity value, thus causing a gap in the sequence.  
</Admonition>

<TabItem value="session_identity_id" label="session_identity_id">
<CodeBlock language="csharp">
{`session.Store(new Company
\{
    Id = "companies|"
\});

session.SaveChanges();
`}
</CodeBlock>
</TabItem>

After the execution of the code above, the ID will be `companies/1`.  
We do not add the node tag to the end of the ID, because the added number is unique in the cluster.  
Identities continuously increase, so running the above code again will generate `companies/2`, and so on.  

Note that we used `companies` as the prefix just to follow the RavenDB convention.  
Nothing prevents you from providing a different prefix, unrelated to the collection name.

<Admonition type="warning" title="Warning">
Be aware that using the pipe symbol (`|`) as a prefix to the ID generates a call to the cluster 
and might affect performance. 
</Admonition>

<Admonition type="note" title="Note">

* **Identity Parts Separator**  
By default, document IDs created by the server use `/` to separate their components.  
This separator can be changed to any other character except `|`, in the 
[Global Identifier Generation Conventions](../../client-api/configuration/identifier-generation/global.mdx#identitypartsseparator).  
See [Setting Identity IDs Using Commands and Operations](../../client-api/document-identifiers/working-with-document-identifiers.mdx#setting-identity-ids-using-commands-and-operations) 
for details.  

* **Concurrent writes**  
  The identities are generated and updated on the server side in the atomic fashion.  
  This means you can safely use this approach in the concurrent writes scenario.
</Admonition>

## Commands Usage

The use of the commands API gives you the full freedom to select the identifier generation strategy. As in the case of session, you can either ask the server to provide the identifier, or provide the identifier of the stored entity manually.

### Identity IDs

As in the case of session, you can indicate if the identifier that you are passing needs to have the identifier suffix added. You have to mark it by ending the ID with `/` or `|` character:

<TabItem value="commands_identity" label="commands_identity">
<CodeBlock language="csharp">
{`var doc = new DynamicJsonValue
\{
    ["Name"] = "My RavenDB"
\};

var blittableDoc = session.Advanced.JsonConverter.ToBlittable(doc, null);

var command = new PutDocumentCommand("products/", null, blittableDoc);

session.Advanced.RequestExecutor.Execute(command, session.Advanced.Context);

var identityId = command.Result.Id; // "products/0000000000000000001-A if using only '/' in the seesion"

var commandWithPipe = new PutDocumentCommand("products|", null, blittableDoc);
session.Advanced.RequestExecutor.Execute(commandWithPipe, session.Advanced.Context);

var identityPipeId = command.Result.Id; // "products/1"
`}
</CodeBlock>
</TabItem>

Using the commands, you can manage to build identifiers on the client, but still relying on the server side identifier generator. Simply point out for which prefix you want to fetch the next available identifier number. Look at the example:

<TabItem value="commands_identity_generate" label="commands_identity_generate">
<CodeBlock language="csharp">
{`var command = new NextIdentityForCommand("products");
session.Advanced.RequestExecutor.Execute(command, session.Advanced.Context);
var identity = command.Result;

var doc = new DynamicJsonValue
\{
    ["Name"] = "My RavenDB"
\};

var blittableDoc = session.Advanced.JsonConverter.ToBlittable(doc, null);

var putCommand = new PutDocumentCommand("products/" + identity, null, blittableDoc);

session.Advanced.RequestExecutor.Execute(putCommand, session.Advanced.Context);
`}
</CodeBlock>
</TabItem>

Note that such construction requires going to the server twice in order to add a single document. The call of `session.Advanced.RequestExecutor.Execute(command, session.Advanced.Context)` is necessary for every entity you want to store. Asking the server about the next identifier results in increasing this value on the server side. You cannot simply get the next available identifier and 
use it to create the identifiers for the whole collection of the same type objects by locally incrementing this value because you can accidentally overwrite the document or get a conflict exception if someone else is putting documents using the identifier mechanism.

There are dedicated commands that allow you to set identifier values for a single given prefix:

<TabItem value="commands_identity_set" label="commands_identity_set">
<CodeBlock language="csharp">
{`var seedIdentityCommand = new SeedIdentityForCommand("products", 1994);
`}
</CodeBlock>
</TabItem>


</LanguageContent>
<LanguageContent language="java">


Each document in a RavenDB database has a unique string associated with its document called an identifier. Every entity that you store either by using [a session](../session/what-is-a-session-and-how-does-it-work.mdx) or with a [put document command](../commands/documents/put.mdx) will have such identifier assigned in the database. In RavenDB there are [four options](../../server/kb/document-identifier-generation.mdx) supported by the server to store a document and assign an identifier to it.
The client can directly take advantage of them. You can always handle the identifier generation using the knowledge of the type of the entity and the identifier number provided by the HiLo algorithm. This is how the identifier is generated by the session, which is described in details below.  

In this page:  

* [Session Usage](working-with-document-identifiers#session-usage)  
* [Autogenerated IDs](working-with-document-identifiers#autogenerated-ids)  
* [Custom / Semantic IDs](working-with-document-identifiers#custom--semantic-ids)  
* [Server-side generated IDs](working-with-document-identifiers#server-side-generated-ids)  
* [Identities](working-with-document-identifiers#identities)  
* [Commands Usage](working-with-document-identifiers#commands-usage)

## Session Usage

If you choose to use the session, you don't have to pay any special attention to the identifiers of the stored entities. The session will take care of it by generating the identifiers automatically.

It utilizes [conventions](../../client-api/configuration/conventions.mdx) and HiLo algorithms to produce the identifiers. Everything is handled by the session's mechanism and is transparent for the user. 
However, you can influence the identifier generation strategy by overwriting [the identifier generation conventions](../../client-api/configuration/identifier-generation/global.mdx). 

In this article we are going to consider the behavior in accordance with the default conventions.

<Admonition type="info" title="Identifiers in RavenDB are strings" id="identifiers-in-ravendb-are-strings" href="#identifiers-in-ravendb-are-strings">
Identifiers of documents in RavenDB database are always strings, so take this into consideration when you model your entities.
</Admonition>


## Autogenerated IDs

In order to figure out which field holds the entity's identifier, the convention `conventions.findIdentityProperty` is called. 
By default, it looks for the field named `id` (case sensitive). However, this field can have a `null` value or even not be present at all. Then the automatic identifier generation strategy is performed. The default convention is that entities get the identifiers in the following format `collection/number-tag`. 
RavenDB client first determines the name of [the collection](../../client-api/faq/what-is-a-collection.mdx) that the entity belongs to, then contacts the server in order to retrieve a numeric range of values. These values can be used as the `number` part.
The range of available numbers is calculated by using the `HiLo` algorithm and it is tracked per collection. The current maximum value in ranges are stored in documents `Raven/Hilo/collection`.

Let's see the example.

<TabItem value="session_id_not_provided" label="session_id_not_provided">
<CodeBlock language="java">
{`Order order = new Order();
order.setId(null); // value not provided

session.store(order);
`}
</CodeBlock>
</TabItem>

What will be the identifier of this order? You can check it by calling:

<TabItem value="session_get_document_id" label="session_get_document_id">
<CodeBlock language="java">
{`String orderId = session.advanced().getDocumentId(order); // "orders/1-A"
`}
</CodeBlock>
</TabItem>

If this is the first `Order` entity in your database, then it will return `orders/1-A`. How does the identifier generation process proceed? The RavenDB client determines the collection name as `orders` (by default it is the plural form of the entity name).
Then it asks the server to give him the ID's range he can use (the first available range is 1 - 32). The server will handle the Raven/Hilo/orders document. 
The next available identifier value (always incrementing number) from the given range is `1` so its combination with the collection name and the node tag gives the result `orders/1-A`.

The next attempt to store another `Order` object within the same session will result in creating the `orders/2-A` identifier. However, this time asking the server about the possible range will not be necessary because the in-memory range (1 - 32) is enough, so simply the next number will be added as the identifier suffix.

<Admonition type="info" title="Identifier value numeric range generation" id="identifier-value-numeric-range-generation" href="#identifier-value-numeric-range-generation">

Each (in code) document store _instance_ handles the generation of the identifier value numeric range. The database stores the last requested number while the document store _instances_ request ranges and caches the returned range of available identities.

The database has a single document (per collection) which stores the last identifier value requested by a document store instance.

E.g. the document `Raven/HiLo/accounts` has the following value 
<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{ 
    "Max": "4000",
    "@metadata": \{
        "@collection": "@hilo"
    \} 
\}
`}
</CodeBlock>
</TabItem>

then the next range will be `4001 - 4032`, if 32 was range size (by default, it's 32).

The number of sessions per document store instance plays no part in identifier value generation. When the store is closed, the client sends to the server the last value that he used and the max value he got from the server. Then the server will write it in the HiLo document (If the Max number is equal to the max number from the client and bigger or equal to the last used value by the client)
</Admonition>

If your intention is to skip the identifier creation strategy that relies on the collection and HiLo value pair, then you can allow the RavenDB database to assign the Guid identifier to the stored document. Then you have to provide the `""` (empty string) as the value of the `id` field:

<TabItem value="session_empty_string_id" label="session_empty_string_id">
<CodeBlock language="java">
{`Order orderEmptyId = new Order();
orderEmptyId.setId(""); // database will create a GUID value for it
session.store(orderEmptyId);
session.saveChanges();

String guidId = session.advanced()
    .getDocumentId(orderEmptyId); // "bc151542-8fa7-45ac-bc04-509b343a8720"
`}
</CodeBlock>
</TabItem>

This time the check for the document ID is called after `saveChanges` because only then we go to the server while the entity's identifier is generated there.

## Custom / Semantic IDs

The session also supports the option to store the entity and explicitly tell under what identifier it should be stored in the database. To do this, you can either set the `id` field of the object:

<TabItem value="session_semantic_id_1" label="session_semantic_id_1">
<CodeBlock language="java">
{`Product product = new Product();
product.setId("products/ravendb");
product.setName("RavenDB");

session.store(product);
`}
</CodeBlock>
</TabItem>

or use the following `store` method overload:

<TabItem value="session_semantic_id_2" label="session_semantic_id_2">
<CodeBlock language="java">
{`Product product = new Product();
product.setName("RavenDB");
session.store(product, "products/ravendb");
`}
</CodeBlock>
</TabItem>

## Server-side generated IDs

RavenDB also supports the notion of the identifier without the usage of the HiLo. By creating a string ID field in your entity and setting it to a value ending with a slash (`/`), you can ask RavenDB to assign a document ID to a new document when it is saved.

<TabItem value="session_auto_id" label="session_auto_id">
<CodeBlock language="java">
{`Company company = new Company();
company.setId("companies/");

session.store(company);
session.saveChanges();
`}
</CodeBlock>
</TabItem>
 
Using `/` at the end of the ID will create an ID at the server side by appending a numeric value and the node tag.
After executing the code above we will get from the server ID something that looks like `companies/000000000000000027-A`.

<Admonition type="info" title="Info">
Be aware that the only guarantee for the numeric part is that it will always be increasing only within the same node.
</Admonition>

## Identities

If you need IDs to increment across the cluster, you can use the **Identity** option.  
To do so you need to use a pipe (`|`) as a suffix to the provided ID. This will instruct RavenDB 
to create the ID when the document is saved, using a special cluster-wide integer value that is 
continuously incremented.  

<Admonition type="note" title="Note">
Using an identity guarantees that IDs will be incremental, but does **not** guarantee 
that there wouldn't be gaps in the sequence.  
The IDs sequence can therefore be, for example, `companies/1`, `companies/2`, `companies/4`..  
This is because -  

 *  Documents could have been deleted.  
 *  A failed transaction still increments the identity value, thus causing a gap in the sequence.  
</Admonition>

<TabItem value="session_identity_id" label="session_identity_id">
<CodeBlock language="java">
{`Company company = new Company();
company.setId("companies|");
session.store(company);
session.saveChanges();
`}
</CodeBlock>
</TabItem>

After the execution of the code above, the ID will be `companies/1`.  
We do not add the node tag to the end of the ID, because the added number is unique in the cluster.  
Identities continuously increase, so running the above code again will generate `companies/2`, and so on.  

Note that we used `companies` as the prefix just to follow the RavenDB convention.  
Nothing prevents you from providing a different prefix, unrelated to the collection name.

<Admonition type="warning" title="Warning">
Be aware that using the pipe symbol (`|`) as a prefix to the ID generates a call to the cluster 
and might affect performance. 
</Admonition>

<Admonition type="note" title="Concurrent writes" id="concurrent-writes" href="#concurrent-writes">
The identities are generated and updated on the server side in the atomic fashion.  
This means you can safely use this approach in the concurrent writes scenario.
</Admonition>

## Commands Usage

The use of the commands API gives you the full freedom to select the identifier generation strategy. As in the case of session, you can either ask the server to provide the identifier, or provide the identifier of the stored entity manually.

### Identity IDs

As in the case of session, you can indicate if the identifier that you are passing needs to have the identifier suffix added. You have to mark it by ending the ID with `/` or `|` character:

<TabItem value="commands_identity" label="commands_identity">
<CodeBlock language="java">
{`Map<String, String> doc = Collections.singletonMap("Name", "My RavenDB");

ObjectNode jsonDoc = session.advanced().getEntityToJson().convertEntityToJson(doc, store.getConventions());
PutDocumentCommand comamnd = new PutDocumentCommand("products/", null, jsonDoc);
session.advanced().getRequestExecutor().execute(comamnd);

String identityId =
    comamnd.getResult().getId(); // "products/0000000000000000001-A if using only '/' in the seesion"

PutDocumentCommand commandWithPipe = new PutDocumentCommand("products|", null, jsonDoc);
session.advanced().getRequestExecutor().execute(commandWithPipe);

String identityPipeId = comamnd.getResult().getId(); // "products/1"
`}
</CodeBlock>
</TabItem>

Using the commands, you can manage to build identifiers on the client, but still relying on the server side identifier generator. Simply point out for which prefix you want to fetch the next available identifier number. Look at the example:

<TabItem value="commands_identity_generate" label="commands_identity_generate">
<CodeBlock language="java">
{`NextIdentityForCommand command = new NextIdentityForCommand("products");
session.advanced().getRequestExecutor().execute(command);
Long identity = command.getResult();

Map<String, String> doc = Collections.singletonMap("Name", "My RavenDB");

ObjectNode jsonDoc = session.advanced().getEntityToJson().convertEntityToJson(doc, store.getConventions());
PutDocumentCommand putCommand = new PutDocumentCommand("products/" + identity, null, jsonDoc);
session.advanced().getRequestExecutor().execute(putCommand);
`}
</CodeBlock>
</TabItem>

Note that such construction requires going to the server twice in order to add a single document. The call of `session.advanced.getRequestExecutor().execute(command)` is necessary for every entity you want to store. Asking the server about the next identifier results in increasing this value on the server side. You cannot simply get the next available identifier and 
use it to create the identifiers for the whole collection of the same type objects by locally incrementing this value because you can accidentally overwrite the document or get a conflict exception if someone else is putting documents using the identifier mechanism.

There are dedicated commands that allow you to set identifier values for a single given prefix:

<TabItem value="commands_identity_set" label="commands_identity_set">
<CodeBlock language="java">
{`SeedIdentityForCommand seedIdentityCommand = new SeedIdentityForCommand("products", 1994L);
`}
</CodeBlock>
</TabItem>


</LanguageContent>
<LanguageContent language="nodejs">


Each document in a RavenDB database has a unique string associated with its document called an identifier. Every entity that you store either by using [a session](../session/what-is-a-session-and-how-does-it-work.mdx) or with a [put document command](../commands/documents/put.mdx) will have such identifier assigned in the database. In RavenDB there are [four options](../../server/kb/document-identifier-generation.mdx) supported by the server to store a document and assign an identifier to it.
The client can directly take advantage of them. You can always handle the identifier generation using the knowledge of the type of the entity and the identifier number provided by the HiLo algorithm. This is how the identifier is generated by the session, which is described in details below.

In this page:  

* [Session Usage](working-with-document-identifiers#session-usage)  
* [Autogenerated IDs](working-with-document-identifiers#autogenerated-ids)  
* [Custom / Semantic IDs](working-with-document-identifiers#custom--semantic-ids)  
* [Server-side generated IDs](working-with-document-identifiers#server-side-generated-ids)  
* [Identities](working-with-document-identifiers#identities)  
* [Commands Usage](working-with-document-identifiers#commands-usage)

## Session Usage

If you choose to use the session, you don't have to pay any special attention to the identifiers of the stored entities. The session will take care of it by generating the identifiers automatically.

It utilizes [conventions](../../client-api/configuration/conventions.mdx) and HiLo algorithms to produce the identifiers. Everything is handled by the session's mechanism and is transparent for the user. 
However, you can influence the identifier generation strategy by overwriting [the identifier generation conventions](../../client-api/configuration/identifier-generation/global.mdx). 

In this article we are going to consider the behavior in accordance with the default conventions.

<Admonition type="info" title="Identifiers in RavenDB are strings" id="identifiers-in-ravendb-are-strings" href="#identifiers-in-ravendb-are-strings">
Identifiers of documents in RavenDB database are always strings, so take this into consideration when you model your entities.
</Admonition>


## Autogenerated IDs

In order to figure out which field holds the entity's identifier, the convention `conventions.identityProperty` value is checked. 
By default, it looks for the field named `id` (case sensitive). However, this field can have a `null` value or even not be present at all. Then the automatic identifier generation strategy is performed. The default convention is that entities get the identifiers in the following format `collection/number-tag`. 
RavenDB client first determines the name of [the collection](../../client-api/faq/what-is-a-collection.mdx) that the entity belongs to, then contacts the server in order to retrieve a numeric range of values. These values can be used as the `number` part.
The range of available numbers is calculated by using the `HiLo` algorithm and it is tracked per collection. The current maximum value in ranges are stored in documents `Raven/Hilo/collection`.

Let's see the example.

<TabItem value="session_id_not_provided" label="session_id_not_provided">
<CodeBlock language="js">
{`const order = new Order();
order.id = null; // value not provided

await session.store(order);
`}
</CodeBlock>
</TabItem>

What will be the identifier of this order? You can check it by calling:

<TabItem value="session_get_document_id" label="session_get_document_id">
<CodeBlock language="js">
{`const orderId = session.advanced.getDocumentId(order); // "orders/1-A"
`}
</CodeBlock>
</TabItem>

If this is the first `Order` entity in your database, then it will return `orders/1-A`. How does the identifier generation process proceed? The RavenDB client determines the collection name as `orders` (by default it is the plural form of the entity name).
Then it asks the server to give him the ID's range he can use (the first available range is 1 - 32). The server will handle the Raven/Hilo/orders document. 
The next available identifier value (always incrementing number) from the given range is `1` so its combination with the collection name and the node tag gives the result `orders/1-A`.

The next attempt to store another `Order` object within the same session will result in creating the `orders/2-A` identifier. However, this time asking the server about the possible range will not be necessary because the in-memory range (1 - 32) is enough, so simply the next number will be added as the identifier suffix.

<Admonition type="info" title="Identifier value numeric range generation" id="identifier-value-numeric-range-generation" href="#identifier-value-numeric-range-generation">

Each (in code) document store _instance_ handles the generation of the identifier value numeric range. The database stores the last requested number while the document store _instances_ request ranges and caches the returned range of available identities.

The database has a single document (per collection) which stores the last identifier value requested by a document store instance.

E.g. the document `Raven/HiLo/accounts` has the following value 
<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{ 
    "Max": "4000",
    "@metadata": \{
        "@collection": "@hilo"
    \} 
\}
`}
</CodeBlock>
</TabItem>

then the next range will be `4001 - 4032`, if 32 was range size (by default, it's 32).

The number of sessions per document store instance plays no part in identifier value generation. When the store is closed, the client sends to the server the last value that he used and the max value he got from the server. Then the server will write it in the HiLo document (If the Max number is equal to the max number from the client and bigger or equal to the last used value by the client)
</Admonition>

If your intention is to skip the identifier creation strategy that relies on the collection and HiLo value pair, then you can allow the RavenDB database to assign the Guid identifier to the stored document. Then you have to provide the `""` (empty string) as the value of the `id` field:

<TabItem value="session_empty_string_id" label="session_empty_string_id">
<CodeBlock language="js">
{`const orderEmptyId = new Order();
orderEmptyId.id = ""; // database will create a GUID value for it
await session.store(orderEmptyId);
await session.saveChanges();

const guidId = await session.advanced
    .getDocumentId(orderEmptyId); // "bc151542-8fa7-45ac-bc04-509b343a8720"
`}
</CodeBlock>
</TabItem>

This time the check for the document ID is called after `saveChanges()` because only then we go to the server while the entity's identifier is generated there.

## Custom / Semantic IDs

The session also supports the option to store the entity and explicitly tell under what identifier it should be stored in the database. To do this, you can either set the `id` field of the object:

<TabItem value="session_semantic_id_1" label="session_semantic_id_1">
<CodeBlock language="js">
{`const product = new Product();
product.id = "products/ravendb";
product.name = "RavenDB";

await session.store(product);
`}
</CodeBlock>
</TabItem>

or use the following `store()` method overload:

<TabItem value="session_semantic_id_2" label="session_semantic_id_2">
<CodeBlock language="js">
{`const product = new Product();
product.name = "RavenDB";
await session.store(product, "products/ravendb");
`}
</CodeBlock>
</TabItem>

## Server-side generated IDs

RavenDB also supports the notion of the identifier without the usage of the HiLo. By creating a string ID field in your entity and setting it to a value ending with a slash (`/`), you can ask RavenDB to assign a document ID to a new document when it is saved.

<TabItem value="session_auto_id" label="session_auto_id">
<CodeBlock language="js">
{`const company = new Company();
company.id = "companies/";

await session.store(company);
await session.saveChanges();
`}
</CodeBlock>
</TabItem>
 
Using `/` at the end of the ID will create an ID at the server side by appending a numeric value and the node tag.
After executing the code above we will get from the server ID something that looks like `companies/000000000000000027-A`.

<Admonition type="info" title="Info">
Be aware that the only guarantee for the numeric part is that it will always be increasing only within the same node.
</Admonition>

## Identities

If you need IDs to increment across the cluster, you can use the **Identity** option.  
To do so you need to use a pipe (`|`) as a suffix to the provided ID. This will instruct RavenDB 
to create the ID when the document is saved, using a special cluster-wide integer value that is 
continuously incremented.  

<Admonition type="note" title="Note">
Using an identity guarantees that IDs will be incremental, but does **not** guarantee 
that there wouldn't be gaps in the sequence.  
The IDs sequence can therefore be, for example, `companies/1`, `companies/2`, `companies/4`..  
This is because -  

 *  Documents could have been deleted.  
 *  A failed transaction still increments the identity value, thus causing a gap in the sequence.  
</Admonition>

<TabItem value="session_identity_id" label="session_identity_id">
<CodeBlock language="js">
{`const company = new Company();
company.id = "companies|";
await session.store(company);
await session.saveChanges();
`}
</CodeBlock>
</TabItem>

After the execution of the code above, the ID will be `companies/1`.  
We do not add the node tag to the end of the ID, because the added number is unique in the cluster.  
Identities continuously increase, so running the above code again will generate `companies/2`, and so on.  

Note that we used `companies` as the prefix just to follow the RavenDB convention.  
Nothing prevents you from providing a different prefix, unrelated to the collection name.

<Admonition type="warning" title="Warning">
Using the pipe symbol (`|`) as a prefix to the ID generates a call to the cluster and **might** affect performance
</Admonition>

<Admonition type="note" title="Concurrent writes" id="concurrent-writes" href="#concurrent-writes">
The identities are generated and updated on the server side in the atomic fashion.  
This means you can safely use this approach in the concurrent writes scenario.
</Admonition>

## Commands Usage

The use of the commands API gives you the full freedom to select the identifier generation strategy. As in the case of session, you can either ask the server to provide the identifier, or provide the identifier of the stored entity manually.

## Identity IDs

As in the case of session, you can indicate if the identifier that you are passing needs to have the identifier suffix added. You have to mark it by ending the ID with `/` or `|` character:

<TabItem value="commands_identity" label="commands_identity">
<CodeBlock language="js">
{`const doc = \{ "Name": "My RavenDB" \};

const jsonDoc = session.advanced.entityToJson.convertEntityToJson(doc, store.conventions);
const command = new PutDocumentCommand("products/", null, jsonDoc);
await session.advanced.getRequestExecutor().execute(command);

const identityId =
    command.result.id; // "products/0000000000000000001-A if using only '/' in the session"

const commandWithPipe = new PutDocumentCommand("products|", null, jsonDoc);
await session.advanced.getRequestExecutor().execute(commandWithPipe);

const identityPipeId = command.result.id; // "products/1"
`}
</CodeBlock>
</TabItem>

Using the commands, you can manage to build identifiers on the client, but still relying on the server side identifier generator. Simply point out for which prefix you want to fetch the next available identifier number. Look at the example:

<TabItem value="commands_identity_generate" label="commands_identity_generate">
<CodeBlock language="js">
{`const command = new NextIdentityForCommand("products");
await session.advanced.getRequestExecutor().execute(command);
const identity = command.result;

const doc = \{ "Name": "My RavenDB" \};
const jsonDoc = session.advanced.entityToJson.convertEntityToJson(doc, store.conventions);
const putCommand = new PutDocumentCommand("products/" + identity, null, jsonDoc);
session.advanced.getRequestExecutor().execute(putCommand);
`}
</CodeBlock>
</TabItem>

Note that such construction requires going to the server twice in order to add a single document. The call of `session.advanced.getRequestExecutor().execute(command)` is necessary for every entity you want to store. Asking the server about the next identifier results in increasing this value on the server side. You cannot simply get the next available identifier and 
use it to create the identifiers for the whole collection of the same type objects by locally incrementing this value because you can accidentally overwrite the document or get a conflict exception if someone else is putting documents using the identifier mechanism.

There are dedicated commands that allow you to set identifier values for a single given prefix:

<TabItem value="commands_identity_set" label="commands_identity_set">
<CodeBlock language="js">
{`const seedIdentityCommand = new SeedIdentityForCommand("products", 1994);
`}
</CodeBlock>
</TabItem>


</LanguageContent>

<!---
### Document Identifiers
- [Global ID Generation Conventions](../../client-api/configuration/identifier-generation/global)
- [Type-specific ID Generation Conventions](../../client-api/configuration/identifier-generation/type-specific)
- [HiLo Algorithm](../../client-api/document-identifiers/hilo-algorithm)

### Knowledge Base
- [Document Identifier Generation](../../server/kb/document-identifier-generation)

### Session
- [How to Get Entity ID](../../client-api/session/how-to/get-entity-id)

### Operations
- [How to Get Identities](../../client-api/operations/maintenance/identities/get-identities)


-->