---
title: "Session: Querying: How to Perform a Faceted (Aggregated) Search"
hide_table_of_contents: true
sidebar_label: Perform Faceted Search
sidebar_position: 8
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Session: Querying: How to Perform a Faceted (Aggregated) Search
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


To execute facet (aggregation) query using the session `Query` method, use the `AggregateBy` or `AggregateUsing` methods. This will scope you to the aggregation query builder where you will be allowed to define single or multiple facets for the query using a straightforward and fluent API.

## Syntax

<TabItem value="facet_1" label="facet_1">
<CodeBlock language="csharp">
{`IAggregationQuery<T> AggregateBy<T>(FacetBase facet);

IAggregationQuery<T> AggregateBy<T>(IEnumerable<FacetBase> facets);

IAggregationQuery<T> AggregateBy<T>(Action<IFacetBuilder<T>> builder);

IAggregationQuery<T> AggregateUsing<T>(string facetSetupDocumentKey);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **facet** | FacetBase | `FacetBase` implementation defining the scope of the facet and its options (either `Facet` or `RangeFacet`) |
| **facets** | `IEnumerable<FacetBase>` | Enumerable containing `FacetBase` implementations |
| **builder** | `Action<IFacetFactory<T>>` | Builder with a fluent API that constructs a `FacetBase` instance |
| **facetSetupDocumentId** | string | ID of a document containing `FacetSetup` | 

### Facet & RangeFacet

<Admonition type="info" title="Facet vs RangeFacet" id="facet-vs-rangefacet" href="#facet-vs-rangefacet">
`RangeFacet` allows you to split the results of the calculations into several ranges, in contrast to `Facet` where whole spectrum of results will be used to generate a single outcome.
</Admonition>

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="csharp">
{`public class Facet
{
    public string FieldName { get; set; }

    public FacetOptions Options { get; set; }

    public Dictionary<FacetAggregation, string> Aggregations { get; set; }

    public string DisplayFieldName { get; set; }
}

public class Facet<T>
{
    public Expression<Func<T, object>> FieldName { get; set; }

    public FacetOptions Options { get; set; }

    public Dictionary<FacetAggregation, string> Aggregations { get; set; }

    public string DisplayFieldName { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="csharp">
{`public class RangeFacet
{
    public List<string> Ranges { get; set; }

    public FacetOptions Options { get; set; }

    public Dictionary<FacetAggregation, string> Aggregations { get; set; }

    public string DisplayFieldName { get; set; }
}

public class RangeFacet<T>
{
    public List<Expression<Func<T, bool>>> Ranges { get; set; }

    public FacetOptions Options { get; set; }

    public Dictionary<FacetAggregation, string> Aggregations { get; set; }

    public string DisplayFieldName { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetAggregation" label="FacetAggregation">
<CodeBlock language="csharp">
{`public enum FacetAggregation
{
    None,
    Max,
    Min,
    Average,
    Sum
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Builder

<TabItem value="facet_7_1" label="facet_7_1">
<CodeBlock language="csharp">
{`IFacetOperations<T> ByRanges(Expression<Func<T, bool>> path, params Expression<Func<T, bool>>[] paths);

IFacetOperations<T> ByField(Expression<Func<T, object>> path);

IFacetOperations<T> ByField(string fieldName);

IFacetOperations<T> WithDisplayName(string displayName);

IFacetOperations<T> WithOptions(FacetOptions options);

IFacetOperations<T> SumOn(Expression<Func<T, object>> path);

IFacetOperations<T> MinOn(Expression<Func<T, object>> path);

IFacetOperations<T> MaxOn(Expression<Func<T, object>> path);

IFacetOperations<T> AverageOn(Expression<Func<T, object>> path);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **path** | string | Points to the index field that should be used for operation (`ByRanges`, `ByField`) or to document field that should be used for aggregation (`SumOn`, `MinOn`, `MaxOn`, `AverageOn`) |
| **fieldName** | string | Points to the index field that should be used for operation (`ByRanges`, `ByField`) or to document field that should be used for aggregation (`SumOn`, `MinOn`, `MaxOn`, `AverageOn`) |
| **displayName** | string | If set, results of a facet will be returned under this name |
| **options** | `FacetOptions` | Non-default options that should be used for operation |

### Options

<TabItem value="facet_7_2" label="facet_7_2">
<CodeBlock language="csharp">
{`public FacetTermSortMode TermSortMode \{ get; set; \} = FacetTermSortMode.ValueAsc;

public bool IncludeRemainingTerms \{ get; set; \}

public int Start \{ get; set; \}

public int PageSize \{ get; set; \} = int.MaxValue;
`}
</CodeBlock>
</TabItem>

| Options | | |
| ------------- | ------------- | ----- |
| **TermSortMode** | `FacetTermSortMode` | Indicates how terms should be sorted (`ValueAsc`, `ValueDesc`, `CountAsc`, `CountDesc`) |
| **IncludeRemainingTerms** | bool | Indicates if remaining terms should be included in results |
| **Start** | int | Used to skip given number of facet results in the outcome |
| **PageSize** | int | Used to limit facet results to the given value |

## Example I

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facets = session
    .Query<Camera>("Camera/Costs")
    .AggregateBy(new Facet
    {
        FieldName = "Manufacturer",
        Options = new FacetOptions
        {
            TermSortMode = FacetTermSortMode.CountDesc
        }
    })
    .AndAggregateBy(new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m
        },
        Aggregations =
        {
            { FacetAggregation.Average, "Cost" }
        }
    })
    .AndAggregateBy(new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0
        }
    })
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facets = await asyncSession
    .Query<Camera>("Camera/Costs")
    .AggregateBy(new Facet
    {
        FieldName = "Manufacturer",
        Options = new FacetOptions
        {
            TermSortMode = FacetTermSortMode.CountDesc
        }
    })
    .AndAggregateBy(new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m
        },
        Aggregations =
        {
            { FacetAggregation.Average, "Cost" }
        }
    })
    .AndAggregateBy(new RangeFacet<Camera>
    {
        Ranges =
        {
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0
        }
    })
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select 
facet(Manufacturer), 
facet(Cost < 200, Cost >= 200 AND Cost < 400, Cost >= 400 AND Cost < 600, Cost >= 600 AND Cost < 800, Cost >= 800),
facet(Megapixels < 3, Megapixels >= 3 AND Megapixels < 7, Megapixels >= 7 AND Megapixels < 10, Megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example II

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facets = session
    .Query<Camera>("Camera/Costs")
    .AggregateBy(builder => builder
        .ByField(x => x.Manufacturer)
        .WithOptions(new FacetOptions
        {
            TermSortMode = FacetTermSortMode.CountDesc
        }))
    .AndAggregateBy(builder => builder
        .ByRanges(
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m)
        .AverageOn(x => x.Cost))
    .AndAggregateBy(builder => builder
        .ByRanges(
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0))
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`Dictionary<string, FacetResult> facets = await asyncSession
    .Query<Camera>("Camera/Costs")
    .AggregateBy(builder => builder
        .ByField(x => x.Manufacturer)
        .WithOptions(new FacetOptions
        {
            TermSortMode = FacetTermSortMode.CountDesc
        }))
    .AndAggregateBy(builder => builder
        .ByRanges(
            camera => camera.Cost < 200m,
            camera => camera.Cost >= 200m && camera.Cost < 400m,
            camera => camera.Cost >= 400m && camera.Cost < 600m,
            camera => camera.Cost >= 600m && camera.Cost < 800m,
            camera => camera.Cost >= 800m)
        .AverageOn(x => x.Cost))
    .AndAggregateBy(builder => builder
        .ByRanges(
            camera => camera.Megapixels < 3.0,
            camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
            camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
            camera => camera.Megapixels >= 10.0))
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select 
facet(Manufacturer), 
facet(Cost < 200, Cost >= 200 AND Cost < 400, Cost >= 400 AND Cost < 600, Cost >= 600 AND Cost < 800, Cost >= 800),
facet(Megapixels < 3, Megapixels >= 3 AND Megapixels < 7, Megapixels >= 7 AND Megapixels < 10, Megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example III

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`session.Store(new FacetSetup
{
    Facets = new List<Facet>
        {
            new Facet
            {
                FieldName = "Manufacturer"
            }
        },
    RangeFacets = new List<RangeFacet>
        {
            new RangeFacet<Camera>
            {
                Ranges =
                {
                    camera => camera.Cost < 200m,
                    camera => camera.Cost >= 200m && camera.Cost < 400m,
                    camera => camera.Cost >= 400m && camera.Cost < 600m,
                    camera => camera.Cost >= 600m && camera.Cost < 800m,
                    camera => camera.Cost >= 800m
                }
            },
            new RangeFacet<Camera>
            {
                Ranges =
                {
                    camera => camera.Megapixels < 3.0,
                    camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
                    camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
                    camera => camera.Megapixels >= 10.0
                }
            }
        }
}, "facets/CameraFacets");

session.SaveChanges();

Dictionary<string, FacetResult> facets = session
    .Query<Camera>("Camera/Costs")
    .AggregateUsing("facets/CameraFacets")
    .Execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`await asyncSession.StoreAsync(new FacetSetup
{
    Facets = new List<Facet>
        {
            new Facet
            {
                FieldName = "Manufacturer"
            }
        },
    RangeFacets = new List<RangeFacet>
        {
            new RangeFacet<Camera>
            {
                Ranges =
                {
                    camera => camera.Cost < 200m,
                    camera => camera.Cost >= 200m && camera.Cost < 400m,
                    camera => camera.Cost >= 400m && camera.Cost < 600m,
                    camera => camera.Cost >= 600m && camera.Cost < 800m,
                    camera => camera.Cost >= 800m
                }
            },
            new RangeFacet<Camera>
            {
                Ranges =
                {
                    camera => camera.Megapixels < 3.0,
                    camera => camera.Megapixels >= 3.0 && camera.Megapixels < 7.0,
                    camera => camera.Megapixels >= 7.0 && camera.Megapixels < 10.0,
                    camera => camera.Megapixels >= 10.0
                }
            }
        }
}, "facets/CameraFacets");

await asyncSession.SaveChangesAsync();

Dictionary<string, FacetResult> facets = await asyncSession
    .Query<Camera>("Camera/Costs")
    .AggregateUsing("facets/CameraFacets")
    .ExecuteAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

## Remarks

<Admonition type="warning" title="">
`AggregateBy` only supports aggregation by a single field. If you want to aggregate by multiple fields, you need to emit a single field that contains all values.
</Admonition>


</LanguageContent>
<LanguageContent language="java">


To execute facet (aggregation) query using the session `query` method, use the `aggregateBy` or `aggregateUsing` methods. This will scope you to the aggregation query builder where you will be allowed to define single or multiple facets for the query using a straightforward and fluent API.

## Syntax

<TabItem value="facet_1" label="facet_1">
<CodeBlock language="java">
{`IAggregationDocumentQuery<T> aggregateBy(Consumer<IFacetBuilder<T>> builder);

IAggregationDocumentQuery<T> aggregateBy(FacetBase facet);

IAggregationDocumentQuery<T> aggregateBy(Facet... facet);

IAggregationDocumentQuery<T> aggregateUsing(String facetSetupDocumentId);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **facet** | FacetBase | `FacetBase` implementation defining the scope of the facet and its options (either `Facet` or `RangeFacet`) |
| **facets** | `FacetBase...` | Items containing `FacetBase` implementations |
| **builder** | `Consumer<IFacetBuilder<T>>` | Builder with a fluent API that constructs a `FacetBase` instance |
| **facetSetupDocumentId** | String | ID of a document containing `FacetSetup` | 

### Facet & RangeFacet

<Admonition type="info" title="Facet vs RangeFacet" id="facet-vs-rangefacet" href="#facet-vs-rangefacet">
`RangeFacet` allows you to split the results of the calculations into several ranges, in contrast to `Facet` where whole spectrum of results will be used to generate a single outcome.
</Admonition>

<Tabs groupId='languageSyntax'>
<TabItem value="Facet" label="Facet">
<CodeBlock language="java">
{`public class Facet {
    private String fieldName;
    private FacetOptions options;
    private Map<FacetAggregation, String> aggregations;
    private String displayFieldName;

    public String getFieldName() {
        return fieldName;
    }

    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }

    public FacetOptions getOptions() {
        return options;
    }

    public void setOptions(FacetOptions options) {
        this.options = options;
    }

    public Map<FacetAggregation, String> getAggregations() {
        return aggregations;
    }

    public void setAggregations(Map<FacetAggregation, String> aggregations) {
        this.aggregations = aggregations;
    }

    public String getDisplayFieldName() {
        return displayFieldName;
    }

    public void setDisplayFieldName(String displayFieldName) {
        this.displayFieldName = displayFieldName;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RangeFacet" label="RangeFacet">
<CodeBlock language="java">
{`public class RangeFacet {
    private List<String> ranges;
    private FacetOptions options;
    private Map<FacetAggregation, String> aggregations;
    private String displayFieldName;

    public List<String> getRanges() {
        return ranges;
    }

    public void setRanges(List<String> ranges) {
        this.ranges = ranges;
    }

    public FacetOptions getOptions() {
        return options;
    }

    public void setOptions(FacetOptions options) {
        this.options = options;
    }

    public Map<FacetAggregation, String> getAggregations() {
        return aggregations;
    }

    public void setAggregations(Map<FacetAggregation, String> aggregations) {
        this.aggregations = aggregations;
    }

    public String getDisplayFieldName() {
        return displayFieldName;
    }

    public void setDisplayFieldName(String displayFieldName) {
        this.displayFieldName = displayFieldName;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="FacetAggregation" label="FacetAggregation">
<CodeBlock language="java">
{`public enum FacetAggregation {
    NONE,
    MAX,
    MIN,
    AVERAGE,
    SUM;
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Builder

<TabItem value="facet_7_1" label="facet_7_1">
<CodeBlock language="java">
{`IFacetOperations<T> byRanges(RangeBuilder range, RangeBuilder... ranges);

IFacetOperations<T> byField(String fieldName);

IFacetOperations<T> withDisplayName(String displayName);

IFacetOperations<T> withOptions(FacetOptions options);

IFacetOperations<T> sumOn(String path);
IFacetOperations<T> minOn(String path);
IFacetOperations<T> maxOn(String path);
IFacetOperations<T> averageOn(String path);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **path** | String | Points to the index field that should be used for operation (`byRanges`, `byField`) or to document field that should be used for aggregation (`sumOn`, `minOn`, `maxOn`, `averageOn`) |
| **fieldName** | String | Points to the index field that should be used for operation (`byRanges`, `byField`) or to document field that should be used for aggregation (`sumOn`, `minOn`, `maxOn`, `averageOn`) |
| **displayName** | String | If set, results of a facet will be returned under this name |
| **options** | `FacetOptions` | Non-default options that should be used for operation |

### Options

<TabItem value="facet_7_2" label="facet_7_2">
<CodeBlock language="java">
{`private FacetTermSortMode termSortMode = FacetTermSortMode.VALUE_ASC;
private boolean includeRemainingTerms;
private int start;
private int pageSize = Integer.MAX_VALUE;

//getters and setters
`}
</CodeBlock>
</TabItem>

| Options | | |
| ------------- | ------------- | ----- |
| **termSortMode** | `FacetTermSortMode` | Indicates how terms should be sorted (`VALUE_ASC`, `VALUE_DESC`, `COUNT_ASC`, `COUNT_DESC`) |
| **includeRemainingTerms** | booelean | Indicates if remaining terms should be included in results |
| **start** | int | Used to skip given number of facet results in the outcome |
| **pageSize** | int | Used to limit facet results to the given value |

## Example I

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`FacetOptions facetOptions = new FacetOptions();
facetOptions.setTermSortMode(FacetTermSortMode.COUNT_DESC);

Facet facet1 = new Facet();
facet1.setFieldName("manufacturer");
facet1.setOptions(facetOptions);

RangeFacet facet2 = new RangeFacet();
facet2.setRanges(Arrays.asList(
    "cost < 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));
facet2.setAggregations(Collections.singletonMap(FacetAggregation.AVERAGE, "cost"));

RangeFacet facet3 = new RangeFacet();
facet3.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

Map<String, FacetResult> facets = session
    .query(Camera.class, Query.index("Camera/Costs"))
    .aggregateBy(facet1)
    .andAggregateBy(facet2)
    .andAggregateBy(facet3)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select 
facet(manufacturer), 
facet(cost < 200, cost >= 200 AND cost < 400, cost >= 400 AND cost < 600, cost >= 600 AND cost < 800, cost >= 800),
facet(megapixels < 3, megapixels >= 3 AND megapixels < 7, megapixels >= 7 AND megapixels < 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example II

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`FacetOptions options = new FacetOptions();
options.setTermSortMode(FacetTermSortMode.COUNT_DESC);

RangeBuilder<Integer> costBuilder = RangeBuilder.forPath("cost");
RangeBuilder<Integer> megapixelsBuilder = RangeBuilder.forPath("megapixels");

Map<String, FacetResult> facetResult = session
    .query(Camera.class, Query.index("Camera/Costs"))
    .aggregateBy(builder -> builder
        .byField("manufacturer")
        .withOptions(options))
    .andAggregateBy(builder -> builder
        .byRanges(
            costBuilder.isLessThan(200),
            costBuilder.isGreaterThanOrEqualTo(200).isLessThan(400),
            costBuilder.isGreaterThanOrEqualTo(400).isLessThan(600),
            costBuilder.isGreaterThanOrEqualTo(600).isLessThan(800),
            costBuilder.isGreaterThanOrEqualTo(800))
        .averageOn("cost"))
    .andAggregateBy(builder -> builder
        .byRanges(
            megapixelsBuilder.isLessThan(3),
            megapixelsBuilder.isGreaterThanOrEqualTo(3).isLessThan(7),
            megapixelsBuilder.isGreaterThanOrEqualTo(7).isLessThan(10),
            megapixelsBuilder.isGreaterThanOrEqualTo(10)
        ))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select 
facet(manufacturer), 
facet(cost < 200, cost >= 200 AND cost < 400, cost >= 400 AND cost < 600, cost >= 600 AND cost < 800, cost >= 800),
facet(megapixels < 3, megapixels >= 3 AND megapixels < 7, megapixels >= 7 AND megapixels < 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example III

<Tabs groupId='languageSyntax'>
<TabItem value="Java" label="Java">
<CodeBlock language="java">
{`FacetSetup facetSetup = new FacetSetup();

Facet facetManufacturer = new Facet();
facetManufacturer.setFieldName("manufacturer");
facetSetup.setFacets(Arrays.asList(facetManufacturer));

RangeFacet cameraFacet = new RangeFacet();
cameraFacet.setRanges(Arrays.asList(
    "cost < 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
));

RangeFacet megapixelsFacet = new RangeFacet();
megapixelsFacet.setRanges(Arrays.asList(
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
));

facetSetup.setRangeFacets(Arrays.asList(cameraFacet, megapixelsFacet));

session.store(facetSetup, "facets/CameraFacets");
session.saveChanges();

Map<String, FacetResult> facets = session
    .query(Camera.class, Query.index("Camera/Costs"))
    .aggregateUsing("facets/CameraFacets")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

## Remarks

<Admonition type="warning" title="">
`aggregateBy` only supports aggregation by a single field. If you want to aggregate by multiple fields, you need to emit a single field that contains all values.
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">


To execute facet (aggregation) query using the session `query()` method, use the `aggregateBy()` or `aggregateUsing()` methods. This will scope you to the aggregation query builder where you will be allowed to define single or multiple facets for the query using a straightforward and fluent API.

## Syntax

<TabItem value="facet_1" label="facet_1">
<CodeBlock language="js">
{`query.aggregateBy(facetBuilder);
query.aggregateBy(facet);
query.aggregateBy(...facets);
query.aggregateUsing(facetSetupDocumentId);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **facet** | `FacetBase` | `FacetBase` implementation defining the scope of the facet and its options (either `Facet` or `RangeFacet`) |
| **facets** | `...FacetBase` | Items containing `FacetBase` implementations |
| **facetBuilder** | `(builder) => void` | Builder with a fluent API that constructs a `FacetBase` instance |
| **facetSetupDocumentId** | string | ID of a document containing `FacetSetup` | 

### Facet & RangeFacet

<Admonition type="info" title="Facet vs RangeFacet" id="facet-vs-rangefacet" href="#facet-vs-rangefacet">
`RangeFacet` allows you to split the results of the calculations into several ranges, in contrast to `Facet` where whole spectrum of results will be used to generate a single outcome.
</Admonition>

`FacetAggregation` is one of the following:

* `"None"` 

* `"Max"` 

* `"Min"` 

* `"Average"`

* `"Sum"`

#### Facet

| Fields | |
| ------------- | ------------- |
| **fieldName** | string |
| **options** | `FacetOptions` |
| **aggregrations** | `Map<FieldAggregration, string>` |
| **displayFieldName** | string |

#### RangeFacet

| Fields | |
| ------------- | ------------- |
| **ranges** | string[] |
| **options** | `FacetOptions` |
| **aggregrations** | `Map<FieldAggregration, string>` |
| **displayFieldName** | string |

### Builder

<TabItem value="facet_7_1" label="facet_7_1">
<CodeBlock language="js">
{`facetBuilder.byRanges(range, ...ranges);
facetBuilder.byField(fieldName);

facetBuilder.withDisplayName(displayName);

facetBuilder.withOptions(options);

facetBuilder.sumOn(path);
facetBuilder.minOn(path);
facetBuilder.maxOn(path);
facetBuilder.averageOn(path);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **path** | string | Points to the index field that should be used for operation (`byRanges()`, `byField()`) or to document field that should be used for aggregation (`sumOn()`, `minOn()`, `maxOn()`, `averageOn()`) |
| **fieldName** | string | Points to the index field that should be used for operation (`byRanges()`, `byField()`) or to document field that should be used for aggregation (`sumOn()`, `minOn()`, `maxOn()`, `averageOn()`) |
| **displayName** | string | If set, results of a facet will be returned under this name |
| **options** | object | Non-default options that should be used for operation |
| &nbsp;&nbsp;**termSortMode** | string | Indicates how terms should be sorted (`ValueAsc`, `ValueDesc`, `CountAsc`, `CountDesc`) |
| &nbsp;&nbsp;**includeRemainingTerms** | boolean | Indicates if remaining terms should be included in results |
| &nbsp;&nbsp;**start** | number | Used to skip given number of facet results in the outcome |
| &nbsp;&nbsp;**pageSize** | number | Used to limit facet results to the given value |

## Example I

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const facetOptions = {
    termSortMode: "CountDesc"
};

const facet1 = new Facet();
facet1.fieldName = "manufacturer";
facet1.options = facetOptions;

const facet2 = new RangeFacet();
facet2.ranges = [ 
    "cost < 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
];
facet2.aggregations = new Map([["Average", "cost"]]);

const facet3 = new RangeFacet();
facet3.ranges = [ 
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
];

const facets = await session
    .query({ indexName: "Camera/Costs" })
    .aggregateBy(facet1)
    .andAggregateBy(facet2)
    .andAggregateBy(facet3)
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select 
facet(manufacturer), 
facet(cost < 200, cost >= 200 AND cost < 400, cost >= 400 AND cost < 600, cost >= 600 AND cost < 800, cost >= 800),
facet(megapixels < 3, megapixels >= 3 AND megapixels < 7, megapixels >= 7 AND megapixels < 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example II

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const options = { termSortMode: "CountDesc" };

const costBuilder = RangeBuilder.forPath("cost");
const megapixelsBuilder = RangeBuilder.forPath("megapixels");

const facetResult = await session
    .query({ indexName: "Camera/Costs" })
    .aggregateBy(builder => builder
        .byField("manufacturer")
        .withOptions(options))
    .andAggregateBy(builder => builder
        .byRanges(
            costBuilder.isLessThan(200),
            costBuilder.isGreaterThanOrEqualTo(200).isLessThan(400),
            costBuilder.isGreaterThanOrEqualTo(400).isLessThan(600),
            costBuilder.isGreaterThanOrEqualTo(600).isLessThan(800),
            costBuilder.isGreaterThanOrEqualTo(800))
        .averageOn("cost"))
    .andAggregateBy(builder => builder
        .byRanges(
            megapixelsBuilder.isLessThan(3),
            megapixelsBuilder.isGreaterThanOrEqualTo(3).isLessThan(7),
            megapixelsBuilder.isGreaterThanOrEqualTo(7).isLessThan(10),
            megapixelsBuilder.isGreaterThanOrEqualTo(10)
        ))
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select 
facet(manufacturer), 
facet(cost < 200, cost >= 200 and cost < 400, cost >= 400 and cost < 600, cost >= 600 and cost < 800, cost >= 800),
facet(megapixels < 3, megapixels >= 3 AND megapixels < 7, megapixels >= 7 AND megapixels < 10, megapixels >= 10)
`}
</CodeBlock>
</TabItem>
</Tabs>

## Example III

<Tabs groupId='languageSyntax'>
<TabItem value="Node.js" label="Node.js">
<CodeBlock language="js">
{`const facetSetup = new FacetSetup();

const facetManufacturer = new Facet();
facetManufacturer.fieldName = "manufacturer";
facetSetup.facets = [ facetManufacturer ];

const cameraFacet = new RangeFacet();
cameraFacet.ranges = [
    "cost < 200",
    "cost between 200 and 400",
    "cost between 400 and 600",
    "cost between 600 and 800",
    "cost >= 800"
];

const megapixelsFacet = new RangeFacet();
megapixelsFacet.ranges = [
    "megapixels < 3",
    "megapixels between 3 and 7",
    "megapixels between 7 and 10",
    "megapixels >= 10"
];

facetSetup.rangeFacets = [ cameraFacet, megapixelsFacet ];

await session.store(facetSetup, "facets/CameraFacets");
await session.saveChanges();

const facets = await session
    .query({ indexName: "Camera/Costs" })
    .aggregateUsing("facets/CameraFacets")
    .execute();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Camera/Costs' 
select facet(id('facets/CameraFacets'))
`}
</CodeBlock>
</TabItem>
</Tabs>

## Remarks

<Admonition type="warning" title="">
`aggregateBy()` only supports aggregation by a single field. If you want to aggregate by multiple fields, you need to emit a single field that contains all values.
</Admonition>


</LanguageContent>

<!---
### Session
- [How to Query](../../../client-api/session/querying/how-to-query)

### Indexes
- [Faceted Search](../../../indexes/querying/faceted-search)


-->