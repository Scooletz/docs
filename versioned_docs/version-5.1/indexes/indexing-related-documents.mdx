---
title: "Indexes: Indexing Related Documents"
hide_table_of_contents: true
sidebar_label: Indexing Related Documents
sidebar_position: 11
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["nodejs", "csharp"];


# Indexes: Indexing Related Documents
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="nodejs">


To extend indexing capabilities and simplify many scenarios, we have introduced the possibility for indexing related documents.

## Example I

Let's consider a simple `Product - Category` scenario where you want to look for a `Product` by `Category Name`.

Without this feature, you would have to create a fairly complex multiple map-reduce index. This is why the `LoadDocument` function was introduced.

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="js">
{`class Products_ByCategoryName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Products.Select(product => new {     
            CategoryName = (this.LoadDocument(product.Category, "Categories")).Name 
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="js">
{`const indexDefinition = new IndexDefinition();
indexDefinition.name = "Products/ByCategoryName";
indexDefinition.maps = new Set([
    \`from product in products    
     select new {        
         CategoryName = LoadDocument(product.Category, "Categories").name    
    }\`]);

await store.maintenance.send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we will be able to search for products using the `categoryName` as a parameter:

<TabItem value="indexing_related_documents_7" label="indexing_related_documents_7">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query(\{indexName: "Products/ByCategoryName/NoTracking"\})
    .whereEquals("CategoryName", "Beverages")
    .all();
`}
</CodeBlock>
</TabItem>

## Example II

Our next scenario will show us how indexing of more complex relationships is also trivial. Let's consider the following case:

<TabItem value="indexing_related_documents_4" label="indexing_related_documents_4">
<CodeBlock language="js">
{`class Authors_ByBooks extends AbstractCsharpIndexCreationTask \{
    constructor() \{
        super();

        // For each Book ID, call LoadDocument and index the book's name
        this.map = \`docs.Authors.Select(author => new \{
            BookNames = author.bookIds.Select(x => (this.LoadDocument(x, "Books")).name) 
        \})\`;

        // Since NoTracking was Not specified,
        // then any change to either Authors or Books will trigger reindexing
    \}
\}
`}
</CodeBlock>
</TabItem>

To create an index with `Author Name` and list of `Book Names`, we need do the following:

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="js">
{`class Authors_ByNameAndBooks extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Authors.Select(author => new {     
            name = author.name,     
            books = author.bookIds.Select(x => (this.LoadDocument(x, "Books")).name) 
        })\`;

    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="js">
{`const indexDefinition = new IndexDefinition();
indexDefinition.name = "Authors/ByNameAndBooks";
indexDefinition.maps = new Set([
    \`from author in docs.Authors      
     select new 
     {          
         name = author.name,          
         books = author.bookIds.Select(x => LoadDocument(x, "Books").id)      
     }\`
]);

await store.maintenance.send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="indexing_related_documents_8" label="indexing_related_documents_8">
<CodeBlock language="js">
{`const results = await session
    .query(\{ indexName: "Authors/ByNameAndBooks" \})
    .whereEquals("name", "Andrzej Sapkowski")
    .whereEquals("books", "The Witcher")
    .ofType(Author)
    .all();
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="Info">
Indexes are updated automatically when related documents change.
</Admonition>

<Admonition type="warning" title="Warning">
Using the `LoadDocument` adds a loaded document to the tracking list. This may cause very expensive calculations to occur, especially when multiple documents are tracking the same document.
</Admonition>


</LanguageContent>
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* As described in [modeling considerations in RavenDB](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#summary),  
  it is recommended for documents to be: independent, isolated, and coherent.  
  However, to accommodate varied models, __documents can reference other documents__.  

* The related data from a referenced (related) document can be indexed,  
  this will allow querying the collection by the indexed related data.

* The related documents that are loaded in the index definition are tracked for changes.

* In this page:

   * [What are related documents](../indexes/indexing-related-documents.mdx#what-are-related-documents)


   * [Index related documents](../indexes/indexing-related-documents.mdx#index-related-documents)
     * [Example I - basic](../indexes/indexing-related-documents.mdx#example-i---basic)
     * [Example II - list](../indexes/indexing-related-documents.mdx#example-ii---list)
     * [Tracking implications](../indexes/indexing-related-documents.mdx#tracking-implications)
   * [Document changes that cause re-indexing](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)
   * [LoadDocument Syntax](../indexes/indexing-related-documents.mdx#loaddocument-syntax)
  
</Admonition>

## What are related documents

* Whenever a document references another document, the referenced document is called a __Related Document__.  

* In the image below, document `products/34-A` references documents `categories/1-A` & `suppliers/16-A`,  
  which are considered Related Documents.

![Referencing related documents](./assets/index-related-documents.png)



## Index related documents

<Admonition type="note" title="Note">
#### Example I - basic
__What is tracked__:

* Both the documents from the __indexed collection__ and the __indexed related documents__ are tracked for changes.  
  Re-indexing will be triggered per any change in either collection.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

__The index__:

* Following the above `Product - Category` relationship from the Northwind sample database,  
  an index defined on the Products collection can index data from the related Category document.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="csharp">
{`public class Products_ByCategoryName : AbstractIndexCreationTask<Product>
{
    public class IndexEntry
    {
        public string CategoryName { get; set; }
    }

    public Products_ByCategoryName()
    {
        Map = products => from product in products
            
            // Call LoadDocument to load the related Category document
            // The document ID to load is specified by 'product.Category'
            let category = LoadDocument<Category>(product.Category)
            
            select new IndexEntry
            {
                // Index the Name field from the related Category document
                CategoryName = category.Name
            };
                
            // Any change to either Products or Categories will trigger reindexing 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="csharp">
{`public class Products_ByCategoryName_JS : AbstractJavaScriptIndexCreationTask
{
    public Products_ByCategoryName_JS()
    {
        Maps = new HashSet<string>()
        {
            // Call method 'load' to load the related Category document
            // The document ID to load is specified by 'product.Category'
            // The Name field from the related Category document will be indexed
            
            @"map('products', function(product) {
                let category = load(product.Category, 'Categories')
                return {
                    CategoryName: category.Name
                };
            })"
            
            // Any change to either Products or Categories will trigger reindexing 
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

__The query__:
 
* We can now query the index for Product documents by `CategoryName`,  
  i.e. get all matching Products that reference a Category that has the specified name term.

<Tabs groupId='languageSyntax'>
<TabItem value="Query(sync)" label="Query(sync)">
<CodeBlock language="csharp">
{`IList<Product> matchingProducts = session
    .Query<Products_ByCategoryName.IndexEntry, Products_ByCategoryName>()
    .Where(x => x.CategoryName == "Beverages")
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query(async)" label="Query(async)">
<CodeBlock language="csharp">
{`IList<Product> matchingProducts = await asyncSession
    .Query<Products_ByCategoryName.IndexEntry, Products_ByCategoryName>()
    .Where(x => x.CategoryName == "Beverages")
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="Note">
#### Example II - list
__The documents__:

<TabItem value="indexing_related_documents_3" label="indexing_related_documents_3">
<CodeBlock language="csharp">
{`// The referencing document
public class Author
\{
    public string Id \{ get; set; \}
    public string Name \{ get; set; \}
    
    // Referencing a list of related document IDs
    public List<string> BookIds \{ get; set; \}
\}

// The related document
public class Book
\{
    public string Id \{ get; set; \}
    public string Name \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

__The index__:

* This index will index all names of the related Book documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="csharp">
{`public class Authors_ByBooks : AbstractIndexCreationTask<Author>
{
    public class IndexEntry
    {
        public IEnumerable<string> BookNames { get; set; }
    }

    public Authors_ByBooks()
    {
        Map = authors => from author in authors
            select new IndexEntry
            {
                // For each Book ID, call LoadDocument and index the book's name
                BookNames = author.BookIds.Select(x => LoadDocument<Book>(x).Name)
            };
        
        // Any change to either Authors or Books will trigger reindexing 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="csharp">
{`public class Authors_ByBooks_JS : AbstractJavaScriptIndexCreationTask
{
    public Authors_ByBooks_JS()
    {
        Maps = new HashSet<string>()
        {
            // For each Book ID, call 'load' and index the book's name
            @"map('Author', function(author) {
                return {
                    Books: author.BooksIds.map(x => load(x, 'Books').Name)
                }
            })"
            
            // Any change to either Authors or Books will trigger reindexing 
        };
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

__The query__:

* We can now query the index for Author documents by a book's name,  
  i.e. get all Authors that have the specified book's name in their list.

<Tabs groupId='languageSyntax'>
<TabItem value="Query(sync)" label="Query(sync)">
<CodeBlock language="csharp">
{`// Get all authors that have books with title: "The Witcher"
IList<Author> matchingAuthors = session
    .Query<Authors_ByBooks.IndexEntry, Authors_ByBooks>()
    .Where(x => x.BookNames.Contains("The Witcher"))
    .OfType<Author>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query(async)" label="Query(async)">
<CodeBlock language="csharp">
{`// Get all authors that have books with title: "The Witcher"
IList<Author> matchingAuthors = await asyncSession
    .Query<Authors_ByBooks.IndexEntry, Authors_ByBooks>()
    .Where(x => x.BookNames.Contains("The Witcher"))
    .OfType<Author>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Get all authors that have books with title: "The Witcher"
from index "Authors/ByBooks"
where BookNames = "The Witcher"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="info" title="Info">
#### Tracking implications

* Indexing related data with tracking can be a useful way to query documents by their related data.  
  However, that may come with performance costs.

* __Re-indexing__ will be triggered whenever any document in the collection that is referenced by `LoadDocument` is changed. 
  Even when indexing just a single field from the related document, any change to any other field will cause re-indexing. 
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* Frequent re-indexing will increase CPU usage and reduce performance,  
  and index results may be stale for prolonged periods.

* Tracking indexed related data is more useful when the indexed related collection is known not to change much.

</Admonition>



## Document changes that cause re-indexing

* The following changes done to a document will trigger re-indexing:  

    * Any modification to any document field (not just to the indexed fields)
    * Adding/Deleting an attachment
    * Creating a new Time series (modifying existing will not trigger)
    * Creating a new Counter (modifying existing will not trigger)

* Any such change done either on any document in the __indexed collection__ or in the  __indexed related documents__ will trigger re-indexing.



## LoadDocument syntax

#### Syntax for LINQ-index:

<TabItem value="syntax" label="syntax">
<CodeBlock language="csharp">
{`T LoadDocument<T>(string relatedDocumentId);

T LoadDocument<T>(string relatedDocumentId, string relatedCollectionName);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds, string relatedCollectionName);
`}
</CodeBlock>
</TabItem>

#### Syntax for JavaScript-index:

<TabItem value="syntax_JS" label="syntax_JS">
<CodeBlock language="js">
{`object load(relatedDocumentId, relatedCollectionName);
`}
</CodeBlock>
</TabItem>

| Parameters                |                       |                                        |
|---------------------------|-----------------------|----------------------------------------|
| **relatedDocumentId**     | `string`              | ID of the related document to load     |
| **relatedCollectionName** | `string`              | The related collection name            |
| **relatedDocumentIds**    | `IEnumerable<string>` | A list of related document IDs to load |




</LanguageContent>

<!---
### Indexes
- [Indexing Basics](../indexes/indexing-basics)
- [Indexing Hierarchical Data](../indexes/indexing-hierarchical-data)
- [Indexing Spatial Data](../indexes/indexing-spatial-data)
- [Indexing Polymorphic Data](../indexes/indexing-polymorphic-data)

### Querying
- [Basics](../indexes/querying/basics)


-->