---
title: "Indexes: Dynamic Index Fields"
hide_table_of_contents: true
sidebar_label: Dynamic Fields
sidebar_position: 28
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexes: Dynamic Index Fields
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

* In RavenDB different documents can have different shapes.  
  Documents are schemaless - new fields can be added or removed as needed.

* For such dynamic data, you can define indexes with __dynamic-index-fields__.
  
* This allows querying the index on fields that aren't yet known at index creation time,  
  which is very useful when working on highly dynamic systems.

* Any value type can be indexed, string, number, date, etc.

* An index definition can contain both dynamic-index-fields and regular-index-fields.

* In this page:

  * [Indexing documents fields KEYS](../indexes/using-dynamic-fields.mdx#indexing-documents-fields-keys)
     * [Example - index any field](../indexes/using-dynamic-fields.mdx#example---index-any-field)
  * [Indexing documents fields VALUES](../indexes/using-dynamic-fields.mdx#indexing-documents-fields-values)
     * [Example - basic](../indexes/using-dynamic-fields.mdx#example---basic)
     * [Example - list](../indexes/using-dynamic-fields.mdx#example---list)
  * [CreateField syntax](../indexes/using-dynamic-fields.mdx#createfield-syntax)

</Admonition>

## Indexing documents fields KEYS

<Admonition type="note" title="">
#### Example - index any field
The following allows you to:  

* Index any field that is under the 'Attributes' object from the document.  
* After index is deployed, any new field added to the this object will be indexed as well.
__The document__:
<TabItem value="dynamic_fields_1" label="dynamic_fields_1">
<CodeBlock language="csharp">
{`public class Product
\{
    public string Id \{ get; set; \}
    
    // The KEYS under the Attributes object will be dynamically indexed 
    // Fields added to this object after index creation time will also get indexed
    public Dictionary<string, object> Attributes \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="json" label="json">
<CodeBlock language="json">
{`// Sample document content
\{
    "Attributes": \{
        "Color": "Red",
        "Size": 42
    \}
\}
`}
</CodeBlock>
</TabItem>

__The index__:

* The following index will index any field under the `Attributes` object from the document,  
  a dynamic-index-field will be created for each such field.  
  New fields added to the object after index creation time will be dynamically indexed as well.  

* The actual dynamic-index-field name on which you can query will be the attribute field __key__.  
  e.g. Keys `Color` & `Size` will become the actual dynamic-index-fields.  

<TabItem value="dynamic_fields_2" label="dynamic_fields_2">
<CodeBlock language="csharp">
{`public class Products_ByAttributeKey : AbstractIndexCreationTask<Product>
\{
    public Products_ByAttributeKey()
    \{
        Map = products => from p in products
            select new
            \{
                // Call 'CreateField' to generate dynamic-index-fields from the Attributes object keys
                // Using '_' is just a convention. Any other string can be used instead of '_'
                
                // The actual field name will be item.Key
                // The actual field terms will be derived from item.Value
                _ = p.Attributes.Select(item => CreateField(item.Key, item.Value))
            \};
    \}
\}
`}
</CodeBlock>
</TabItem>

__The query__:

* You can now query the generated dynamic-index fields.  
  Property `_` is Not queryable, it is only used in the index definition syntax.

* To get all documents with some 'Size' use:

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Product> matchingDocuments = session
    .Advanced
    .DocumentQuery<Product, Products_ByAttributeKey>()
     // 'Size' is a dynamic-index-field that was indexed from the Attributes object
    .WhereEquals("Size", 42)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// 'Size' is a dynamic-index-field that was indexed from the Attributes object
from index 'Products/ByAttributeKey' where Size = 42
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



## Indexing documents fields VALUES

<Admonition type="note" title="">
#### Example - basic
This example shows:  

  * Only the __basic concept__ of creating a dynamic-index-field from the __value__ of a document field.  
  * Documents can then be queried based on those indexed values.
  * For a more practical usage see the [Example](../indexes/using-dynamic-fields.mdx#example---index-a-list-of-properties) below.
__The document__:
<TabItem value="dynamic_fields_4" label="dynamic_fields_4">
<CodeBlock language="csharp">
{`public class Product
\{
    public string Id \{ get; set; \}

    // All KEYS in the document will be dynamically indexed 
    // Fields added to the document after index creation time will also get indexed
    public string FirstName \{ get; set; \}
    public string LastName \{ get; set; \}
    public string Title \{ get; set; \}
    // ...
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="json" label="json">
<CodeBlock language="json">
{`// Sample document content
\{
    "ProductType": "Electronics",
    "PricePerUnit": 23
\}
`}
</CodeBlock>
</TabItem>

__The index__:

* The following index will index the __value__ of document field 'ProductType'.

* This value will be the dynamic-index-field name on which you can query.  
  e.g. Field value `Electronics` will be the dynamic-index-field.

<TabItem value="dynamic_fields_5" label="dynamic_fields_5">
<CodeBlock language="csharp">
{`_JS
        public class Products_ByAnyField_JS : AbstractJavaScriptIndexCreationTask
        \{
            public Products_ByAnyField_JS()
            \{
                // This will index EVERY FIELD under the top level of the document
                Maps = new HashSet<string>
                \{
                    @"map('Products', function (p) \{
                          return \{
                              _: Object.keys(p).map(key => createField(key, p[key],
                                  \{ indexing: 'Search', storage: true, termVector: null \}))
                          \}
                     \})"
                \};
            \}
        \}
`}
</CodeBlock>
</TabItem>

__The query__:

* To get all documents of some product type having a specific price per unit use:

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Product> matchingDocuments = session
    .Advanced
    .DocumentQuery<Product, Products_ByProductType>()
     // 'Electronics' is the dynamic-index-field that was indexed from document field 'ProductType'
    .WhereEquals("Electronics", 23)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// 'Electronics' is the dynamic-index-field that was indexed from document field 'ProductType'
from index 'Products/ByProductType' where Electronics = 23
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">
#### Example - list
The following allows you to:

* Index __values__ from items in a list  
* After index is deployed, any item added this list in the document will be dynamically indexed as well.
__The document__:
<TabItem value="dynamic_fields_7" label="dynamic_fields_7">
<CodeBlock language="csharp">
{`public class Product
\{
    public string Id \{ get; set; \}
    
    // The VALUE of ProductType will be dynamically indexed
    public string ProductType \{ get; set; \}
    public int PricePerUnit \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="json" label="json">
<CodeBlock language="json">
{`// Sample document content
\{
    "Name": "SomeName",
    "Attributes": [
       \{  
           "PropName": "Color",
           "PropValue": "Blue"
       \},
       \{
           "PropName": "Width",
           "PropValue": "10"
       \},
       \{
           "PropName": "Length",
           "PropValue": "20"
       \},
       ...
    ]
\}
`}
</CodeBlock>
</TabItem>

__The index__:

* The following index will create a dynamic-index-field per item in the document's `Attributes` list.  
  New items added to the Attributes list after index creation time will be dynamically indexed as well.

* The actual dynamic-index-field name on which you can query will be the item's PropName __value__.  
  e.g. 'PropName' value `Width` will be a dynamic-index-field.

<TabItem value="dynamic_fields_8" label="dynamic_fields_8">
<CodeBlock language="csharp">
{`public class Products_ByProductType : AbstractIndexCreationTask<Product>
\{
    public Products_ByProductType()
    \{
        Map = products => from p in products
            select new
            \{
                // Call 'CreateField' to generate the dynamic-index-fields
                // The field name will be the value of document field 'ProductType'
                // The field terms will be derived from document field 'PricePerUnit'
                _ = CreateField(p.ProductType, p.PricePerUnit)
            \};
    \}
\}
`}
</CodeBlock>
</TabItem>

__The query__:

* To get all documents matching a specific attribute property use:

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Product> matchingDocuments = session
    .Advanced
    .DocumentQuery<Product, Attributes_ByName>()
     // 'Width' is a dynamic-index-field that was indexed from the Attributes list
    .WhereEquals("Width", 10)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// 'Width' is a dynamic-index-field that was indexed from the Attributes list
from index 'Attributes/ByName' where Width = 10
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>


## CreateField syntax

<TabItem value="syntax" label="syntax">
<CodeBlock language="csharp">
{`object CreateField(string name, object value);

object CreateField(string name, object value, bool stored, bool analyzed);

object CreateField(string name, object value, CreateFieldOptions options);
`}
</CodeBlock>
</TabItem>

| Parameters       |                      |                                                                                                                                                                                    |
|------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **fieldName**    | `string`             | Name of the dynamic-index-field                                                                                                                                                    |
| **fieldValue**   | `object`             | Value of the dynamic-index-field
The field Terms are derived from this value.                                                                                                  |
| **stored**       | `bool`               | Sets [FieldStorage](../indexes/storing-data-in-index.mdx)

`false` - will set `FieldStorage.No` (default value)
`true` - will set `FieldStorate.Yes`                       |
| **analyzed**     | `bool`               | Sets [FieldIndexing](../indexes/using-analyzers.mdx)

`null` - `FieldIndexing.Default` (default value)
`false` - `FieldIndexing.Exact`
`true` - `FieldIndexing.Search` |
| **options**      | `CreateFieldOptions` | Dynamic-index-field options                                                                                                                                                        |

| CreateFieldOptions |                    |                                                                            |
|--------------------|--------------------|----------------------------------------------------------------------------|
| **Storage**        | `FieldStorage?`    | Learn about [storing data](../indexes/storing-data-in-index.mdx) in the index. |
| **Indexing**       | `FieldIndexing?`   | Learn about [using analyzers](../indexes/using-analyzers.mdx) in the index.    |
| **TermVector**     | `FieldTermVector?` | Learn about [term vectors](../indexes/using-term-vectors.mdx) in the index.    |

<Admonition type="info" title="">

* All above examples have used the character `_` in the dynamic-index-field definition.  
  However, using `_` is just a convention. Any other string can be used instead.

* This property is Not queryable, it is only used in the index definition syntax.  
  The actual dynamic-index-fields that are generated are defined by the `CreateField` method.

</Admonition>




</LanguageContent>
<LanguageContent language="java">


<Admonition type="note" title="">

* In RavenDB different documents can have different shapes.  
  Documents are schemaless - new fields can be added or removed as needed.

* For such dynamic data, you can define indexes with __dynamic-index-fields__.

* This allows querying the index on fields that aren't yet known at index creation time,  
  which is very useful when working on highly dynamic systems.

* Any value type can be indexed, string, number, date, etc.

* An index definition can contain both dynamic-index-fields and regular-index-fields.

</Admonition>
RavenDB exposes an indexing API for creating fields dynamically.

With this feature, you can search for documents using fields which are created on the fly.  
For example, consider a `Product` object that is declared as follows:

<TabItem value="dynamic_fields_1" label="dynamic_fields_1">
<CodeBlock language="java">
{`public class Product \{
    private String id;

    // The KEYS under the attributes object will be dynamically indexed
    // Fields added to this object after index creation time will also get indexed
    private Dictionary<String, Object> attributes;

    // get + set implementation ...
\}
`}
</CodeBlock>
</TabItem>

Properties such as color or size are added only to some products, while other ones can have the weight and volume defined. Since `Attribute` has String fields, they can specify very different properties of products.
In order to query on fields which aren't known at index creation time, we introduced the ability to create them dynamically during indexing.

The following index can be created in order to index each attribute value under its name as a separate field:

<TabItem value="dynamic_fields_2" label="dynamic_fields_2">
<CodeBlock language="java">
{`_JS
        public class Products_ByAttributeKey_JS extends AbstractJavaScriptIndexCreationTask \{
            public Products_ByAttributeKey_JS() \{
                // Call 'createField' to generate dynamic-index-fields from the attributes object keys
                // Using '_' is just a convention. Any other string can be used instead of '_'

                // The actual field name will be the key
                // The actual field terms will be derived from p.attributes[key]
                setMaps(Sets.newHashSet(
                    "map('Products', function (p) \{ " +
                    "    return \{ " +
                    "        _: Object.keys(p.attributes).map(key => createField(key, p.attributes[key], " +
                    "            \{ indexing: 'Search', storage: false, termVector: null \})) " +
                    "    \}; " +
                    "\}) "
                ));
            \}
        \}
`}
</CodeBlock>
</TabItem>

The `_` character used as the field name in the mapping definition is just a convention. You can use any name, it won't be used by the index anyway. The actual field name
that you want to query by is defined in `CreateField(...)`. It will generate an index field based on the properties of indexed documents and passed parameters 

The index can have more fields defined, just like in any other ordinary index.


## Syntax

<TabItem value="syntax" label="syntax">
<CodeBlock language="java">
{`object CreateField(string name, object value);

object CreateField(string name, object value, bool stored, bool analyzed);

object CreateField(string name, object value, CreateFieldOptions options);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **name** | `String` | Name of the dynamic field |
| **value** | `Object` | Value of the dynamic field |
| **stored** | `boolean` | Sets [FieldStorage](../indexes/storing-data-in-index.mdx). By default value is set to `false` which equals to `FieldStorage.No`. |
| **analyzed** | `boolean` | Sets [FieldIndexing](../indexes/using-analyzers.mdx).

Values:
`null` - `FieldIndexing.Default` (set by overloads without this 'parameter')
`false` - `FieldIndexing.Exact`
`true` - `FieldIndexing.Search` |
| **options** | `CreateFieldOptions` | Dynamic field options |

### Options

| CreateFieldOptions | | |
| ------------- | ------------- | ----- |
| **Storage** | `FieldStorage` | More information about storing data in index can be found [here](../indexes/storing-data-in-index.mdx). |
| **Indexing** | `FieldIndexing` | More information about analyzers in index can be found [here](../indexes/using-analyzers.mdx). |
| **TermVector** | `FieldTermVector` | More information about term vectors in index can be found [here](../indexes/using-term-vectors.mdx). |

## Example

Looking for products by attributes with the usage of such a defined index is supported as if it were real object properties:

<TabItem value="dynamic_fields_4" label="dynamic_fields_4">
<CodeBlock language="java">
{`public class Product \{
    private String id;

    // All KEYS in the document will be dynamically indexed
    // Fields added to the document after index creation time will also get indexed
    private String firstName;
    private String lastName;
    private String title;
    // ...

    // get + set implementation ...
\}
`}
</CodeBlock>
</TabItem>

<Admonition type="info" title="">
All types of values are supported by dynamically created fields. They can be numbers, dates, etc.
</Admonition>


</LanguageContent>
<LanguageContent language="nodejs">


<Admonition type="note" title="">

* In RavenDB different documents can have different shapes.  
  Documents are schemaless - new fields can be added or removed as needed.

* For such dynamic data, you can define indexes with __dynamic-index-fields__.

* This allows querying the index on fields that aren't yet known at index creation time,  
  which is very useful when working on highly dynamic systems.

* Any value type can be indexed, string, number, date, etc.

* An index definition can contain both dynamic-index-fields and regular-index-fields.

</Admonition>
RavenDB exposes an indexing API for creating fields dynamically.

With this feature, you can search for documents using fields which are created on the fly.  
For example, consider a `Product` object that is declared as follows:

<TabItem value="dynamic_fields_1" label="dynamic_fields_1">
<CodeBlock language="js">
{`class Product \{
    constructor(id, attributes) \{
        this.id = id;

        // The KEYS under the attributes object will be dynamically indexed 
        // Fields added to this object after index creation time will also get indexed
        this.attributes = attributes;
    \}
\}
`}
</CodeBlock>
</TabItem>

Properties such as color or size are added only to some products, while other ones can have the weight and volume defined. Since `Attribute` has string fields, they can specify very different properties of products.
In order to query on fields which aren't known at index creation time, we introduced the ability to create them dynamically during indexing.

The following index can be created in order to index each attribute value under its name as a separate field:

<TabItem value="dynamic_fields_2" label="dynamic_fields_2">
<CodeBlock language="js">
{`_JS
    class Products_ByAttributeKey_JS extends AbstractJavaScriptIndexCreationTask \{
        constructor() \{
            super();

            const \{ createField \} = this.mapUtils();

            this.map("Products", p => \{
                return \{
                    // Call 'createField' to generate dynamic-index-fields from the attributes object keys
                    // Using '_' is just a convention. Any other string can be used instead of '_'

                    // The actual field name will be the key
                    // The actual field terms will be derived from p.attributes[key]
                    _: Object.keys(p.attributes).map(key => createField(key, p.attributes[key], \{
                        indexing: "Search",
                        storage: false,
                        termVector: null
                    \}))
                \};
            \});
        \}
    \}
`}
</CodeBlock>
</TabItem>

The `_` character used as the field name in the mapping definition is just a convention. You can use any name, it won't be used by the index anyway. The actual field name
that you want to query by is defined in `CreateField(...)`. It will generate an index field based on the properties of indexed documents and passed parameters 

The index can have more fields defined, just like in any other ordinary index.

## Syntax

<TabItem value="syntax" label="syntax">
<CodeBlock language="js">
{`_JS
    createField(fieldName, fieldValue, options); // returns object
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **name** | `string` | Name of the dynamic field |
| **value** | `object` | Value of the dynamic field |
| **stored** | `boolean` | Sets [FieldStorage](../indexes/storing-data-in-index.mdx). By default value is set to `false` which equals to `FieldStorage.No`. |
| **analyzed** | `boolean` | Sets [FieldIndexing](../indexes/using-analyzers.mdx).

Values:
`null` - `FieldIndexing.Default` (set by overloads without this 'parameter')
`false` - `FieldIndexing.Exact`
`true` - `FieldIndexing.Search` |
| **options** | `CreateFieldOptions` | Dynamic field options |

### Options

| CreateFieldOptions | | |
| ------------- | ------------- | ----- |
| **Storage** | `FieldStorage?` | More information about storing data in index can be found [here](../indexes/storing-data-in-index.mdx). |
| **Indexing** | `FieldIndexing?` | More information about analyzers in index can be found [here](../indexes/using-analyzers.mdx). |
| **TermVector** | `FieldTermVector?` | More information about term vectors in index can be found [here](../indexes/using-term-vectors.mdx). |

#### Querying

Looking for products by attributes with the usage of such a defined index is supported as if it were real object properties:

<TabItem value="dynamic_fields_4" label="dynamic_fields_4">
<CodeBlock language="js">
{`class Product \{
    constructor(id, firstName, lastName, title) \{
        this.id = id;

        // All KEYS in the document will be dynamically indexed 
        // Fields added to the document after index creation time will also get indexed
        this.firstName = firstName;
        this.lastName = lastName;
        this.title = title;
        // ...
    \}
\}
`}
</CodeBlock>
</TabItem>



</LanguageContent>

<!---
### Indexes
- [Boosting](../indexes/boosting)
- [Analyzers](../indexes/using-analyzers)
- [Storing Data in Index](../indexes/storing-data-in-index)
- [Term Vectors](../indexes/using-term-vectors)


-->