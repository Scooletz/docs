import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

To extend indexing capabilities and simplify many scenarios, we have introduced the possibility for indexing related documents.

## Example I

Let's consider a simple `Product - Category` scenario where you want to look for a `Product` by `Category Name`.

Without this feature, you would have to create a fairly complex multiple map-reduce index. This is why the `LoadDocument` function was introduced.

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="js">
{`class Products_ByCategoryName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Products.Select(product => new {     
            CategoryName = (this.LoadDocument(product.Category, "Categories")).Name 
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="js">
{`const indexDefinition = new IndexDefinition();
indexDefinition.name = "Products/ByCategoryName";
indexDefinition.maps = new Set([
    \`from product in products    
     select new {        
         CategoryName = LoadDocument(product.Category, "Categories").name    
    }\`]);

await store.maintenance.send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we will be able to search for products using the `categoryName` as a parameter:

<TabItem value="indexing_related_documents_7" label="indexing_related_documents_7">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query(\{indexName: "Products/ByCategoryName/NoTracking"\})
    .whereEquals("CategoryName", "Beverages")
    .all();
`}
</CodeBlock>
</TabItem>

## Example II

Our next scenario will show us how indexing of more complex relationships is also trivial. Let's consider the following case:

<TabItem value="indexing_related_documents_4" label="indexing_related_documents_4">
<CodeBlock language="js">
{`class Authors_ByBooks extends AbstractCsharpIndexCreationTask \{
    constructor() \{
        super();

        // For each Book ID, call LoadDocument and index the book's name
        this.map = \`docs.Authors.Select(author => new \{
            BookNames = author.bookIds.Select(x => (this.LoadDocument(x, "Books")).name) 
        \})\`;

        // Since NoTracking was Not specified,
        // then any change to either Authors or Books will trigger reindexing
    \}
\}
`}
</CodeBlock>
</TabItem>

To create an index with `Author Name` and list of `Book Names`, we need do the following:

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="js">
{`class Authors_ByNameAndBooks extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Authors.Select(author => new {     
            name = author.name,     
            books = author.bookIds.Select(x => (this.LoadDocument(x, "Books")).name) 
        })\`;

    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="js">
{`const indexDefinition = new IndexDefinition();
indexDefinition.name = "Authors/ByNameAndBooks";
indexDefinition.maps = new Set([
    \`from author in docs.Authors      
     select new 
     {          
         name = author.name,          
         books = author.bookIds.Select(x => LoadDocument(x, "Books").id)      
     }\`
]);

await store.maintenance.send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="indexing_related_documents_8" label="indexing_related_documents_8">
<CodeBlock language="js">
{`const results = await session
    .query(\{ indexName: "Authors/ByNameAndBooks" \})
    .whereEquals("name", "Andrzej Sapkowski")
    .whereEquals("books", "The Witcher")
    .ofType(Author)
    .all();
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="">
Indexes are updated automatically when related documents change.
</Admonition>

<Admonition type="warning" title="">
Using the `LoadDocument` adds a loaded document to the tracking list. This may cause very expensive calculations to occur, especially when multiple documents are tracking the same document.
</Admonition>


