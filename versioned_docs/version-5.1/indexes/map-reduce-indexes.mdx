---
title: "Indexes: Map-Reduce Indexes"
hide_table_of_contents: true
sidebar_label: Map-Reduce Indexes
sidebar_position: 7
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "nodejs"];


# Indexes: Map-Reduce Indexes
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="">

* **Map-Reduce indexes** allow you to perform complex ***data aggregation*** that can be queried on with very little cost, 
  regardless of the data size.  

* To expedite queries and prevent performance degradation during queries, the aggregation is done during the indexing phase, _not_ at query time.  

* Once new data comes into the database, or existing documents are modified,  
  the Map-Reduce index will re-calculate the aggregated data  
  so that the aggregation results are always available and up-to-date.  

* The aggregation computation is done in two separate consecutive actions: the `Map` and the `Reduce`.  
  * **The Map stage:**  
    This first stage runs the defined Map function(s) on each document, indexing the specified fields.  
  * **The Reduce stage:**  
    This second stage groups the specified requested fields that were indexed in the Map stage,  
    and then runs the Reduce function to get a final aggregation result per field value.  

For a more in-depth look at how map-reduce works, you can read this post: [RavenDB 4.0 Unsung Heroes: Map/reduce](https://ayende.com/blog/179938/ravendb-4-0-unsung-heroes-map-reduce).

* In this page: 
  * [Creating Map Reduce Indexes](../indexes/map-reduce-indexes.mdx#creating-map-reduce-indexes)
  * [Creating Multi-Map-Reduce Indexes](../indexes/map-reduce-indexes.mdx#creating-multi-map-reduce-indexes)
  * [Reduce Results as Artificial Documents](../indexes/map-reduce-indexes.mdx#reduce-results-as-artificial-documents)

</Admonition>

## Creating Map Reduce Indexes

When it comes to index creation, the only difference between simple indexes and the map-reduce ones is an additional 
reduce function defined in the index definition. 
To deploy an index we need to create a definition and deploy it using one of the ways described in the 
[creating and deploying](../indexes/creating-and-deploying.mdx) article.
### Example I - Count

Let's assume that we want to count the number of products for each category. To do it, we can create the following index using `LoadDocument` inside:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="csharp">
{`public class Products_ByCategory : AbstractIndexCreationTask<Product, Products_ByCategory.Result>
{
    public class Result
    {
        public string Category { get; set; }

        public int Count { get; set; }
    }

    public Products_ByCategory()
    {
        Map = products => from product in products
                          let categoryName = LoadDocument<Category>(product.Category).Name
                          select new
                          {
                              Category = categoryName,
                              Count = 1
                          };

        Reduce = results => from result in results
                            group result by result.Category into g
                            select new
                            {
                                Category = g.Key,
                                Count = g.Sum(x => x.Count)
                            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="csharp">
{`public class Products_ByCategory : AbstractJavaScriptIndexCreationTask
{
    public class Result
    {
        public string Category { get; set; }

        public int Count { get; set; }
    }

    public Products_ByCategory()
    {
        Maps = new HashSet<string>()
        {
            @"map('products', function(p){
                return {
                    Category: load(p.Category, 'Categories').Name,
                    Count: 1
                }
            })"
        };

        Reduce = @"groupBy(x => x.Category)
                    .aggregate(g => {
                        return {
                            Category: g.key,
                            Count: g.values.reduce((count, val) => val.Count + count, 0)
                        };
                    })";
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

and issue the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Products_ByCategory.Result> results = session
    .Query<Products_ByCategory.Result, Products_ByCategory>()
    .Where(x => x.Category == "Seafood")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Products_ByCategory.Result> results = session
    .Advanced
    .DocumentQuery<Products_ByCategory.Result, Products_ByCategory>()
    .WhereEquals(x => x.Category, "Seafood")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Products/ByCategory'
where Category == 'Seafood'
`}
</CodeBlock>
</TabItem>
</Tabs>

The above query will return one result for _Seafood_ with the appropriate number of products from that category.
### Example II - Average

In this example, we will count an average product price for each category. The index definition:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="csharp">
{`public class Products_Average_ByCategory :
    AbstractIndexCreationTask<Product, Products_Average_ByCategory.Result>
{
    public class Result
    {
        public string Category { get; set; }

        public decimal PriceSum { get; set; }

        public double PriceAverage { get; set; }

        public int ProductCount { get; set; }
    }

    public Products_Average_ByCategory()
    {
        Map = products => from product in products
                          let categoryName = LoadDocument<Category>(product.Category).Name
                          select new
                          {
                              Category = categoryName,
                              PriceSum = product.PricePerUnit,
                              PriceAverage = 0,
                              ProductCount = 1
                          };

        Reduce = results => from result in results
                            group result by result.Category into g
                            let productCount = g.Sum(x => x.ProductCount)
                            let priceSum = g.Sum(x => x.PriceSum)
                            select new
                            {
                                Category = g.Key,
                                PriceSum = priceSum,
                                PriceAverage = priceSum / productCount,
                                ProductCount = productCount
                            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="csharp">
{`public class Products_Average_ByCategory :
                        AbstractJavaScriptIndexCreationTask
{
    public class Result
    {
        public string Category { get; set; }

        public decimal PriceSum { get; set; }

        public double PriceAverage { get; set; }

        public int ProductCount { get; set; }
    }

    public Products_Average_ByCategory()
    {
        Maps = new HashSet<string>()
        {
            @"map('products', function(product){
                return {
                    Category: load(product.Category, 'Categories').Name,
                    PriceSum: product.PricePerUnit,
                    PriceAverage: 0,
                    ProductCount: 1
                }
            })"
        };

        Reduce = @"groupBy(x => x.Category)
                    .aggregate(g => {
                        var pricesum = g.values.reduce((sum,x) => x.PriceSum + sum,0);
                        var productcount = g.values.reduce((sum,x) => x.ProductCount + sum,0);
                        return {
                            Category: g.key,
                            PriceSum: pricesum,
                            ProductCount: productcount,
                            PriceAverage: pricesum / productcount
                        }
                    })";
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

and the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Products_Average_ByCategory.Result> results = session
    .Query<Products_Average_ByCategory.Result, Products_Average_ByCategory>()
    .Where(x => x.Category == "Seafood")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Products_Average_ByCategory.Result> results = session
    .Advanced
    .DocumentQuery<Products_Average_ByCategory.Result, Products_Average_ByCategory>()
    .WhereEquals(x => x.Category, "Seafood")
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Products/Average/ByCategory'
where Category == 'Seafood'
`}
</CodeBlock>
</TabItem>
</Tabs>
### Example III - Calculations

This example illustrates how we can put some calculations inside an index using one of the indexes available in the sample database (`Product/Sales`).

We want to know how many times each product was ordered and how much we earned for it. In order to extract that information, we need to define the following index:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="csharp">
{`public class Product_Sales : AbstractIndexCreationTask<Order, Product_Sales.Result>
{
    public class Result
    {
        public string Product { get; set; }

        public int Count { get; set; }

        public decimal Total { get; set; }
    }

    public Product_Sales()
    {
        Map = orders => from order in orders
                        from line in order.Lines
                        select new
                        {
                            Product = line.Product,
                            Count = 1,
                            Total = ((line.Quantity * line.PricePerUnit) * (1 - line.Discount))
                        };

        Reduce = results => from result in results
                            group result by result.Product into g
                            select new
                            {
                                Product = g.Key,
                                Count = g.Sum(x => x.Count),
                                Total = g.Sum(x => x.Total)
                            };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="csharp">
{`public class Product_Sales : AbstractJavaScriptIndexCreationTask
{
    public class Result
    {
        public string Product { get; set; }

        public int Count { get; set; }

        public decimal Total { get; set; }
    }

    public Product_Sales()
    {
        Maps = new HashSet<string>()
        {
            @"map('orders', function(order){
                    var res = [];
                    order.Lines.forEach(l => {
                        res.push({
                            Product: l.Product,
                            Count: 1,
                            Total:  (l.Quantity * l.PricePerUnit) * (1- l.Discount)
                        })
                    });
                    return res;
                })"
        };

        Reduce = @"groupBy(x => x.Product)
            .aggregate(g => {
                return {
                    Product : g.key,
                    Count: g.values.reduce((sum, x) => x.Count + sum, 0),
                    Total: g.values.reduce((sum, x) => x.Total + sum, 0)
                }
            })";
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

and send the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<Product_Sales.Result> results = session
    .Query<Product_Sales.Result, Product_Sales>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<Product_Sales.Result> results = session
    .Advanced
    .DocumentQuery<Product_Sales.Result, Product_Sales>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Product/Sales'
`}
</CodeBlock>
</TabItem>
</Tabs>



## Creating Multi-Map-Reduce Indexes

A **Multi-Map-Reduce** index allows aggregating (or 'reducing') data from several collections.  

They can be created and edited via [Studio](../studio/database/indexes/create-map-reduce-index.mdx#multi-map-reduce), or with API as shown below.  

In the following code sample, we want the number of companies, suppliers, and employees per city.  
We define the map phase on collections 'Employees', 'Companies', and 'Suppliers'.  
We then define the reduce phase.  

<TabItem value="multi_map_reduce_LINQ" label="multi_map_reduce_LINQ">
<CodeBlock language="csharp">
{`public class Cities_Details :
  AbstractMultiMapIndexCreationTask<Cities_Details.IndexEntry>
\{
    public class IndexEntry
    \{
        public string City;
        public int Companies, Employees, Suppliers;
    \}

    public Cities_Details()
    \{
        // Map employees collection.
        AddMap<Employee>(employees =>
            from e in employees
            select new IndexEntry
            \{
                City = e.Address.City,
                Companies = 0,
                Suppliers = 0,
                Employees = 1
            \}
        );

        // Map companies collection.
        AddMap<Company>(companies =>
            from c in companies
            select new IndexEntry
            \{
                City = c.Address.City,
                Companies = 1,
                Suppliers = 0,
                Employees = 0
            \}
        );

        // Map suppliers collection.
        AddMap<Supplier>(suppliers =>
            from s in suppliers
            select new IndexEntry
            \{
                City = s.Address.City,
                Companies = 0,
                Suppliers = 1,
                Employees = 0
            \}
        );

        // Apply reduction/aggregation on multi-map results.
        Reduce = results =>
            from result in results
            group result by result.City
            into g
            select new IndexEntry
            \{
                City = g.Key,
                Companies = g.Sum(x => x.Companies),
                Suppliers = g.Sum(x => x.Suppliers),
                Employees = g.Sum(x => x.Employees)
            \};
    \}
\}
`}
</CodeBlock>
</TabItem>

A query on the index:

<TabItem value="multi-map-reduce-index-query" label="multi-map-reduce-index-query">
<CodeBlock language="csharp">
{`// Queries the index "Cities_Details" - filters "Companies" results and orders by "City".
IList<Cities_Details.IndexEntry> commerceDetails = session
    .Query<Cities_Details.IndexEntry, Cities_Details>()
    .Where(doc => doc.Companies > 5)
    .OrderBy(x => x.City)
    .ToList();
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="">
You can see this sample described in detail in [Inside RavenDB - Multi-Map-Reduce Indexes](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/11-mapreduce-and-aggregations-in-ravendb#multimapreduce-indexes).
</Admonition>



## Reduce Results as Artificial Documents

#### Map-Reduce Output Documents

In addition to storing the aggregation results in the index, the map-reduce index can also output 
those reduce results as documents to a specified collection. In order to create these documents, 
called _"artificial",_ you need to define the target collection using the `OutputReduceToCollection` 
property in the index definition.  

Writing map-reduce outputs into documents allows you to define additional indexes on top of them 
that give you the option to create recursive map-reduce operations. This makes it cheap and easy 
to, for example, recursively create daily, monthly, and yearly summaries on the same data.  

In addition, you can also apply the usual operations on artificial documents (e.g. data 
subscriptions or ETL).  

If the aggregation value for a given reduce key changes, we overwrite the output document. If the 
given reduce key no longer has a result, the output document will be removed.  

#### Reference Documents

To help organize these output documents, the map-reduce index can also create an additional 
collection of artificial _reference documents_. These documents aggregate the output documents 
and store their document IDs in an array field `ReduceOutputs`.  

The document IDs of reference documents are customized to follow some pattern. The format you 
give to their document ID also determines how the output documents are grouped.  

Because reference documents have well known, predictable IDs, they are easier to plug into 
indexes and other operations, and can serve as an intermediary for the output documents whose 
IDs are less predictable. This allows you to chain map-reduce indexes in a recursive fashion, 
see [Example II](../indexes/map-reduce-indexes.mdx#example-ii).  

Learn more about how to configure output and reference documents in the 
[Studio: Create Map-Reduce Index](../studio/database/indexes/create-map-reduce-index.mdx).  
### Artificial Document Properties  

#### IDs

The identifiers of **map reduce output documents** have three components in this format:  

`<Output collection name>/<incrementing value>/<hash of reduce key values>`  

The index in [Example I](../indexes/map-reduce-indexes.mdx#example-i) might generate an output document 
ID like this:  

`DailyProductSales/35/14369232530304891504`  

* "DailyProductSales" is the collection name specified for the output documents.  
* The middle part is an incrementing integer assigned by the server. This number grows by some 
amount whenever the index definition is modified. This can be useful because when an index definition 
changes, there is a brief transition phase when the new output documents are being created, but the 
old output documents haven't been deleted yet (this phase is called 
["side-by-side indexing"](../studio/database/indexes/indexes-list-view.mdx#indexes-list-view---side-by-side-indexing)). 
During this phase, the output collection contains output documents created both by the old version 
and the new version of the index, and they can be distinguished by this value: the new output 
documents will always have a higher value (by 1 or more).  
* The last part of the document ID (the unique part) is the hash of the reduce key values - in this 
case: `hash(Product, Month)`.  

The identifiers of **reference documents** follow some pattern you choose, and this pattern 
determines which output documents are held by a given reference document.  

The index in [Example I](../indexes/map-reduce-indexes.mdx#example-i) has this pattern for reference documents:  

`sales/daily/{Date:yyyy-MM-dd}`

And this produces reference document IDs like this:

`sales/daily/1998-05-06`

The pattern is built using the same syntax as 
[the `StringBuilder.AppendFormat` method](https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.appendformat). 
See [here](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings) 
to learn about the date formatting in particular.  
#### Metadata

Artificial documents generated by map-reduce indexes get the following `@flags` in their metadata:  

<TabItem value="json" label="json">
<CodeBlock language="json">
{`"@flags": "Artificial, FromIndex"
`}
</CodeBlock>
</TabItem>

These flags are used internally by the database to filter out artificial documents during replication.  
### Syntax

The map-reduce output documents are configured with these properties of 
`IndexDefinition`:  

<TabItem value="syntax_0" label="syntax_0">
<CodeBlock language="csharp">
{`string OutputReduceToCollection;

string PatternReferencesCollectionName;

// Using IndexDefinition
string PatternForOutputReduceToCollectionReferences;

// Inheriting from AbstractGenericIndexCreationTask<TReduceResult>
Expression<Func<TReduceResult, string>> PatternForOutputReduceToCollectionReferences;
`}
</CodeBlock>
</TabItem>

| Parameters | Type | Description |
| - | - | - |
| **OutputReduceToCollection** | `string` | Collection name for the output documents. |
| **PatternReferencesCollectionName** | `string` | Optional collection name for the reference documents - by default it is `<OutputReduceToCollection>/References`. |
| **PatternForOutputReduceToCollectionReferences** | `string` / `Expression<Func<TReduceResult, string>>` | Document ID format for reference documents. This ID references the fields of the reduce function output, which determines how the output documents are aggregated. The type of this parameter is different depending on if the index is created using [IndexDefinition](../indexes/creating-and-deploying.mdx#using-maintenance-operations) or [AbstractIndexCreationTask](../indexes/creating-and-deploying.mdx#using-abstractindexcreationtask). |

To index artificial documents in strongly typed syntax (LINQ), you will need the 
type of reference documents:

<TabItem value="syntax_1" label="syntax_1">
<CodeBlock language="csharp">
{`public class OutputReduceToCollectionReference
\{
    public string Id \{ get; set; \}
    public List<string> ReduceOutputs \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

| Parameters | Type | Description |
| - | - | - |
| **Id** | `string` | The reference document's ID |
| **ReduceOutputs** | `List<string>` | List of map-reduce output documents that this reference document aggregates. Determined by the pattern of the reference document ID. |
### Examples

#### Example I

Here is a map-reduce index with output documents and reference documents:  

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="csharp">
{`public Product_Sales_ByDate()
{
    Map = orders => from order in orders
                    from line in order.Lines
                    select new
                    {
                        Product = line.Product,
                        Date = new DateTime(order.OrderedAt.Year,
                                            order.OrderedAt.Month,
                                            order.OrderedAt.Day),
                        Count = 1,
                        Total = ((line.Quantity * line.PricePerUnit) * (1 - line.Discount))
                    };

    Reduce = results => from result in results
                        group result by new { result.Product, result.Date } into g
                        select new
                        {
                            Product = g.Key.Product,
                            Date = g.Key.Date,
                            Count = g.Sum(x => x.Count),
                            Total = g.Sum(x => x.Total)
                        };

    OutputReduceToCollection = "DailyProductSales";
    PatternReferencesCollectionName = "DailyProductSales/References";
    PatternForOutputReduceToCollectionReferences = x => $"sales/daily/{x.Date:yyyy-MM-dd}";
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="csharp">
{`public class Product_Sales_ByMonth : AbstractJavaScriptIndexCreationTask
{
    public class Result
    {
        public string Product { get; set; }

        public DateTime Month { get; set; }

        public int Count { get; set; }

        public decimal Total { get; set; }
    }

    public Product_Sales_ByMonth()
    {
        Maps = new HashSet<string>()
        {
            @"map('orders', function(order){
                    var res = [];
                    order.Lines.forEach(l => {
                        res.push({
                            Product: l.Product,
                            Month: new Date( (new Date(order.OrderedAt)).getFullYear(),(new Date(order.OrderedAt)).getMonth(),1),
                            Count: 1,
                            Total: (l.Quantity * l.PricePerUnit) * (1- l.Discount)
                        })
                    });
                    return res;
                })"
            };

        Reduce = @"groupBy(x => ({Product: x.Product, Month: x.Month}))
            .aggregate(g => {
            return {
                Product: g.key.Product,
                Month: g.key.Month,
                Count: g.values.reduce((sum, x) => x.Count + sum, 0),
                Total: g.values.reduce((sum, x) => x.Total + sum, 0)
            }
        })";

        OutputReduceToCollection = "MonthlyProductSales";
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

In the **LINQ** index example above (which inherits `AbstractIndexCreationTask`), 
the reference document ID pattern is set with a lambda expression:  

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`PatternForOutputReduceToCollectionReferences = x => $"sales/daily/\{x.Date:yyyy-MM-dd\}";
`}
</CodeBlock>
</TabItem>  

This gives the reference documents IDs in this general format: `sales/monthly/1998-05-01`. 
The reference document with that ID contains the IDs of all the output documents from the 
month of May 1998.  


In the **JavaScript** index example (which uses `IndexDefinition`), 
the reference document ID pattern is set with a `string`:  

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`PatternForOutputReduceToCollectionReferences = "sales/daily/\{Date:yyyy-MM-dd\}"
`}
</CodeBlock>
</TabItem>  

This gives the reference documents IDs in this general format: `sales/daily/1998-05-06`. 
The reference document with that ID contains the IDs of all the output documents from 
May 6th 1998.  
#### Example II

This is an example of a "recursive" map-reduce index - it indexes the output documents 
of the index above, using the reference documents.  

<TabItem value="map_reduce_4_0" label="map_reduce_4_0">
<CodeBlock language="csharp">
{`public class NumberOfOrders_ByProduct : AbstractIndexCreationTask<DailyProductSale, OutputDocument>
\{
    public NumberOfOrders_ByProduct()
    \{
        Map = dailyProductSales => from sale in dailyProductSales
              let referenceDocuments = LoadDocument<OutputReduceToCollectionReference>(
                                       $"sales/daily/\{sale.Date:yyyy-MM-dd\}",
                                       "DailyProductSales/References")
                  
              from refDoc in referenceDocuments.ReduceOutputs
              let outputDoc = LoadDocument<OutputDocument>(refDoc)
              select new OutputDocument
              \{
                  Product = outputDoc.Product,
                  Count = outputDoc.Count,
                  NumOrders = 1
              \};

        Reduce = results => from r in results
                 group r by new \{ r.Count, r.Product \} into g
                 select new OutputDocument
                 \{
                     Product = g.Key.Product,
                     Count = g.Key.Count,
                     NumOrders = g.Sum(x => x.NumOrders)
                 \};
    \}
\}

public class OutputDocument \{
    public string Product;
    public int Count;
    public int NumOrders;
\}

public class OutputReduceToCollectionReference
\{
    public string Id \{ get; set; \}
    public List<string> ReduceOutputs \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

## Important Comments

#### Saving documents
[Artificial documents](../indexes/map-reduce-indexes.mdx#reduce-results-as-artificial-documents) 
are stored immediately after the indexing transaction completes.  

#### Recursive indexing loop
It is **forbidden** to output reduce results to collections such as the following:  

- A collection that the current index is already working on.  
  E.g., an index on a `DailyInvoices` collection outputs to `DailyInvoices`.  
- A collection that the current index is loading a document from.  
  E.g., an index with `LoadDocument(id, "Invoices")` outputs to `Invoices`.  
- Two collections, each processed by a map-reduce indexes,  
  when each index outputs to the second collection.  
  E.g.,  
  An index on the `Invoices` collection outputs to the `DailyInvoices` collection,  
  while an index on `DailyInvoices` outputs to `Invoices`.  

When an attempt to create such an infinite indexing loop is 
detected a detailed error is generated.  

#### Output to an Existing collection
Creating a map-reduce index which defines an output collection that already 
exists and contains documents, will result in an error.  
Delete all documents from the target collection before creating the index, 
or output results to a different collection.  

#### Modification of Artificial Documents
Artificial documents can be loaded and queried just like regular documents.  
However, it is **not** recommended to edit artificial documents manually since 
any index results update would overwrite all manual modifications made in them.  




</LanguageContent>
<LanguageContent language="java">


Map-Reduce indexes allow you to perform complex aggregations of data. The first stage, called the map, runs over documents and extracts portions of data according to the defined mapping function(s).
Upon completion of the first phase, reduction is applied to the map results and the final outcome is produced.

The idea behind map-reduce indexing is that aggregation queries using such indexes are very cheap. The aggregation is performed only once and the results are stored inside the index.
Once new data comes into the database or existing documents are modified, the map-reduce index will keep the aggregation results up-to-date. The aggregations are never done during
querying to avoid expensive calculations that could result in severe performance degradation. When you make the query, RavenDB immediately returns the matching results directly from the index.

For a more in-depth look at how map reduce works, you can read this post: [RavenDB 4.0 Unsung Heroes: Map/reduce](https://ayende.com/blog/179938/ravendb-4-0-unsung-heroes-map-reduce).

## Creating

When it comes to index creation, the only difference between simple indexes and the map-reduce ones is an additional reduce function defined in index definition. 
To deploy an index we need to create a definition and deploy it using one of the ways described in the [creating and deploying](../indexes/creating-and-deploying.mdx) article.

### Example I - Count

Let's assume that we want to count the number of products for each category. To do it, we can create the following index using `LoadDocument` inside:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="java">
{`public static class Products_ByCategory extends AbstractIndexCreationTask {
    public static class Result {
        private String category;
        private String count;

        public String getCategory() {
            return category;
        }

        public void setCategory(String category) {
            this.category = category;
        }

        public String getCount() {
            return count;
        }

        public void setCount(String count) {
            this.count = count;
        }
    }

    public Products_ByCategory() {
        map = "docs.Products.Select(product => new { " +
            "    Product = Product, " +
            "    CategoryName = (this.LoadDocument(product.Category, \\"Categories\\")).Name " +
            "}).Select(this0 => new { " +
            "    Category = this0.CategoryName, " +
            "    Count = 1 " +
            "})";

        reduce = "results.GroupBy(result => result.Category).Select(g => new { " +
            "    Category = g.Key, " +
            "    Count = Enumerable.Sum(g, x => ((int) x.Count)) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Products_ByCategory extends AbstractJavaScriptIndexCreationTask {
    public Products_ByCategory() {
        setMaps(Sets.newHashSet("map('products', function(p){\\n" +
            "            return {\\n" +
            "                Category: load(p.Category, 'Categories').Name,\\n" +
            "                Count: 1\\n" +
            "            }\\n" +
            "        })"));

        setReduce("groupBy(x => x.Category)\\n" +
            "    .aggregate(g => {\\n" +
            "        return {\\n" +
            "            Category: g.key,\\n" +
            "            Count: g.values.reduce((count, val) => val.Count + count, 0)\\n" +
            "        };\\n" +
            "    })");
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

and issue the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Products_ByCategory.Result> results = session
    .query(Products_ByCategory.Result.class, Products_ByCategory.class)
    .whereEquals("Category", "Seafood")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Products/ByCategory'
where Category == 'Seafood'
`}
</CodeBlock>
</TabItem>
</Tabs>

The above query will return one result for _Seafood_ with the appropriate number of products from that category.

### Example II - Average

In this example, we will count an average product price for each category. The index definition:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="java">
{`public static class Products_Average_ByCategory extends AbstractIndexCreationTask {
    public static class Result {
        private String category;
        private double priceSum;
        private double priceAverage;
        private int productCount;

        public String getCategory() {
            return category;
        }

        public void setCategory(String category) {
            this.category = category;
        }

        public double getPriceSum() {
            return priceSum;
        }

        public void setPriceSum(double priceSum) {
            this.priceSum = priceSum;
        }

        public double getPriceAverage() {
            return priceAverage;
        }

        public void setPriceAverage(double priceAverage) {
            this.priceAverage = priceAverage;
        }

        public int getProductCount() {
            return productCount;
        }

        public void setProductCount(int productCount) {
            this.productCount = productCount;
        }
    }

    public Products_Average_ByCategory() {
        map = "docs.Products.Select(product => new { " +
            "    Product = Product, " +
            "    CategoryName = (this.LoadDocument(product.Category, \\"Categories\\")).Name " +
            "}).Select(this0 => new { " +
            "    Category = this0.CategoryName, " +
            "    PriceSum = this0.Product.PricePerUnit, " +
            "    PriceAverage = 0, " +
            "    ProductCount = 1 " +
            "})";

        reduce = "results.GroupBy(result => result.Category).Select(g => new { " +
            "    g = g, " +
            "    ProductCount = Enumerable.Sum(g, x => ((int) x.ProductCount)) " +
            "}).Select(this0 => new { " +
            "    this0 = this0, " +
            "    PriceSum = Enumerable.Sum(this0.g, x0 => ((decimal) x0.PriceSum)) " +
            "}).Select(this1 => new { " +
            "    Category = this1.this0.g.Key, " +
            "    PriceSum = this1.PriceSum, " +
            "    PriceAverage = this1.PriceSum / ((decimal) this1.this0.ProductCount), " +
            "    ProductCount = this1.this0.ProductCount " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Product_Average_ByCategory extends AbstractJavaScriptIndexCreationTask {
    public Product_Average_ByCategory() {
        setMaps(Sets.newHashSet("map('products', function(product){\\n" +
            "    return {\\n" +
            "        Category: load(product.Category, 'Categories').Name,\\n" +
            "        PriceSum: product.PricePerUnit,\\n" +
            "        PriceAverage: 0,\\n" +
            "        ProductCount: 1\\n" +
            "    }\\n" +
            "})"));

        setReduce("groupBy(x => x.Category)\\n" +
            "        .aggregate(g => {\\n" +
            "          var pricesum = g.values.reduce((sum,x) => x.PriceSum + sum,0);\\n" +
            "          var productcount = g.values.reduce((sum,x) => x.ProductCount + sum,0);\\n" +
            "          return {\\n" +
            "            Category: g.key,\\n" +
            "            PriceSum: pricesum,\\n" +
            "            ProductCount: productcount,\\n" +
            "            PriceAverage: pricesum / productcount\\n" +
            "          }\\n" +
            "        })");
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

and the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Products_Average_ByCategory.Result> results = session
    .query(Products_Average_ByCategory.Result.class, Products_Average_ByCategory.class)
    .whereEquals("Category", "Seafood")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Products/Average/ByCategory'
where Category == 'Seafood'
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Calculations

This example illustrates how we can put some calculations inside an index using on one of the indexes available in the sample database (`Product/Sales`).

We want to know how many times each product was ordered and how much we earned for it. In order to extract that information, we need to define the following index:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="java">
{`public static class Product_Sales extends AbstractIndexCreationTask {
    public static class Result {
        private String product;
        private int count;
        private double total;

        public String getProduct() {
            return product;
        }

        public void setProduct(String product) {
            this.product = product;
        }

        public int getCount() {
            return count;
        }

        public void setCount(int count) {
            this.count = count;
        }

        public double getTotal() {
            return total;
        }

        public void setTotal(double total) {
            this.total = total;
        }
    }

    public Product_Sales() {
        map = "docs.Orders.SelectMany(order => order.Lines, (order, line) => new { " +
            "    Product = line.Product, " +
            "    Count = 1, " +
            "    Total = (((decimal) line.Quantity) * line.PricePerUnit) * (1M - line.Discount) " +
            "})";


        reduce = "results.GroupBy(result => result.Product).Select(g => new { " +
            "    Product = g.Key, " +
            "    Count = Enumerable.Sum(g, x => ((int) x.Count)), " +
            "    Total = Enumerable.Sum(g, x0 => ((decimal) x0.Total)) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Product_Sales extends AbstractJavaScriptIndexCreationTask {
    public Product_Sales() {
        setMaps(Sets.newHashSet("map('orders', function(order){\\n" +
            "            var res = [];\\n" +
            "            order.Lines.forEach(l => {\\n" +
            "              res.push({\\n" +
            "                Product: l.Product,\\n" +
            "                Count: 1,\\n" +
            "                Total:  (l.Quantity * l.PricePerUnit) * (1- l.Discount)\\n" +
            "              })\\n" +
            "            });\\n" +
            "            return res;\\n" +
            "        })"));

        setReduce("groupBy(x => x.Product)\\n" +
            "    .aggregate(g => {\\n" +
            "        return {\\n" +
            "            Product : g.key,\\n" +
            "            Count: g.values.reduce((sum, x) => x.Count + sum, 0),\\n" +
            "            Total: g.values.reduce((sum, x) => x.Total + sum, 0)\\n" +
            "        }\\n" +
            "    })");
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

and send the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Product_Sales.Result> results = session
    .query(Product_Sales.Result.class, Product_Sales.class)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Product/Sales'
`}
</CodeBlock>
</TabItem>
</Tabs>



## Reduce Results as Artificial Documents

#### Map-Reduce Output Documents

In addition to storing the aggregation results in the index, the map-reduce index can also output 
those reduce results as documents to a specified collection. In order to create these documents, 
called _"artificial",_ you need to define the target collection using the `outputReduceToCollection` 
property in the index definition.  

Writing map-reduce outputs into documents allows you to define additional indexes on top of them 
that give you the option to create recursive map-reduce operations. This makes it cheap and easy 
to, for example, recursively create daily, monthly, and yearly summaries on the same data.  

In addition, you can also apply the usual operations on artificial documents (e.g. data 
subscriptions or ETL).  

If the aggregation value for a given reduce key changes, we overwrite the output document. If the 
given reduce key no longer has a result, the output document will be removed.  

#### Reference Documents

To help organize these output documents, the map-reduce index can also create an additional 
collection of artificial _reference documents_. These documents aggregate the output documents 
and store their document IDs in an array field `ReduceOutputs`.  

The document IDs of reference documents are customized to follow some pattern. The format you 
give to their document ID also determines how the output documents are grouped.  

Because reference documents have well known, predictable IDs, they are easier to plug into 
indexes and other operations, and can serve as an intermediary for the output documents whose 
IDs are less predictable. This allows you to chain map-reduce indexes in a recursive fashion, 
see [Example II](../indexes/map-reduce-indexes.mdx#example-ii).  

Learn more about how to configure output and reference documents in the 
[Studio: Create Map-Reduce Index](../studio/database/indexes/create-map-reduce-index.mdx).  

### Artificial Document Properties  

#### IDs

The identifiers of **map reduce output documents** have three components in this format:  

`<Output collection name>/<incrementing value>/<hash of reduce key values>`  

The index in [Example I](../indexes/map-reduce-indexes.mdx#example-i) might generate an output document 
ID like this:  

`DailyProductSales/35/14369232530304891504`  

* "DailyProductSales" is the collection name specified for the output documents.  
* The middle part is an incrementing integer assigned by the server. This number grows by some 
amount whenever the index definition is modified. This can be useful because when an index definition 
changes, there is a brief transition phase when the new output documents are being created, but the 
old output documents haven't been deleted yet (this phase is called 
["side-by-side indexing"](../studio/database/indexes/indexes-list-view.mdx#indexes-list-view---side-by-side-indexing)). 
During this phase, the output collection contains output documents created both by the old version 
and the new version of the index, and they can be distinguished by this value: the new output 
documents will always have a higher value (by 1 or more).  
* The last part of the document ID (the unique part) is the hash of the reduce key values - in this 
case: `hash(Product, Month)`.  

The identifiers of **reference documents** follow some pattern you choose, and this pattern 
determines which output documents are held by a given reference document.  

The index in [Example I](../indexes/map-reduce-indexes.mdx#example-i) has this pattern for reference documents:  

`sales/daily/{Date:yyyy-MM-dd}`

And this produces reference document IDs like this:

`sales/daily/1998-05-06`

The pattern is built using the same syntax as 
[the `StringBuilder.AppendFormat` method](https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.appendformat). 
See [here](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings) 
to learn about the date formatting in particular.  

#### Metadata

Artificial documents generated by map-reduce indexes get the following `@flags` in their metadata:  

<TabItem value="json" label="json">
<CodeBlock language="json">
{`"@flags": "Artificial, FromIndex"
`}
</CodeBlock>
</TabItem>

These flags are used internally by the database to filter out artificial documents during replication.  

### Syntax
The map-reduce output documents are configured with these properties of 
`IndexDefinition`:  

<TabItem value="syntax_0" label="syntax_0">
<CodeBlock language="java">
{`private String outputReduceToCollection;

private String patternReferencesCollectionName;

private String patternForOutputReduceToCollectionReferences;
`}
</CodeBlock>
</TabItem>

| Parameters | Type | Description |
| - | - | - |
| **outputReduceToCollection** | `String` | Collection name for the output documents. |
| **patternReferencesCollectionName** | `String` | Optional collection name for the reference documents - by default it is `<outputReduceToCollection>/References`. |
| **patternForOutputReduceToCollectionReferences** | `String` | Document ID format for reference documents. This ID references the fields of the reduce function output, which determines how the output documents are aggregated. The type of this parameter is different depending on if the index is created using [IndexDefinition](../indexes/creating-and-deploying.mdx#using-maintenance-operations) or [AbstractIndexCreationTask](../indexes/creating-and-deploying.mdx#using-abstractindexcreationtask). |

### Examples

#### Example I

Here is a map-reduce index with output documents and reference documents:  

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ" label="LINQ">
<CodeBlock language="java">
{`public Product_Sales_ByMonth() {
    map = "docs.Orders.SelectMany(order => order.Lines, (order, line) => new { " +
        "    Product = line.Product, " +
        "    Month = new DateTime(order.OrderedAt.Year, order.OrderedAt.Month, 1), " +
        "    Count = 1, " +
        "    Total = (((decimal) line.Quantity) * line.PricePerUnit) * (1M - line.Discount) " +
        "})";

    reduce = "results.GroupBy(result => new { " +
        "    Product = result.Product, " +
        "    Month = result.Month " +
        "}).Select(g => new { " +
        "    Product = g.Key.Product, " +
        "    Month = g.Key.Month, " +
        "    Count = Enumerable.Sum(g, x => ((int) x.Count)), " +
        "    Total = Enumerable.Sum(g, x0 => ((decimal) x0.Total)) " +
        "})";

    outputReduceToCollection = "MonthlyProductSales";
    patternReferencesCollectionName = "DailyProductSales/References";
    patternForOutputReduceToCollectionReferences = "sales/daily/{Date:yyyy-MM-dd}";
}
    }
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Product_Sales_ByMonth extends AbstractJavaScriptIndexCreationTask {
    public Product_Sales_ByMonth() {
        setMaps(Sets.newHashSet("map('orders', function(order){\\n" +
            "            var res = [];\\n" +
            "            order.Lines.forEach(l => {\\n" +
            "            res.push({\\n" +
            "                Product: l.Product,\\n" +
            "                Month: new Date( (new Date(order.OrderedAt)).getFullYear(),(new Date(order.OrderedAt)).getMonth(),1),\\n" +
            "                Count: 1,\\n" +
            "                Total: (l.Quantity * l.PricePerUnit) * (1- l.Discount)\\n" +
            "            })\\n" +
            "        });\\n" +
            "        return res;\\n" +
            "    })"));

        setReduce("groupBy(x => ({Product: x.Product, Month: x.Month}))\\n" +
            "    .aggregate(g => {\\n" +
            "        return {\\n" +
            "            Product: g.key.Product,\\n" +
            "            Month: g.key.Month,\\n" +
            "            Count: g.values.reduce((sum, x) => x.Count + sum, 0),\\n" +
            "            Total: g.values.reduce((sum, x) => x.Total + sum, 0)\\n" +
            "        }\\n" +
            "    })");

        setOutputReduceToCollection("MonthlyProductSales");
        setPatternReferencesCollectionName("DailyProductSales/References");
        setPatternForOutputReduceToCollectionReferences("sales/daily/{Date:yyyy-MM-dd}");
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

In the **LINQ** index example above (which inherits `AbstractIndexCreationTask`), 
the reference document ID pattern is set with a lambda expression:  

<TabItem value="java" label="java">
<CodeBlock language="java">
{`PatternForOutputReduceToCollectionReferences = "sales/daily/\{Date:yyyy-MM-dd\}";
`}
</CodeBlock>
</TabItem>  

This gives the reference documents IDs in this general format: `sales/monthly/1998-05-01`. 
The reference document with that ID contains the IDs of all the output documents from the 
month of May 1998.  


In the **JavaScript** index example (which uses `IndexDefinition`), 
the reference document ID pattern is set with a `String`:  

<TabItem value="javascript" label="javascript">
<CodeBlock language="javascript">
{`PatternForOutputReduceToCollectionReferences ("sales/daily/\{Date:yyyy-MM-dd\})"
`}
</CodeBlock>
</TabItem>  

This gives the reference documents IDs in this general format: `sales/daily/1998-05-06`. 
The reference document with that ID contains the IDs of all the output documents from 
May 6th 1998.  

## Important Comments

#### Saving documents
[Artificial documents](../indexes/map-reduce-indexes.mdx#reduce-results-as-artificial-documents) 
are stored immediately after the indexing transaction completes.  

#### Recursive indexing loop
It is **forbidden** to output reduce results to collections such as the following:  

- A collection that the current index is already working on.  
  E.g., an index on a `DailyInvoices` collection outputs to `DailyInvoices`.  
- A collection that the current index is loading a document from.  
  E.g., an index with `LoadDocument(id, "Invoices")` outputs to `Invoices`.  
- Two collections, each processed by a map-reduce indexes,  
  when each index outputs to the second collection.  
  E.g.,  
  An index on the `Invoices` collection outputs to the `DailyInvoices` collection,  
  while an index on `DailyInvoices` outputs to `Invoices`.  

When an attempt to create such an infinite indexing loop is 
detected a detailed error is generated.  

#### Output to an Existing collection
Creating a map-reduce index which defines an output collection that already 
exists and contains documents, will result in an error.  
Delete all documents from the target collection before creating the index, 
or output results to a different collection.  

#### Modification of Artificial Documents
Artificial documents can be loaded and queried just like regular documents.  
However, it is **not** recommended to edit artificial documents manually since 
any index results update would overwrite all manual modifications made in them.  




</LanguageContent>
<LanguageContent language="nodejs">


Map-Reduce indexes allow you to perform complex aggregations of data. The first stage, called the map, runs over documents and extracts portions of data according to the defined mapping function(s).
Upon completion of the first phase, reduction is applied to the map results and the final outcome is produced.

The idea behind map-reduce indexing is that aggregation queries using such indexes are very cheap. The aggregation is performed only once and the results are stored inside the index.
Once new data comes into the database or existing documents are modified, the map-reduce index will keep the aggregation results up-to-date. The aggregations are never done during
querying to avoid expensive calculations that could result in severe performance degradation. When you make the query, RavenDB immediately returns the matching results directly from the index.

For a more in-depth look at how map reduce works, you can read this post: [RavenDB 4.0 Unsung Heroes: Map/reduce](https://ayende.com/blog/179938/ravendb-4-0-unsung-heroes-map-reduce).

## Creating

When it comes to index creation, the only difference between simple indexes and the map-reduce ones is an additional reduce function defined in index definition. 
To deploy an index we need to create a definition and deploy it using one of the ways described in the [creating and deploying](../indexes/creating-and-deploying.mdx) article.

### Example I - Count

Let's assume that we want to count the number of products for each category. To do it, we can create the following index using `LoadDocument` inside:

<TabItem value="map_reduce_0_0" label="map_reduce_0_0">
<CodeBlock language="js">
{`class Products_ByCategory extends AbstractCsharpIndexCreationTask \{

    constructor() \{
        super();

        this.map = "docs.Products.Select(product => new \{ " +
            "    Product = product, " +
            "    CategoryName = (this.LoadDocument(product.Category, \\"Categories\\")).Name " +
            "\}).Select(this0 => new \{ " +
            "    Category = this0.CategoryName, " +
            "    Count = 1 " +
            "\})";

        this.reduce = "results.GroupBy(result => result.category).Select(g => new \{ " +
            "    category = g.Key, " +
            "    count = Enumerable.Sum(g, x => ((int) x.count)) " +
            "\})";
    \}
\}
`}
</CodeBlock>
</TabItem>

and issue the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    .query({ indexName: "Products/ByCategory" })
    .whereEquals("Category", "Seafood")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Products/ByCategory'
where Category == 'Seafood'
`}
</CodeBlock>
</TabItem>
</Tabs>

The above query will return one result for _Seafood_ with the appropriate number of products from that category.

### Example II - Average

In this example, we will count an average product price for each category. The index definition:

<TabItem value="map_reduce_1_0" label="map_reduce_1_0">
<CodeBlock language="js">
{`class Products_Average_ByCategory extends AbstractCsharpIndexCreationTask \{

    constructor() \{
        super();

        this.map = "docs.Products.Select(product => new \{ " +
            "    Product = product, " +
            "    CategoryName = (this.LoadDocument(product.Category, \\"Categories\\")).Name " +
            "\}).Select(this0 => new \{ " +
            "    Category = this0.CategoryName, " +
            "    PriceSum = this0.product.PricePerUnit, " +
            "    PriceAverage = 0, " +
            "    ProductCount = 1 " +
            "\})";

        this.reduce = "results.GroupBy(result => result.Category).Select(g => new \{ " +
            "    g = g, " +
            "    ProductCount = Enumerable.Sum(g, x => ((int) x.ProductCount)) " +
            "\}).Select(this0 => new \{ " +
            "    this0 = this0, " +
            "    PriceSum = Enumerable.Sum(this0.g, x0 => ((decimal) x0.PriceSum)) " +
            "\}).Select(this1 => new \{ " +
            "    Category = this1.this0.g.Key, " +
            "    PriceSum = this1.PriceSum, " +
            "    PriceAverage = this1.PriceSum / ((decimal) this1.this0.ProductCount), " +
            "    ProductCount = this1.this0.ProductCount " +
            "\})";
    \}
\}
`}
</CodeBlock>
</TabItem>

and the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    .query({ indexName: "Products_Average_ByCategory" })
    .whereEquals("Category", "Seafood")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Products/Average/ByCategory'
where Category == 'Seafood'
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Calculations

This example illustrates how we can put some calculations inside an index using on one of the indexes available in the sample database (`Product/Sales`).

We want to know how many times each product was ordered and how much we earned for it. In order to extract that information, we need to define the following index:

<TabItem value="map_reduce_2_0" label="map_reduce_2_0">
<CodeBlock language="js">
{`class Product_Sales extends AbstractCsharpIndexCreationTask \{
    constructor() \{
        super();

        this.map = "docs.Orders.SelectMany(order => order.Lines, (order, line) => new \{ " +
            "    Product = line.Product, " +
            "    Count = 1, " +
            "    Total = (((decimal) line.Quantity) * line.PricePerUnit) * (1M - line.Discount) " +
            "\})";


        this.reduce = "results.GroupBy(result => result.Product).Select(g => new \{ " +
            "    Product = g.Key, " +
            "    Count = Enumerable.Sum(g, x => ((int) x.Count)), " +
            "    Total = Enumerable.Sum(g, x0 => ((decimal) x0.Total)) " +
            "\})";
    \}
\}
`}
</CodeBlock>
</TabItem>

and send the query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    .query({ indexName: "Product/Sales" })
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from 'Product/Sales'
`}
</CodeBlock>
</TabItem>
</Tabs>



## Reduce Results as Artificial Documents

In addition to storing the aggregation results in the index, the map-reduce index can also output 
those reduce results as documents to a specified collection. In order to create these documents, 
called _"artificial",_ you need to define the target collection using the `outputReduceToCollection` 
property in the index definition.  

Writing map-reduce outputs into documents allows you to define additional indexes on top of them 
that give you the option to create recursive map-reduce operations. This makes it cheap and easy 
to, for example, recursively create daily, monthly, and yearly summaries on the same data.  

In addition, you can also apply the usual operations on artificial documents (e.g. data 
subscriptions or ETL).  

If the aggregation value for a given reduce key changes, we overwrite the output document. If the 
given reduce key no longer has a result, the output document will be removed.  

#### Reference Documents

To help organize these output documents, the map-reduce index can also create an additional 
collection of artificial _reference documents_. These documents aggregate the output documents 
and store their document IDs in an array field `ReduceOutputs`.  

The document IDs of reference documents are customized to follow some pattern. The format you 
give to their document ID also determines how the output documents are grouped.  

Because reference documents have well known, predictable IDs, they are easier to plug into 
indexes and other operations, and can serve as an intermediary for the output documents whose 
IDs are less predictable. This allows you to chain map-reduce indexes in a recursive fashion, 
see [Example II](../indexes/map-reduce-indexes.mdx#example-ii).  

Learn more about how to configure output and reference documents in the 
[Studio: Create Map-Reduce Index](../studio/database/indexes/create-map-reduce-index.mdx).  

### Artificial Document IDs

The identifiers of artificial documents are generated as:

- `<OutputCollectionName>/<hash-of-reduce-key>`

For the above sample index, the document ID can be:

- `MonthlyProductSales/13770576973199715021`

The numeric part is the hash of the reduce key values, in this case: `hash(Product, Month)`.

If the aggregation value for a given reduce key changes then we overwrite the artificial document. It will get removed once there is no result for a given reduce key.
    
### Artificial Document Flags

Documents generated by map-reduce indexes get the following `@flags` metadata:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`"@flags": "Artificial, FromIndex"
`}
</CodeBlock>
</TabItem>

Those flags are used internally by the database to filter out artificial documents during replication.

### Usage

The map-reduce output documents are configured with these properties of 
`IndexDefinition`:  

<TabItem value="syntax_0" label="syntax_0">
<CodeBlock language="js">
{`const outputReduceToCollection = indexDefinition.outputReduceToCollection;

const patternReferencesCollectionName = indexDefinition.patternReferencesCollectionName;

const patternForOutputReduceToCollectionReferences = indexDefinition.patternForOutputReduceToCollectionReferences;
`}
</CodeBlock>
</TabItem>

| Parameters | Type | Description |
| - | - | - |
| **outputReduceToCollection** | `string` | Collection name for the output documents. |
| **patternReferencesCollectionName** | `string` | Optional collection name for the reference documents - by default it is `<outputReduceToCollection>/References`. |
| **patternForOutputReduceToCollectionReferences** | `string` | Document ID format for reference documents. This ID references the fields of the reduce function output, which determines how the output documents are aggregated. The type of this parameter is different depending on if the index is created using [IndexDefinition](../indexes/creating-and-deploying.mdx#using-maintenance-operations) or [AbstractIndexCreationTask](../indexes/creating-and-deploying.mdx#using-abstractindexcreationtask). |

### Examples

<TabItem value="map_reduce_3_0" label="map_reduce_3_0">
<CodeBlock language="js">
{`class Product_Sales_ByMonth extends AbstractCsharpIndexCreationTask \{
    constructor() \{
        super();

        this.map = "docs.Orders.SelectMany(order => order.Lines, (order, line) => new \{ " +
            "    Product = line.Product, " +
            "    Month = new DateTime(order.OrderedAt.Year, order.OrderedAt.Month, 1), " +
            "    Count = 1, " +
            "    Total = (((decimal) line.Quantity) * line.PricePerUnit) * (1M - line.Discount) " +
            "\})";

        this.reduce = "results.GroupBy(result => new \{ " +
            "    Product = result.Product, " +
            "    Month = result.Month " +
            "\}).Select(g => new \{ " +
            "    Product = g.Key.Product, " +
            "    Month = g.Key.Month, " +
            "    Count = Enumerable.Sum(g, x => ((int) x.Count)), " +
            "    Total = Enumerable.Sum(g, x0 => ((decimal) x0.Total)) " +
            "\})";

        this.outputReduceToCollection = "MonthlyProductSales";
    \}
\}
`}
</CodeBlock>
</TabItem>

## Important Comments

#### Saving documents
[Artificial documents](../indexes/map-reduce-indexes.mdx#reduce-results-as-artificial-documents) 
are stored immediately after the indexing transaction completes.  

#### Recursive indexing loop
It is **forbidden** to output reduce results to collections such as the following:  

- A collection that the current index is already working on.  
  E.g., an index on a `DailyInvoices` collection outputs to `DailyInvoices`.  
- A collection that the current index is loading a document from.  
  E.g., an index with `LoadDocument(id, "Invoices")` outputs to `Invoices`.  
- Two collections, each processed by a map-reduce indexes,  
  when each index outputs to the second collection.  
  E.g.,  
  An index on the `Invoices` collection outputs to the `DailyInvoices` collection,  
  while an index on `DailyInvoices` outputs to `Invoices`.  

When an attempt to create such an infinite indexing loop is 
detected a detailed error is generated.  

#### Output to an Existing collection
Creating a map-reduce index which defines an output collection that already 
exists and contains documents, will result in an error.  
Delete all documents from the target collection before creating the index, 
or output results to a different collection.  

#### Modification of Artificial Documents
Artificial documents can be loaded and queried just like regular documents.  
However, it is **not** recommended to edit artificial documents manually since 
any index results update would overwrite all manual modifications made in them.  




</LanguageContent>

<!---
### Indexes
- [Map Indexes](../indexes/map-indexes)
- [Multi-Map Indexes](../indexes/multi-map-indexes)
- [Indexing Related Documents](../indexes/indexing-related-documents)
- [Creating and Deploying Indexes](../indexes/creating-and-deploying)

### Querying
- [Basics](../indexes/querying/basics)

### Studio
- [Indexes: Overview](../studio/database/indexes/indexes-overview)
- [Index List View](../studio/database/indexes/indexes-list-view)
- [Create Map Index](../studio/database/indexes/create-map-index)
- [Create Multi-Map Index](../studio/database/indexes/create-multi-map-index)
- [Map-Reduce Visualizer](../studio/database/indexes/map-reduce-visualizer)
- [Create Map-Reduce Index](../studio/database/indexes/create-map-reduce-index)


-->