---
title: "Data Subscriptions: Subscription Consumption Examples"
hide_table_of_contents: true
sidebar_label: Examples
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];


# Data Subscriptions: Subscription Consumption Examples
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

In this page:  

[Subscription workers with failover on other nodes](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-workers-with-failover-on-other-nodes)  
[Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-with-a-specified-batch-size)  
[Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples.mdx#client-with-full-exception-handling-and-processing-retries)  
[Subscription that ends when no documents left](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-ends-when-no-documents-left)  
[Worker that processes dynamic objects](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-that-processes-dynamic-objects)  
[Subscription that works with a session](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-works-with-a-session)  
[Subscription that uses included documents](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-uses-included-documents)  
[Subscription that works with lowest level API](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-works-with-lowest-level-api)  
[Subscription workers with a primary and a secondary node](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-workers-with-a-primary-and-a-secondary-node)  

</Admonition>
## Subscription workers with failover on other nodes

In this configuration, any available node will create a worker.  
If the worker fails, another available node will take over.

<TabItem value="waitforfree" label="waitforfree">
<CodeBlock language="csharp">
{`var worker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.WaitForFree
\});
`}
</CodeBlock>
</TabItem>



## Worker with a specified batch size

Here we create a worker, specifying the maximum batch size we want to receive.

<TabItem value="subscription_worker_with_batch_size" label="subscription_worker_with_batch_size">
<CodeBlock language="csharp">
{`var workerWBatch = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
    \{
        MaxDocsPerBatch = 20
    \});

_ = workerWBatch.Run(x =>
\{
    // your custom logic 
\});
`}
</CodeBlock>
</TabItem>



## Client with full exception handling and processing retries

Here we implement a client that treats exceptions thrown by worker, and retries creating the worker if an exception is recoverable.

<TabItem value="reconnecting_client" label="reconnecting_client">
<CodeBlock language="csharp">
{`while (true)
\{
    // Create the worker:
    // ==================
    var options = new SubscriptionWorkerOptions(subscriptionName);

    // Configure the worker:
    // Allow a downtime of up to 2 hours,
    // and wait 2 minutes before reconnecting
    options.MaxErroneousPeriod = TimeSpan.FromHours(2);
    options.TimeToWaitBeforeConnectionRetry = TimeSpan.FromMinutes(2);

    subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(options);

    try
    \{
        // Subscribe to connection retry events
        // and log any exceptions that occur during processing
        subscriptionWorker.OnSubscriptionConnectionRetry += exception =>
        \{
            Logger.Error("Error during subscription processing: " + subscriptionName,
                exception);
        \};

        // Run the worker:
        // ===============
        await subscriptionWorker.Run(batch =>
        \{
            foreach (var item in batch.Items)
            \{
                // Forcefully stop subscription processing if the ID is "companies/2-A"
                // and throw an exception to let external logic handle the specific case
                if (item.Result.Company == "companies/2-A")
                \{
                    // The custom exception thrown from here
                    // will be wrapped by \`SubscriberErrorException\`
                    throw new UnsupportedCompanyException(
                        "Company ID can't be 'companies/2-A', pleases fix");
                \}

                // Process the order document - provide your own logic
                ProcessOrder(item.Result);
            \}
        \}, cancellationToken);

        // The Run method will stop if the subscription worker is disposed,
        // exiting the while loop
        return;
    \}
    catch (Exception e)
    \{
        Logger.Error("Failure in subscription: " + subscriptionName, e);

        // The following exceptions are Not recoverable
        if (e is DatabaseDoesNotExistException ||
            e is SubscriptionDoesNotExistException ||
            e is SubscriptionInvalidStateException ||
            e is AuthorizationException)
            throw;


        if (e is SubscriptionClosedException)
            // Subscription probably closed explicitly by admin
            return;

        if (e is SubscriberErrorException se)
        \{
            // For UnsupportedCompanyException we want to throw an exception,
            // otherwise, continue processing
            if (se.InnerException != null && se.InnerException is UnsupportedCompanyException)
            \{
                throw;
            \}

            // Call continue to skip the current while(true) iteration and try reconnecting
            // in the next one, allowing the worker to process future batches.
            continue;
        \}

        // Handle this depending on the subscription opening strategy
        if (e is SubscriptionInUseException)
            continue;

        // Call return to exit the while(true) loop,
        // dispose the worker (via finally), and stop the subscription.
        return;
    \}
    finally
    \{
        subscriptionWorker.Dispose();
    \}
\}
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents left

Here we create a subscription client that runs only up to the point there are no more new documents left to process.  

This is useful for an ad-hoc single use processing that the user wants to be sure is performed completely. 

<TabItem value="single_run" label="single_run">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================
var subscriptionName = store.Subscriptions.Create<Order>(
    new SubscriptionCreationOptions<Order>
    \{
        Filter = order => order.Lines.Sum(line => line.PricePerUnit * line.Quantity) > 10000,
        Projection = order => new OrderAndCompany
        \{
            OrderId = order.Id,
            Company = RavenQuery.Load<Company>(order.Company)
        \}
    \});

// Create the subscription worker that will consume the documents:
// ===============================================================
var highValueOrdersWorker = store.Subscriptions.GetSubscriptionWorker<OrderAndCompany>(
    new SubscriptionWorkerOptions(subscriptionName)
    \{
        // Here we set the worker to stop when there are no more documents left to send 
        // Will throw SubscriptionClosedException when it finishes it's job
        CloseWhenNoDocsLeft = true
    \});

try
\{
    await highValueOrdersWorker.Run(batch =>
    \{
        foreach (var item in batch.Items)
        \{
            SendThankYouNoteToEmployee(item.Result); // call your custom method 
        \}
    \});
\}
catch (SubscriptionClosedException)
\{
    // That's expected, no more documents to process
\}
`}
</CodeBlock>
</TabItem>




## Worker that processes dynamic objects

Here we create a worker that processes received data as dynamic objects.

<TabItem value="dynamic_worker" label="dynamic_worker">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = "My dynamic subscription";
store.Subscriptions.Create(new SubscriptionCreationOptions<Order>()
\{
    Name = subscriptionName,
    Projection = order => 
        new \{ DynanamicField_1 = "Company: " + order.Company + " Employee: " + order.Employee \}
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    foreach (var item in batch.Items)
    \{
        // Access the dynamic field in the document
        dynamic field = item.Result.DynanamicField_1;
        
        // Call your custom method
        ProcessItem(field); 
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that works with a session

Here we create a worker that receives all orders without a shipping date, lets the shipment mechanism to handle it and updates the `ShippedAt` field value.

<TabItem value="subscription_with_open_session_usage" label="subscription_with_open_session_usage">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions()
\{
    Query = @"from Orders as o where o.ShippedAt = null"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    // Open a session with 'batch.OpenSession'
    using (var session = batch.OpenSession())
    \{
        foreach (var order in batch.Items.Select(x => x.Result))
        \{
            TransferOrderToShipmentCompany(order); // call your custom method 
            order.ShippedAt = DateTime.UtcNow;     // update the document field
        \}

        // Save the updated Order documents
        session.SaveChanges();
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that uses included documents

Here we create a subscription utilizing the includes feature, by processing `Order` documents and including all `Product`s of each order.  
When processing the subscription, we create a session using the [SubscriptionBatch&lt;T&gt;](../../../client-api/data-subscriptions/consumption/api-overview.mdx#subscriptionbatch&lt;t&gt;) object, 
and for each order line, we obtain the `Product` document and process it alongside with the `Order`.

<TabItem value="subscription_with_includes_path_usage" label="subscription_with_includes_path_usage">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions()
\{
    // Include the referenced Product documents for each Order document
    Query = @"from Orders include Lines[].Product"
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
_ = subscriptionWorker.Run(batch =>
\{
    // Open a session via 'batch.OpenSession'
    // in order to access the Product documents
    using (var session = batch.OpenSession())
    \{
        foreach (var order in batch.Items.Select(x => x.Result))
        \{
            foreach (var orderLine in order.Lines)
            \{
                // Calling Load will Not generate a request to the server,
                // because orderLine.Product was included in the batch
                var product = session.Load<Product>(orderLine.Product);
                
                ProcessOrderAndProduct(order, product); // call your custom method
            \}
        \}
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that works with lowest level API

Here we create a subscription that works with blittable document representation that can be useful in very high performance scenarios, 
but it may be dangerous due to the direct usage of unmanaged memory.

<TabItem value="blittable_worker" label="blittable_worker">
<CodeBlock language="csharp">
{`// Create the subscription task on the server:
// ===========================================

var subscriptionName = store.Subscriptions.Create(new SubscriptionCreationOptions<Order>
\{
    Projection = x => new
    \{
        x.Employee
    \}
\});

// Create the subscription worker that will consume the documents:
// ===============================================================

var subscriptionWorker = 
    // Specify \`BlittableJsonReaderObject\` as the generic type parameter
    store.Subscriptions.GetSubscriptionWorker<BlittableJsonReaderObject>(subscriptionName);

_ = subscriptionWorker.Run(batch =>
\{
    foreach (var item in batch.Items)
    \{
        // Access the Employee field within the blittable object
        var employeeField = item.Result["Employee"].ToString();
        
        ProcessItem(employeeField); // call your custom method 
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription workers with a primary and a secondary node

Here we create two workers:  

* The primary worker, set with a `TakeOver` strategy, will take the lead over the secondary worker.  
* The secondary worker, set with a `WaitForFree` strategy, will take over if the primary worker fails (e.g. due to a machine failure).  

The primary worker:  
<TabItem value="waiting_subscription_1" label="waiting_subscription_1">
<CodeBlock language="csharp">
{`var primaryWorker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.TakeOver
\});

while (true)
\{
    try
    \{
        await primaryWorker.Run(x =>
        \{
            // your logic
        \});
    \}
    catch (Exception)
    \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>

The secondary worker:  
<TabItem value="waiting_subscription_2" label="waiting_subscription_2">
<CodeBlock language="csharp">
{`var secondaryWorker = store.Subscriptions.GetSubscriptionWorker<Order>(
    new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.WaitForFree
\});

while (true)
\{
    try
    \{
        await secondaryWorker.Run(x =>
        \{
            // your logic
        \});
    \}
    catch (Exception)
    \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="java">

<Admonition type="note" title="Note">

In this page:  

[Worker with a specified batch size](../../../client-api/data-subscriptions/consumption/examples.mdx#worker-with-a-specified-batch-size)  
[Client with full exception handling and processing retries](../../../client-api/data-subscriptions/consumption/examples.mdx#client-with-full-exception-handling-and-processing-retries)  
[Subscription that ends when no documents left](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-ends-when-no-documents-left)  
[Subscription that processes ObjectNode objects](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-processes-objectnode-objects)  
[Subscription that works with a session](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-works-with-a-session)  
[Subscription that uses included documents](../../../client-api/data-subscriptions/consumption/examples.mdx#subscription-that-uses-included-documents)  
[Two subscription workers that are waiting for each other](../../../client-api/data-subscriptions/consumption/examples.mdx#two-subscription-workers-that-are-waiting-for-each-other)  

</Admonition>
## Worker with a specified batch size

Here we create a worker, specifying the maximum batch size we want to receive.

<TabItem value="subscription_worker_with_batch_size" label="subscription_worker_with_batch_size">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subscriptionName);
options.setMaxDocsPerBatch(20);
SubscriptionWorker<Order> workerWBatch = store.subscriptions().getSubscriptionWorker(Order.class, options);
workerWBatch.run(x -> \{ /* custom logic */\});
`}
</CodeBlock>
</TabItem>



## Client with full exception handling and processing retries

Here we implement a client that treats exceptions thrown by worker, and retries creating the worker if an exception is recoverable.

<TabItem value="reconnecting_client" label="reconnecting_client">
<CodeBlock language="java">
{`while (true) \{
    SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subscriptionName);
    // here we configure that we allow a down time of up to 2 hours,
    // and will wait for 2 minutes for reconnecting

    options.setMaxErroneousPeriod(Duration.ofHours(2));
    options.setTimeToWaitBeforeConnectionRetry(Duration.ofMinutes(2));

    subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, options);

    try \{
        // here we are able to be informed of any exception that happens during processing
        subscriptionWorker.addOnSubscriptionConnectionRetry(exception -> \{
            logger.error("Error during subscription processing: " + subscriptionName, exception);
        \});

        subscriptionWorker.run(batch -> \{
            for (SubscriptionBatch.Item<Order> item : batch.getItems()) \{
                // we want to force close the subscription processing in that case
                // and let the external code decide what to do with that
                if ("Europe".equalsIgnoreCase(item.getResult().getShipVia())) \{
                    throw new IllegalStateException("We cannot ship via Europe");
                \}
                processOrder(item.getResult());
            \}
        \}).get();


        // Run will complete normally if you have disposed the subscription
        return;
    \} catch (Exception e) \{
        logger.error("Failure in subscription: " + subscriptionName, e);

        e = ExceptionsUtils.unwrapException(e);
        if (e instanceof DatabaseDoesNotExistException ||
            e instanceof SubscriptionDoesNotExistException ||
            e instanceof SubscriptionInvalidStateException ||
            e instanceof AuthorizationException) \{
            throw e; // not recoverable
        \}

        if (e instanceof SubscriptionClosedException) \{
            // closed explicitly by admin, probably
            return;
        \}

        if (e instanceof SubscriberErrorException) \{
            SubscriberErrorException se = (SubscriberErrorException) e;
            // for IllegalStateException type, we want to throw an exception, otherwise
            // we continue processing
            if (se.getCause() != null && se.getCause() instanceof IllegalStateException) \{
                throw e;
            \}

            continue;
        \}

        // handle this depending on subscription
        // open strategy (discussed later)
        if (e instanceof SubscriptionInUseException) \{
            continue;
        \}

        return;
    \} finally \{
        subscriptionWorker.close();
    \}
\}
`}
</CodeBlock>
</TabItem>



## Subscription that ends when no documents left

Here we create a subscription client that runs only up to the point there are no more new documents left to process.  

This is useful for an ad-hoc single use processing that the user wants to be sure is performed completely. 

<TabItem value="single_run" label="single_run">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options = new SubscriptionWorkerOptions(subsId);

// Here we ask the worker to stop when there are no documents left to send.
// Will throw SubscriptionClosedException when it finishes it's job
options.setCloseWhenNoDocsLeft(true);
SubscriptionWorker<OrderAndCompany> highValueOrdersWorker = store
    .subscriptions().getSubscriptionWorker(OrderAndCompany.class, options);

try \{
    highValueOrdersWorker.run(batch -> \{
        for (SubscriptionBatch.Item<OrderAndCompany> item : batch.getItems()) \{
            sendThankYouNoteToEmployee(item.getResult());
        \}
    \});
\} catch (SubscriptionClosedException e) \{
    //that's expected
\}
`}
</CodeBlock>
</TabItem>



## Worker that processes raw objects

Here we create a worker that processes received data as ObjectNode objects.

<TabItem value="dynamic_worker" label="dynamic_worker">
<CodeBlock language="java">
{`String subscriptionName = "My dynamic subscription";

SubscriptionCreationOptions subscriptionCreationOptions = new SubscriptionCreationOptions();
subscriptionCreationOptions.setName("My dynamic subscription");
subscriptionCreationOptions.setQuery("from Orders as o \\n" +
    "select \{ \\n" +
    "   DynamicField_1: 'Company:' + o.Company + ' Employee: ' + o.Employee \\n" +
    "\}");

SubscriptionWorker<ObjectNode> worker = store.subscriptions().getSubscriptionWorker(subscriptionName);
worker.run(x -> \{
    for (SubscriptionBatch.Item<ObjectNode> item : x.getItems()) \{
        ObjectNode result = item.getResult();
        raiseNotification(result.get("DynamicField_1"));
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that works with a session

Here we create a worker that receives all orders without a shipping date, lets the shipment mechanism to handle it and updates the `ShippedAt` field value.

<TabItem value="subscription_with_open_session_usage" label="subscription_with_open_session_usage">
<CodeBlock language="java">
{`SubscriptionCreationOptions subscriptionCreationOptions = new SubscriptionCreationOptions();
subscriptionCreationOptions.setQuery("from Orders as o where o.ShippedAt = null");
String subscriptionName = store.subscriptions().create(subscriptionCreationOptions);

SubscriptionWorker<Order> subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, subscriptionName);

subscriptionWorker.run(batch -> \{
    try (IDocumentSession session = batch.openSession()) \{
        for (SubscriptionBatch.Item<Order> orderItem : batch.getItems()) \{
            transferOrderToShipmentCompany(orderItem.getResult());
            orderItem.getResult().setShippedAt(new Date());
        \}

        // we know that we have at least one order to ship,
        // because the subscription query above has that in it's WHERE clause
        session.saveChanges();
    \}
\});
`}
</CodeBlock>
</TabItem>



## Subscription that uses included documents

Here we create a subscription utilizing the includes feature, by processing `Order` documents and including all `Product`s of each order.  
When processing the subscription, we create a session using the [SubscriptionBatch&lt;T&gt;](../../../client-api/data-subscriptions/consumption/api-overview.mdx#subscriptionbatch&lt;t&gt;) object, 
and for each order line, we obtain the `Product` document and process it alongside with the `Order`.

<TabItem value="subscription_with_includes_path_usage" label="subscription_with_includes_path_usage">
<CodeBlock language="java">
{`SubscriptionCreationOptions subscriptionCreationOptions = new SubscriptionCreationOptions();
subscriptionCreationOptions.setQuery("from Orders include Lines[].Product");


String subscriptionName = store.subscriptions().create(subscriptionCreationOptions);

SubscriptionWorker<Order> subscriptionWorker = store.subscriptions().getSubscriptionWorker(Order.class, subscriptionName);

subscriptionWorker.run(batch -> \{
    try (IDocumentSession session = batch.openSession()) \{
        for (SubscriptionBatch.Item<Order> orderItem : batch.getItems()) \{
            Order order = orderItem.getResult();
            for (OrderLine orderLine : order.getLines()) \{
                // this line won't generate a request, because orderLine.Product was included
                Product product = session.load(Product.class, orderLine.getProduct());
                raiseProductNotification(order, product);
            \}
        \}
    \}
\});
`}
</CodeBlock>
</TabItem>




## Two subscription workers that are waiting for each other

Here we create two workers:  
* The main worker with the `TAKE_OVER` strategy that will take over the other one and will take the lead  
* The secondary worker that will wait for the first one fail (due to machine failure etc.)

The main worker:

<TabItem value="waiting_subscription_1" label="waiting_subscription_1">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options1 = new SubscriptionWorkerOptions(subscriptionName);
options1.setStrategy(SubscriptionOpeningStrategy.TAKE_OVER);
SubscriptionWorker<Order> worker1 = store.subscriptions().getSubscriptionWorker(Order.class, options1);


while (true) \{
    try \{
        worker1
            .run(x -> \{
                // your logic
            \});
    \} catch (Exception e) \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>

The secondary worker:

<TabItem value="waiting_subscription_2" label="waiting_subscription_2">
<CodeBlock language="java">
{`SubscriptionWorkerOptions options2 = new SubscriptionWorkerOptions(subscriptionName);
options2.setStrategy(SubscriptionOpeningStrategy.WAIT_FOR_FREE);
SubscriptionWorker<Order> worker2 = store.subscriptions().getSubscriptionWorker(Order.class, options2);

while (true) \{
    try \{
        worker2
            .run(x -> \{
                // your logic
            \});
    \} catch (Exception e) \{
        // retry
    \}
\}
`}
</CodeBlock>
</TabItem>




</LanguageContent>

<!---
### Data Subscriptions:
- [What are Data Subscriptions](../../../client-api/data-subscriptions/what-are-data-subscriptions)
- [How to Create a Data Subscription](../../../client-api/data-subscriptions/creation/how-to-create-data-subscription)
- [How to Consume a Data Subscription](../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription)


-->