---
title: "Indexes: Indexing Related Documents"
hide_table_of_contents: true
sidebar_label: Indexing Related Documents
sidebar_position: 11
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["java", "csharp", "python", "php", "nodejs"];


# Indexes: Indexing Related Documents
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="java">


To extend indexing capabilities and simplify many scenarios, we have introduced the possibility for indexing related documents.

## Example I

Let's consider a simple `Product - Category` scenario where you want to look for a `Product` by `Category Name`.

Without this feature, you would have to create a fairly complex multiple map-reduce index. This is why the `LoadDocument` function was introduced.

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="java">
{`public static class Products_ByCategoryName extends AbstractIndexCreationTask {
    public Products_ByCategoryName() {
        map = "docs.Products.Select(product => new { " +
            "    CategoryName = (this.LoadDocument(product.Category, \\"Categories\\")).Name " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="java">
{`IndexDefinition indexDefinition = new IndexDefinition();
indexDefinition.setName("Products/ByCategoryName");
indexDefinition.setMaps(Collections.singleton("from product in products " +
    "   select new " +
    "   { " +
    "       CategoryName = LoadDocument(product.Category, \\"\\"Categories\\"\\").Name " +
    "   }"));

store.maintenance().send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Products_ByCategoryName extends AbstractJavaScriptIndexCreationTask {
    public Products_ByCategoryName() {
        setMaps(Sets.newHashSet("map('products', function(product ){\\n" +
            "            return {\\n" +
            "                CategoryName : load(product .Category, 'Categories').Name,\\n" +
            "            }\\n" +
            "        })"));
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we will be able to search for products using the `CategoryName` as a parameter:

<TabItem value="indexing_related_documents_7" label="indexing_related_documents_7">
<CodeBlock language="java">
{`List<Product> results = session
    .query(Product.class, Products_ByCategoryName.class)
    .whereEquals("CategoryName", "Beverages")
    .toList();
`}
</CodeBlock>
</TabItem>

## Example II

Our next scenario will show us how indexing of more complex relationships is also trivial. Let's consider the following case:

<TabItem value="indexing_related_documents_4" label="indexing_related_documents_4">
<CodeBlock language="java">
{`public static class Book \{
    private String id;
    private String name;

    public String getId() \{
        return id;
    \}

    public void setId(String id) \{
        this.id = id;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}
\}

public static class Author \{
    private String id;
    private String name;
    private List<String> bookIds;

    public String getId() \{
        return id;
    \}

    public void setId(String id) \{
        this.id = id;
    \}

    public String getName() \{
        return name;
    \}

    public void setName(String name) \{
        this.name = name;
    \}

    public List<String> getBookIds() \{
        return bookIds;
    \}

    public void setBookIds(List<String> bookIds) \{
        this.bookIds = bookIds;
    \}
\}
`}
</CodeBlock>
</TabItem>

To create an index with `Author Name` and list of `Book Names`, we need do the following:

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
<CodeBlock language="java">
{`public static class Authors_ByNameAndBooks extends AbstractIndexCreationTask {
    public Authors_ByNameAndBooks() {
        map = "docs.Authors.Select(author => new { " +
            "    name = author.name, " +
            "    books = author.bookIds.Select(x => (this.LoadDocument(x, \\"Books\\")).name) " +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Operation" label="Operation">
<CodeBlock language="java">
{`IndexDefinition indexDefinition = new IndexDefinition();
indexDefinition.setName("Authors/ByNameAndBooks");
indexDefinition.setMaps(Collections.singleton("from author in docs.Authors " +
    "     select new " +
    "     { " +
    "         name = author.name, " +
    "         books = author.bookIds.Select(x => LoadDocument(x, \\"\\"Books\\"\\").id) " +
    "     }"));
store.maintenance().send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript" label="JavaScript">
<CodeBlock language="java">
{`public static class Authors_ByNameAndBookNames extends AbstractJavaScriptIndexCreationTask {
    public Authors_ByNameAndBookNames() {
        setMaps(Sets.newHashSet("map('author', function(a){\\n" +
            "            return {\\n" +
            "                name: a.name,\\n" +
            "                books: a.booksIds.forEach(x => load(x, 'Book').name)\\n" +
            "            }\\n" +
            "        })"));
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

<TabItem value="indexing_related_documents_8" label="indexing_related_documents_8">
<CodeBlock language="java">
{`List<Author> results = session
    .query(Author.class, Authors_ByNameAndBooks.class)
    .whereEquals("name", "Andrzej Sapkowski")
    .whereEquals("books", "The Witcher")
    .toList();
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="">
Indexes are updated automatically when related documents change.
</Admonition>

<Admonition type="warning" title="">
Using the `LoadDocument` adds a loaded document to the tracking list. This may cause very expensive calculations to occur, especially when multiple documents are tracking the same document.
</Admonition>


</LanguageContent>
<LanguageContent language="csharp">

<Admonition type="note" title="">

* As described in [modeling considerations in RavenDB](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#summary),  
  it is recommended for documents to be: independent, isolated, and coherent.  
  However, to accommodate varied models, **documents can reference other documents**.  

* The related data from a referenced (related) document can be indexed,  
  this will allow querying the collection by the indexed related data.

* The related documents that are loaded in the index definition can be either **Tracked** or **Not-Tracked**.

* In this page:

   * [What are related documents](../indexes/indexing-related-documents.mdx#what-are-related-documents)


   * [Index related documents - With tracking](../indexes/indexing-related-documents.mdx#index-related-documents---with-tracking)
     * [Example I - basic](../indexes/indexing-related-documents.mdx#example-i---basic)
     * [Example II - list](../indexes/indexing-related-documents.mdx#example-ii---list)
     * [Tracking implications](../indexes/indexing-related-documents.mdx#tracking-implications)
   * [Index related documents - No tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [Example III - no tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [No-tracking implications](../indexes/indexing-related-documents.mdx#no-tracking-implications)
   * [Document changes that cause re-indexing](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)
   * [LoadDocument Syntax](../indexes/indexing-related-documents.mdx#loaddocument-syntax)
  
</Admonition>

## What are related documents

* Whenever a document references another document, the referenced document is called a **Related Document**.  

* In the image below, document `products/34-A` references documents `categories/1-A` & `suppliers/16-A`,  
  which are considered Related Documents.
  ![Referencing related documents](./assets/index-related-documents.png)



## Index related documents - With tracking

### Example I - basic

* **What is tracked**:  
  Both the documents from the **indexed collection** and the **indexed related documents** are tracked for changes.  
  Re-indexing will be triggered per any change in either collection.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
  Following the above `Product - Category` relationship from the Northwind sample database,  
  an index defined on the Products collection can index data from the related Category document.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="csharp">
{`public class Products_ByCategoryName : AbstractIndexCreationTask<Product>
{
    public class IndexEntry
    {
        public string CategoryName { get; set; }
    }

    public Products_ByCategoryName()
    {
        Map = products => from product in products
            
            // Call LoadDocument to load the related Category document
            // The document ID to load is specified by 'product.Category'
            let category = LoadDocument<Category>(product.Category)
            
            select new IndexEntry
            {
                // Index the Name field from the related Category document
                CategoryName = category.Name
            };
                
            // Since NoTracking was Not specified,
            // then any change to either Products or Categories will trigger reindexing 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="csharp">
{`public class Products_ByCategoryName_JS : AbstractJavaScriptIndexCreationTask
{
    public Products_ByCategoryName_JS()
    {
        Maps = new HashSet<string>()
        {
            // Call method 'load' to load the related Category document
            // The document ID to load is specified by 'product.Category'
            // The Name field from the related Category document will be indexed
            
            @"map('products', function(product) {
                let category = load(product.Category, 'Categories')
                return {
                    CategoryName: category.Name
                };
            })"
            
            // Since noTracking was Not specified,
            // then any change to either Products or Categories will trigger reindexing 
        };
    }
}
`}
</CodeBlock>
</TabItem>
     </Tabs>

* **The query**:  
  We can now query the index for Product documents by `CategoryName`,  
  i.e. get all matching Products that reference a Category that has the specified name term.

<Tabs groupId='languageSyntax'>
<TabItem value="Query(sync)" label="Query(sync)">
<CodeBlock language="csharp">
{`IList<Product> matchingProducts = session
    .Query<Products_ByCategoryName.IndexEntry, Products_ByCategoryName>()
    .Where(x => x.CategoryName == "Beverages")
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query(async)" label="Query(async)">
<CodeBlock language="csharp">
{`IList<Product> matchingProducts = await asyncSession
    .Query<Products_ByCategoryName.IndexEntry, Products_ByCategoryName>()
    .Where(x => x.CategoryName == "Beverages")
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
### Example II - list

* **The documents**:  
<TabItem value="indexing_related_documents_3" label="indexing_related_documents_3">
<CodeBlock language="csharp">
{`// The referencing document
public class Author
\{
    public string Id \{ get; set; \}
    public string Name \{ get; set; \}
    
    // Referencing a list of related document IDs
    public List<string> BookIds \{ get; set; \}
\}

// The related document
public class Book
\{
    public string Id \{ get; set; \}
    public string Name \{ get; set; \}
\}
`}
</CodeBlock>
</TabItem>

* **The index**:  
  This index will index all names of the related Book documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="csharp">
{`public class Authors_ByBooks : AbstractIndexCreationTask<Author>
{
    public class IndexEntry
    {
        public IEnumerable<string> BookNames { get; set; }
    }

    public Authors_ByBooks()
    {
        Map = authors => from author in authors
            select new IndexEntry
            {
                // For each Book ID, call LoadDocument and index the book's name
                BookNames = author.BookIds.Select(x => LoadDocument<Book>(x).Name)
            };
        
        // Since NoTracking was Not specified,
        // then any change to either Authors or Books will trigger reindexing 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="csharp">
{`public class Authors_ByBooks_JS : AbstractJavaScriptIndexCreationTask
{
    public Authors_ByBooks_JS()
    {
        Maps = new HashSet<string>()
        {
            // For each Book ID, call 'load' and index the book's name
            @"map('Author', function(author) {
                return {
                    Books: author.BooksIds.map(x => load(x, 'Books').Name)
                }
            })"
            
            // Since NoTracking was Not specified,
            // then any change to either Authors or Books will trigger reindexing 
        };
    }
}
`}
</CodeBlock>
</TabItem>
     </Tabs>
     
* **The query**:  
  We can now query the index for Author documents by a book's name,  
  i.e. get all Authors that have the specified book's name in their list.
<Tabs groupId='languageSyntax'>
<TabItem value="Query(sync)" label="Query(sync)">
<CodeBlock language="csharp">
{`// Get all authors that have books with title: "The Witcher"
IList<Author> matchingAuthors = session
    .Query<Authors_ByBooks.IndexEntry, Authors_ByBooks>()
    .Where(x => x.BookNames.Contains("The Witcher"))
    .OfType<Author>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query(async)" label="Query(async)">
<CodeBlock language="csharp">
{`// Get all authors that have books with title: "The Witcher"
IList<Author> matchingAuthors = await asyncSession
    .Query<Authors_ByBooks.IndexEntry, Authors_ByBooks>()
    .Where(x => x.BookNames.Contains("The Witcher"))
    .OfType<Author>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Get all authors that have books with title: "The Witcher"
from index "Authors/ByBooks"
where BookNames = "The Witcher"
`}
</CodeBlock>
</TabItem>
  </Tabs>
<Admonition type="info" title="">
### Tracking implications

* Indexing related data with tracking can be a useful way to query documents by their related data.  
  However, that may come with performance costs.

* **Re-indexing** will be triggered whenever any document in the collection that is referenced by `LoadDocument` is changed. 
  Even when indexing just a single field from the related document, any change to any other field will cause re-indexing. 
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* Frequent re-indexing will increase CPU usage and reduce performance,  
  and index results may be stale for prolonged periods.

* Tracking indexed related data is more useful when the indexed related collection is known not to change much.

</Admonition>



## Index related documents - No tracking

### Example III - no tracking

* **What is tracked**:  
   * Only the documents from the **indexed collection** are tracked for changes and can trigger re-indexing.  
     Any change done to any document in the **indexed related documents** will Not trigger re-indexing.  
     (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="csharp">
{`public class Products_ByCategoryName_NoTracking : AbstractIndexCreationTask<Product>
{
    public class IndexEntry
    {
        public string CategoryName { get; set; }
    }

    public Products_ByCategoryName_NoTracking()
    {
        Map = products => from product in products
            
            // Call NoTracking.LoadDocument to load the related Category document w/o tracking
            let category = NoTracking.LoadDocument<Category>(product.Category)
            
            select new IndexEntry
            {
                // Index the Name field from the related Category document
                CategoryName = category.Name
            };
                
            // Since NoTracking is used -
            // then only the changes to Products will trigger reindexing 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="csharp">
{`public class Products_ByCategoryName_NoTracking_JS : AbstractJavaScriptIndexCreationTask
{
    public Products_ByCategoryName_NoTracking_JS()
    {
        Maps = new HashSet<string>()
        {
            // Call 'noTracking.load' to load the related Category document w/o tracking
            
            @"map('products', function(product) {
                let category = noTracking.load(product.Category, 'Categories')
                return {
                    CategoryName: category.Name
                };
            })"
            
            // Since noTracking is used -
            // then only the changes to Products will trigger reindexing
        };
    }
}
`}
</CodeBlock>
</TabItem>
  </Tabs>

* **The query**:  
  When querying the index for Product documents by `CategoryName`,   
  results will be based on the related data that was **first indexed** when the index was deployed.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query(sync)" label="Query(sync)">
<CodeBlock language="csharp">
{`IList<Product> matchingProducts = session
    .Query<Products_ByCategoryName_NoTracking.IndexEntry, Products_ByCategoryName_NoTracking>()
    .Where(x => x.CategoryName == "Beverages")
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query(async)" label="Query(async)">
<CodeBlock language="csharp">
{`IList<Product> matchingProducts = await asyncSession
    .Query<Products_ByCategoryName_NoTracking.IndexEntry, Products_ByCategoryName_NoTracking>()
    .Where(x => x.CategoryName == "Beverages")
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName/NoTracking"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
<Admonition type="info" title="">
### No-tracking implications

* Indexing related data with no-tracking can be a useful way to query documents by their related data.  
  However, that may come with some data accuracy costs.

* **Re-indexing** will Not be triggered when documents in the collection that is referenced by `LoadDocument` are changed. 
  Although this may save system resources, the index entries and the indexed terms may not be updated with the current state of data.

* Indexing related data without tracking is useful when the indexed related data is fixed and not supposed to change.

</Admonition>



## Document changes that cause re-indexing

* The following changes done to a document will trigger re-indexing:  
   * Any modification to any document field (not just to the indexed fields)
   * Adding/Deleting an attachment
   * Creating a new Time series (modifying existing will not trigger)
   * Creating a new Counter (modifying existing will not trigger)

* Any such change done on any document in the **indexed collection** will trigger re-indexing.

* Any such change done on any document in the **indexed related documents** will trigger re-indexing  
  only if `NoTracking` was Not used in the index definition.



## LoadDocument syntax

#### Syntax for LINQ-index:

<TabItem value="syntax" label="syntax">
<CodeBlock language="csharp">
{`T LoadDocument<T>(string relatedDocumentId);

T LoadDocument<T>(string relatedDocumentId, string relatedCollectionName);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds, string relatedCollectionName);
`}
</CodeBlock>
</TabItem>
#### Syntax for JavaScript-index:

<TabItem value="syntax_JS" label="syntax_JS">
<CodeBlock language="js">
{`object load(relatedDocumentId, relatedCollectionName);
`}
</CodeBlock>
</TabItem>

| Parameters                |                       |                                        |
|---------------------------|-----------------------|----------------------------------------|
| **relatedDocumentId**     | `string`              | ID of the related document to load     |
| **relatedCollectionName** | `string`              | The related collection name            |
| **relatedDocumentIds**    | `IEnumerable<string>` | A list of related document IDs to load |




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="">

* As described in [modeling considerations in RavenDB](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#summary),  
  it is recommended for documents to be: independent, isolated, and coherent.  
  However, to accommodate varied models, **documents can reference other documents**.  

* The related data from a referenced (related) document can be indexed,  
  this will allow querying the collection by the indexed related data.

* The related documents that are loaded in the index definition can be either **Tracked** or **Not-Tracked**.

* In this page:

   * [What are related documents](../indexes/indexing-related-documents.mdx#what-are-related-documents)


   * [Index related documents - With tracking](../indexes/indexing-related-documents.mdx#index-related-documents---with-tracking)
     * [Example I - basic](../indexes/indexing-related-documents.mdx#example-i---basic)
     * [Example II - list](../indexes/indexing-related-documents.mdx#example-ii---list)
     * [Tracking implications](../indexes/indexing-related-documents.mdx#tracking-implications)
   * [Index related documents - No tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [Example III - no tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [No-tracking implications](../indexes/indexing-related-documents.mdx#no-tracking-implications)
   * [Document changes that cause re-indexing](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)
   * [LoadDocument Syntax](../indexes/indexing-related-documents.mdx#loaddocument-syntax)
  
</Admonition>

## What are related documents

* Whenever a document references another document, the referenced document is called a **Related Document**.  

* In the image below, document `products/34-A` references documents `categories/1-A` & `suppliers/16-A`,  
  which are considered Related Documents.
  ![Referencing related documents](./assets/index-related-documents.png)



## Index related documents - With tracking

### Example I - basic

* **What is tracked**:  
  Both the documents from the **indexed collection** and the **indexed related documents** are tracked for changes.  
  Re-indexing will be triggered per any change in either collection.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
  Following the above `Product - Category` relationship from the Northwind sample database,  
  an index defined on the Products collection can index data from the related Category document.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="python">
{`class Products_ByCategoryName(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, category_name: str = None):
            self.category_name = category_name

    def __init__(self):
        super().__init__()
        self.map = (
            "from product in docs.Products "
            'let category = this.LoadDocument(product.Category, "Categories") '
            "select new { category_name = category.Name }"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="python">
{`class Products_ByCategoryName_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            # Call method 'load' to load the related Category document
            # The document ID to load is specified by 'product.Category'
            # The Name field from the related Category document will be indexed
            """
            map('products', function(product) {
                let category = load(product.Category, 'Categories')
                return {
                    category_name: category.Name
                };
            })
            """
            # Since no_tracking was not specified,
            # then any change to either Products or Categories will trigger reindexing
        }
`}
</CodeBlock>
</TabItem>
     </Tabs>

* **The query**:  
  We can now query the index for Product documents by `CategoryName`,  
  i.e. get all matching Products that reference a Category that has the specified name term.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`matching_products = list(
    session.query_index_type(Products_ByCategoryName, Products_ByCategoryName.IndexEntry)
    .where_equals("category_name", "Beverages")
    .of_type(Product)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
### Example II - list

* **The documents**:  
<TabItem value="indexing_related_documents_3" label="indexing_related_documents_3">
<CodeBlock language="python">
{`# The referencing document
class Author:
    def __init__(self, Id: str = None, name: str = None, book_ids: List[str] = None):
        self.Id = Id
        self.name = name

        # Referencing a list of related document IDs
        self.book_ids = book_ids


# The related document
class Book:
    def __init__(self, Id: str = None, name: str = None):
        self.Id = Id
        self.name = name
`}
</CodeBlock>
</TabItem>

* **The index**:  
  This index will index all names of the related Book documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="python">
{`class Authors_ByBooks(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, book_names: List[str] = None):
            self.book_names = book_names

    def __init__(self):
        super().__init__()
        self.map = (
            "from author in docs.Authors "
            "select new "
            "{"
            # For each Book ID, call LoadDocument and index the book's name
            '    book_names = author.book_ids.Select(x => LoadDocument(x, "Books").Name)'
            "}"
        )
        # Since no_tracking was not specified,
        # then any change to either Authors or Books will trigger reindexing
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="python">
{`class Authors_ByBooks_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            # For each Book ID, call 'load' and index the book's name
            """
            map('Author', function(author) {
                return {
                    books: author.BooksIds.map(x => load(x, 'Books').Name)
                }
            })
            """
            # Since no_tracking was not specified,
            # then any change to either Authors or Books will trigger reindexing
        }
`}
</CodeBlock>
</TabItem>
     </Tabs>
     
* **The query**:  
  We can now query the index for Author documents by a book's name,  
  i.e. get all Authors that have the specified book's name in their list.
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`# Get all authors that have books with title: "The Witcher"
matching_authors = list(
    session.query_index_type(Authors_ByBooks, Authors_ByBooks.IndexEntry)
    .where_in("book_names", ["The Witcher"])
    .of_type(Author)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Get all authors that have books with title: "The Witcher"
from index "Authors/ByBooks"
where BookNames = "The Witcher"
`}
</CodeBlock>
</TabItem>
  </Tabs>
<Admonition type="info" title="">
### Tracking implications

* Indexing related data with tracking can be a useful way to query documents by their related data.  
  However, that may come with performance costs.

* **Re-indexing** will be triggered whenever any document in the collection that is referenced by `LoadDocument` is changed. 
  Even when indexing just a single field from the related document, any change to any other field will cause re-indexing. 
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* Frequent re-indexing will increase CPU usage and reduce performance,  
  and index results may be stale for prolonged periods.

* Tracking indexed related data is more useful when the indexed related collection is known not to change much.

</Admonition>



## Index related documents - No tracking

### Example III - no tracking

* **What is tracked**:  
   * Only the documents from the **indexed collection** are tracked for changes and can trigger re-indexing.  
     Any change done to any document in the **indexed related documents** will Not trigger re-indexing.  
     (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="python">
{`class Products_ByCategoryName_NoTracking(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, category_name: str = None):
            self.category_name = category_name

    def __init__(self):
        super().__init__()
        self.map = (
            "from product in docs.Products "
            # Call NoTracking.LoadDocument to load the related Category document w/o tracking
            'let category = NoTracking.LoadDocument(product.Category, "Categories") '
            "select new {"
            # Index the name field from the related Category document
            " category_name = category.Name "
            "}"
        )
        # Since NoTracking is used -
        # then only the changes to Products will trigger reindexing
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="python">
{`class Products_ByCategoryName_NoTracking_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            # Call 'noTracking.load' to load the related Category document w/o tracking
            """
            map('products', function(product) {
                let category = noTracking.load(product.Category, 'Categories')
                return {
                    category_name: category.Name
                };
            })
            """
        }
        # Since noTracking is used -
        # then only the changes to Products will trigger reindexing
`}
</CodeBlock>
</TabItem>
  </Tabs>

* **The query**:  
  When querying the index for Product documents by `CategoryName`,   
  results will be based on the related data that was **first indexed** when the index was deployed.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`matching_products = list(
    session.query_index_type(
        Products_ByCategoryName_NoTracking, Products_ByCategoryName_NoTracking.IndexEntry
    )
    .where_equals("category_name", "Beverages")
    .of_type(Product)
)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName/NoTracking"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
<Admonition type="info" title="">
### No-tracking implications

* Indexing related data with no-tracking can be a useful way to query documents by their related data.  
  However, that may come with some data accuracy costs.

* **Re-indexing** will Not be triggered when documents in the collection that is referenced by `LoadDocument` are changed. 
  Although this may save system resources, the index entries and the indexed terms may not be updated with the current state of data.

* Indexing related data without tracking is useful when the indexed related data is fixed and not supposed to change.

</Admonition>



## Document changes that cause re-indexing

* The following changes done to a document will trigger re-indexing:  
   * Any modification to any document field (not just to the indexed fields)
   * Adding/Deleting an attachment
   * Creating a new Time series (modifying existing will not trigger)
   * Creating a new Counter (modifying existing will not trigger)

* Any such change done on any document in the **indexed collection** will trigger re-indexing.

* Any such change done on any document in the **indexed related documents** will trigger re-indexing  
  only if `NoTracking` was Not used in the index definition.



## LoadDocument syntax

<TabItem value="syntax" label="syntax">
<CodeBlock language="python">
{`T LoadDocument<T>(string relatedDocumentId);

T LoadDocument<T>(string relatedDocumentId, string relatedCollectionName);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds, string relatedCollectionName);
`}
</CodeBlock>
</TabItem>
#### Syntax for JavaScript-index:

<TabItem value="syntax_JS" label="syntax_JS">
<CodeBlock language="js">
{`object load(relatedDocumentId, relatedCollectionName);
`}
</CodeBlock>
</TabItem>

| Parameters                |                       |                                        |
|---------------------------|-----------------------|----------------------------------------|
| **relatedDocumentId**     | `string`              | ID of the related document to load     |
| **relatedCollectionName** | `string`              | The related collection name            |
| **relatedDocumentIds**    | `IEnumerable<string>` | A list of related document IDs to load |




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="">

* As described in [modeling considerations in RavenDB](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#summary),  
  it is recommended for documents to be: independent, isolated, and coherent.  
  However, to accommodate varied models, **documents can reference other documents**.  

* The related data from a referenced (related) document can be indexed,  
  this will allow querying the collection by the indexed related data.

* The related documents that are loaded in the index definition can be either **Tracked** or **Not-Tracked**.

* In this page:

   * [What are related documents](../indexes/indexing-related-documents.mdx#what-are-related-documents)


   * [Index related documents - With tracking](../indexes/indexing-related-documents.mdx#index-related-documents---with-tracking)
     * [Example I - basic](../indexes/indexing-related-documents.mdx#example-i---basic)
     * [Example II - list](../indexes/indexing-related-documents.mdx#example-ii---list)
     * [Tracking implications](../indexes/indexing-related-documents.mdx#tracking-implications)
   * [Index related documents - No tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [Example III - no tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
     * [No-tracking implications](../indexes/indexing-related-documents.mdx#no-tracking-implications)
   * [Document changes that cause re-indexing](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)
   * [LoadDocument Syntax](../indexes/indexing-related-documents.mdx#loaddocument-syntax)
  
</Admonition>

## What are related documents

* Whenever a document references another document, the referenced document is called a **Related Document**.  

* In the image below, document `products/34-A` references documents `categories/1-A` & `suppliers/16-A`,  
  which are considered Related Documents.
  ![Referencing related documents](./assets/index-related-documents.png)



## Index related documents - With tracking

### Example I - basic

* **What is tracked**:  
  Both the documents from the **indexed collection** and the **indexed related documents** are tracked for changes.  
  Re-indexing will be triggered per any change in either collection.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
  Following the above `Product - Category` relationship from the Northwind sample database,  
  an index defined on the Products collection can index data from the related Category document.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="php">
{`class Products_ByCategoryName_IndexEntry
{
    private ?string $categoryName = null;

    public function getCategoryName(): ?string
    {
        return $this->categoryName;
    }

    public function setCategoryName(?string $categoryName): void
    {
        $this->categoryName = $categoryName;
    }
}
class Products_ByCategoryName extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from product in docs.Products " .
            'let category = this.LoadDocument(product.Category, "Categories") ' .
            "select new { CategoryName = category.Name }";

            // Since NoTracking was Not specified,
            // then any change to either Products or Categories will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="php">
{`class Products_ByCategoryName_JS extends AbstractJavaScriptIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        // Call method 'load' to load the related Category document
        // The document ID to load is specified by 'product.Category'
        // The Name field from the related Category document will be indexed
        $this->setMaps([
            "map('products', function(product) { " .
            "    let category = load(product.Category, 'Categories') " .
            "    return { " .
            "        CategoryName: category.Name " .
            "    }; " .
            "})"
        ]);

        // Since noTracking was Not specified,
        // then any change to either Products or Categories will trigger reindexing

    }
}
`}
</CodeBlock>
</TabItem>
     </Tabs>

* **The query**:  
  We can now query the index for Product documents by `CategoryName`,  
  i.e. get all matching Products that reference a Category that has the specified name term.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$matchingProducts = $session
    ->query(Products_ByCategoryName_IndexEntry::class, Products_ByCategoryName::class)
    ->whereEquals("CategoryName", "Beverages")
    ->ofType(Product::class)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
### Example II - list

* **The documents**:  
<TabItem value="indexing_related_documents_3" label="indexing_related_documents_3">
<CodeBlock language="php">
{`// The referencing document
class Author
\{
    private ?string $id = null;
    private ?string $name = null;

    // Referencing a list of related document IDs
    private ?StringArray $bookIds = null;

    public function getId(): ?string
    \{
        return $this->id;
    \}

    public function setId(?string $id): void
    \{
        $this->id = $id;
    \}

    public function getName(): ?string
    \{
        return $this->name;
    \}

    public function setName(?string $name): void
    \{
        $this->name = $name;
    \}

    public function getBookIds(): ?StringArray
    \{
        return $this->bookIds;
    \}

    public function setBookIds(?StringArray $bookIds): void
    \{
        $this->bookIds = $bookIds;
    \}
\}

// The related document
class Book
\{
    private ?string $id = null;
    private ?string $name = null;

    public function getId(): ?string
    \{
        return $this->id;
    \}

    public function setId(?string $id): void
    \{
        $this->id = $id;
    \}

    public function getName(): ?string
    \{
        return $this->name;
    \}

    public function setName(?string $name): void
    \{
        $this->name = $name;
    \}
\}
`}
</CodeBlock>
</TabItem>

* **The index**:  
  This index will index all names of the related Book documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="php">
{`class Authors_ByBooks_IndexEntry
{
    private ?StringArray $bookNames = null;

    public function getBookNames(): ?StringArray
    {
        return $this->bookNames;
    }

    public function setBookNames(?StringArray $bookNames): void
    {
        $this->bookNames = $bookNames;
    }
}
class Authors_ByBooks extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from author in docs.Authors " .
            "select new " .
            "{" .
            // For each Book ID, call LoadDocument and index the book's name
            '    BookNames = author.BookIds.Select(x => LoadDocument(x, "Books").Name)' .
            "}";

        // Since NoTracking was Not specified,
        // then any change to either Authors or Books will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="php">
{`class Authors_ByBooks_JS extends AbstractJavaScriptIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->setMaps([
            // For each Book ID, call 'load' and index the book's name
            "map('Author', function(author) {
                return {
                    Books: author.BooksIds.map(x => load(x, 'Books').Name)
                }
            })"
        ]);

        // Since NoTracking was Not specified,
        // then any change to either Authors or Books will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
     </Tabs>
     
* **The query**:  
  We can now query the index for Author documents by a book's name,  
  i.e. get all Authors that have the specified book's name in their list.
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`// Get all authors that have books with title: "The Witcher"
$matchingAuthors = $session
    ->query(Authors_ByBooks_IndexEntry::class, Authors_ByBooks::class)
    ->containsAny("BookNames", ["The Witcher"])
    ->ofType(Author::class)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Get all authors that have books with title: "The Witcher"
from index "Authors/ByBooks"
where BookNames = "The Witcher"
`}
</CodeBlock>
</TabItem>
  </Tabs>
<Admonition type="info" title="">
### Tracking implications

* Indexing related data with tracking can be a useful way to query documents by their related data.  
  However, that may come with performance costs.

* **Re-indexing** will be triggered whenever any document in the collection that is referenced by `LoadDocument` is changed. 
  Even when indexing just a single field from the related document, any change to any other field will cause re-indexing. 
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* Frequent re-indexing will increase CPU usage and reduce performance,  
  and index results may be stale for prolonged periods.

* Tracking indexed related data is more useful when the indexed related collection is known not to change much.

</Admonition>



## Index related documents - No tracking

### Example III - no tracking

* **What is tracked**:  
   * Only the documents from the **indexed collection** are tracked for changes and can trigger re-indexing.  
     Any change done to any document in the **indexed related documents** will Not trigger re-indexing.  
     (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* **The index**:  
<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="php">
{`class Products_ByCategoryName_NoTracking_IndexEntry
{
    private ?string $categoryName = null;

    public function getCategoryName(): ?string
    {
        return $this->categoryName;
    }

    public function setCategoryName(?string $categoryName): void
    {
        $this->categoryName = $categoryName;
    }
}

class Products_ByCategoryName_NoTracking extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from product in docs.Products " .
            # Call NoTracking.LoadDocument to load the related Category document w/o tracking
            'let category = NoTracking.LoadDocument(product.Category, "Categories") ' .
            "select new {" .
            # Index the name field from the related Category document
            " CategoryName = category.Name " .
            "}";

        // Since NoTracking is used -
        // then only the changes to Products will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="php">
{`class Products_ByCategoryName_NoTracking_JS extends AbstractJavaScriptIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->setMaps([
            // Call 'noTracking.load' to load the related Category document w/o tracking
            "map('products', function(product) {
                let category = noTracking.load(product.Category, 'Categories')
                return {
                    CategoryName: category.Name
                };
            })"
        ]);

        // Since noTracking is used -
        // then only the changes to Products will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
  </Tabs>

* **The query**:  
  When querying the index for Product documents by `CategoryName`,   
  results will be based on the related data that was **first indexed** when the index was deployed.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$matchingProducts = $session
    ->query(Products_ByCategoryName_NoTracking_IndexEntry::class, Products_ByCategoryName_NoTracking::class)
    ->whereEquals("CategoryName", "Beverages")
    ->ofType(Product::class)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName/NoTracking"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
     </Tabs>
<Admonition type="info" title="">
### No-tracking implications

* Indexing related data with no-tracking can be a useful way to query documents by their related data.  
  However, that may come with some data accuracy costs.

* **Re-indexing** will Not be triggered when documents in the collection that is referenced by `LoadDocument` are changed. 
  Although this may save system resources, the index entries and the indexed terms may not be updated with the current state of data.

* Indexing related data without tracking is useful when the indexed related data is fixed and not supposed to change.

</Admonition>



## Document changes that cause re-indexing

* The following changes done to a document will trigger re-indexing:  
   * Any modification to any document field (not just to the indexed fields)
   * Adding/Deleting an attachment
   * Creating a new Time series (modifying existing will not trigger)
   * Creating a new Counter (modifying existing will not trigger)

* Any such change done on any document in the **indexed collection** will trigger re-indexing.

* Any such change done on any document in the **indexed related documents** will trigger re-indexing  
  only if `NoTracking` was Not used in the index definition.



## LoadDocument syntax

<TabItem value="syntax" label="syntax">
<CodeBlock language="php">
{`T LoadDocument<T>(string relatedDocumentId);

T LoadDocument<T>(string relatedDocumentId, string relatedCollectionName);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds, string relatedCollectionName);
`}
</CodeBlock>
</TabItem>
#### Syntax for JavaScript-index:

<TabItem value="syntax_JS" label="syntax_JS">
<CodeBlock language="js">
{`object load(relatedDocumentId, relatedCollectionName);
`}
</CodeBlock>
</TabItem>

| Parameters                |                       |                                        |
|---------------------------|-----------------------|----------------------------------------|
| **relatedDocumentId**     | `string`              | ID of the related document to load     |
| **relatedCollectionName** | `string`              | The related collection name            |
| **relatedDocumentIds**    | `IEnumerable<string>` | A list of related document IDs to load |




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="">

* As described in [modeling considerations in RavenDB](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#summary),  
  it is recommended for documents to be: independent, isolated, and coherent.  
  However, to accommodate varied models, **documents can reference other documents**.

* The related data from a referenced (related) document can be indexed,  
  this will allow querying the collection by the indexed related data.

* The related documents that are loaded in the index definition can be either **Tracked** or **Not-Tracked**.

* In this page:

    * [What are related documents](../indexes/indexing-related-documents.mdx#what-are-related-documents)


    * [Index related documents - With tracking](../indexes/indexing-related-documents.mdx#index-related-documents---with-tracking)
        * [Example I - basic](../indexes/indexing-related-documents.mdx#example-i---basic)
        * [Example II - list](../indexes/indexing-related-documents.mdx#example-ii---list)
        * [Tracking implications](../indexes/indexing-related-documents.mdx#tracking-implications)
    * [Index related documents - No tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
        * [Example III - no tracking](../indexes/indexing-related-documents.mdx#index-related-documents---no-tracking)
        * [No-tracking implications](../indexes/indexing-related-documents.mdx#no-tracking-implications)
    * [Document changes that cause re-indexing](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)
    * [LoadDocument Syntax](../indexes/indexing-related-documents.mdx#loaddocument-syntax)

</Admonition>

## What are related documents

* Whenever a document references another document, the referenced document is called a **Related Document**.

* In the image below, document `products/34-A` references documents `categories/1-A` & `suppliers/16-A`,  
  which are considered Related Documents.
  ![Referencing related documents](./assets/index-related-documents.png)



## Index related documents - With tracking

<Admonition type="note" title="">
#### Example I - basic
**What is tracked**:

* Both the documents from the **indexed collection** and the **indexed related documents** are tracked for changes.  
  Re-indexing will be triggered per any change in either collection.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

**The index**:

* Following the above `Product - Category` relationship from the Northwind sample database,  
  an index defined on the Products collection can index data from the related Category document.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="js">
{`class Products_ByCategoryName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();
        
        // Call LoadDocument to load the related Category document
        // The document ID to load is specified by 'product.Category'
        // The Name field from the related Category document will be indexed
        
        this.map = \`docs.Products.Select(product => new {
            CategoryName = (this.LoadDocument(product.Category, "Categories")).Name 
        })\`;

        // Since NoTracking was Not specified,
        // then any change to either Products or Categories will trigger reindexing 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="js">
{`class Products_ByCategoryName_JS extends AbstractJavaScriptIndexCreationTask {
    constructor () {
        super();

        const { load } = this.mapUtils();

        this.map("Products", product => {
            return {
                // Call method 'load' to load the related Category document
                // The document ID to load is specified by 'product.Category'
                // The Name field from the related Category document will be indexed                
                categoryName: load(product.Category, "Categories").Name

                // Since NoTracking was Not specified,
                // then any change to either Products or Categories will trigger reindexing
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

**The query**:

* We can now query the index for Product documents by `CategoryName`,  
  i.e. get all matching Products that reference a Category that has the specified name term.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query({indexName: "Products/ByCategoryName"})
    .whereEquals("CategoryName", "Beverages")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="note" title="">
#### Example II - list
**The documents**:

<TabItem value="indexing_related_documents_3" label="indexing_related_documents_3">
<CodeBlock language="js">
{`// The referencing document
class Author \{
    constructor(id, name, bookIds) \{
        this.id = id;
        this.name = name;
        
        // Referencing a list of related document IDs
        this.bookIds = bookIds;
    \}
\}
// The related document
class Book \{
    constructor(id, name) \{
        this.id = id;
        this.name = name;
    \}
\}
`}
</CodeBlock>
</TabItem>

**The index**:

* This index will index all names of the related Book documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="js">
{`class Authors_ByBooks extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        // For each Book ID, call LoadDocument and index the book's name
        this.map = \`docs.Authors.Select(author => new {
            BookNames = author.bookIds.Select(x => (this.LoadDocument(x, "Books")).name) 
        })\`;

        // Since NoTracking was Not specified,
        // then any change to either Authors or Books will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="js">
{`class Authors_ByBooks_JS extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        const { load } = this.mapUtils();

        this.map("Authors", author => {
            return {
                // For each Book ID, call 'load' and index the book's name
                BookNames: author.bookIds.map(x => load(x, "Books").name)

                // Since NoTracking was Not specified,
                // then any change to either Products or Categories will trigger reindexing
            };
        });
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

**The query**:

* We can now query the index for Author documents by a book's name,  
  i.e. get all Authors that have the specified book's name in their list.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query({indexName: "Authors/ByBooks"})
    .whereEquals("BookNames", "The Witcher")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Get all authors that have books with title: "The Witcher"
from index "Authors/ByBooks"
where BookNames = "The Witcher"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="info" title="">
#### Tracking implications

* Indexing related data with tracking can be a useful way to query documents by their related data.  
  However, that may come with performance costs.

* **Re-indexing** will be triggered whenever any document in the collection that is referenced by `LoadDocument` is changed.
  Even when indexing just a single field from the related document, any change to any other field will cause re-indexing.
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

* Frequent re-indexing will increase CPU usage and reduce performance,  
  and index results may be stale for prolonged periods.

* Tracking indexed related data is more useful when the indexed related collection is known not to change much.

</Admonition>



## Index related documents - No tracking

<Admonition type="note" title="">
#### Example III - no tracking
**What is tracked**:

* Only the documents from the **indexed collection** are tracked for changes and can trigger re-indexing.  
  Any change done to any document in the **indexed related documents** will Not trigger re-indexing.  
  (See changes that cause re-indexing [here](../indexes/indexing-related-documents.mdx#document-changes-that-cause-re-indexing)).

**The index**:

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ-index" label="LINQ-index">
<CodeBlock language="js">
{`class Products_ByCategoryName_NoTracking extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        // Call NoTracking.LoadDocument to load the related Category document w/o tracking
        this.map = \`docs.Products.Select(product => new {
            CategoryName = (this.NoTracking.LoadDocument(product.Category, "Categories")).Name 
        })\`;

        // Since NoTracking is used -
        // then only the changes to Products will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JavaScript-index" label="JavaScript-index">
<CodeBlock language="js">
{`class Products_ByCategoryName_NoTracking_JS extends AbstractJavaScriptIndexCreationTask {
    constructor() {
        super();

        const { noTracking } = this.mapUtils();

        this.map("Products", product => {
            return {
                // Call 'noTracking.load' to load the related Category document w/o tracking
                categoryName: noTracking.load(product.Category, "Categories").Name
            };
        });
        
        // Since noTracking is used -
        // then only the changes to Products will trigger reindexing
    }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

**The query**:

* When querying the index for Product documents by `CategoryName`,   
  results will be based on the related data that was **first indexed** when the index was deployed.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const matchingProducts = await session
    .query({indexName: "Products/ByCategoryName/NoTracking"})
    .whereEquals("CategoryName", "Beverages")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByCategoryName/NoTracking"
where CategoryName == "Beverages"
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>

<Admonition type="info" title="">
#### No-tracking implications

* Indexing related data with no-tracking can be a useful way to query documents by their related data.  
  However, that may come with some data accuracy costs.

* **Re-indexing** will Not be triggered when documents in the collection that is referenced by `LoadDocument` are changed.
  Although this may save system resources, the index entries and the indexed terms may not be updated with the current state of data.

* Indexing related data without tracking is useful when the indexed related data is fixed and not supposed to change.

</Admonition>



## Document changes that cause re-indexing

* The following changes done to a document will trigger re-indexing:

    * Any modification to any document field (not just to the indexed fields)
    * Adding/Deleting an attachment
    * Creating a new Time series (modifying existing will not trigger)
    * Creating a new Counter (modifying existing will not trigger)

* Any such change done on any document in the **indexed collection** will trigger re-indexing.

* Any such change done on any document in the **indexed related documents** will trigger re-indexing  
  only if `NoTracking` was Not used in the index definition.



## LoadDocument syntax

#### Syntax for LINQ-index:

<TabItem value="syntax" label="syntax">
<CodeBlock language="csharp">
{`T LoadDocument<T>(string relatedDocumentId);

T LoadDocument<T>(string relatedDocumentId, string relatedCollectionName);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds);

T[] LoadDocument<T>(IEnumerable<string> relatedDocumentIds, string relatedCollectionName);
`}
</CodeBlock>
</TabItem>
#### Syntax for JavaScript-index:

<TabItem value="syntax_JS" label="syntax_JS">
<CodeBlock language="js">
{`object load(relatedDocumentId, relatedCollectionName);
`}
</CodeBlock>
</TabItem>

| Parameters                |                       |                                        |
|---------------------------|-----------------------|----------------------------------------|
| **relatedDocumentId**     | `string`              | ID of the related document to load     |
| **relatedCollectionName** | `string`              | The related collection name            |
| **relatedDocumentIds**    | `IEnumerable<string>` | A list of related document IDs to load |




</LanguageContent>

<!---
### Indexes
- [Indexing Basics](../indexes/indexing-basics)
- [Indexing Hierarchical Data](../indexes/indexing-hierarchical-data)
- [Indexing Spatial Data](../indexes/indexing-spatial-data)
- [Indexing Polymorphic Data](../indexes/indexing-polymorphic-data)

### Querying
- [Basics](../indexes/querying/query-index)
- [Query Overview](../client-api/session/querying/how-to-query)


-->