---
title: "Full-Text Search with Index"
hide_table_of_contents: true
sidebar_label: Full-Text Search
sidebar_position: 7
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "python", "php", "nodejs"];


# Full-Text Search with Index
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Prior to this article, please refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) to learn about the `Search` method.  

* **All capabilities** provided by `Search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).    
* In this page:
  * [Indexing single field for FTS](../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Boosting search results](../../indexes/querying/searching.mdx#boosting-search-results)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="csharp">
{`public class Employees_ByNotes :
    AbstractIndexCreationTask<Employee, Employees_ByNotes.IndexEntry>
\{
    // The IndexEntry class defines the index-fields
    public class IndexEntry
    \{
        public string EmployeeNotes \{ get; set; \}
    \}

    public Employees_ByNotes()
    \{
        // The 'Map' function defines the content of the index-fields
        Map = employees => from employee in employees
            select new IndexEntry()
            \{
                EmployeeNotes = employee.Notes[0]
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeNotes'
        Index(x => x.EmployeeNotes, FieldIndexing.Search);
        
        // Optionally: Set your choice of analyzer for the index-field.
        // Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        Analyze(x => x.EmployeeNotes, "WhitespaceAnalyzer");

        // Note:
        // If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `Search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
     // Query the index
    .Query<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
     // Query the index
    .Query<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToListAsync();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
// 
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
     // Query the index
    .DocumentQuery<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
// 
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="csharp">
{`public class Employees_ByEmployeeData : 
    AbstractIndexCreationTask<Employee, Employees_ByEmployeeData.IndexEntry>
\{
    public class IndexEntry
    \{
        public object[] EmployeeData \{ get; set; \}
    \}

    public Employees_ByEmployeeData()
    \{
        Map = employees => from employee in employees
            select new IndexEntry()
            \{
                EmployeeData = new object[]
                \{
                    // Multiple document-fields can be indexed
                    // into the single index-field 'EmployeeData' 
                    employee.FirstName,
                    employee.LastName,
                    employee.Title,
                    employee.Notes
                \}
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeData'
        Index(x => x.EmployeeData, FieldIndexing.Search);
        
        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
     // Query the static-index
    .Query<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
     // Query the static-index
    .Query<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .OfType<Employee>()
    .ToListAsync();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
     // Query the static-index
    .DocumentQuery<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
    .OpenSubclause()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .CloseSubclause()
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//                                                                                                                                                                                                                                                                                                                  
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../indexes/boosting.mdx).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../client-api/session/querying/text-search/boost-search-results.mdx).




</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).    
* In this page:
  * [Indexing single field for FTS](../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Boosting search results](../../indexes/querying/searching.mdx#boosting-search-results)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="python">
{`class Employees_ByNotes(AbstractIndexCreationTask):
    # The IndexEntry class defines the index-fields
    class IndexEntry:
        def __init__(self, employee_notes: str = None):
            self.employee_notes = employee_notes

    def __init__(self):
        super().__init__()
        # The 'Map' function defines the content of the index-fields
        self.map = "from employee in docs.Employees " "select new " "\{ " " employee_notes = employee.Notes[0]" "\}"

        # Configure the index-field for FTS:
        # Set 'FieldIndexing.Search' on index-field 'employee_notes'
        self._index("employee_notes", FieldIndexing.SEARCH)

        # Optionally: Set your choice of analyzer for the index-field:
        # Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        self._analyze("employee_notes", "WhitespaceAnalyzer")

        # Note:
        # If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `Search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`employees = list(
    session
    # Query the index
    .query_index_type(Employees_ByNotes, Employees_ByNotes.IndexEntry)
    # Call 'search':
    # pass the index field that was configured for FTS and the term to search for.
    .search("employee_notes", "French").of_type(Employee)
)
# * Results will contain all Employee documents that have 'French' in their 'Notes' field.

# * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
#   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="python">
{`class Employees_ByEmployeeData(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, employee_data: List = None):
            self.employee_data = employee_data

    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new \{"
            "  employee_data = "
            "  \{"
            # Multiple document-fields can be indexed
            # into the single index-field 'employee_data'
            "    employee.FirstName,"
            "    employee.LastName,"
            "    employee.Title,"
            "    employee.Notes"
            "  \}"
            "\}"
        )
        # Configure the index-field for FTS:
        # Set 'FieldIndexing.SEARCH' on index-field 'employee_data'
        self._index("employee_data", FieldIndexing.SEARCH)

        # Note:
        # Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`employees = list(
    session
    # Query the static-index
    .query_index_type(Employees_ByEmployeeData, Employees_ByEmployeeData.IndexEntry)
    .open_subclause()
    # A logical OR is applied between the following two search calls
    .search("employee_data", "Manager")
    # A logical AND is applied between the following two terms
    .search("employee_data", "French Spanish", operator=SearchOperator.AND)
    .close_subclause()
    .of_type(Employee)
)

# * Results will contain all Employee documents that have:
#   ('Manager' in any of the 4 document-fields that were indexed)
#   OR
#   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)

# * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../indexes/boosting.mdx).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../client-api/session/querying/text-search/boost-search-results.mdx).




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).    
* In this page:
  * [Indexing single field for FTS](../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Boosting search results](../../indexes/querying/searching.mdx#boosting-search-results)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="php">
{`// The IndexEntry class defines the index-fields
class Employees_ByNotes_IndexEntry
\{
    private ?string $employeeNotes = null;

    public function getEmployeeNotes(): ?string
    \{
        return $this->employeeNotes;
    \}

    public function setEmployeeNotes(?string $employeeNotes): void
    \{
        $this->employeeNotes = $employeeNotes;
    \}
\}
class Employees_ByNotes extends AbstractIndexCreationTask
\{
    public function __construct()
    \{
        parent::__construct();

        // The 'Map' function defines the content of the index-fields
        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "\{ " .
               " employee_notes = employee.Notes[0]" .
            "\}";

        # Configure the index-field for FTS:
        # Set 'FieldIndexing.Search' on index-field 'employee_notes'
        $this->index("employee_notes", FieldIndexing::search());

        # Optionally: Set your choice of analyzer for the index-field:
        # Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        $this->analyze("employee_notes", "WhitespaceAnalyzer");

        # Note:
        # If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session
     // Query the index
    ->query(Employees_ByNotes_IndexEntry::class, Employees_ByNotes::class)
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    ->search("EmployeeNotes", "French")
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session->advanced()
     // Query the index
    ->documentQuery(Employees_ByNotes_IndexEntry::class, Employees_ByNotes::class)
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    ->search("EmployeeNotes", "French")
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="php">
{`class EmployeeData
\{
    private ?string $firstName = null;
    private ?string $lastName = null;
    private ?string $title = null;
    private ?string $notes = null;

    // ... getters and setters
\}

class EmployeeDataArray extends TypedArray
\{
    protected function __construct()
    \{
        parent::__construct(EmployeeData::class);
    \}
\}

class Employees_ByEmployeeData_IndexEntry
\{
    public ?EmployeeDataArray  $employeeData = null;
\}
class Employees_ByEmployeeData extends AbstractIndexCreationTask
\{
    public function __construct()
    \{
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new \{" .
            "  EmployeeData = " .
            "  \{" .
            # Multiple document-fields can be indexed
            # into the single index-field 'employee_data'
            "    employee.FirstName," .
            "    employee.LastName," .
            "    employee.Title," .
            "    employee.Notes" .
            "  \}" .
            "\}";

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeData'
        $this->index("EmployeeData", FieldIndexing::search());

        // Note:
        // Since no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session
     // Query the static-index
    ->query(Employees_ByEmployeeData_IndexEntry::class, Employees_ByEmployeeData::class)
     // A logical OR is applied between the following two Search calls:
    ->search("EmployeeData", "Manager")
     // A logical AND is applied between the following two terms:
    ->search("EmployeeData", "French Spanish", SearchOperator::and())
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session->advanced()
     // Query the static-index
    ->documentQuery(Employees_ByEmployeeData_IndexEntry::class, Employees_ByEmployeeData::class)
    ->openSubclause()
     // A logical OR is applied between the following two Search calls:
    ->search("EmployeeData", "Manager")
     // A logical AND is applied between the following two terms:
    ->search("EmployeeData", "French Spanish", SearchOperator::and())
    ->closeSubclause()
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* To prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to the indexes [Boosting](../../indexes/boosting.mdx) article.  

  * Add a boost value to the queried terms **at query time**.  
    Refer to the [Boost search results](../../client-api/session/querying/text-search/boost-search-results.mdx) article.  




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).    
* In this page:
  * [Indexing single field for FTS](../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Boosting search results](../../indexes/querying/searching.mdx#boosting-search-results)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="js">
{`class Employees_ByNotes extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            employeeNotes: e.Notes
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");
        
        // Optionally: Set your choice of analyzer for the index-field.
        // Here the text from index-field 'employeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        this.analyze("employeeNotes", "WhitespaceAnalyzer");

        // Note:
        // If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Using the `search` method has the advantage of using any of its functionalities,  
  such as using wildcards, searching for multiple terms, etc.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const employees = await session
     // Query the index
    .query({ indexName: "Employees/ByNotes" })
     // Call 'Search':
     // pass the index field name that was configured for FTS and the term to search for.
    .search("employeeNotes", "French")
    .all();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(employeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="js">
{`class Employees_ByEmployeeData extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            // Multiple document-fields can be indexed
            // into the single index-field 'employeeData' 
            employeeData: [e.FirstName, e.LastName, e.Title, e.Notes]
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");

        // Note:
        // Since no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const employees = await session
     // Query the static-index
    .query({ indexName: "Employees/ByEmployeeData" })
    .openSubclause()
     // A logical OR is applied between the following two Search calls:
    .search("employeeData", "Manager")
     // A logical AND is applied between the following two terms: 
    .search("employeeData", "French Spanish", "AND")
    .closeSubclause()
    .all();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(employeeData, "Manager") or search(employeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../indexes/boosting.mdx).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../client-api/session/querying/text-search/boost-search-results.mdx).




</LanguageContent>

<!---
### Client API
- [Full-Text search](../../client-api/session/querying/text-search/full-text-search)

### Indexes
- [Analyzers](../../indexes/using-analyzers)
- [Boosting](../../indexes/boosting)


-->