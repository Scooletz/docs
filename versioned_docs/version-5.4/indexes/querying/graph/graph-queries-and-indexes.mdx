---
title: "Graph Queries And Indexes"
hide_table_of_contents: true
sidebar_label: Graph Queries and Indexes
sidebar_position: 4
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Graph Queries And Indexes  
<Admonition type="note" title="">

* You can **query indexes** using graph queries.  
* Graph queries use **various indexing methods**, depending on their characteristics.  
* You can create **Map Reduce** definitions that would lift some of the workload from the graph engine.  
* In this page:  
   * [Querying Indexes](../../../indexes/querying/graph/graph-queries-and-indexes.mdx#querying-indexes)  
   * [How Are Graph Queries Indexes](../../../indexes/querying/graph/graph-queries-and-indexes.mdx#how-are-graph-queries-indexed)  
   * [Graph Queries and Map Reduce](../../../indexes/querying/graph/graph-queries-and-indexes.mdx#graph-queries-and-map-reduce)  

</Admonition>
## Graph queries and Indexes

#### Querying Indexes

To query an index, define it as a **data node** using the 
[explicit syntax](../../../indexes/querying/graph/graph-queries-explicit-and-implicit.mdx#explicitly-declaring-data-elements).  
Use `from index` rather than the ordinary "from", with the index name as a parameter:  
`with {from index 'Orders/ByCompany'} as orders`  
  
The following query for example uses the `Orders/ByCompany` 
index while searching for big orders made by German companies.
<TabItem value="json" label="json">
<CodeBlock language="json">
{`with \{from index 'Orders/ByCompany' where Count > 10\} as bigOrders

match
    (bigOrders) -
    [Company as company] ->
    (Companies as companies where Address.Country = "Germany")
`}
</CodeBlock>
</TabItem>
#### How Are Graph Queries Indexed

Any graph query over the bare minimum is interpreted to several types of queries, each with its 
own measure of indexing and resource usage. Complex queries may combine methods mentioned here.  

* **No Indexing**  
  This query creates **no index**, since retrieving a whole collection requires no searching.  
<TabItem value="json" label="json">
<CodeBlock language="json">
{`match 
    (Orders as orders) 
`}
</CodeBlock>
</TabItem>

* **Auto Indexing**  
  The node clause shown here will trigger RavenDB to create an auto index for queried orders, 
  as done with non-graph queries.  
<TabItem value="json" label="json">
<CodeBlock language="json">
{`match 
    (Orders as orders 
        where ShipTo.Region = "Nueva Esparta")
`}
</CodeBlock>
</TabItem>

* **Handled by the graph queries engine**  
  Queries with edges are handled by the graph queries engine before handing them to clients, 
  to fathom the relations between data nodes.  
<TabItem value="json" label="json">
<CodeBlock language="json">
{`match 
    (Orders as orders)-
    [ShipVia as shipvia]->
    (Shippers as shippers)
`}
</CodeBlock>
</TabItem>
#### Graph Queries and Map Reduce

It is sometimes "cheaper" to transfer work load from the graph engine to Map Reduce 
for the "heavy lifting", and let the graph engine handle just the final results.  
To do this, create static [Map Reduce](../../../studio/database/indexes/create-map-reduce-index.mdx) 
definitions for datasets you intend to include in edge clauses.  



