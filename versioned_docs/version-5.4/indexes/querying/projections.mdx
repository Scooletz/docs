---
title: "Querying: Projections"
hide_table_of_contents: true
sidebar_label: Projections
sidebar_position: 5
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Querying: Projections
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


There are couple of ways to perform projections in RavenDB:

- projections using [Select](../../indexes/querying/projections.mdx#select)
- using [SelectFields](../../indexes/querying/projections.mdx#selectfields)
- using [ProjectInto](../../indexes/querying/projections.mdx#projectinto)
- using [OfType (As)](../../indexes/querying/projections.mdx#oftype-(as))

## What are Projections and When to Use Them

When performing a query, we usually pull the full document back from the server.

However, we often need to display the data to the user. Instead of pulling the whole document back and picking 
just what we'll show, we can ask the server to send us just the details we want to show the user and thus reduce 
the amount of traffic on the network.   

The savings can be very significant if we need to show just a bit of information on a large document.  

A good example in the sample data set would be the order document. If we ask for all the Orders where Company 
is "companies/65-A", the size of the result that we get back from the server is 19KB.

However, if we perform the same query and ask to get back only the Employee and OrderedAt fields, the size of 
the result is only 5KB.  

Aside from allowing you to pick only a portion of the data, projection functions give you the ability to 
rename some fields, load external documents, and perform transformations on the results. 

## Projections are Applied as the Last Stage in the Query

It is important to understand that projections are applied after the query has been processed, filtered, 
sorted, and paged. The projection doesn't apply to all the documents in the database, only to the results 
that are actually returned.  
This reduces the load on the server significantly, since we can avoid doing work only to throw it immediately 
after. It also means that we cannot do any filtering work as part of the projection. You can filter what will 
be returned, but not which documents will be returned. That has already been determined earlier in the query 
pipeline.  

## The Cost of Running a Projection

Another consideration to take into account is the cost of running the projection. It is possible to make the 
projection query expensive to run. RavenDB has limits on the amount of time it will spend in evaluating the 
projection, and exceeding these (quite generous) limits will fail the query.

## Projections and Stored Fields

If a projection function only requires fields that are stored, then the document will not be loaded from 
storage and all data will come from the index directly. This can increase query performance (by the cost 
of disk space used) in many situations when whole document is not needed. You can read more about field 
storing [here](../../indexes/storing-data-in-index.mdx).

## Select
The most basic projection can be done using LINQ `Select` method:

### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Employee, Employees_ByFirstAndLastName>()
    .Select(x => new
    {
        FirstName = x.FirstName,
        LastName = x.LastName
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastName()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               LastName = employee.LastName
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

This will issue a query to a database, requesting only `FirstName` and `LastName` from all documents that 
index entries match query predicate from `Employees/ByFirstAndLastName` index. What does it mean? If an index 
entry matches our query predicate, then we will try to extract all requested fields from that particular entry. 
If all requested fields are available in there, then we do not download it from storage. 
The index `Employees/ByFirstAndLastName` used in the above query is not storing any fields, 
so the documents will be fetched from storage.

### Example II - Projecting Stored Fields

If we create an index that stores `FirstName` and `LastName` and it requests only those fields in query, 
then **the data will come from the index directly**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Employee, Employees_ByFirstAndLastNameWithStoredFields>()
    .Select(x => new
    {
        FirstName = x.FirstName,
        LastName = x.LastName
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastNameWithStoredFields : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastNameWithStoredFields()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               LastName = employee.LastName
                           };
        StoreAllFields(FieldStorage.Yes); // FirstName and LastName fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastNameWithStoredFields'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Order, Orders_ByShipToAndLines>()
    .Select(x => new
    {
        ShipTo = x.ShipTo,
        Products = x.Lines.Select(y => y.ProductName),
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Orders_ByShipToAndLines : AbstractIndexCreationTask<Order>
{
    public Orders_ByShipToAndLines()
    {
        Map = orders => from order in orders
                        select new
                        {
                            ShipTo = order.ShipTo,
                            Lines = order.Lines
                        };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select 
{ 
    ShipTo: o.ShipTo, 
    Products : o.Lines.map(function(y){return y.ProductName;}) 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IV - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Employee, Employees_ByFirstAndLastName>()
    .Select(x => new
    {
        FullName = x.FirstName + " " + x.LastName
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastName()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               LastName = employee.LastName
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e
select 
{ 
    FullName : e.FirstName + " " + e.LastName 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example V - Projection with `let`
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = (from e in session.Query<Employee, Employees_ByFirstAndLastName>()
               let format = (Func<Employee, string>)(p => p.FirstName + " " + p.LastName)
               select new
               {
                   FullName = format(e)
               }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastName()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               LastName = employee.LastName
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from index 'Employees/ByFirstAndLastName' as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VI - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Order, Orders_ByShipToAndLines>()
    .Select(x => new
    {
        Total = x.Lines.Sum(l => l.PricePerUnit * l.Quantity)

    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Orders_ByShipToAndLines : AbstractIndexCreationTask<Order>
{
    public Orders_ByShipToAndLines()
    {
        Map = orders => from order in orders
                        select new
                        {
                            ShipTo = order.ShipTo,
                            Lines = order.Lines
                        };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VII - Projection With a Count() Predicate

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = (from o in session.Query<Order>()
                let c = RavenQuery.Load<Company>(o.Company)
    select new
    {
        CompanyName = c.Name,
        ShippedAt = o.ShippedAt,
        TotalProducts = o.Lines.Count(), //both empty syntax and with a predicate is supported
        TotalDiscountedProducts = o.Lines.Count(x => x.Discount > 0)
    }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Orders_ByShippedAtAndCompany : AbstractIndexCreationTask<Order>
{
    public Orders_ByShippedAtAndCompany()
    {
        Map = orders => from order in orders
                        select new
                        {
                            ShippedAt = order.ShippedAt,
                            Company = order.Company
                        };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o 
load o.Company as c 
select 
{ 
    CompanyName : c.Name, 
    ShippedAt : o.ShippedAt, 
    TotalProducts : o.Lines.length, 
    TotalDiscountedProducts : o.Lines.filter(x => x.Discount > 0 ).length 
}
`}
</CodeBlock>
</TabItem>
</Tabs>


### Example VIII - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = (from o in session.Query<Order, Orders_ByShippedAtAndCompany>()
               let c = RavenQuery.Load<Company>(o.Company)
               select new
               {
                   CompanyName = c.Name,
                   ShippedAt = o.ShippedAt
               }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Orders_ByShippedAtAndCompany : AbstractIndexCreationTask<Order>
{
    public Orders_ByShippedAtAndCompany()
    {
        Map = orders => from order in orders
                        select new
                        {
                            ShippedAt = order.ShippedAt,
                            Company = order.Company
                        };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShippedAtAndCompany' as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IX - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Employee, Employees_ByFirstNameAndBirthday>()
    .Select(e => new
    {
        DayOfBirth = e.Birthday.Day,
        MonthOfBirth = e.Birthday.Month,
        Age = DateTime.Today.Year - e.Birthday.Year
    }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstNameAndBirthday : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstNameAndBirthday()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               Birthday = employee.Birthday
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example X - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Employee, Employees_ByFirstNameAndBirthday>()
    .Select(e => new
    {
        Date = RavenQuery.Raw<DateTime>("new Date(Date.parse(e.Birthday))"),
        Name = RavenQuery.Raw(e.FirstName, "substr(0,3)")
    }).ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstNameAndBirthday : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstNameAndBirthday()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               Birthday = employee.Birthday
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example XI - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
    .Query<Employee, Employees_ByFirstAndLastName>()
    .Select(e => new
    {
        Name = e.FirstName,
        Metadata = RavenQuery.Metadata(e),
    })
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstAndLastName : AbstractIndexCreationTask<Employee>
{
    public Employees_ByFirstAndLastName()
    {
        Map = employees => from employee in employees
                           select new
                           {
                               FirstName = employee.FirstName,
                               LastName = employee.LastName
                           };
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## SelectFields

The `SelectFields` method can only be used with the 
[Document Query](../../client-api/session/querying/document-query/what-is-document-query.mdx). 
It has two overloads:

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`// 1) By array of fields
IDocumentQuery<TProjection> SelectFields<TProjection>(params string[] fields);
// 2) By projection type
IDocumentQuery<TProjection> SelectFields<TProjection>();
`}
</CodeBlock>
</TabItem>

1) The fields of the projection are specified as a `string` array of field names. 
It also takes the type of the projection as a generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var fields = new string[]{
    "Name",
    "Phone"
};

var results = session
    .Advanced
    .DocumentQuery<Company, Companies_ByContact>()
    .SelectFields<ContactDetails>(fields)
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Companies_ByContact : AbstractIndexCreationTask<Company>
{
    public Companies_ByContact()
    {
        Map = companies => companies
            .Select(x => new
            {
                Name = x.Contact.Name,
                x.Phone
            });

        StoreAllFields(FieldStorage.Yes); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class ContactDetails
{
    public string Name { get; set; }

    public string Phone { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>

2) The projection is defined by simply passing the projection type as the generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session
.Advanced
.DocumentQuery<Company, Companies_ByContact>()
.SelectFields<ContactDetails>()
.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Companies_ByContact : AbstractIndexCreationTask<Company>
{
    public Companies_ByContact()
    {
        Map = companies => companies
            .Select(x => new
            {
                Name = x.Contact.Name,
                x.Phone
            });

        StoreAllFields(FieldStorage.Yes); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class ContactDetails
{
    public string Name { get; set; }

    public string Phone { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>

#### Projection Behavior

The `SelectFields` methods can also take a `ProjectionBehavior` parameter, which 
determines whether the query should retrieve indexed data or directly retrieve 
document data, and what to do when the data can't be retrieved. Learn more 
[here](../../client-api/session/querying/how-to-customize-query.mdx#projection).  

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`IDocumentQuery<TProjection> SelectFields<TProjection>(ProjectionBehavior projectionBehavior,
                                                      params string[] fields);

IDocumentQuery<TProjection> SelectFields<TProjection>(ProjectionBehavior projectionBehavior);
`}
</CodeBlock>
</TabItem>



## ProjectInto

This extension method retrieves all public fields and properties of the type given in generic and uses 
them to perform projection to the requested type.

You can use this method instead of using `Select` together with all fields of the projection class.

### Example

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var results = session.Query<Company, Companies_ByContact>()
    .ProjectInto<ContactDetails>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_2" label="RQL_2">
<CodeBlock language="csharp">
{`from index 'Companies/ByContact' 
select Name, Phone
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Companies_ByContact : AbstractIndexCreationTask<Company>
{
    public Companies_ByContact()
    {
        Map = companies => companies
            .Select(x => new
            {
                Name = x.Contact.Name,
                x.Phone
            });

        StoreAllFields(FieldStorage.Yes); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>

</Tabs>



## OfType (As)

`OfType` or `As` is a client-side projection. You can read more about it 
[here](../../client-api/session/querying/how-to-project-query-results.mdx#oftype-(as)---simple-projection).



## Projections and the Session
Because you are working with projections and not directly with documents, they are _not_ tracked by the session. 
Modifications to a projection will not modify the document when SaveChanges is called.


</LanguageContent>
<LanguageContent language="java">


There are couple of ways to perform projections in RavenDB:

- projections using [SelectFields](../../indexes/querying/projections.mdx#selectfields)
- using [OfType](../../indexes/querying/projections.mdx#oftype)

## What are Projections and When to Use Them

When performing a query, we usually pull the full document back from the server.

However, we often need to display the data to the user. Instead of pulling the whole document back and picking just what we'll show, we can ask the server to send us just the details we want to show the user and thus reduce the amount of traffic on the network.   

The savings can be very significant if we need to show just a bit of information on a large document.  

A good example in the sample data set would be the order document. If we ask for all the Orders where Company is "companies/65-A", the size of the result that we get back from the server is 19KB.

However, if we perform the same query and ask to get back only the Employee and OrderedAt fields, the size of the result is only 5KB.  

Aside from allowing you to pick only a portion of the data, projection functions give you the ability to rename some fields, load external documents, and perform transformations on the results. 

## Projections are Applied as the Last Stage in the Query

It is important to understand that projections are applied after the query has been processed, filtered, sorted, and paged. The projection doesn't apply to all the documents in the database, only to the results that are actually returned.  
This reduces the load on the server significantly, since we can avoid doing work only to throw it immediately after. It also means that we cannot do any filtering work as part of the projection. You can filter what will be returned, but not which documents will be returned. That has already been determined earlier in the query pipeline.  

## The Cost of Running a Projection

Another consideration to take into account is the cost of running the projection. It is possible to make the projection query expensive to run. RavenDB has limits on the amount of time it will spend in evaluating the projection, and exceeding these (quite generous) limits will fail the query.

## Projections and Stored Fields

If a projection function only requires fields that are stored, then the document will not be loaded from storage and all data will come from the index directly. This can increase query performance (by the cost of disk space used) in many situations when whole document is not needed. You can read more about field storing [here](../../indexes/storing-data-in-index.mdx).

## SelectFields
The most basic projection can be done using `selectFields` method:

### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<FirstAndLastName> results = session
    .query(Employee.class, Employees_ByFirstAndLastName.class)
    .selectFields(FirstAndLastName.class, "FirstName", "LastName")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastName() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

This will issue a query to a database, requesting only `FirstName` and `LastName` from all documents that index entries match query predicate from `Employees/ByFirstAndLastName` index. What does it mean? If an index entry matches our query predicate, then we will try to extract all requested fields from that particular entry. If all requested fields are available in there, then we do not download it from storage. The index `Employees/ByFirstAndLastName` used in the above query is not storing any fields, so the documents will be fetched from storage.

### Example II - Projecting Stored Fields

If we create an index that stores `FirstName` and `LastName` and it requests only those fields in query, then **the data will come from the index directly**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<FirstAndLastName> results = session
    .query(Employee.class, Employees_ByFirstAndLastNameWithStoredFields.class)
    .selectFields(FirstAndLastName.class, "FirstName", "LastName")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByFirstAndLastNameWithStoredFields extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastNameWithStoredFields() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";

        storeAllFields(FieldStorage.YES); // firstName and lastName fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastNameWithStoredFields'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`QueryData queryData = new QueryData(new String[]{"ShipTo", "Lines[].ProductName"},
    new String[]{"ShipTo", "Products"});

List<ShipToAndProducts> results = session.query(Order.class)
    .selectFields(ShipToAndProducts.class, queryData)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Orders_ByShipToAndLines extends AbstractIndexCreationTask {
    public Orders_ByShipToAndLines() {
        map = "docs.Orders.Select(order => new {" +
            "    ShipTo = order.ShipTo," +
            "    Lines = order.Lines" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select 
{ 
    ShipTo: o.ShipTo, 
    Products : o.Lines.map(function(y){return y.ProductName;}) 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IV - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<FullName> results = session.advanced().rawQuery(FullName.class, "from Employees as e " +
    "select {" +
    "    FullName : e.FirstName + \\" \\" + e.LastName " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastName() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e
select 
{ 
    FullName : e.FirstName + " " + e.LastName 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example V - Projection with `declared function`
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Employee> results = session.advanced().rawQuery(Employee.class, "declare function output(e) { " +
    "    var format = function(p){ return p.FirstName + \\" \\" + p.LastName; }; " +
    "    return { FullName : format(e) }; " +
    "} " +
    "from Employees as e select output(e)").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastName() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from index 'Employees/ByFirstAndLastName' as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VI - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Total> results = session.advanced().rawQuery(Total.class, "from Orders as o " +
    "select { " +
    "    Total : o.Lines.reduce( " +
    "        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0) " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Orders_ByShipToAndLines extends AbstractIndexCreationTask {
    public Orders_ByShipToAndLines() {
        map = "docs.Orders.Select(order => new {" +
            "    ShipTo = order.ShipTo," +
            "    Lines = order.Lines" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VII - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<OrderProjection> results = session.advanced().rawQuery(OrderProjection.class, "from Orders as o " +
    "load o.company as c " +
    "select { " +
    "    CompanyName: c.Name," +
    "    ShippedAt: o.ShippedAt" +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Orders_ByShippedAtAndCompany extends AbstractIndexCreationTask {
    public Orders_ByShippedAtAndCompany() {
        map = "docs.Orders.Select(order => new {" +
            "    ShippedAt = order.ShippedAt," +
            "    Company = order.Company" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShippedAtAndCompany' as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VIII - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<EmployeeProjection> results = session.advanced().rawQuery(EmployeeProjection.class, "from Employees as e " +
    "select { " +
    "    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), " +
    "    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1, " +
    "    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByFirstNameAndBirthday extends AbstractIndexCreationTask {
    public Employees_ByFirstNameAndBirthday() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    Birthday = employee.Birthday" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IX - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<EmployeeProjection> results = session.advanced().rawQuery(EmployeeProjection.class, "from Employees as e " +
    "select { " +
    "    Date : new Date(Date.parse(e.Birthday)), " +
    "    Name : e.FirstName.substr(0,3) " +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByFirstNameAndBirthday extends AbstractIndexCreationTask {
    public Employees_ByFirstNameAndBirthday() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    Birthday = employee.Birthday" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example X - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Employee> results = session.advanced().rawQuery(Employee.class, "from Employees as e " +
    "select {" +
    "     Name : e.FirstName, " +
    "     Metadata : getMetadata(e)" +
    "}").toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="java">
{`public static class Employees_ByFirstAndLastName extends AbstractIndexCreationTask {
    public Employees_ByFirstAndLastName() {
        map = "docs.Employees.Select(employee => new {" +
            "    FirstName = employee.FirstName," +
            "    LastName = employee.LastName" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>




## OfType

`OfType` is a client-side projection. You can read more about it [here](../../client-api/session/querying/how-to-project-query-results.mdx#oftype-(as)---simple-projection).



## Projections and the Session
Because you are working with projections and not directly with documents, they are _not_ tracked by the session. Modifications to a projection will not modify the document when `saveChanges` is called.


</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* This article provides examples of projecting query results when querying a **static-index**.  

* Prior to reading this article, please refer to [query results projection overview](../../client-api/session/querying/how-to-project-query-results.mdx) 
  for general knowledge about Projections and for dynamic-queries examples.  

* Projections can be applied using the `select_fields` and `select_fields_query_data` methods.  

* In this page:  

  * [What are Projections and When to Use Them](../../indexes/querying/projections.mdx#what-are-projections-and-when-to-use-them)
  * [`select_fields`](../../indexes/querying/projections.mdx#select_fields)
  * [Examples](../../indexes/querying/projections.mdx#examples)
  * [Projection Behavior](../../indexes/querying/projections.mdx#projection-behavior)
  * [Projections and the Session](../../indexes/querying/projections.mdx#projections-and-the-session)
  * [Syntax](../../indexes/querying/projections.mdx#syntax)
  
</Admonition>
## What are Projections and When to Use Them

When performing a query, we usually pull the full document back from the server.

However, we often need to display the data to the user. Instead of pulling the whole document back and picking 
just what we'll show, we can ask the server to send us just the details we want to show the user and thus reduce 
the amount of traffic on the network.   

The savings can be very significant if we need to show just a bit of information on a large document.  

A good example in the sample data set would be the order document. If we ask for all the Orders where Company 
is "companies/65-A", the size of the result that we get back from the server is 19KB.

However, if we perform the same query and ask to get back only the Employee and OrderedAt fields, the size of 
the result is only 5KB.  

Aside from allowing you to pick only a portion of the data, projection functions give you the ability to 
rename some fields, load external documents, and perform transformations on the results. 

#### Projections are Applied as the Last Stage in the Query
It is important to understand that projections are applied after the query has been processed, filtered, 
sorted, and paged. The projection doesn't apply to all the documents in the database, only to the results 
that are actually returned.  
This reduces the load on the server significantly, since we can avoid doing work only to throw it immediately 
after. It also means that we cannot do any filtering work as part of the projection. You can filter what will 
be returned, but not which documents will be returned. That has already been determined earlier in the query 
pipeline.  

#### The Cost of Running a Projection
Another consideration to take into account is the cost of running the projection. It is possible to make the 
projection query expensive to run. RavenDB has limits on the amount of time it will spend in evaluating the 
projection, and exceeding these (quite generous) limits will fail the query.

#### Projections and Stored Fields
If a projection function only requires fields that are stored, then the document will not be loaded from 
storage and all data will come from the index directly. This can increase query performance (by the cost 
of disk space used) in many situations when whole document is not needed. You can read more about field 
storing [here](../../indexes/storing-data-in-index.mdx).



## `select_fields`

Projections can be applied using the `select_fields` and `select_fields_query_data` methods.

The projection fields can be specified as a `str` array of field names,  
and the projection type can be passed as a generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`fields = ["Name", "Phone"]
results = list(
    session.advanced.document_query_from_index_type(Companies_ByContact, Company).select_fields(
        ContactDetails, fields
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Companies_ByContact(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "companies.Select(x => new {name = x.Contact.Name, phone = x.Phone})"
        self._store_all_fields(FieldStorage.YES)  # Name and Phone fields can be retrieved directly from index
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="python">
{`class ContactDetails:
    def __init__(self, name: str = None, phone: str = None):
        self.name = name
        self.phone = phone
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>

The projection can also be defined by simply passing the projection type as a generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.advanced.document_query_from_index_type(Companies_ByContact, Company).select_fields(
        ContactDetails
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Companies_ByContact(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "companies.Select(x => new {name = x.Contact.Name, phone = x.Phone})"
        self._store_all_fields(FieldStorage.YES)  # Name and Phone fields can be retrieved directly from index
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="python">
{`class ContactDetails:
    def __init__(self, name: str = None, phone: str = None):
        self.name = name
        self.phone = phone
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>



## Examples

#### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.query_index_type(Employees_ByFirstAndLastName, Employee).select_fields(
        Employee, "FirstName", "LastName"
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Employees_ByFirstAndLastName(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new "
            "{"
            " FirstName = employee.FirstName,"
            " LastName = employee.LastName"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

This will issue a query to a database, requesting only `FirstName` and `LastName` from all documents that 
index entries match query predicate from `Employees/ByFirstAndLastName` index. What does it mean? If an index 
entry matches our query predicate, then we will try to extract all requested fields from that particular entry. 
If all requested fields are available in there, then we do not download it from storage. 
The index `Employees/ByFirstAndLastName` used in the above query is not storing any fields, 
so the documents will be fetched from storage.
#### Example II - Projecting Stored Fields

If we create an index that stores `FirstName` and `LastName` and it requests only those fields in query, 
then **the data will come from the index directly**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.query_index_type(Employees_ByFirstAndLastNameWithStoredFields, Employee).select_fields(
        Employee, "FirstName", "LastName"
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Employees_ByFirstAndLastNameWithStoredFields(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new"
            "{"
            " FirstName = employee.FirstName,"
            " LastName = employee.LastName"
            "}"
        )
        self._store_all_fields(FieldStorage.YES)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastNameWithStoredFields'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example III - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`query_data = QueryData(["ShipTo", "Lines[].ProductName"], ["ShipTo", "Products"])
results = list(session.query(object_type=Order).select_fields_query_data(ShipToAndProducts, query_data))
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Orders_ByShipToAndLines(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from order in docs.Orders select new { ShipTo = order.ShipTo, Lines = order.Lines}"
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select 
{ 
    ShipTo: o.ShipTo, 
    Products : o.Lines.map(function(y){return y.ProductName;}) 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example IV - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.advanced.raw_query(
        'from Employees as e select { FullName: e.FirstName + " " + e.LastName }', FullName
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Employees_ByFirstAndLastName(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new "
            "{"
            " FirstName = employee.FirstName,"
            " LastName = employee.LastName"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e
select 
{ 
    FullName : e.FirstName + " " + e.LastName 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example V - Projection with `let`

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.advanced.raw_query(
        "declare function output (e) { "
        '    var format = function(p){ return p.FirstName + " " + p.LastName; };'
        "    return { FullName : format(e) }; "
        "} "
        "from Employees as e select output(e)",
        Employee,
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Employees_ByFirstAndLastName(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new "
            "{"
            " FirstName = employee.FirstName,"
            " LastName = employee.LastName"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from index 'Employees/ByFirstAndLastName' as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example VI - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = session.advanced.raw_query(
    "from Orders as o "
    "select { "
    "    Total : o.Lines.reduce( "
    "        (acc, 1) => acc += l.PricePerUnit * l.Quantity, 0) "
    "}",
    Total,
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Orders_ByShipToAndLines(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = "from order in docs.Orders select new { ShipTo = order.ShipTo, Lines = order.Lines}"
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example VII - Projection With a Count() Predicate

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Orders_ByShippedAtAndCompany(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from order in docs.Orders "
            "select new "
            "{"
            " ShippedAt = order.ShippedAt,"
            " Company = order.Company"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o 
load o.Company as c 
select 
{ 
    CompanyName : c.Name, 
    ShippedAt : o.ShippedAt, 
    TotalProducts : o.Lines.length, 
    TotalDiscountedProducts : o.Lines.filter(x => x.Discount > 0 ).length 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example VIII - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.advanced.raw_query(
        "from Orders as o "
        "load o.company as c "
        "select { "
        "    CompanyName: c.Name,"
        "    ShippedAt: o.ShippedAt"
        "}",
        OrderProjection,
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Orders_ByShippedAtAndCompany(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from order in docs.Orders "
            "select new "
            "{"
            " ShippedAt = order.ShippedAt,"
            " Company = order.Company"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShippedAtAndCompany' as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example IX - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.advanced.raw_query(
        "from Employees as e "
        "select { "
        "    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), "
        "    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1, "
        "    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() "
        "}"
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Employees_ByFirstNameAndBirthday(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new "
            "{"
            " FirstName = employee.FirstName,"
            " Birthday = employee.Birthday"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example X - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.advanced.raw_query(
        "from Employees as e "
        "select { "
        "    Date : new Date(Date.parse(e.Birthday)), "
        "    Name : e.FirstName.substr(0,3) "
        "}",
        EmployeeProjection,
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Employees_ByFirstNameAndBirthday(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new "
            "{"
            " FirstName = employee.FirstName,"
            " Birthday = employee.Birthday"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example XI - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`results = list(
    session.advanced.raw_query(
        "from Employee as e " "select {" "    Name : e.FirstName, " "    Metadata : getMetadata(e)" "}",
        Employee,
    )
)
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="python">
{`class Employees_ByFirstAndLastName(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new "
            "{"
            " FirstName = employee.FirstName,"
            " LastName = employee.LastName"
            "}"
        )
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Projection Behavior
The `select_fields` methods can also take a `ProjectionBehavior` parameter, which
determines whether the query should retrieve indexed data or directly retrieve 
document data, and what to do when the data can't be retrieved. Learn more 
[here](../../client-api/session/querying/how-to-customize-query.mdx#projection).  



## Projections and the Session
As you work with projections rather than directly with documents, the data is _not_ tracked by the session.  
Modifications to a projection will not modify the document when `save_changes` is called.


## Syntax

<TabItem value="syntax_select_fields" label="syntax_select_fields">
<CodeBlock language="python">
{`def select_fields(
    self,
    projection_class: Type[_TProjection],
    *fields: str,
    projection_behavior: Optional[ProjectionBehavior] = ProjectionBehavior.DEFAULT,
) -> DocumentQuery[_TProjection]: ...

def select_fields_query_data(
    self, projection_class: Type[_TProjection], query_data: QueryData
) -> DocumentQuery[_TProjection]: ...

class QueryData:
    def __init__(
        self,
        fields: List[str],
        projections: List[str],
        from_alias: Optional[str] = None,
        declare_tokens: Optional[List[DeclareToken]] = None,
        load_tokens: Optional[List[LoadToken]] = None,
        is_custom_function: Optional[bool] = None,
    ):
        self.fields = fields
        self.projections = projections
        self.from_alias = from_alias
        self.declare_tokens = declare_tokens
        self.load_tokens = load_tokens
        self.is_custom_function = is_custom_function

        self.map_reduce: Union[None, bool] = None
        self.project_into: Union[None, bool] = None
        self.projection_behavior: Union[None, ProjectionBehavior] = None
`}
</CodeBlock>
</TabItem>
#### `ProjectionBehavior` Syntax:

<TabItem value="ProjectionBehavior_syntax" label="ProjectionBehavior_syntax">
<CodeBlock language="python">
{`class ProjectionBehavior(Enum):
    DEFAULT = "Default"
    FROM_INDEX = "FromIndex"
    FROM_INDEX_OR_THROW = "FromIndexOrThrow"
    FROM_DOCUMENT = "FromDocument"
    FROM_DOCUMENT_OR_THROW = "FromDocumentOrThrow"
`}
</CodeBlock>
</TabItem>

* `Default`  
  Retrieve values from the stored index fields when available.  
  If fields are not stored then get values from the document,  
  a field that is not found in the document is skipped.

* `FromIndex`  
  Retrieve values from the stored index fields when available.  
  A field that is not stored in the index is skipped.

* `FromIndexOrThrow`  
  Retrieve values from the stored index fields when available.  
  An exception is thrown if the index does not store the requested field.

* `FromDocument`  
  Retrieve values directly from the documents store.  
  A field that is not found in the document is skipped.

* `FromDocumentOrThrow`  
  Retrieve values directly from the documents store.  
  An exception is thrown if the document does not contain the requested field.
 



</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* This article provides examples of projecting query results when querying a **static-index**.  

* Prior to reading this article, please refer to [query results projection overview](../../client-api/session/querying/how-to-project-query-results.mdx) 
  for general knowledge about Projections and for dynamic-queries examples.  

* Projections can be applied using the `selectFields` method.  

* In this page:  

  * [What are Projections and When to Use Them](../../indexes/querying/projections.mdx#what-are-projections-and-when-to-use-them)
  * [`selectFields`](../../indexes/querying/projections.mdx#selectfields)
  * [Examples](../../indexes/querying/projections.mdx#examples)
  * [Projection Behavior](../../indexes/querying/projections.mdx#projection-behavior)
  * [Projections and the Session](../../indexes/querying/projections.mdx#projections-and-the-session)
  
</Admonition>
## What are Projections and When to Use Them

When performing a query, we usually pull the full document back from the server.

However, we often need to display the data to the user. Instead of pulling the whole document back and picking 
just what we'll show, we can ask the server to send us just the details we want to show the user and thus reduce 
the amount of traffic on the network.   

The savings can be very significant if we need to show just a bit of information on a large document.  

A good example in the sample data set would be the order document. If we ask for all the Orders where Company 
is "companies/65-A", the size of the result that we get back from the server is 19KB.

However, if we perform the same query and ask to get back only the Employee and OrderedAt fields, the size of 
the result is only 5KB.  

Aside from allowing you to pick only a portion of the data, projection functions give you the ability to 
rename some fields, load external documents, and perform transformations on the results. 

#### Projections are Applied as the Last Stage in the Query
It is important to understand that projections are applied after the query has been processed, filtered, 
sorted, and paged. The projection doesn't apply to all the documents in the database, only to the results 
that are actually returned.  
This reduces the load on the server significantly, since we can avoid doing work only to throw it immediately 
after. It also means that we cannot do any filtering work as part of the projection. You can filter what will 
be returned, but not which documents will be returned. That has already been determined earlier in the query 
pipeline.  

#### The Cost of Running a Projection
Another consideration to take into account is the cost of running the projection. It is possible to make the 
projection query expensive to run. RavenDB has limits on the amount of time it will spend in evaluating the 
projection, and exceeding these (quite generous) limits will fail the query.

#### Projections and Stored Fields
If a projection function only requires fields that are stored, then the document will not be loaded from 
storage and all data will come from the index directly. This can increase query performance (by the cost 
of disk space used) in many situations when whole document is not needed. You can read more about field 
storing [here](../../indexes/storing-data-in-index.mdx).



## `selectFields`

Projections can be applied using the `selectFields` method.

The projection fields can be specified as a `str` array of field names,  
and the projection type can be passed as a generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$fields = [
    "Name",
    "Phone"
];

$results = $session
    ->advanced()
    ->documentQuery(Company::class, Companies_ByContact::class)
    ->selectFields(ContactDetails::class, $fields)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Companies_ByContact extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "companies.Select(x => new {Name = x.Contact.Name, Phone = x.Phone})";

        $this->storeAllFields(FieldStorage::yes()); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="php">
{`class ContactDetails
{
    private ?string $name = null;
    private ?string $phone = null;

    public function getName(): ?string
    {
        return $this->name;
    }

    public function setName(?string $name): void
    {
        $this->name = $name;
    }

    public function getPhone(): ?string
    {
        return $this->phone;
    }

    public function setPhone(?string $phone): void
    {
        $this->phone = $phone;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>

The projection can also be defined by simply passing the projection type as a generic parameter.  

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
->advanced()
->documentQuery(Company::class, Companies_ByContact::class)
->selectFields(ContactDetails::class)
->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Companies_ByContact extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "companies.Select(x => new {Name = x.Contact.Name, Phone = x.Phone})";

        $this->storeAllFields(FieldStorage::yes()); // Name and Phone fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="php">
{`class ContactDetails
{
    private ?string $name = null;
    private ?string $phone = null;

    public function getName(): ?string
    {
        return $this->name;
    }

    public function setName(?string $name): void
    {
        $this->name = $name;
    }

    public function getPhone(): ?string
    {
        return $this->phone;
    }

    public function setPhone(?string $phone): void
    {
        $this->phone = $phone;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Companies/ByContact'
select Name, Phone
`}
</CodeBlock>
</TabItem>
</Tabs>



## Examples

#### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
    ->query(Employee::class, Employees_ByFirstAndLastName::class)
    ->selectFields(Employee::class, ["FirstName", "LastName"])
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Employees_ByFirstAndLastName extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "{" .
            "   FirstName = employee.FirstName," .
            "   LastName = employee.LastName" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

This will issue a query to a database, requesting only `FirstName` and `LastName` from all documents that 
index entries match query predicate from `Employees/ByFirstAndLastName` index. What does it mean? If an index 
entry matches our query predicate, then we will try to extract all requested fields from that particular entry. 
If all requested fields are available in there, then we do not download it from storage. 
The index `Employees/ByFirstAndLastName` used in the above query is not storing any fields, 
so the documents will be fetched from storage.
#### Example II - Projecting Stored Fields

If we create an index that stores `FirstName` and `LastName` and it requests only those fields in query, 
then **the data will come from the index directly**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
    ->query(Employee::class, Employees_ByFirstAndLastNameWithStoredFields::class)
    ->selectFields(Employee::class, ["FirstName", "LastName"])
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Employees_ByFirstAndLastNameWithStoredFields extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new" .
            "{" .
            "   FirstName = employee.FirstName," .
            "   LastName = employee.LastName" .
            "}";

        $this->storeAllFields(FieldStorage::yes()); // FirstName and LastName fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastNameWithStoredFields'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example III - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$queryData = new QueryData(["ShipTo", "Lines[].ProductName"], ["ShipTo", "Products"]);

$results = $session
    ->query(Order::class, Orders_ByShipToAndLines::class)
    ->selectFields(ShipToAndProducts::class, $queryData)
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Orders_ByShipToAndLines extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "from order in docs.Orders" .
            "select new { " .
            "   ShipTo = order.ShipTo, " .
            "   Lines = order.Lines " .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select 
{ 
    ShipTo: o.ShipTo, 
    Products : o.Lines.map(function(y){return y.ProductName;}) 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example IV - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session
    ->rawQuery(FullName::class, 'from Employees as e select { FullName: e.FirstName + " " + e.LastName }')
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Employees_ByFirstAndLastName extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "{" .
            "   FirstName = employee.FirstName," .
            "   LastName = employee.LastName" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e
select 
{ 
    FullName : e.FirstName + " " + e.LastName 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example V - Projection with `let`

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session->advanced()->rawQuery(
    Employee::class,
    "declare function output(e) { " .
        "    var format = function(p){ return p.FirstName + \\" \\" + p.LastName; }; " .
        "    return { FullName : format(e) }; " .
        "} " .
        "from Employees as e select output(e)"
    )
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Employees_ByFirstAndLastName extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "{" .
            "   FirstName = employee.FirstName," .
            "   LastName = employee.LastName" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from index 'Employees/ByFirstAndLastName' as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example VI - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session->advanced()->rawQuery(
    Total::class,
    "from Orders as o " .
    "select { " .
    "    Total : o.Lines.reduce( " .
    "        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0) " .
    "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Orders_ByShipToAndLines extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map = "from order in docs.Orders" .
            "select new { " .
            "   ShipTo = order.ShipTo, " .
            "   Lines = order.Lines " .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example VII - Projection With a Count() Predicate

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Orders_ByShippedAtAndCompany extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from order in docs.Orders " .
            "select new " .
            "{" .
            "   ShippedAt = order.ShippedAt," .
            "   Company = order.Company" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from Orders as o 
load o.Company as c 
select 
{ 
    CompanyName : c.Name, 
    ShippedAt : o.ShippedAt, 
    TotalProducts : o.Lines.length, 
    TotalDiscountedProducts : o.Lines.filter(x => x.Discount > 0 ).length 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example VIII - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session->advanced()->rawQuery(
    OrderProjection::class,
    "from Orders as o " .
        "load o.company as c " .
        "select { " .
        "    CompanyName: c.Name," .
        "    ShippedAt: o.ShippedAt" .
        "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Orders_ByShippedAtAndCompany extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from order in docs.Orders " .
            "select new " .
            "{" .
            "   ShippedAt = order.ShippedAt," .
            "   Company = order.Company" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShippedAtAndCompany' as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example IX - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session->advanced()->rawQuery(
    EmployeeProjection::class,
    "from Employees as e " .
    "select { " .
    "    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), " .
    "    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1, " .
    "    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() " .
    "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Employees_ByFirstNameAndBirthday extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "{" .
            "   FirstName = employee.FirstName," .
            "   Birthday = employee.Birthday" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example X - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session->advanced()->rawQuery(
    EmployeeProjection::class,
    "from Employees as e " .
    "select { " .
    "    Date : new Date(Date.parse(e.Birthday)), " .
    "    Name : e.FirstName.substr(0,3) " .
    "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Employees_ByFirstNameAndBirthday extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "{" .
            "   FirstName = employee.FirstName," .
            "   Birthday = employee.Birthday" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>
#### Example XI - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session->advanced()->rawQuery(
    Employee::class,
    "from Employees as e " .
    "select {" .
    "     Name : e.FirstName, " .
    "     Metadata : getMetadata(e)" .
    "}")
    ->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="php">
{`class Employees_ByFirstAndLastName extends AbstractIndexCreationTask
{
    public function __construct()
    {
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "{" .
            "   FirstName = employee.FirstName," .
            "   LastName = employee.LastName" .
            "}";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## Projection Behavior
The `selectFields` methods can also take a `ProjectionBehavior` parameter, which
determines whether the query should retrieve indexed data or directly retrieve 
document data, and what to do when the data can't be retrieved. Learn more 
[here](../../client-api/session/querying/how-to-customize-query.mdx#projection).  



## Projections and the Session
As you work with projections rather than directly with documents, the data is _not_ tracked by the session.  
Modifications to a projection will not modify the document when `saveChanges` is called.



</LanguageContent>
<LanguageContent language="nodejs">


There are couple of ways to perform projections in RavenDB:

- projections using [selectFields](../../indexes/querying/projections.mdx#selectfields)
- using [ofType](../../indexes/querying/projections.mdx#oftype)

## What are Projections and When to Use Them

When performing a query, we usually pull the full document back from the server.

However, we often need to display the data to the user. Instead of pulling the whole document back and picking just what we'll show, we can ask the server to send us just the details we want to show the user and thus reduce the amount of traffic on the network.   

The savings can be very significant if we need to show just a bit of information on a large document.  

A good example in the sample data set would be the order document. If we ask for all the Orders where Company is "companies/65-A", the size of the result that we get back from the server is 19KB.

However, if we perform the same query and ask to get back only the `Employee` and `OrderedAt` fields, the size of the result is only 5KB.  

Aside from allowing you to pick only a portion of the data, projection functions give you the ability to rename some fields, load external documents, and perform transformations on the results. 

## Projections are Applied as the Last Stage in the Query

It is important to understand that projections are applied after the query has been processed, filtered, sorted, and paged. The projection doesn't apply to all the documents in the database, only to the results that are actually returned.  
This reduces the load on the server significantly, since we can avoid doing work only to throw it immediately after. It also means that we cannot do any filtering work as part of the projection. You can filter what will be returned, but not which documents will be returned. That has already been determined earlier in the query pipeline.  

## The Cost of Running a Projection

Another consideration to take into account is the cost of running the projection. It is possible to make the projection query expensive to run. RavenDB has limits on the amount of time it will spend in evaluating the projection, and exceeding these (quite generous) limits will fail the query.

## Projections and Stored Fields

If a projection function only requires fields that are stored, then the document will not be loaded from storage and all data will come from the index directly. This can increase query performance (by the cost of disk space used) in many situations when whole document is not needed. You can read more about field storing [here](../../indexes/storing-data-in-index.mdx).

## selectFields
The most basic projection can be done using `selectFields()` method:

### Example I - Projecting Individual Fields of the Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    .query({ indexName: "Employees/ByFirstAndLastName" })
    .selectFields([ "FirstName", "LastName" ])
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstAndLastName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            LastName = employee.LastName
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

This will issue a query to a database, requesting only `FirstName` and `LastName` from all documents that index entries match query predicate from `Employees/ByFirstAndLastName` index. What does it mean? If an index entry matches our query predicate, then we will try to extract all requested fields from that particular entry. If all requested fields are available in there, then we do not download it from storage. The index `Employees/ByFirstAndLastName` used in the above query is not storing any fields, so the documents will be fetched from storage.

### Example II - Projecting Stored Fields

If we create an index that stores `FirstName` and `LastName` and it requests only those fields in query, then **the data will come from the index directly**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session
    .query({ indexName: "Employees/ByFirstAndLastNameWithStoredFields" })
    .selectFields("FirstName", "LastName")
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstAndLastNameWithStoredFields extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            LastName = employee.LastName
        })\`;

        this.storeAllFields("Yes"); // FirstName and LastName fields can be retrieved directly from index
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastNameWithStoredFields'
select FirstName, LastName
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Projecting Arrays and Objects

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const queryData = new QueryData(
    [ "ShipTo", "Lines[].ProductName" ],
    [ "ShipTo", "Products" ]);

const results = await session.query(Order)
    .selectFields(queryData, Order)
    .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Orders_ByShipToAndLines extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = "docs.Orders.Select(order => new {" +
            "    ShipTo = order.ShipTo," +
            "    Lines = order.Lines" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select 
{ 
    ShipTo: o.ShipTo, 
    Products : o.Lines.map(function(y){return y.ProductName;}) 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IV - Projection with Expression

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session.advanced.rawQuery(\`from Employees as e select {    
    FullName : e.FirstName + " " + e.LastName 
}\`).all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstAndLastName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            LastName = employee.LastName
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e
select 
{ 
    FullName : e.FirstName + " " + e.LastName 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example V - Projection with `declared function`
<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(\`declare function output(e) {     
            var format = function(p) { 
                return p.FirstName + " " + p.LastName; 
            };     
    
            return { FullName : format(e) }; 
        } from Employees as e select output(e)\`)
        .all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstAndLastName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            LastName = employee.LastName
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`declare function output(e) {
	var format = function(p){ return p.FirstName + " " + p.LastName; };
	return { FullName : format(e) };
}
from index 'Employees/ByFirstAndLastName' as e select output(e)
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VI - Projection with Calculation

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session.advanced.rawQuery(
    \`from Orders as o select {     
        Total: o.Lines.reduce(
            (acc , l) => acc += l.PricePerUnit * l.Quantity, 0) 
        }\`).all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Orders_ByShipToAndLines extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = "docs.Orders.Select(order => new {" +
            "    ShipTo = order.ShipTo," +
            "    Lines = order.Lines" +
            "})";
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShipToAndLines' as o
select {
    Total : o.Lines.reduce(
        (acc , l) => acc += l.PricePerUnit * l.Quantity, 0)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VII - Projection Using a Loaded Document

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(
        \`from Orders as o load o.Company as c select {     
            CompanyName: c.Name,    
            ShippedAt: o.ShippedAt
        }\`).all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Orders_ByShippedAtAndCompany extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Orders.Select(order => new {    
            ShippedAt = order.ShippedAt,    
            Company = order.Company
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Orders/ByShippedAtAndCompany' as o
load o.Company as c
select {
	CompanyName: c.Name,
	ShippedAt: o.ShippedAt
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example VIII - Projection with Dates

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(
    \`from Employees as e select {     
        DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(),     
        MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,     
        Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
        }\`).all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstNameAndBirthday extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            Birthday = employee.Birthday
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select { 
    DayOfBirth : new Date(Date.parse(e.Birthday)).getDate(), 
    MonthOfBirth : new Date(Date.parse(e.Birthday)).getMonth() + 1,
    Age : new Date().getFullYear() - new Date(Date.parse(e.Birthday)).getFullYear() 
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example IX - Projection with Raw JavaScript Code

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(
        \`from Employees as e select {     
            Date : new Date(Date.parse(e.Birthday)),     
            Name : e.FirstName.substr(0,3) 
        }\`).all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstNameAndBirthday extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            Birthday = employee.Birthday
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstNameAndBirthday' as e 
select {
    Date : new Date(Date.parse(e.Birthday)), 
    Name : e.FirstName.substr(0,3)
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example X - Projection with Metadata

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const results = await session.advanced
    .rawQuery(\`from Employees as e select {     
        Name : e.FirstName,      
        Metadata : getMetadata(e)
    }\`).all();
`}
</CodeBlock>
</TabItem>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstAndLastName extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        this.map = \`docs.Employees.Select(employee => new {    
            FirstName = employee.FirstName,    
            LastName = employee.LastName
        })\`;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_1" label="RQL_1">
<CodeBlock language="sql">
{`from index 'Employees/ByFirstAndLastName' as e 
select {
     Name : e.FirstName, 
     Metadata : getMetadata(e)
}
`}
</CodeBlock>
</TabItem>
</Tabs>



## ofType

`ofType()` is a client-side projection. You can read more about it [here](../../client-api/session/querying/how-to-project-query-results.mdx#oftype-(as)---simple-projection).



## Projections and the Session
Because you are working with projections and not directly with documents, they are _not_ tracked by the session. Modifications to a projection will not modify the document when `saveChanges()` is called.


</LanguageContent>

<!---
### Querying
- [Query Overview](../../client-api/session/querying/how-to-query)
- [Querying an Index](../../indexes/querying/query-index)

### Client API
- [How to Project Query Results](../../client-api/session/querying/how-to-project-query-results)

### Knowledge Base
- [JavaScript Engine](../../server/kb/javascript-engine)


-->