---
title: "Aggregating Time Series Values"
hide_table_of_contents: true
sidebar_label: Aggregating Values
sidebar_position: 3
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "php", "nodejs"];


# Aggregating Time Series Values
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Time series queries can easily generate powerful statistics by applying an aggregation function  
  (such as Min, Max, Count, Average, etc.) to a group of entries within a chosen time frame,  
  such as an hour or a week.

* For an overview of the available time series queries, please refer to [Time series querying](../../../document-extensions/timeseries/client-api/session/querying.mdx).

* In this page:  
  * [Grouping and aggregation options](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#grouping-and-aggregation-options)  
  * [Examples](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#examples)
      * [Aggregate entries with single value](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-with-single-value)
      * [Aggregate entries with multiple values](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-with-multiple-values)
      * [Aggregate entries without grouping by time frame](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-without-grouping-by-time-frame)
      * [Aggregate entries filtered by referenced document](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-filtered-by-referenced-document)
      * [Secondary grouping by tag](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#secondary-grouping-by-tag)
      * [Group by dynamic criteria](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#group-by-dynamic-criteria)
      * [Project document data in addition to aggregated data](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#project-document-data-in-addition-to-aggregated-data)
  * [Syntax](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#syntax)  

</Admonition>
## Grouping and aggregation options

* **Group entries by time frame**:  
  First, you can group the time series entries based on the specified time frame.  
  The following time units are available:

  * `Milliseconds`
  * `Seconds`
  * `Minutes`
  * `Hours`
  * `Days`
  * `Months`
  * `Quarters` 
  * `Years`

* **Secondary grouping**:  
  After grouping by a time unit, you can also perform a _secondary grouping_ by the time series [tag](../../../document-extensions/timeseries/overview.mdx#tags).

* **Aggregate values**:  
  You can select one or more aggregation functions to retrieve aggregated values for each group.  
  The resulting aggregated values are **projected** to the client in the query result.  
  The following functions are available:

  * `Min()` - the lowest value
  * `Max()` - the highest value
  * `Sum()` - sum of all values
  * `Average()` - the average value
  * `First()` - value of first entry
  * `Last()` - value of last entry
  * `Percentile(<percentage>)` - The value under which the specified percentage of values fall
  * `Slope()` - the change in value divided by the change in time between the first and last entries 
  * `StandardDeviation()` - the standard deviation of all values (a measure of how spread out the values are from the average)
  * `Count()` - The result of Count() is always returned, even if you do not explicitly request it.
     * When each entry has a single value:  
       Returns the number of entries.  
     * When each entry has multiple values:  
       Returns an array of the size of the number of values.  
       Each array element contains the number of entries having a measurement for that value.  

<Admonition type="note" title="Note">

**Execute all aggregation functions**:  
When a query groups entries by a time frame but does Not explicitly select a specific aggregation function,  
the server will implicitly execute ALL available aggregation functions (except for Percentile, Slope, and StandardDeviation) for each group.

</Admonition>
<Admonition type="note" title="Note">

**Get aggregated values without grouping**:  
When selecting aggregation functions WITHOUT first grouping the time series entries,  
the aggregation calculations will be executed over the entire set of time series entries instead of per group of entries.

</Admonition>


## Examples

#### Aggregate entries with single value:

* Each entry in the "HeartRates" time series within the Employees collection contains a single value.

* In this example, for each employee document, we group entries from the "HeartRates" time series  
  by a 1-hour time frame and then project the lowest and highest values of each group.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var query = session.Query<Employee>()
    .Select(u => RavenQuery
        .TimeSeries(u, "HeartRates")
         // Call 'GroupBy' to group the time series entries by a time frame
        .GroupBy(g => g.Hours(1))
         // Call 'Select' to choose aggregation functions that will be evaluated for each group
        .Select(g => new
        {
            // Project the lowest and highest value of each group
            Min = g.Min(),
            Max = g.Max()
        })
        .ToList());

// Execute the query
List<TimeSeriesAggregationResult> results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Query collection Employees
  from "Employees"
  // Project the time series data:
  select timeseries (
      from HeartRates
      // Use 'group by' to group the time series entries by the specified time frame
      group by "1 hour"   // Group entries into consecutive 1-hour groups
      // Use 'select' to choose aggregation functions that will be evaluated for each group
      select min(), max() // Project the lowest and highest value of each group
  )
`}
</CodeBlock>
</TabItem>
    </Tabs>
#### Aggregate entries with multiple values:  

* Each entry in the "StockPrices" time series within the Companies collection holds five values:  
  Values[0] - **Open** - stock price when trade opens  
  Values[1] - **Close** - stock price when trade ends  
  Values[2] - **High** - highest stock price during trade time  
  Values[3] - **Low** - lowest stock price during trade time  
  Values[4] - **Volume** - overall trade volume  

* In this example, for each company that is located in USA, we group entries from the "StockPrices" time series  
  by a 7-day time frame and then project the highest and lowest values of each group.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var query = session.Query<Company>()
     // Query only USA companies:
    .Where(c => c.Address.Country == "USA")
    .Select(u => RavenQuery
         .TimeSeries(u, "StockPrices")
         // Query stock price behavior when trade volume is high
        .Where(ts => ts.Values[4] > 500000)
         // Group entries into consecutive 7-day groups
        .GroupBy(g => g.Days(7))
         // Project the lowest and highest value of each group
        .Select(g => new
        {
            Min = g.Min(),
            Max = g.Max()
        })
        .ToList());

// Execute the query
List<TimeSeriesAggregationResult> results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_declare_syntax" label="RQL_declare_syntax">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000 // Query stock price behavior when trade volume is high
    group by "7 days"         // Group entries into consecutive 7-day groups
    select max(), min()       // Project the lowest and highest value of each group
}

from "Companies" as c
  // Query only USA companies:
  where c.Address.Country == "USA"
  // Project the time series data:
  select SP(c)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_select_syntax" label="RQL_select_syntax">
<CodeBlock language="sql">
{`from "Companies" as c
// Query only USA companies:
where c.Address.Country = 'USA'
    // Project the time series data:
    select timeseries (
        from StockPrices
        where Values[4] > 500000 // Query stock price behavior when trade volume is high
        group by "7 day"         // Group entries into consecutive 7-day groups
        select max(), min()      // Project the lowest and highest value of each group
    )
`}
</CodeBlock>
</TabItem>
    </Tabs>

* Since each entry holds 5 values, the query will project:  
  * 5 `Max` values for each group (the highest Values[0], highest Values[1], etc.) and
  * 5 `Min` values for each group (the lowest Values[0], lowest Values[1], etc.)
#### Aggregate entries without grouping by time frame:  

* This example is similar to the one above, except that time series entries are Not grouped by a time frame.

* The highest and lowest values are collected from the entire set of time series entries that match the query criteria.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var query = session.Query<Company>()
    .Where(c => c.Address.Country == "USA")
    .Select(u => RavenQuery
        .TimeSeries(u, "StockPrices")
        .Where(ts => ts.Values[4] > 500000)
        // Project the lowest and highest value of ALL entries that match the query criteria
        .Select(g => new
        {
            Min = g.Min(),
            Max = g.Max()
        })
        .ToList());

// Execute the query
List<TimeSeriesAggregationResult> results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000
    select max(), min()
}

from "Companies" as c
where c.Address.Country == "USA"
select SP(c)
`}
</CodeBlock>
</TabItem>
    </Tabs>

* Since no grouping is done, results wil include the highest and lowest Open, Close, High, Low, and Volume values 
  for ALL entries in the time series that match the query criteria.
#### Aggregate entries filtered by referenced document:

* The tag in each entry in the "StockPrices" series contains an Employee document ID.

* In this example, we load this [referenced document](../../../document-extensions/timeseries/querying/filtering.mdx#filter-by-referenced-document)
  and filter the entries by its properties.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var query = session.Query<Company>()
    .Select(u => RavenQuery
        .TimeSeries(u, "StockPrices")
         // Call 'LoadByTag' to load the document referenced by the tag
        .LoadByTag<Employee>()
         // Filter entries: 
         // Process only entries that reference an employee with the Sales title
        .Where((entry, employee) => employee.Title == "Sales Representative")
        .GroupBy(g =>g.Months(1))
        .Select(g => new
        {
            Min = g.Min(),
            Max = g.Max()
        })
        .ToList());

// Execute the query
List<TimeSeriesAggregationResult> results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies" as c
select timeseries(
    from StockPrices
    // Load the referenced document into variable 'employee'
    load Tag as employee
    // Filter entries by the 'Title' field of the employee document
    where employee.Title == "Sales Representative"
    group by "1 month"
    select min(), max()
)
`}
</CodeBlock>
</TabItem>
    </Tabs>
  
* Only entries that reference an employee with title 'Sales Representative' will be grouped by 1 month,  
  and the results will include the highest and lowest values for each group.
#### Secondary grouping by tag:

* In this example, we perform secondary grouping by the entries' tags.

* The tag in each entry in the "StockPrices" series contains an Employee document ID.

* "StockPrices" entries are grouped by 6 months and then by the tags of the entries within that time frame.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var query = session.Query<Company>()
    .Select(u => RavenQuery
        .TimeSeries(u, "StockPrices")
        .GroupBy(g => g
             // First group by 6 months   
            .Months(6)
             // Then group by tag
            .ByTag())
        .Select(g => new
        {  
            // Project the highest and lowest values of each group
            Min = g.Min(),
            Max = g.Max()
        })
        .ToList());

// Execute the query
List<TimeSeriesAggregationResult> results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select timeseries (
    from StockPrices
    // Use the 'tag' keyword to perform a secondary grouping by the entries' tags.
    group by "6 months", tag  // Group by months and by tag
    select max(), min()       // Project the highest and lowest values of each group
)
`}
</CodeBlock>
</TabItem>
    </Tabs>
#### Group by dynamic criteria:

Starting in version 5.2, the LINQ method `GroupBy()` can take a switch statement or a method as an argument.

* In this example, we pass a switch statement to the `GroupBy()` method. 

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var grouping = GroupingInterval.Year; // Dynamic input from the client

var groupingAction = grouping switch 
{
    GroupingInterval.Year => (Action<ITimePeriodBuilder>)(builder => builder.Years(1)),
    GroupingInterval.Month=> (Action<ITimePeriodBuilder>)(builder => builder.Months(1)),
    GroupingInterval.Day => (Action<ITimePeriodBuilder>)(builder => builder.Days(1))
};

var query = session.Query<Company>()
    .Select(c => RavenQuery
        .TimeSeries(c, "StockPrices")
        .GroupBy(groupingAction)
        .Select(g => new
        {
            Ave = g.Average()
        })
        .ToList());

// Execute the query
List<TimeSeriesAggregationResult> results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="GroupingInterval_Enum" label="GroupingInterval_Enum">
<CodeBlock language="csharp">
{`public enum GroupingInterval
{
    Hour,
    Day,
    Month,
    Year
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select timeseries (
    from StockPrices
    group by "1 year"
    select average
)
`}
</CodeBlock>
</TabItem>
    </Tabs>

* In this example, we pass the `GroupingFunction()` metod to the `GroupBy()` method.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var query = session.Query<Company>()
    .Select(c => RavenQuery
        .TimeSeries(c, "StockPrices")
        .GroupBy(builder => GroupingFunction(builder, "year"))
        .Select(g => new
        {
            Ave = g.Average()
        })
        .ToList());

// Execute the query
List<TimeSeriesAggregationResult> results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Grouping_function" label="Grouping_function">
<CodeBlock language="csharp">
{`public static ITimeSeriesAggregationOperations GroupingFunction(ITimePeriodBuilder builder,
    string input)
{
    if (input == "year")
    {
        return builder.Years(1);
    }
    
    if (input == "month")
    {
        return builder.Months(1);
    }
    
    return builder.Days(1);
}
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select timeseries (
    from StockPrices
    group by "1 year"
    select average
)
`}
</CodeBlock>
</TabItem>
    </Tabs>
#### Project document data in addition to aggregated data:

* In addition to projecting the aggregated time series data, you can project data from the parent document that contains the time series.
 
* In this example, projecting the **company name** alongside the query results clearly associates each entry in the result set with a specific company.
  This provides immediate context and makes it easier to interpret the time series data.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var query = session.Query<Company>()
    .Select(company => new
    {
        // Projecting time series data:
        MinMaxValues = RavenQuery.TimeSeries(company, "StockPrices")
            .Where(e => e.Values[4] > 500_000)
            .GroupBy(g => g.Days(7))
            .Select(x => new
            {
                Min = x.Min(),
                Max = x.Max(),
            })
            .ToList(),
        
        // Projecting the company name:
        CompanyName = company.Name 
    });

// Execute the query
var results = query.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_declare_syntax" label="RQL_declare_syntax">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000 // Query stock price behavior when trade volume is high
    group by "7 days"         // Group entries into consecutive 7-day groups
    select max(), min()       // Project the lowest and highest value of each group
}

from "Companies" as c
// Project the company's name along with the time series query results to make results more clear
select SP(c) as MinMaxValues, c.Name as CompanyName
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_select_syntax" label="RQL_select_syntax">
<CodeBlock language="sql">
{`from "Companies" as c
select timeseries (
    from StockPrices
    where Values[4] > 500000
    group by "7 day"
    select max(), min()
) as MinMaxValues,
c.Name as CompanyName // Project property 'Name' from the company document
`}
</CodeBlock>
</TabItem>
    </Tabs>



## Syntax

<TabItem value="syntax_1" label="syntax_1">
<CodeBlock language="csharp">
{`public interface ITimeSeriesQueryable
\{
   
    ITimeSeriesQueryable Where(Expression<Func<TimeSeriesEntry, bool>> predicate);

    ITimeSeriesQueryable Offset(TimeSpan offset);

    ITimeSeriesQueryable Scale(double value);

    ITimeSeriesQueryable FromLast(Action<ITimePeriodBuilder> timePeriod);

    ITimeSeriesQueryable FromFirst(Action<ITimePeriodBuilder> timePeriod);

    ITimeSeriesLoadQueryable<TEntity> LoadByTag<TEntity>();

    // GroupBy overloads:
    ITimeSeriesAggregationQueryable GroupBy(string s);
    ITimeSeriesAggregationQueryable GroupBy(Action<ITimePeriodBuilder> timePeriod);

    // Select method:
    ITimeSeriesAggregationQueryable Select(
        Expression<Func<ITimeSeriesGrouping, object>> selector);

    TimeSeriesRawResult ToList();
\}
`}
</CodeBlock>
</TabItem>
<TabItem value="syntax_2" label="syntax_2">
<CodeBlock language="csharp">
{`public interface ITimePeriodBuilder
\{
    ITimeSeriesAggregationOperations Milliseconds(int duration);
    ITimeSeriesAggregationOperations Seconds(int duration);
    ITimeSeriesAggregationOperations Minutes(int duration);
    ITimeSeriesAggregationOperations Hours(int duration);
    ITimeSeriesAggregationOperations Days(int duration);
    ITimeSeriesAggregationOperations Months(int duration);
    ITimeSeriesAggregationOperations Quarters(int duration);
    ITimeSeriesAggregationOperations Years(int duration);
\}
`}
</CodeBlock>
</TabItem>
<TabItem value="syntax_3" label="syntax_3">
<CodeBlock language="csharp">
{`public interface ITimeSeriesGrouping
\{
    double[] Max();
    double[] Min();
    double[] Sum();
    double[] Average();
    double[] First();
    double[] Last();
    long[] Count();
    double[] Percentile(double number);
    double[] Slope();
    double[] StandardDeviation();
\} 
`}
</CodeBlock>
</TabItem>




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* Time series queries can easily generate powerful statistics by applying an aggregation function  
  (such as Min, Max, Count, Average, etc.) to a group of entries within a chosen time frame,  
  such as an hour or a week.

* In this page:  
  * [Grouping and aggregation options](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#grouping-and-aggregation-options)  
  * [Examples](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#examples)
      * [Aggregate entries with single value](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-with-single-value)
      * [Aggregate entries with multiple values](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-with-multiple-values)
      * [Aggregate entries without grouping by time frame](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-without-grouping-by-time-frame)
      * [Aggregate entries filtered by referenced document](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-filtered-by-referenced-document)
      * [Secondary grouping by tag](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#secondary-grouping-by-tag)
      * [Project document data in addition to aggregated data](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#project-document-data-in-addition-to-aggregated-data)

</Admonition>
## Grouping and aggregation options

* **Group entries by time frame**:  
  First, you can group the time series entries based on the specified time frame.  
  The following time units are available:

  * `milliseconds` ( milliseconds / milli / ms)
  * `seconds`      ( seconds/ second / s )
  * `minutes`      ( minutes / minute / min )
  * `hours`        ( hours / hour / h )
  * `days`         ( days / day / d )
  * `months`       ( months / month / mon / mo )
  * `quarters`     ( quarters / quarter / q )
  * `years`        ( years / year / y )

* **Secondary grouping**:  
  After grouping by a time unit, you can also perform a _secondary grouping_ by the time series [tag](../../../document-extensions/timeseries/overview.mdx#tags).

* **Aggregate values**:  
  You can select one or more aggregation functions to retrieve aggregated values for each group.  
  The resulting aggregated values are **projected** to the client in the query result.  
  The following functions are available:

  * `min()` - the lowest value
  * `max()` - the highest value
  * `sum()` - sum of all values
  * `average()` - the average value
  * `first()` - value of first entry
  * `last()` - value of last entry
  * `percentile(<percentage>)` - The value under which the specified percentage of values fall
  * `slope` - the change in value divided by the change in time between the first and last entries 
  * `standardDeviation()` - the standard deviation of all values (a measure of how spread out the values are from the average)
  * `count()` - The result of Count() is always returned, even if you do not explicitly request it.
     * When each entry has a single value:  
       Returns the number of entries.  
     * When each entry has multiple values:  
       Returns an array of the size of the number of values.  
       Each array element contains the number of entries having a measurement for that value.  

<Admonition type="note" title="Note">

**Execute all aggregation functions**:  
When a query groups entries by a time frame but does Not explicitly select a specific aggregation function,  
the server will implicitly execute ALL available aggregation functions (except for Percentile, Slope, and StandardDeviation) for each group.

</Admonition>
<Admonition type="note" title="Note">

**Get aggregated values without grouping**:  
When selecting aggregation functions WITHOUT first grouping the time series entries,  
the aggregation calculations will be executed over the entire set of time series entries instead of per group of entries.

</Admonition>


## Examples

#### Aggregate entries with single value

* Each entry in the "HeartRates" time series within the Employees collection contains a single value.

* In this example, for each employee document, we group entries from the "HeartRates" time series  
  by a 1-hour time frame and then project the lowest and highest values of each group.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`// Define the time series query part (expressed in RQL):
$tsQueryText = "
    from HeartRates
    // Use 'group by' to group the time series entries by the specified time frame
    group by \\"1 hour\\"
    // Use 'select' to choose aggregation functions that will be evaluated
    // Project the lowest and highest value of each group
    select min(), max()";

$query = $session->query(Employee::class)
        ->selectTimeSeries(TimeSeriesRawResult::class, function($b) use ($tsQueryText) { return $b->raw($tsQueryText);});

// Execute the query
/** @var array<TimeSeriesAggregationResult> $results */
$results = $query->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Query collection Employees
  from "Employees"
  // Project the time series data:
  select timeseries (
      from HeartRates
      // Use 'group by' to group the time series entries by the specified time frame
      group by "1 hour"   // Group entries into consecutive 1-hour groups
      // Use 'select' to choose aggregation functions that will be evaluated for each group
      select min(), max() // Project the lowest and highest value of each group
  )
`}
</CodeBlock>
</TabItem>
    </Tabs>
#### Aggregate entries with multiple values:

* Each entry in the "StockPrices" time series within the Companies collection holds five values:  
  Values[0] - **Open** - stock price when trade opens  
  Values[1] - **Close** - stock price when trade ends  
  Values[2] - **High** - highest stock price during trade time  
  Values[3] - **Low** - lowest stock price during trade time  
  Values[4] - **Volume** - overall trade volume  

* In this example, for each company that is located in USA, we group entries from the "StockPrices" time series  
  by a 7-day time frame and then project the highest and lowest values of each group.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$tsQueryText = "
    from StockPrices
    // Query stock price behavior when trade volume is high
    where Values[4] > 500000 
    // Group entries into consecutive 7-day groups
    group by \\"7 day\\"
    // Project the lowest and highest value of each group         
    select max(), min()";

$query = $session->query(Company::class)
    ->whereEquals("Address.Country", "USA")
    ->selectTimeSeries(TimeSeriesRawResult::class, function($b) use ($tsQueryText) { return $b->raw($tsQueryText);});

// Execute the query
/** @var array<TimeSeriesAggregationResult> $results */
$results = $query->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_declare_syntax" label="RQL_declare_syntax">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000 // Query stock price behavior when trade volume is high
    group by "7 days"         // Group entries into consecutive 7-day groups
    select max(), min()       // Project the lowest and highest value of each group
}

from "Companies" as c
  // Query only USA companies:
  where c.Address.Country == "USA"
  // Project the time series data:
  select SP(c)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_select_syntax" label="RQL_select_syntax">
<CodeBlock language="sql">
{`from "Companies" as c
// Query only USA companies:
where c.Address.Country = 'USA'
    // Project the time series data:
    select timeseries (
        from StockPrices
        where Values[4] > 500000 // Query stock price behavior when trade volume is high
        group by "7 day"         // Group entries into consecutive 7-day groups
        select max(), min()      // Project the lowest and highest value of each group
    )
`}
</CodeBlock>
</TabItem>
    </Tabs>

* Since each entry holds 5 values, the query will project:  
  * 5 `Max` values for each group (the highest Values[0], highest Values[1], etc.) and
  * 5 `Min` values for each group (the lowest Values[0], lowest Values[1], etc.)
#### Aggregate entries without grouping by time frame:

* This example is similar to the one above, except that time series entries are Not grouped by a time frame.

* The highest and lowest values are collected from the entire set of time series entries that match the query criteria.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$tsQueryText = "
    from StockPrices
    where Values[4] > 500_000
    select max(), min()";

$query = $session->query(Company::class)
    ->whereEquals("Address.Country", "USA")
    ->selectTimeSeries(TimeSeriesRawResult::class, function($b) use ($tsQueryText) { return $b->raw($tsQueryText);});

// Execute the query
/** @var array<TimeSeriesAggregationResult> $results */
$results = $query->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000
    select max(), min()
}

from "Companies" as c
where c.Address.Country == "USA"
select SP(c)
`}
</CodeBlock>
</TabItem>
    </Tabs>

* Since no grouping is done, results wil include the highest and lowest Open, Close, High, Low, and Volume values 
  for ALL entries in the time series that match the query criteria.
#### Aggregate entries filtered by referenced document:

* The tag in each entry in the "StockPrices" series contains an Employee document ID.

* In this example, we load this [referenced document](../../../document-extensions/timeseries/querying/filtering.mdx#filter-by-referenced-document)
  and filter the entries by its properties.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$tsQueryText = "
    from StockPrices
    // Load the referenced document into variable 'employee'
    load Tag as employee
    // Filter entries by the 'Title' field of the employee document
    where employee.Title == \\"Sales Representative\\"
    group by \\"1 month\\"
    select min(), max()";

$query = $session->query(Company::class)
    ->selectTimeSeries(TimeSeriesRawResult::class, function($b) use ($tsQueryText) { return $b->raw($tsQueryText);});

// Execute the query
/** @var array<TimeSeriesAggregationResult> $results */
$results = $query->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies" as c
select timeseries(
    from StockPrices
    // Load the referenced document into variable 'employee'
    load Tag as employee
    // Filter entries by the 'Title' field of the employee document
    where employee.Title == "Sales Representative"
    group by "1 month"
    select min(), max()
)
`}
</CodeBlock>
</TabItem>
    </Tabs>
  
* Only entries that reference an employee with title 'Sales Representative' will be grouped by 1 month,  
  and the results will include the highest and lowest values for each group.
#### Secondary grouping by tag:

* In this example, we perform secondary grouping by the entries' tags.

* The tag in each entry in the "StockPrices" series contains an Employee document ID.

* "StockPrices" entries are grouped by 6 months and then by the tags of the entries within that time frame.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$tsQueryText = "
    from StockPrices
    // Use the 'tag' keyword to perform a secondary grouping by the entries' tags
    // Group by months and by tag
    group by \\"6 months\\", tag
    // Project the highest and lowest values of each group  
    select max(), min()";

$query = $session->query(Company::class)
    ->selectTimeSeries(TimeSeriesRawResult::class, function($b) use ($tsQueryText) { return $b->raw($tsQueryText);});

// Execute the query
/** @var array<TimeSeriesAggregationResult> $results */
$results = $query->toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select timeseries (
    from StockPrices
    // Use the 'tag' keyword to perform a secondary grouping by the entries' tags.
    group by "6 months", tag  // Group by months and by tag
    select max(), min()       // Project the highest and lowest values of each group
)
`}
</CodeBlock>
</TabItem>
    </Tabs>
#### Project document data in addition to aggregated data:

* In addition to projecting the aggregated time series data, you can project data from the parent document that contains the time series.
 
* In this example, projecting the **company name** alongside the query results clearly associates each entry in the result set with a specific company.
  This provides immediate context and makes it easier to interpret the time series data.

<Tabs groupId='languageSyntax'>
<TabItem value="RQL_declare_syntax" label="RQL_declare_syntax">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000 // Query stock price behavior when trade volume is high
    group by "7 days"         // Group entries into consecutive 7-day groups
    select max(), min()       // Project the lowest and highest value of each group
}

from "Companies" as c
// Project company name along with time series query results to make the results clearer
select SP(c) as MinMaxValues, c.Name as CompanyName
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_select_syntax" label="RQL_select_syntax">
<CodeBlock language="sql">
{`from "Companies" as c
select timeseries (
    from StockPrices
    where Values[4] > 500000
    group by "7 day"
    select max(), min()
) as MinMaxValues,
c.Name as CompanyName // Project property 'Name' from the company document
`}
</CodeBlock>
</TabItem>
    </Tabs>




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Time series queries can easily generate powerful statistics by applying an aggregation function  
  (such as Min, Max, Count, Average, etc.) to a group of entries within a chosen time frame,  
  such as an hour or a week.

* For an overview of the available time series queries, please refer to [Time series querying](../../../document-extensions/timeseries/client-api/session/querying.mdx).

* In this page:  
  * [Grouping and aggregation options](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#grouping-and-aggregation-options)  
  * [Examples](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#examples)
      * [Aggregate entries with single value](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-with-single-value)
      * [Aggregate entries with multiple values](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-with-multiple-values)
      * [Aggregate entries without grouping by time frame](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-without-grouping-by-time-frame)
      * [Aggregate entries filtered by referenced document](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#aggregate-entries-filtered-by-referenced-document)
      * [Secondary grouping by tag](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#secondary-grouping-by-tag)
      * [Project document data in addition to aggregated data](../../../document-extensions/timeseries/querying/aggregation-and-projections.mdx#project-document-data-in-addition-to-aggregated-data)

</Admonition>
## Grouping and aggregation options

* **Group entries by time frame**:  
  First, you can group the time series entries based on the specified time frame.  
  The following time units are available:

  * `milliseconds` ( milliseconds / milli / ms)
  * `seconds`      ( seconds/ second / s )
  * `minutes`      ( minutes / minute / min )
  * `hours`        ( hours / hour / h )
  * `days`         ( days / day / d )
  * `months`       ( months / month / mon / mo )
  * `quarters`     ( quarters / quarter / q )
  * `years`        ( years / year / y )

* **Secondary grouping**:  
  After grouping by a time unit, you can also perform a _secondary grouping_ by the time series [tag](../../../document-extensions/timeseries/overview.mdx#tags).

* **Aggregate values**:  
  You can select one or more aggregation functions to retrieve aggregated values for each group.  
  The resulting aggregated values are **projected** to the client in the query result.  
  The following functions are available:

  * `min()` - the lowest value
  * `max()` - the highest value
  * `sum()` - sum of all values
  * `average()` - the average value
  * `first()` - value of first entry
  * `last()` - value of last entry
  * `percentile(<percentage>)` - The value under which the specified percentage of values fall
  * `slope` - the change in value divided by the change in time between the first and last entries 
  * `standardDeviation()` - the standard deviation of all values (a measure of how spread out the values are from the average)
  * `count()` - The result of Count() is always returned, even if you do not explicitly request it.
     * When each entry has a single value:  
       Returns the number of entries.  
     * When each entry has multiple values:  
       Returns an array of the size of the number of values.  
       Each array element contains the number of entries having a measurement for that value.  

<Admonition type="note" title="Note">

**Execute all aggregation functions**:  
When a query groups entries by a time frame but does Not explicitly select a specific aggregation function,  
the server will implicitly execute ALL available aggregation functions (except for Percentile, Slope, and StandardDeviation) for each group.

</Admonition>
<Admonition type="note" title="Note">

**Get aggregated values without grouping**:  
When selecting aggregation functions WITHOUT first grouping the time series entries,  
the aggregation calculations will be executed over the entire set of time series entries instead of per group of entries.

</Admonition>


## Examples

#### Aggregate entries with single value

* Each entry in the "HeartRates" time series within the Employees collection contains a single value.

* In this example, for each employee document, we group entries from the "HeartRates" time series  
  by a 1-hour time frame and then project the lowest and highest values of each group.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`// Define the time series query part (expressed in RQL):
const tsQueryText = \`
    from HeartRates
    // Use 'group by' to group the time series entries by the specified time frame
    group by "1 hour"
    // Use 'select' to choose aggregation functions that will be evaluated
    // Project the lowest and highest value of each group
    select min(), max()\`;

// Define the query:
const query = session.query({ collection: "employees" })
    .selectTimeSeries(b => b.raw(tsQueryText), TimeSeriesRawResult);

// Execute the query:
const results = await query.all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`// Query collection Employees
  from "Employees"
  // Project the time series data:
  select timeseries (
      from HeartRates
      // Use 'group by' to group the time series entries by the specified time frame
      group by "1 hour"   // Group entries into consecutive 1-hour groups
      // Use 'select' to choose aggregation functions that will be evaluated for each group
      select min(), max() // Project the lowest and highest value of each group
  )
`}
</CodeBlock>
</TabItem>
    </Tabs>
#### Aggregate entries with multiple values:

* Each entry in the "StockPrices" time series within the Companies collection holds five values:  
  Values[0] - **Open** - stock price when trade opens  
  Values[1] - **Close** - stock price when trade ends  
  Values[2] - **High** - highest stock price during trade time  
  Values[3] - **Low** - lowest stock price during trade time  
  Values[4] - **Volume** - overall trade volume  

* In this example, for each company that is located in USA, we group entries from the "StockPrices" time series  
  by a 7-day time frame and then project the highest and lowest values of each group.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const tsQueryText = \`
    from StockPrices
    // Query stock price behavior when trade volume is high
    where Values[4] > 500000 
    // Group entries into consecutive 7-day groups
    group by "7 day"
    // Project the lowest and highest value of each group         
    select max(), min()\`;

const query = session.query({ collection: "companies" })
    .whereEquals("Address.Country", "USA")
    .selectTimeSeries(b => b.raw(tsQueryText), TimeSeriesRawResult);

const results = await query.all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_declare_syntax" label="RQL_declare_syntax">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000 // Query stock price behavior when trade volume is high
    group by "7 days"         // Group entries into consecutive 7-day groups
    select max(), min()       // Project the lowest and highest value of each group
}

from "Companies" as c
  // Query only USA companies:
  where c.Address.Country == "USA"
  // Project the time series data:
  select SP(c)
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_select_syntax" label="RQL_select_syntax">
<CodeBlock language="sql">
{`from "Companies" as c
// Query only USA companies:
where c.Address.Country = 'USA'
    // Project the time series data:
    select timeseries (
        from StockPrices
        where Values[4] > 500000 // Query stock price behavior when trade volume is high
        group by "7 day"         // Group entries into consecutive 7-day groups
        select max(), min()      // Project the lowest and highest value of each group
    )
`}
</CodeBlock>
</TabItem>
    </Tabs>

* Since each entry holds 5 values, the query will project:  
  * 5 `Max` values for each group (the highest Values[0], highest Values[1], etc.) and
  * 5 `Min` values for each group (the lowest Values[0], lowest Values[1], etc.)
#### Aggregate entries without grouping by time frame:

* This example is similar to the one above, except that time series entries are Not grouped by a time frame.

* The highest and lowest values are collected from the entire set of time series entries that match the query criteria.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const tsQueryText = \`
    from StockPrices
    where Values[4] > 500_000
    select max(), min()\`;

const query = session.query({ collection: "companies" })
    .whereEquals("Address.Country", "USA")
    .selectTimeSeries(b => b.raw(tsQueryText), TimeSeriesRawResult);

const results = await query.all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000
    select max(), min()
}

from "Companies" as c
where c.Address.Country == "USA"
select SP(c)
`}
</CodeBlock>
</TabItem>
    </Tabs>

* Since no grouping is done, results wil include the highest and lowest Open, Close, High, Low, and Volume values 
  for ALL entries in the time series that match the query criteria.
#### Aggregate entries filtered by referenced document:

* The tag in each entry in the "StockPrices" series contains an Employee document ID.

* In this example, we load this [referenced document](../../../document-extensions/timeseries/querying/filtering.mdx#filter-by-referenced-document)
  and filter the entries by its properties.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const tsQueryText = \`
    from StockPrices
    // Load the referenced document into variable 'employee'
    load Tag as employee
    // Filter entries by the 'Title' field of the employee document
    where employee.Title == "Sales Representative"
    group by "1 month"
    select min(), max()\`;

const query = session.query({ collection: "companies" })
    .selectTimeSeries(b => b.raw(tsQueryText), TimeSeriesRawResult);

const results = await query.all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies" as c
select timeseries(
    from StockPrices
    // Load the referenced document into variable 'employee'
    load Tag as employee
    // Filter entries by the 'Title' field of the employee document
    where employee.Title == "Sales Representative"
    group by "1 month"
    select min(), max()
)
`}
</CodeBlock>
</TabItem>
    </Tabs>
  
* Only entries that reference an employee with title 'Sales Representative' will be grouped by 1 month,  
  and the results will include the highest and lowest values for each group.
#### Secondary grouping by tag:

* In this example, we perform secondary grouping by the entries' tags.

* The tag in each entry in the "StockPrices" series contains an Employee document ID.

* "StockPrices" entries are grouped by 6 months and then by the tags of the entries within that time frame.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const tsQueryText = \`
    from StockPrices
    // Use the 'tag' keyword to perform a secondary grouping by the entries' tags
    // Group by months and by tag
    group by "6 months", tag
    // Project the highest and lowest values of each group  
    select max(), min()\`;

const query = session.query({ collection: "companies" })
    .selectTimeSeries(b => b.raw(tsQueryText), TimeSeriesRawResult);

const results = await query.all();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from "Companies"
select timeseries (
    from StockPrices
    // Use the 'tag' keyword to perform a secondary grouping by the entries' tags.
    group by "6 months", tag  // Group by months and by tag
    select max(), min()       // Project the highest and lowest values of each group
)
`}
</CodeBlock>
</TabItem>
    </Tabs>
#### Project document data in addition to aggregated data:

* In addition to projecting the aggregated time series data, you can project data from the parent document that contains the time series.
 
* In this example, projecting the **company name** alongside the query results clearly associates each entry in the result set with a specific company.
  This provides immediate context and makes it easier to interpret the time series data.

<Tabs groupId='languageSyntax'>
<TabItem value="RQL_declare_syntax" label="RQL_declare_syntax">
<CodeBlock language="sql">
{`declare timeseries SP(c)
{
    from c.StockPrices
    where Values[4] > 500_000 // Query stock price behavior when trade volume is high
    group by "7 days"         // Group entries into consecutive 7-day groups
    select max(), min()       // Project the lowest and highest value of each group
}

from "Companies" as c
// Project the company's name along with the time series query results to make results more clear
select SP(c) as MinMaxValues, c.Name as CompanyName
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL_select_syntax" label="RQL_select_syntax">
<CodeBlock language="sql">
{`from "Companies" as c
select timeseries (
    from StockPrices
    where Values[4] > 500000
    group by "7 day"
    select max(), min()
) as MinMaxValues,
c.Name as CompanyName // Project property 'Name' from the company document
`}
</CodeBlock>
</TabItem>
    </Tabs>




</LanguageContent>

<!---
### Time Series Overview
- [Time Series Overview](../../../document-extensions/timeseries/overview)

### Studio Articles
- [Studio Time Series Management](../../../studio/database/document-extensions/time-series)

### Time Series Indexing
- [Time Series Indexing](../../../document-extensions/timeseries/indexing)

### Time Series Queries
- [Range Selection](../../../document-extensions/timeseries/querying/choosing-query-range)
- [Filtering](../../../document-extensions/timeseries/querying/filtering)
- [Indexed Time Series Queries](../../../document-extensions/timeseries/querying/using-indexes)

### Policies
- [Time Series Rollup and Retention](../../../document-extensions/timeseries/rollup-and-retention)

### Querying
- [Querying: Projections](../../../indexes/querying/projections)


-->