---
title: "Creating and deploying indexes"
hide_table_of_contents: true
sidebar_label: Creating and Deploying Indexes
sidebar_position: 2
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Creating and deploying indexes

**Indexes are used by server to satisfy queries**, whenever a user issues a query RavenDB will use an existing index if it matches query or create a new one if no match is found.

<Admonition type="info" title="Remember" id="remember" href="#remember">

Indexes created by issuing a query are called `dynamic` or `Auto` indexes and can be easily identified, due to their name that starts with `Auto/` prefix.

Indexes created explicitly by user are called `static`.

</Admonition>

## **Static indexes**

There are a couple of ways to create `static index` and send it to server, we can use low-level [commands](../indexes/creating-and-deploying.mdx#using-commands) or create a [custom class](../indexes/creating-and-deploying.mdx#using-abstractindexcreationtask). There is also a possibility to [scan an assembly](../indexes/creating-and-deploying.mdx#using-assembly-scanner) and deploy all found indexes or even deploy indexes [side by side](../indexes/side-by-side-indexes.mdx).

---

### using AbstractIndexCreationTask

If you are interested in having a **strongly-typed syntax** during index creation, have an **ability to deploy indexes using assembly scanner**, **avoid hard-coding index names in every query** and **do not worry about setting sorting for numerical fields**, then `AbstractIndexCreationTask` should be your choice. 

<Admonition type="note" title="Note">
We recommend creating and using indexes in this form due to its simplicity, many benefits and few disadvantages.
</Admonition>

<Admonition type="note" title="Note">
When index is deployed using `AbstractIndexCreationTask` then all numerical fields in generated index definition will contain appropriate sorting options set.
</Admonition>

#### Naming conventions

Actually there is only one naming conventions: each `_` in class name will be translated to `/` in index name.

e.g.

In `Northwind` samples there is a index called `Orders/Totals`. To get such a index name, we need to create class called `Orders_Totals`.

<TabItem value="indexes_1" label="indexes_1">
<CodeBlock language="csharp">
{`// Define a static-index
// Inherit from 'AbstractIndexCreationTask'
public class Orders_ByTotal : AbstractIndexCreationTask<Order>
\{
    // ...
\}
`}
</CodeBlock>
</TabItem>

#### Sending to server

There is not much use from an index if it is not deployed to server. In order to do so, we need to create instance of our class that inherits from `AbstractIndexCreationTask` and use one of the deployment methods: `Execute` or `ExecuteAsync` for asynchronous call.

<TabItem value="indexes_2" label="indexes_2">
<CodeBlock language="csharp">
{`public class Orders_ByTotal : AbstractIndexCreationTask<Order>
\{
    public Orders_ByTotal()
    \{
        // ...
        // Set an indexing configuration value for this index:
        Configuration["Indexing.MapTimeoutInSec"] = "30";
    \}
\}
`}
</CodeBlock>
</TabItem>

<TabItem value="indexes_3" label="indexes_3">
<CodeBlock language="csharp">
{`// Call 'Execute' directly on the index instance
new Orders_ByTotal().Execute(store);
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="Note">
If index exists on server and stored definition is the same as the one that was send, then it will not be overwritten, which implies that indexed data will not be deleted and indexation will not start from scratch.
</Admonition>

#### Using assembly scanner

All classes that inherit from `AbstractIndexCreationTask` can be deployed at once using one of `IndexCreation.CreateIndexes` method overloads.

<TabItem value="indexes_4" label="indexes_4">
<CodeBlock language="csharp">
{`// Call 'ExecuteAsync' directly on the index instance
await new Orders_ByTotal().ExecuteAsync(store);
`}
</CodeBlock>
</TabItem>

Underneath, the `IndexCreation` will attempt to create all indexes in a single request. If it fails, then it will repeat the execution by calling 
 `Execute` method one-by-one for each of found indexes in separate requests.

<Admonition type="warning" title="Warning">
`IndexCreation.CreateIndexes` will also deploy all classes that inherit from `AbstractTransformerCreationTask` (more about it [here](../transformers/creating-and-deploying.mdx)).
</Admonition>

#### Example

<TabItem value="indexes_8" label="indexes_8">
<CodeBlock language="csharp">
{`var indexesToDeploy = new List<AbstractIndexCreationTask>
\{
    new Orders_ByTotal(),
    new Employees_ByLastName()
\};

// Call 'ExecuteIndexesAsync' on your store object
await store.ExecuteIndexesAsync(indexesToDeploy);
`}
</CodeBlock>
</TabItem>

---

### using Commands

Low-level `PutIndex` command from `DatabaseCommands` (which API reference can be found [here](../client-api/commands/indexes/put.mdx)) can be used also to send index to server.

The benefit of this approach is that you can choose the name as you feel fit and change various settings available in `IndexDefinition`, but loose the ability to deploy using assembly scanner. Also you will have to use string-based names of indexes when querying.

<TabItem value="indexes_5" label="indexes_5">
<CodeBlock language="csharp">
{`// Call 'ExecuteIndex' on your store object
store.ExecuteIndex(new Orders_ByTotal());
`}
</CodeBlock>
</TabItem>

#### IndexDefinitionBuilder

`IndexDefinitionBuilder` is a very useful class that enables you to create `IndexDefinitions` using strongly-typed syntax with an access to low-level settings not available when `AbstractIndexCreationTask` approach is used.

<TabItem value="indexes_6" label="indexes_6">
<CodeBlock language="csharp">
{`// Call 'ExecuteIndexAsync' on your store object
await store.ExecuteIndexAsync(new Orders_ByTotal());
`}
</CodeBlock>
</TabItem>

#### Remarks

<Admonition type="info" title="Info">
Commands or `IndexDefinitionBuilder` approaches are not recommended and should be used only if you can't do that by inheriting from `AbstractIndexCreationTask`.
</Admonition>



## **Auto indexes**

Auto-indexes are created when queries that do not specify an index name are executed and (after in-depth query analysis) no matching index is found on server-side.

### Naming convention

As mentioned earlier auto-indexes can be recognized by `Auto/` prefix in name. Their name also contains name of a collection that was queried and list of fields that were required to find valid query results.

For instance, issuing query like this

<TabItem value="indexes_7" label="indexes_7">
<CodeBlock language="csharp">
{`var indexesToDeploy = new List<AbstractIndexCreationTask>
\{
    new Orders_ByTotal(),
    new Employees_ByLastName()
\};

// Call 'ExecuteIndexes' on your store object
store.ExecuteIndexes(indexesToDeploy);
`}
</CodeBlock>
</TabItem>

will result in a creation of a index named `Auto/Employees/ByFirstNameAndLastName`.

### Disabling creation of Auto indexes

By default, `Raven/CreateAutoIndexesForAdHocQueriesIfNeeded` configuration option is set to `true`, which allows auto-index creation if needed. To disable it server or database-wide please refer to [this article](../server/configuration/configuration-options.mdx).

### Auto indexes and indexing prioritization

To reduce the server load, if auto-indexes are not queried for a certain amount of time defined in `Raven/TimeToWaitBeforeMarkingAutoIndexAsIdle` setting (1 hour by default), then they will be marked as `Idle`. You can read more about implications of marking index as `Idle` [here](../server/administration/index-administration.mdx#index-prioritization).

If this is disabled, you'll have to manually ensure that all queries have covering indexes. This is _not_ a recommended configuration.



## Remarks

<Admonition type="note" title="In-memory indexes" id="in-memory-indexes" href="#in-memory-indexes">

By default, new indexes are created in-memory (can be disabled by changing `Raven/DisableInMemoryIndexing` to `false`) and persisted to disk when one of the following conditions are met:

- index is not [stale](../indexes/stale-indexes.mdx) after write,
- when in-memory size of an index exceeds 64MB (can be altered by changing `Raven/NewIndexInMemoryMaxMB`),
- when difference between current write time and index creation time exceeds 15 minutes (can be altered by changing `Raven/NewIndexInMemoryMaxTime`),
- when backup is created,
- when database is closed,
- on user request. More info [here](../server/administration/index-administration.mdx#persistence-of-an-auto-index).

</Admonition>

