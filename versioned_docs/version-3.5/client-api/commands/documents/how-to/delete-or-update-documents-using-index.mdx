---
title: "Commands: Documents: How to delete or update documents using index?"
hide_table_of_contents: true
sidebar_label: ...delete/update documents using index
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "http"];


# Commands: Documents: How to delete or update documents using index?
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">


Sometimes we need to update or delete a large amount of documents answering certain criteria. With SQL this is a simple operation, and a query doing that will look like this:

`DELETE FROM Users WHERE LastLogin < '2009-01-01'`   
`UPDATE Users SET IsActive = 0 WHERE LastLogin < '2010-01-01'`   

This is usually not the case for NoSQL databases, where batch operations are not supported. RavenDB does support them, and by passing it a query and an operation definition, it will run the query and perform that operation on its results.

The same queries and indexes that are used for data retrieval are used for the batch operations, therefore the syntax defining which documents to work on is exactly the same as you'd specified for those documents to be pulled from store.

## **DeleteByIndex**

To issue a batch-delete command you need to specify an index and a query to be sent to it. To minimize the chances of stale results coming back, bulk operations should only be performed on static indexes.

### Syntax

<TabItem value="delete_by_index_1" label="delete_by_index_1">
<CodeBlock language="csharp">
{`Operation DeleteByIndex(
	string indexName,
	IndexQuery queryToDelete,
	BulkOperationOptions options = null);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **indexName** | string | name of an index to perform a query on |
| **queryToDelete** | IndexQuery | query that will be performed |
| **options** | [BulkOperationOptions](../../../../glossary/bulk-operation-options.mdx)  | various operation options e.g. `AllowStale` or `MaxOpsPerSec` |

| Return Value | |
| ------------- | ----- |
| [Operation](../../../../glossary/operation.mdx) | Object that allows waiting for operation to complete. |

### Remarks

<Admonition type="note" title="">
`DeleteByIndex` can only be performed on map index. Executing it on map-reduce index will lead to an exception.
</Admonition>

### Example

<TabItem value="delete_by_index_2" label="delete_by_index_2">
<CodeBlock language="csharp">
{`// remove all documents from 'Employees' collection
Operation operation = store
	.DatabaseCommands
	.DeleteByIndex(
		"Raven/DocumentsByEntityName",
		new IndexQuery
		\{
			Query = "Tag:Employees"
		\},
		new BulkOperationOptions
		\{
			AllowStale = false
		\});

operation.WaitForCompletion();
`}
</CodeBlock>
</TabItem>


## **UpdateByIndex**

Performing a mass-update is exactly the same as making a mass-delete, but this time it uses the Patching API to make it easy for us to define what to do with the documents matching our query.

### Syntax

<TabItem value="update_by_index_1" label="update_by_index_1">
<CodeBlock language="csharp">
{`Operation UpdateByIndex(
	string indexName,
	IndexQuery queryToUpdate,
	PatchRequest[] patchRequests,
	BulkOperationOptions options = null);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **indexName** | string | name of an index to perform a query on |
| **queryToUpdate** | IndexQuery | query that will be performed |
| **patchRequests** | PatchRequest[]  | array of patches that will be executed on a query results |
| **options** | [BulkOperationOptions](../../../../glossary/bulk-operation-options.mdx) | various operation options e.g. `AllowStale` or `MaxOpsPerSec` |

| Return Value | |
| ------------- | ----- |
| [Operation](../../../../glossary/operation.mdx) | Object that allows waiting for operation to complete. |

### Example

<TabItem value="update_by_index_2" label="update_by_index_2">
<CodeBlock language="csharp">
{`// Set property 'FirstName' for all documents in collection 'Employees' to 'Patched Name'
Operation operation = store
	.DatabaseCommands
	.UpdateByIndex(
		"Raven/DocumentsByEntityName",
		new IndexQuery
		\{
			Query = "Tag:Employees"
		\},
		new[]
		\{
			new PatchRequest
			\{
				Type = PatchCommandType.Set, 
				Name = "FirstName", 
				Value = "Patched Name"
			\}
		\},
		new BulkOperationOptions
		\{
			AllowStale = false
		\});

operation.WaitForCompletion();
`}
</CodeBlock>
</TabItem>


## **UpdateByIndex** - using JavaScript

Mass-update can also be executed with JavaScript patch.

### Syntax

<TabItem value="update_by_index_3" label="update_by_index_3">
<CodeBlock language="csharp">
{`Operation UpdateByIndex(
	string indexName,
	IndexQuery queryToUpdate,
	ScriptedPatchRequest patch,
	BulkOperationOptions options = null);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **indexName** | string | name of an index to perform a query on |
| **queryToUpdate** | IndexQuery | query that will be performed |
| **patch** | ScriptedPatchRequest  | JavaScript patch that will be executed on query results |
| **options** | [BulkOperationOptions](../../../../glossary/bulk-operation-options.mdx) | various operation options e.g. `AllowStale` or `MaxOpsPerSec` |

| Return Value | |
| ------------- | ----- |
| [Operation](../../../../glossary/operation.mdx) | Object that allows waiting for operation to complete. |

### Example

<TabItem value="update_by_index_4" label="update_by_index_4">
<CodeBlock language="csharp">
{`// Set property 'FirstName' for all documents in collection 'Employees' to 'Patched Name'
Operation operation = store
	.DatabaseCommands
	.UpdateByIndex(
		"Raven/DocumentsByEntityName",
		new IndexQuery
		\{
			Query = "Tag:Employees"
		\},
		new ScriptedPatchRequest
		\{
			Script = @"this.FirstName = 'Patched Name';"
		\},
		new BulkOperationOptions
		\{
			AllowStale = false
		\});

operation.WaitForCompletion();
`}
</CodeBlock>
</TabItem>



## Remarks

<Admonition type="note" title="">
By default, Set-based operations will **not work** on indexes that are stale, and the operation will **only succeed** if the specified **index is not stale**. This is to make sure you only delete what you intended to delete.
</Admonition>

For indexes that are updated all the time, you can set a `Cutoff` in the `IndexQuery` object you send, which will make sure the operation is executed and that you know what results to expect.

When you are absolutely certain that you can perform the operation when the index is stale, simply set the `allowStale` parameter to true.


</LanguageContent>
<LanguageContent language="java">


Sometimes we need to update or delete a large amount of documents answering certain criteria. With SQL this is a simple operation, and a query doing that will look like this:

`DELETE FROM Users WHERE LastLogin < '2009-01-01'`   
`UPDATE Users SET IsActive = 0 WHERE LastLogin < '2010-01-01'`   

This is usually not the case for NoSQL databases, where batch operations are not supported. RavenDB does support them, and by passing it a query and an operation definition, it will run the query and perform that operation on its results.

The same queries and indexes that are used for data retrieval are used for the batch operations, therefore the syntax defining which documents to work on is exactly the same as you'd specified for those documents to be pulled from store.

## **DeleteByIndex**

To issue a batch-delete command you need to specify an index and a query to be sent to it. To minimize the chances of stale results coming back, bulk operations should only be performed on static indexes.

### Syntax

<TabItem value="delete_by_index_1" label="delete_by_index_1">
<CodeBlock language="java">
{`public Operation deleteByIndex(String indexName, IndexQuery queryToDelete);

public Operation deleteByIndex(String indexName, IndexQuery queryToDelete, BulkOperationOptions options);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **indexName** | String | name of an index to perform a query on |
| **queryToDelete** | IndexQuery | query that will be performed |
| **options** | [BulkOperationOptions](../../../../glossary/bulk-operation-options.mdx) | various operation options e.g. `AllowStale` or `MaxOpsPerSec` |

| Return Value | |
| ------------- | ----- |
| [Operation](../../../../glossary/operation.mdx) | Object that allows waiting for operation to complete. |

### Remarks

<Admonition type="note" title="">
`DeleteByIndex` can only be performed on map index. Executing it on map-reduce index will lead to an exception.
</Admonition>

### Example

<TabItem value="delete_by_index_2" label="delete_by_index_2">
<CodeBlock language="java">
{`// remove all documents from 'Employees' collection
Operation operation = store.getDatabaseCommands()
  .deleteByIndex("Raven/DocumentsByEntityName", new IndexQuery("Tag:Employees"));

operation.waitForCompletion();
`}
</CodeBlock>
</TabItem>


## **UpdateByIndex**

Performing a mass-update is exactly the same as making a mass-delete, but this time it uses the Patching API to make it easy for us to define what to do with the documents matching our query.

### Syntax

<TabItem value="update_by_index_1" label="update_by_index_1">
<CodeBlock language="java">
{`public Operation updateByIndex(String indexName, IndexQuery queryToUpdate, PatchRequest[] patchRequests);

public Operation updateByIndex(String indexName, IndexQuery queryToUpdate, PatchRequest[] patchRequests, BulkOperationOptions options);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **indexName** | String | name of an index to perform a query on |
| **queryToUpdate** | IndexQuery | query that will be performed |
| **patchRequests** | PatchRequest[]  | array of patches that will be executed on a query results |
| **options** | [BulkOperationOptions](../../../../glossary/bulk-operation-options.mdx) | various operation options e.g. `AllowStale` or `MaxOpsPerSec` |

| Return Value | |
| ------------- | ----- |
| [Operation](../../../../glossary/operation.mdx) | Object that allows waiting for operation to complete. |

### Example

<TabItem value="update_by_index_2" label="update_by_index_2">
<CodeBlock language="java">
{`// Set property 'FirstName' for all documents in collection 'Employees' to 'Patched Name'
PatchRequest patchRequest = new PatchRequest(PatchCommandType.SET, "FirstName", RavenJToken.fromObject("Patched Name"));

Operation operation = store.getDatabaseCommands().updateByIndex(
  "Raven/DocumentsByEntityName",
  new IndexQuery("Tag:Employees"),
  new PatchRequest[] \{ patchRequest \});

operation.waitForCompletion();
`}
</CodeBlock>
</TabItem>


## **UpdateByIndex** - using JavaScript

Mass-update can also be executed with JavaScript patch.

### Syntax

<TabItem value="update_by_index_3" label="update_by_index_3">
<CodeBlock language="java">
{`public Operation updateByIndex(String indexName, IndexQuery queryToUpdate, ScriptedPatchRequest patch);

public Operation updateByIndex(String indexName, IndexQuery queryToUpdate, ScriptedPatchRequest patch, BulkOperationOptions options);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **indexName** | String | name of an index to perform a query on |
| **queryToUpdate** | IndexQuery | query that will be performed |
| **patch** | ScriptedPatchRequest  | JavaScript patch that will be executed on query results |
| **options** | [BulkOperationOptions](../../../../glossary/bulk-operation-options.mdx) | various operation options e.g. `AllowStale` or `MaxOpsPerSec` |

| Return Value | |
| ------------- | ----- |
| [Operation](../../../../glossary/operation.mdx) | Object that allows waiting for operation to complete. |

### Example

<TabItem value="update_by_index_4" label="update_by_index_4">
<CodeBlock language="java">
{`// Set property 'FirstName' for all documents in collection 'Employees' to 'Patched Name'
Operation operation = store.getDatabaseCommands().updateByIndex(
  "Raven/DocumentsByEntityName",
  new IndexQuery("Tag:Employees"),
  new ScriptedPatchRequest("this.FirstName = 'Patched Name';"));

operation.waitForCompletion();
`}
</CodeBlock>
</TabItem>



## Remarks

<Admonition type="note" title="">
By default, Set-based operations will **not work** on indexes that are stale, and the operation will **only succeed** if the specified **index is not stale**. This is to make sure you only delete what you intended to delete.
</Admonition>

For indexes that are updated all the time, you can set a `Cutoff` in the `IndexQuery` object you send, which will make sure the operation is executed and that you know what results to expect.

When you are absolutely certain that you can perform the operation when the index is stale, simply set the `allowStale` parameter to true.


</LanguageContent>
<LanguageContent language="http">


Sometimes we need to update or delete a large amount of documents answering certain criteria. With SQL this is a simple operation, and a query doing that will look like this:

`DELETE FROM Users WHERE LastLogin < '2009-01-01'`   
`UPDATE Users SET IsActive = 0 WHERE LastLogin < '2010-01-01'`   

This is usually not the case for NoSQL databases, where batch operations are not supported. RavenDB does support them, and by passing it a query and an operation definition, it will run the query and perform that operation on its results.

The same queries and indexes that are used for data retrieval are used for the batch operations, therefore the syntax defining which documents to work on is exactly the same as you'd specified for those documents to be pulled from store.

## **DeleteByIndex**

To issue a batch-delete command you need to specify an index and a query to be sent to it. To minimize the chances of stale results coming back, bulk operations should only be performed on static indexes.

### Syntax

<TabItem value="json" label="json">
<CodeBlock language="json">
{`curl \\ 
	http://\{serverName\}/databases/\{databaseName\}/bulk_docs/\{indexName\}? \\
		query=\{query\}& \\
		allowStale=\{allowStale\} \\
		[Other indexQuery parameters] \\
	-X DELETE 
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="IndexQuery parameters" id="indexquery-parameters" href="#indexquery-parameters">
This endpoint accepts [IndexQuery](../../../../glossary/index-query.mdx) object. All possible [IndexQuery](../../../../glossary/index-query.mdx) parameters are listed [here](../../../../client-api/commands/querying/how-to-query-a-database.mdx#indexquery-parameters)
</Admonition>

### Request

| Query parameter | Required | Description |
| ------------- | -- | ---- |
| **indexName** | Yes | name of an index to perform a query on |
| **query** | Yes | query that will be performed |
| **allowStale** | No | can operation be performed on a stale index (default: `false`) |

### Response

| Status code | Description |
| ----------- | - |
| `200` | OK |

| Return Value | Description |
| ------------- | ------------- |
| **OperationId** | Operation id |

---

### Remarks

<Admonition type="note" title="">
`DeleteByIndex` can only be performed on map index. Executing it on map-reduce index will lead to an exception.
</Admonition>

---

### Example

Remove all documents from 'Shops' collection

<TabItem value="json" label="json">
<CodeBlock language="json">
{`curl -X DELETE "http://localhost:8080/databases/NorthWind/bulk_docs/Raven/DocumentsByEntityName?&query=Tag%3AShops&allowStale=false" 
< HTTP/1.1 200 OK
\{"OperationId":1\}
`}
</CodeBlock>
</TabItem>


## **UpdateByIndex**

Performing a mass-update is exactly the same as making a mass-delete, but this time it uses the Patching API to make it easy for us to define what to do with the documents matching our query.

### Syntax

<TabItem value="json" label="json">
<CodeBlock language="json">
{`curl \\
	http://\{serverName\}/databases/\{databaseName\}/bulk_docs/\{indexName\}? \\
		query=\{query\}& \\
		allowStale=\{allowStale\} \\
		[Other indexQuery parameters] \\
	-X PATCH \\
	-d @patchs.txt
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="IndexQuery parameters" id="indexquery-parameters" href="#indexquery-parameters">
This endpoint accepts [IndexQuery](../../../../glossary/index-query.mdx) object. All possible [IndexQuery](../../../../glossary/index-query.mdx) parameters are listed [here](../../../../client-api/commands/querying/how-to-query-a-database.mdx#indexquery-parameters)
</Admonition>

### Request

| Query parameter | Required | Description |
| ------------- | -- | ---- |
| **indexName** | Yes | name of an index to perform a query on |
| **query** | Yes | query that will be performed |
| **allowStale** | No | can operation be performed on a stale index (default: `false`) |

| Payload |
| ------- |
| Array of patch requests |

### Response

| Status code | Description |
| ----------- | - |
| `200` | OK |

| Return Value | Description |
| ------------- | ------------- |
| **OperationId** | Operation id |

---

### Example

Set property 'FirstName' for all documents in collection 'Employees' to 'Patched Name'

<TabItem value="json" label="json">
<CodeBlock language="json">
{`curl -X PATCH "http://localhost:8080/databases/NorthWind/bulk_docs/Raven/DocumentsByEntityName?&query=Tag%3AEmployees&pageSize=128&allowStale=false" \\
 -d "[\{\\"Name\\":\\"FirstName\\",\\"Value\\":\\"Patched Name\\",\\"Type\\":\\"Set\\"\}]"

< HTTP/1.1 200 OK
\{"OperationId":4\}
`}
</CodeBlock>
</TabItem>


## **UpdateByIndex** - using JavaScript

Mass-update can also be executed with JavaScript patch.

### Syntax

<TabItem value="json" label="json">
<CodeBlock language="json">
{`curl \\
	http://\{serverName\}/databases/\{databaseName\}/bulk_docs/\{indexName\}? \\
		query=\{query\}& \\
		allowStale=\{allowStale\} \\
		[Other indexQuery parameters] \\
	-X EVAL \\
	-d @jsScript.txt
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="IndexQuery parameters" id="indexquery-parameters" href="#indexquery-parameters">
This endpoint accepts [IndexQuery](../../../../glossary/index-query.mdx) object. All possible [IndexQuery](../../../../glossary/index-query.mdx) parameters are listed [here](../../../../client-api/commands/querying/how-to-query-a-database.mdx#indexquery-parameters)
</Admonition>

### Request

| Query parameter | Required | Description |
| ------------- | -- | ---- |
| **indexName** | Yes | name of an index to perform a query on |
| **query** | Yes | query that will be performed |
| **allowStale** | No | can operation be performed on a stale index (default: `false`) |

| Payload |
| ------- |
| Java script used for patching |

### Response

| Status code | Description |
| ----------- | - |
| `200` | OK |

| Return Value | Description |
| ------------- | ------------- |
| **OperationId** | Operation id |

---

### Example

Set property 'FirstName' for all documents in collection 'Employees' to 'Patched Name'. 

<TabItem value="json" label="json">
<CodeBlock language="json">
{`curl -X EVAL "http://localhost:8080/databases/NorthWind/bulk_docs/Raven/DocumentsByEntityName?&query=Tag%3AEmployees&pageSize=128&allowStale=false" \\
 -d "\{\\"Values\\":\{\},\\"Script\\":\\"this.FirstName = 'Patched Name';\\"\}"

< HTTP/1.1 200 OK
\{"OperationId":4\}
`}
</CodeBlock>
</TabItem>



## Remarks

<Admonition type="note" title="">
By default, Set-based operations will **not work** on indexes that are stale, and the operation will **only succeed** if the specified **index is not stale**. This is to make sure you only delete what you intended to delete.
</Admonition>

For indexes that are updated all the time, you can set a `cutoff` which will make sure the operation is executed and that you know what results to expect.

When you are absolutely certain that you can perform the operation when the index is stale, simply set the `allowStale` parameter to true.


</LanguageContent>

<!---
- [Put](../../../../client-api/commands/documents/put)
- [Delete](../../../../client-api/commands/documents/delete)
- [Session: DeleteByIndex](../../../session/how-to/delete-documents-using-index-with-linq)

-->