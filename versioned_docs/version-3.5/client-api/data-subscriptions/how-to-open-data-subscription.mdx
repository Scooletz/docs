---
title: "How to open data subscription?"
hide_table_of_contents: true
sidebar_label: How to open a data subscription?
sidebar_position: 2
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java"];



<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">
#How to open data subscription?

Having a subscription identifier allows you to open it. Together with id you need to specify some details about the subscription connection:

<TabItem value="open_1" label="open_1">
<CodeBlock language="csharp">
{`subscription = store.Subscriptions.GetSubscriptionWorker<Order>(subscriptionName);
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **id** | long | A data subscription identifier. |
| **options** | SubscriptionConnectionOptions | Connection options. |

| Return value | |
| ------------- | ----- |
| Subscription&lt;RavenJObject&gt; / Subscription&lt;T&gt; | Subscription instance. |

We have two method to open subscription. The first one is to deal with documents belonging to different collections - results are returned as `RavenJObject` objects then. The second one returns strongly
typed subscription where retrieved documents are converted to a given type.

<Admonition type="warning" title="Single subscription consumer at a time allowed" id="single-subscription-consumer-at-a-time-allowed" href="#single-subscription-consumer-at-a-time-allowed">
There can be only a single open subscription connection per subscription. An attempt to open already being opened subscription will result in throwing an exception.
</Admonition>

Documents are sent to a client in batches. `SubscriptionConnectionOptions` has `BatchOptions` property where you can specify:

* _MaxDocCount_ - max number of docs that can be sent in a single batch (default: 4096),
* _MaxSize_ - max total batch size in bytes (default: null - no size limit),
* _AcknowledgmentTimeout_ - max time within the subscription needs to confirm that the batch has been successfully processed (default: 1 minute).

Additionally connection options have the following settings:

- _IgnoreSubscribersErrors_ - determines if subscription should ignore errors thrown by subscription handlers (default: false),
- _ClientAliveNotificationInterval_ - specifies how often the subscription sends heart beats to the server (server keeps the subscription open until a connected client
sends these alive notifications - two undelivered notifications would let an another client to connect, default: 2 minutes),
- _Strategy_ - the enum that represents subscription opening strategy. There are four strategies available:

	- `OpenIfFree` - the client will successfully open a subscription only if there isn't any other currently connected client. Otherwise it will end up with `SubscriptionInUseException`,
	- `TakeOver` - the connecting client will successfully open a subscription even if there is another active subscription's consumer.
If the new client takes over the subscription then the existing one will get rejected. 
The subscription will always be processed by the last connected client.
	- `ForceAndKeep` - the client opening a subscription with forced strategy set will always get it and keep it open until another client with the same strategy gets connected.
	- `WaitForFree` - if the client currently cannot open the subscription because it is used by another client then it will subscribe Changes API to be notified about subscription status changes.
Every time `SubscriptionReleased` notification arrives, it will repeat an attempt to open the subscription. After it succeeds in opening, it will process docs as usual.

<Admonition type="info" title="Error handling" id="error-handling" href="#error-handling">
By default the data subscription does not allow processing errors (`IgnoreSubscribersErrors: false`). So if any subscription handler fails,
then it will stop pulling documents and close the subscription connection immediately. If you set `IgnoreSubscribersErrors` to `true`, it will ignore an error raised by a handler and
keep retrieving next docs.
</Admonition>

<Admonition type="info" title="Acknowledgment timeout handling" id="acknowledgment-timeout-handling" href="#acknowledgment-timeout-handling">
Under the scenes, once you have successfully processed a batch, the notification will send a confirmation to the server about it. The server keeps track of the last processed and
acknowledged document. If subscription handlers don't process the batch within the specified `AcknowledgmentTimeout`, then the server will resend the whole batch again. You will get 
the same documents over and over until you successfully processed it.
</Admonition>
 

<Admonition type="info" title="Crashing handling" id="crashing-handling" href="#crashing-handling">
Tracking the last acknowledged Etag allows the data subscription to handle crashing scenarios. If there is a crash, we know what documents have been already processed. 
If you crashed midway, the database will just resend you the relevant documents when you open the subscription again. The data subscription automatically
retries to open the subscription connection every 15 seconds if it get lost.
</Admonition>



<TabItem value="open_2" label="open_2">
<CodeBlock language="csharp">
{`subscription = store.Subscriptions.GetSubscriptionWorker<Order>(new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.WaitForFree
\});
`}
</CodeBlock>
</TabItem>

## Processing documents

The result of opening subscription is `Subscription<T>` or `Subscription<RavenJObject>` instance. It implements `IObservable` interface, so it means that you can just utilize [Reactive Extensions](https://www.nuget.org/packages/Rx-Main)
and subscribe to the incoming documents in order to process them. Also you will continue to get them, even for items that were added after you opened the subscription, because under the hood the [Changes API](../changes/what-is-changes-api.mdx)
is used to get notifications about any document updates.

### Example II

<TabItem value="open_3" label="open_3">
<CodeBlock language="csharp">
{`subscription = store.Subscriptions.GetSubscriptionWorker<Order>(new SubscriptionWorkerOptions(subscriptionName)
\{
    Strategy = SubscriptionOpeningStrategy.WaitForFree,
    MaxDocsPerBatch = 500,
    IgnoreSubscriberErrors = true
\});
`}
</CodeBlock>
</TabItem>

### Example III

You may want to dynamically manage subscription handlers. The returned subscriber object is type of `IDisposable`, in order to detach it from subscription just call `Dispose` on it:

<TabItem value="open_4" label="open_4">
<CodeBlock language="csharp">
{`//	var subscriber = orders.Subscribe(x => \{ \});

//	subscriber.Dispose();
//
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="No subscriber attached" id="no-subscriber-attached" href="#no-subscriber-attached">
The data subscription stops pulling docs if there is no subscriber attached.
</Admonition>

</LanguageContent>
<LanguageContent language="java">
#How to open data subscription?

Having a subscription identifier allows you to open it. Together with id you need to specify some details about the subscription connection:

<TabItem value="open_1" label="open_1">
<CodeBlock language="java">
{`<T> Subscription<T> open(Class<T> clazz, long id, SubscriptionConnectionOptions options) throws SubscriptionException;

<T> Subscription<T> open(Class<T> clazz, long id, SubscriptionConnectionOptions options, String database) throws SubscriptionException;

Subscription<RavenJObject> open(long id, SubscriptionConnectionOptions options) throws SubscriptionException;

Subscription<RavenJObject> open(long id, SubscriptionConnectionOptions options, String database) throws SubscriptionException;
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **id** | long | A data subscription identifier. |
| **options** | SubscriptionConnectionOptions | Connection options. |

| Return value | |
| ------------- | ----- |
| Subscription&lt;RavenJObject&gt; / Subscription&lt;T&gt; | Subscription instance. |

We have two method to open subscription. The first one is to deal with documents belonging to different collections - results are returned as `RavenJObject` objects then. The second one returns strongly
typed subscription where retrieved documents are converted to a given type.

<Admonition type="warning" title="Single subscription consumer at a time allowed" id="single-subscription-consumer-at-a-time-allowed" href="#single-subscription-consumer-at-a-time-allowed">
There can be only a single open subscription connection per subscription. An attempt to open already being opened subscription will result in throwing an exception.
</Admonition>

Documents are sent to a client in batches. `SubscriptionConnectionOptions` has `BatchOptions` property where you can specify:

* _MaxDocCount_ - max number of docs that can be sent in a single batch (default: 4096),
* _MaxSize_ - max total batch size in bytes (default: null - no size limit),
* _AcknowledgmentTimeout_ - max time within the subscription needs to confirm that the batch has been successfully processed (default: 1 minute).

Additionally connection options have the following settings:

- _IgnoreSubscribersErrors_ - determines if subscription should ignore errors thrown by subscription handlers (default: false),
- _ClientAliveNotificationInterval_ - specifies how often the subscription sends heart beats to the server (server keeps the subscription open until a connected client
sends these alive notifications - two undelivered notifications would let an another client to connect, default: 2 minutes),
- _Strategy_ - the enum that represents subscription opening strategy. There are four strategies available:

	- `OPEN_IF_FREE` - the client will successfully open a subscription only if there isn't any other currently connected client. Otherwise it will end up with `SubscriptionInUseException`,
	- `TAKE_OVER` - the connecting client will successfully open a subscription even if there is another active subscription's consumer.
If the new client takes over the subscription then the existing one will get rejected. 
The subscription will always be processed by the last connected client.
	- `FORCE_AND_KEEP` - the client opening a subscription with forced strategy set will always get it and keep it open until another client with the same strategy gets connected.
	- `WAIT_FOR_FREE` - if the client currently cannot open the subscription because it is used by another client then it will subscribe Changes API to be notified about subscription status changes.
Every time `subscriptionReleased` notification arrives, it will repeat an attempt to open the subscription. After it succeeds in opening, it will process docs as usual.

<Admonition type="info" title="Error handling" id="error-handling" href="#error-handling">
By default the data subscription does not allow processing errors (`IgnoreSubscribersErrors: false`). So if any subscription handler fails,
then it will stop pulling documents and close the subscription connection immediately. If you set `IgnoreSubscribersErrors` to `true`, it will ignore an error raised by a handler and
keep retrieving next docs.
</Admonition>

<Admonition type="info" title="Acknowledgment timeout handling" id="acknowledgment-timeout-handling" href="#acknowledgment-timeout-handling">
Under the scenes, once you have successfully processed a batch, the notification will send a confirmation to the server about it. The server keeps track of the last processed and
acknowledged document. If subscription handlers don't process the batch within the specified `AcknowledgmentTimeout`, then the server will resend the whole batch again. You will get 
the same documents over and over until you successfully processed it.
</Admonition>
 

<Admonition type="info" title="Crashing handling" id="crashing-handling" href="#crashing-handling">
Tracking the last acknowledged Etag allows the data subscription to handle crashing scenarios. If there is a crash, we know what documents have been already processed. 
If you crashed midway, the database will just resend you the relevant documents when you open the subscription again. The data subscription automatically
retries to open the subscription connection every 15 seconds if it get lost.
</Admonition>



<TabItem value="open_2" label="open_2">
<CodeBlock language="java">
{`SubscriptionConnectionOptions connectionOptions = new SubscriptionConnectionOptions();
connectionOptions.setIgnoreSubscribersErrors(false);
connectionOptions.setClientAliveNotificationInterval(30 * 60 * 1000);
SubscriptionBatchOptions batchOptions = new SubscriptionBatchOptions();
connectionOptions.setBatchOptions(batchOptions);
batchOptions.setMaxSize(4 * 1024 * 1024);
batchOptions.setMaxDocCount(16 * 1024);
batchOptions.setAcknowledgmentTimeout(3 * 60 * 1000L);
Subscription<Order> orders = store.subscriptions().open(Order.class, id, connectionOptions);
`}
</CodeBlock>
</TabItem>

## Processing documents

The result of opening subscription is `Subscription<T>` or `Subscription<RavenJObject>` instance. It implements `IObservable` interface, so it means that you can 
subscribe to the incoming documents in order to process them. Also you will continue to get them, even for items that were added after you opened the subscription, because under the hood the [Changes API](../changes/what-is-changes-api.mdx)
is used to get notifications about any document updates.

### Example II

<TabItem value="open_3" label="open_3">
<CodeBlock language="java">
{`orders.subscribe(new ObserverAdapter<Order>() \{
  @Override
  public void onNext(Order value) \{
    generateInvoice(value);
  \}
\});

orders.subscribe(new ObserverAdapter<Order>() \{
  @Override
  public void onNext(Order value) \{
    if (value.getRequireAt().getTime() > new Date().getTime())
      sendReminder(value.getEmployee(), value.getId());
  \}
\});
`}
</CodeBlock>
</TabItem>

### Example III

You may want to dynamically manage subscription handlers. The returned subscriber object is type of `CleanCloseable`, in order to detach it from subscription just call `close` on it:

<TabItem value="open_4" label="open_4">
<CodeBlock language="java">
{`CleanCloseable subscriber = orders.subscribe(null);
subscriber.close();
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="No subscriber attached" id="no-subscriber-attached" href="#no-subscriber-attached">
The data subscription stops pulling docs if there is no subscriber attached.
</Admonition>
</LanguageContent>

<!---

-->