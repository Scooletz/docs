import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

#Global identifier generation conventions



You can setup a custom key generation strategy by supplying a custom function `DocumentKeyGenerator`. By default a session uses [the HiLo algorithm](../../../../client-api/document-identifiers/hilo-algorithm.mdx) for both sync and async API usage:

<TabItem value="key_generator_hilo" label="key_generator_hilo">
<CodeBlock language="csharp">
{`MultiDatabaseHiLoGenerator hiLoGenerator = new MultiDatabaseHiLoGenerator(32);
Conventions.DocumentKeyGenerator = (dbName, databaseCommands, entity) =>
					hiLoGenerator.GenerateDocumentKey(dbName, databaseCommands, Conventions, entity);

AsyncMultiDatabaseHiLoKeyGenerator asyncHiLoGenerator = new AsyncMultiDatabaseHiLoKeyGenerator(32);
Conventions.AsyncDocumentKeyGenerator = (dbName, commands, entity) =>
					asyncHiLoGenerator.GenerateDocumentKeyAsync(dbName, commands, Conventions, entity);
`}
</CodeBlock>
</TabItem>

However if you want the session to use [an identity key generation strategy](../../../../client-api/document-identifiers/working-with-document-ids.mdx#identity-ids) by default, you can overwrite this convention in the following manner:

<TabItem value="key_generator_identityKeys" label="key_generator_identityKeys">
<CodeBlock language="csharp">
{`Conventions.DocumentKeyGenerator = (dbname, commands, entity) =>
					store.Conventions.GetTypeTagName(entity.GetType()) + "/";
`}
</CodeBlock>
</TabItem>

Function `GetTypeTagName` will use either the convention specified in `FindTypeTagName` (see below) or its default implementation.

### FindTypeTagName and FindDynamicTagName

Entity objects that share a common tag name belong to the same [collection](../../../../client-api/faq/what-is-a-collection.mdx) on the server side. Tag names are also used to build document keys. There are two functions that the client uses to determine the collection name. The first one is used for standard objects with well defined type:

<TabItem value="find_type_tagname" label="find_type_tagname">
<CodeBlock language="csharp">
{`Conventions.FindTypeTagName = type => // function that provides the collection name based on the entity type
`}
</CodeBlock>
</TabItem>

The second one is dedicated for dynamic objects:

<TabItem value="find_dynamic_tag_name" label="find_dynamic_tag_name">
<CodeBlock language="csharp">
{`Conventions.FindDynamicTagName = dynamicObject => // function to determine the collection name for the given dynamic object
`}
</CodeBlock>
</TabItem>

### TransformTypeTagNameToDocumentKeyPrefix

Actually, tag names determined by recently described convention functions aren't directly used as prefixes in document keys. There is a convention function called `TransformTypeTagNameToDocumentKeyPrefix` which takes the collection name and produces the prefix:

<TabItem value="transform_tag_name_to_prefix" label="transform_tag_name_to_prefix">
<CodeBlock language="csharp">
{`Conventions.TransformTypeTagNameToDocumentKeyPrefix = tagName => // transform the tag name to the prefix of a key, e.g. [prefix]/12
`}
</CodeBlock>
</TabItem>

Its default behavior is that for a tag which contains one upper character it simply converts it to lower case string, e.g. `Users` would be transformed into `users`. For tag names containing more upper characters there will be no change, e.g. the tag name: `LineItems` would output the following prefix: `LineItems`.

### FindClrTypeName and FindClrType

In metadata of all documents stored in a database you can find the following property which specifies the client-side type. For instance:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{
    "Raven-Clr-Type": "Orders.Shipper, Northwind"
\}
`}
</CodeBlock>
</TabItem>

This property is used by RavenDB client to perform a conversion between .NET object and JSON document stored in a database. A function responsible for retrieving the CLR type of an entity is defined by `FindClrTypeName` convention:

<TabItem value="find_type_name" label="find_type_name">
<CodeBlock language="csharp">
{`Conventions.FindClrTypeName = type => // use reflection to determine the type;
`}
</CodeBlock>
</TabItem>

To properly perform the revert conversion that is from a JSON result into a .NET object we need to retrieve the CLR type from `Raven-Clr-Type` metadata:

<TabItem value="find_clr_type" label="find_clr_type">
<CodeBlock language="csharp">
{`Conventions.FindClrType = (id, doc, metadata) =>
					metadata.Value<string>(Abstractions.Data.Constants.RavenClrType);
`}
</CodeBlock>
</TabItem>


### FindIdentityProperty

The client must know where in your entity an identifier is stored to be property able to transform it into JSON document. It uses `FindIdentityProperty` convention for that. The default and very common convention is that a property named `Id` is the identifier, so it is the default one:

<TabItem value="find_identity_property" label="find_identity_property">
<CodeBlock language="csharp">
{`Conventions.FindIdentityProperty = memberInfo => memberInfo.Name == "Id";
`}
</CodeBlock>
</TabItem>

You can provide a customization based on the `MemberInfo` parameter to indicate which property or field keeps the identifier. The client will iterate over all object properties and take the first one according to the defined predicate.

### FindIdentityPropertyNameFromEntityName

It can happen that sometimes the results returned by the server can haven't identifiers defined (for example if you run a projection query) however they have `Raven-Entity-Name` in metadata.
Then to perform the conversion into .NET object a function that finds the identity property name for a given entity name is applied:

<TabItem value="find_iden_propn_name_from_entity_name" label="find_iden_propn_name_from_entity_name">
<CodeBlock language="csharp">
{`Conventions.FindIdentityPropertyNameFromEntityName = entityName => "Id";
`}
</CodeBlock>
</TabItem>

### IdentityPartsSeparator

According to the default, convention document keys have the following format: `[collectionName]/[identityValue]`. The slash character (`/`) separates the two parts of an identifier.
You can overwrite it by using `IdentityPartsSeparator` convention. Its default definition is:

<TabItem value="identity_part_separator" label="identity_part_separator">
<CodeBlock language="csharp">
{`Conventions.IdentityPartsSeparator = "/";
`}
</CodeBlock>
</TabItem>

### IdentityTypeConvertors

RavenDB is designed to work with string identifiers. However it has the support for numeric and GUID ids. To be more exact it is able to work with `Int32`, `Int64` and `Guid` identifiers,
because it has dedicated converters for them:

<TabItem value="identity_type_convertors" label="identity_type_convertors">
<CodeBlock language="csharp">
{`Conventions.IdentityTypeConvertors = new List<ITypeConverter>
\{
	new GuidConverter(),
	new Int32Converter(),
	new Int64Converter()
\};
`}
</CodeBlock>
</TabItem>

If you need to have the support for different types of identifier properties, you can add a custom converter that implements `ITypeConverter` interface:

<TabItem value="custom_converter" label="custom_converter">
<CodeBlock language="csharp">
{`public class UInt32Converter : ITypeConverter
\{
	public bool CanConvertFrom(Type sourceType)
	\{
		throw new CodeOmitted();
	\}

	public string ConvertFrom(string tag, object value, bool allowNull)
	\{
		throw new CodeOmitted();
	\}

	public object ConvertTo(string value)
	\{
		throw new CodeOmitted();
	\}
\}
`}
</CodeBlock>
</TabItem>
<TabItem value="identity_type_convertors_2" label="identity_type_convertors_2">
<CodeBlock language="csharp">
{`Conventions.IdentityTypeConvertors.Add(new UInt32Converter());
`}
</CodeBlock>
</TabItem>

### FindIdValuePartForValueTypeConversion

You need to remember that even if the identity property of your entry isn't a string, a document in a database always has a string key. E.g. for the `Orders` entity that has
a numeric ID and its value is `3`, the server side key will be `orders/3`. If such document is fetched by RavenDB client, the key needs to be converted into a number. By default
we look for the last part of the identifier after `IdentityPartsSeparator`:

<TabItem value="find_id_value_part_for_value_type_conversion" label="find_id_value_part_for_value_type_conversion">
<CodeBlock language="csharp">
{`Conventions.FindIdValuePartForValueTypeConversion = (entity, id) =>
	id.Split(new[] \{ Conventions.IdentityPartsSeparator \}, StringSplitOptions.RemoveEmptyEntries).Last();
`}
</CodeBlock>
</TabItem>

### FindFullDocumentKeyFromNonStringIdentifier

Sometimes the client needs to know the full id of the document that will be stored for an entity with non-sting identifier. We can use the following function:

<TabItem value="find_full_doc_key_from_non_string_identifier" label="find_full_doc_key_from_non_string_identifier">
<CodeBlock language="csharp">
{`Conventions.FindFullDocumentKeyFromNonStringIdentifier = (id, type, allowNull) => // by default returns [tagName]/[identityValue];
`}
</CodeBlock>
</TabItem>

to find the full key based on the type of a document and the value type identifier.


